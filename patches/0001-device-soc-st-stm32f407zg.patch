From 63b8eafc808d1e5fd58cc6f6783182cb73cfd936 Mon Sep 17 00:00:00 2001
From: zhangdengyu <zhangdengyu2@huawei.com>
Date: Thu, 8 Sep 2022 22:08:01 +0800
Subject: [PATCH] =?UTF-8?q?=E5=A2=9E=E5=8A=A0=E7=BD=91=E7=BB=9C?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: zhangdengyu <zhangdengyu2@huawei.com>
Change-Id: I710354e2690321ee3bf783280f2e3749bf8f7180
---
 stm32f407zg/BUILD.gn                          |   30 +
 stm32f407zg/ohos.build                        |   10 +
 stm32f407zg/uniproton/BUILD.gn                |   35 +
 stm32f407zg/uniproton/board/ARCH/ethernetif.c |  132 +
 stm32f407zg/uniproton/board/ARCH/ethernetif.h |   18 +
 stm32f407zg/uniproton/board/BUILD.gn          |  124 +
 stm32f407zg/uniproton/board/CORE/core_cm4.h   | 1772 ++++
 .../uniproton/board/CORE/core_cm4_simd.h      |  673 ++
 .../uniproton/board/CORE/core_cmFunc.h        |  636 ++
 .../uniproton/board/CORE/core_cmInstr.h       |  688 ++
 .../STM32F4x7_ETH_Driver/inc/stm32f4x7_eth.h  | 1883 ++++
 .../inc/stm32f4x7_eth_conf.h                  |   43 +
 .../STM32F4x7_ETH_Driver/src/stm32f4x7_eth.c  | 2702 +++++
 .../STM32F4xx_StdPeriph_Driver/inc/misc.h     |  178 +
 .../inc/stm32f4xx_adc.h                       |  656 ++
 .../inc/stm32f4xx_can.h                       |  644 ++
 .../inc/stm32f4xx_crc.h                       |   83 +
 .../inc/stm32f4xx_cryp.h                      |  384 +
 .../inc/stm32f4xx_dac.h                       |  304 +
 .../inc/stm32f4xx_dbgmcu.h                    |  109 +
 .../inc/stm32f4xx_dcmi.h                      |  312 +
 .../inc/stm32f4xx_dma.h                       |  609 ++
 .../inc/stm32f4xx_dma2d.h                     |  475 +
 .../inc/stm32f4xx_exti.h                      |  183 +
 .../inc/stm32f4xx_flash.h                     |  488 +
 .../inc/stm32f4xx_flash_ramfunc.h             |  103 +
 .../inc/stm32f4xx_fmc.h                       | 1143 ++
 .../inc/stm32f4xx_fsmc.h                      |  675 ++
 .../inc/stm32f4xx_gpio.h                      |  502 +
 .../inc/stm32f4xx_hash.h                      |  257 +
 .../inc/stm32f4xx_i2c.h                       |  711 ++
 .../inc/stm32f4xx_iwdg.h                      |  131 +
 .../inc/stm32f4xx_ltdc.h                      |  531 +
 .../inc/stm32f4xx_pwr.h                       |  212 +
 .../inc/stm32f4xx_rcc.h                       |  630 ++
 .../inc/stm32f4xx_rng.h                       |  120 +
 .../inc/stm32f4xx_rtc.h                       |  881 ++
 .../inc/stm32f4xx_sai.h                       |  611 ++
 .../inc/stm32f4xx_sdio.h                      |  536 +
 .../inc/stm32f4xx_spi.h                       |  549 +
 .../inc/stm32f4xx_syscfg.h                    |  210 +
 .../inc/stm32f4xx_tim.h                       | 1150 +++
 .../inc/stm32f4xx_usart.h                     |  431 +
 .../inc/stm32f4xx_wwdg.h                      |  111 +
 .../STM32F4xx_StdPeriph_Driver/src/misc.c     |  250 +
 .../src/stm32f4xx_adc.c                       | 1745 ++++
 .../src/stm32f4xx_can.c                       | 1700 +++
 .../src/stm32f4xx_crc.c                       |  133 +
 .../src/stm32f4xx_cryp.c                      |  934 ++
 .../src/stm32f4xx_cryp_aes.c                  | 1707 +++
 .../src/stm32f4xx_cryp_des.c                  |  308 +
 .../src/stm32f4xx_cryp_tdes.c                 |  325 +
 .../src/stm32f4xx_dac.c                       |  714 ++
 .../src/stm32f4xx_dbgmcu.c                    |  180 +
 .../src/stm32f4xx_dcmi.c                      |  538 +
 .../src/stm32f4xx_dma.c                       | 1301 +++
 .../src/stm32f4xx_dma2d.c                     |  784 ++
 .../src/stm32f4xx_exti.c                      |  311 +
 .../src/stm32f4xx_flash.c                     | 1612 +++
 .../src/stm32f4xx_flash_ramfunc.c             |  158 +
 .../src/stm32f4xx_fmc.c                       | 1367 +++
 .../src/stm32f4xx_fsmc.c                      |  986 ++
 .../src/stm32f4xx_gpio.c                      |  612 ++
 .../src/stm32f4xx_hash.c                      |  726 ++
 .../src/stm32f4xx_hash_md5.c                  |  320 +
 .../src/stm32f4xx_hash_sha1.c                 |  323 +
 .../src/stm32f4xx_i2c.c                       | 1462 +++
 .../src/stm32f4xx_iwdg.c                      |  266 +
 .../src/stm32f4xx_ltdc.c                      | 1110 ++
 .../src/stm32f4xx_pwr.c                       |  939 ++
 .../src/stm32f4xx_rcc.c                       | 2308 +++++
 .../src/stm32f4xx_rng.c                       |  397 +
 .../src/stm32f4xx_rtc.c                       | 2761 +++++
 .../src/stm32f4xx_sai.c                       | 1079 ++
 .../src/stm32f4xx_sdio.c                      | 1011 ++
 .../src/stm32f4xx_spi.c                       | 1319 +++
 .../src/stm32f4xx_syscfg.c                    |  240 +
 .../src/stm32f4xx_tim.c                       | 3365 ++++++
 .../src/stm32f4xx_usart.c                     | 1487 +++
 .../src/stm32f4xx_wwdg.c                      |  307 +
 .../board/HARDWARE/ETHERNET/lan8720.c         |  266 +
 .../board/HARDWARE/ETHERNET/lan8720.h         |   39 +
 stm32f407zg/uniproton/board/LWIP/lwip_comm.c  |  282 +
 stm32f407zg/uniproton/board/LWIP/lwip_comm.h  |   46 +
 stm32f407zg/uniproton/board/SYSTEM/sys/sys.c  |   63 +
 stm32f407zg/uniproton/board/SYSTEM/sys/sys.h  |   98 +
 .../uniproton/board/SYSTEM/usart/usart.c      |  161 +
 .../uniproton/board/SYSTEM/usart/usart.h      |   38 +
 stm32f407zg/uniproton/board/USER/board.c      |  226 +
 stm32f407zg/uniproton/board/USER/dprintf.c    |   61 +
 stm32f407zg/uniproton/board/USER/stm32f4xx.h  | 9177 +++++++++++++++++
 .../uniproton/board/USER/stm32f4xx_conf.h     |  125 +
 .../uniproton/board/USER/stm32f4xx_it.c       |  168 +
 .../uniproton/board/USER/stm32f4xx_it.h       |   60 +
 .../uniproton/board/USER/system_stm32f4xx.c   | 1130 ++
 .../uniproton/board/USER/system_stm32f4xx.h   |  105 +
 stm32f407zg/uniproton/board/rtos.ld           |  117 +
 stm32f407zg/uniproton/board/target_config.h   |  107 +
 stm32f407zg/uniproton/config.gni              |   96 +
 99 files changed, 70115 insertions(+)
 create mode 100644 stm32f407zg/BUILD.gn
 create mode 100644 stm32f407zg/ohos.build
 create mode 100644 stm32f407zg/uniproton/BUILD.gn
 create mode 100644 stm32f407zg/uniproton/board/ARCH/ethernetif.c
 create mode 100644 stm32f407zg/uniproton/board/ARCH/ethernetif.h
 create mode 100644 stm32f407zg/uniproton/board/BUILD.gn
 create mode 100644 stm32f407zg/uniproton/board/CORE/core_cm4.h
 create mode 100644 stm32f407zg/uniproton/board/CORE/core_cm4_simd.h
 create mode 100644 stm32f407zg/uniproton/board/CORE/core_cmFunc.h
 create mode 100644 stm32f407zg/uniproton/board/CORE/core_cmInstr.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/inc/stm32f4x7_eth.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/inc/stm32f4x7_eth_conf.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/src/stm32f4x7_eth.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/misc.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_adc.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_can.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_crc.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_cryp.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dac.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dbgmcu.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dcmi.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma2d.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_exti.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash_ramfunc.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fmc.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fsmc.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_hash.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_i2c.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_iwdg.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_ltdc.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_pwr.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rng.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rtc.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sai.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sdio.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_spi.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_syscfg.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_usart.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_wwdg.h
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/misc.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_adc.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_can.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_crc.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_aes.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_des.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_tdes.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dbgmcu.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dcmi.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma2d.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_exti.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash_ramfunc.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fmc.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fsmc.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_gpio.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_md5.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_sha1.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_i2c.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_iwdg.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_ltdc.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rcc.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rng.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rtc.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sai.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sdio.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_spi.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_syscfg.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_tim.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c
 create mode 100644 stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_wwdg.c
 create mode 100644 stm32f407zg/uniproton/board/HARDWARE/ETHERNET/lan8720.c
 create mode 100644 stm32f407zg/uniproton/board/HARDWARE/ETHERNET/lan8720.h
 create mode 100644 stm32f407zg/uniproton/board/LWIP/lwip_comm.c
 create mode 100644 stm32f407zg/uniproton/board/LWIP/lwip_comm.h
 create mode 100644 stm32f407zg/uniproton/board/SYSTEM/sys/sys.c
 create mode 100644 stm32f407zg/uniproton/board/SYSTEM/sys/sys.h
 create mode 100644 stm32f407zg/uniproton/board/SYSTEM/usart/usart.c
 create mode 100644 stm32f407zg/uniproton/board/SYSTEM/usart/usart.h
 create mode 100644 stm32f407zg/uniproton/board/USER/board.c
 create mode 100644 stm32f407zg/uniproton/board/USER/dprintf.c
 create mode 100644 stm32f407zg/uniproton/board/USER/stm32f4xx.h
 create mode 100644 stm32f407zg/uniproton/board/USER/stm32f4xx_conf.h
 create mode 100644 stm32f407zg/uniproton/board/USER/stm32f4xx_it.c
 create mode 100644 stm32f407zg/uniproton/board/USER/stm32f4xx_it.h
 create mode 100644 stm32f407zg/uniproton/board/USER/system_stm32f4xx.c
 create mode 100644 stm32f407zg/uniproton/board/USER/system_stm32f4xx.h
 create mode 100644 stm32f407zg/uniproton/board/rtos.ld
 create mode 100644 stm32f407zg/uniproton/board/target_config.h
 create mode 100644 stm32f407zg/uniproton/config.gni

diff --git a/stm32f407zg/BUILD.gn b/stm32f407zg/BUILD.gn
new file mode 100644
index 0000000..f185908
--- /dev/null
+++ b/stm32f407zg/BUILD.gn
@@ -0,0 +1,30 @@
+# Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+group("stm32f407zg") {
+}
diff --git a/stm32f407zg/ohos.build b/stm32f407zg/ohos.build
new file mode 100644
index 0000000..34f14d8
--- /dev/null
+++ b/stm32f407zg/ohos.build
@@ -0,0 +1,10 @@
+{
+  "parts": {
+    "device_stm32f407zg": {
+      "module_list": [
+        "//device/soc/st/stm32f407zg:stm32f407zg"
+      ]
+    }
+  },
+  "subsystem": "device_stm32f407zg"
+}
\ No newline at end of file
diff --git a/stm32f407zg/uniproton/BUILD.gn b/stm32f407zg/uniproton/BUILD.gn
new file mode 100644
index 0000000..2a669cc
--- /dev/null
+++ b/stm32f407zg/uniproton/BUILD.gn
@@ -0,0 +1,35 @@
+# Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+group("device") {
+  deps = [ "board:bsp_config" ]
+}
+
+config("public") {
+  configs = [ "board:public" ]
+}
diff --git a/stm32f407zg/uniproton/board/ARCH/ethernetif.c b/stm32f407zg/uniproton/board/ARCH/ethernetif.c
new file mode 100644
index 0000000..55c6d8f
--- /dev/null
+++ b/stm32f407zg/uniproton/board/ARCH/ethernetif.c
@@ -0,0 +1,132 @@
+#include "ethernetif.h" 
+#include "lan8720.h"  
+#include "lwip_comm.h" 
+#include "netif/etharp.h"  
+#include "string.h"  
+
+//由ethernetif_init()调用用于初始化硬件
+//netif:网卡结构体指针 
+//返回值:ERR_OK,正常
+//       其他,失败
+static err_t low_level_init(struct netif *netif)
+{
+#ifdef CHECKSUM_BY_HARDWARE
+	int i; 
+#endif 
+	netif->hwaddr_len = ETHARP_HWADDR_LEN; //设置MAC地址长度,为6个字节
+	//初始化MAC地址,设置什么地址由用户自己设置,但是不能与网络中其他设备MAC地址重复
+	netif->hwaddr[0]=lwipdev.mac[0]; 
+	netif->hwaddr[1]=lwipdev.mac[1]; 
+	netif->hwaddr[2]=lwipdev.mac[2];
+	netif->hwaddr[3]=lwipdev.mac[3];
+	netif->hwaddr[4]=lwipdev.mac[4];
+	netif->hwaddr[5]=lwipdev.mac[5];
+	netif->mtu=1500; //最大允许传输单元,允许该网卡广播和ARP功能
+	//并且该网卡允许有硬件链路连接
+	netif->flags = NETIF_FLAG_BROADCAST|NETIF_FLAG_ETHARP|NETIF_FLAG_LINK_UP;
+	
+	ETH_MACAddressConfig(ETH_MAC_Address0, netif->hwaddr); //向STM32F4的MAC地址寄存器中写入MAC地址
+	ETH_DMATxDescChainInit(DMATxDscrTab, Tx_Buff, ETH_TXBUFNB);
+	ETH_DMARxDescChainInit(DMARxDscrTab, Rx_Buff, ETH_RXBUFNB);
+#ifdef CHECKSUM_BY_HARDWARE 	//使用硬件帧校验
+	for(i=0;i<ETH_TXBUFNB;i++)	//使能TCP,UDP和ICMP的发送帧校验,TCP,UDP和ICMP的接收帧校验在DMA中配置了
+	{
+		ETH_DMATxDescChecksumInsertionConfig(&DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
+	}
+#endif
+	ETH_Start(); //开启MAC和DMA				
+	return ERR_OK;
+} 
+
+//用于发送数据包的最底层函数(lwip通过netif->linkoutput指向该函数)
+//netif:网卡结构体指针
+//p:pbuf数据结构体指针
+//返回值:ERR_OK,发送正常
+//       ERR_MEM,发送失败
+static err_t low_level_output(struct netif *netif, struct pbuf *p)
+{
+	u8 res;
+	struct pbuf *q;
+	int l = 0;
+	u8 *buffer=(u8*)ETH_GetCurrentTxBuffer(); 
+	for(q=p;q!=NULL;q=q->next) 
+	{
+		memcpy((u8_t*)&buffer[l], q->payload, q->len);
+		l=l+q->len;
+	} 
+	res=ETH_Tx_Packet(l); 
+	if(res==ETH_ERROR)return ERR_MEM;//返回错误状态
+	printf("		low_level_output end\n\r");
+	return ERR_OK;
+}
+
+//用于接收数据包的最底层函数
+//neitif:网卡结构体指针
+//返回值:pbuf数据结构体指针
+static struct pbuf * low_level_input(struct netif *netif)
+{
+	struct pbuf *p, *q;
+	u16_t len;
+	int l =0;
+	FrameTypeDef frame;
+	u8 *buffer;
+	p = NULL;
+	frame=ETH_Rx_Packet();
+	len=frame.length;//得到包大小
+	buffer=(u8 *)frame.buffer;//得到包数据地址 
+	p=pbuf_alloc(PBUF_RAW,len,PBUF_POOL);//pbufs内存池分配pbuf
+	if(p!=NULL)
+	{
+		for(q=p;q!=NULL;q=q->next)
+		{
+			memcpy((u8_t*)q->payload,(u8_t*)&buffer[l], q->len);
+			l=l+q->len;
+		}
+	}
+	frame.descriptor->Status=ETH_DMARxDesc_OWN;//设置Rx描述符OWN位,buffer重归ETH DMA 
+	if((ETH->DMASR&ETH_DMASR_RBUS)!=(u32)RESET)//当Rx Buffer不可用位(RBUS)被设置的时候,重置它.恢复传输
+	{ 
+		ETH->DMASR=ETH_DMASR_RBUS;//重置ETH DMA RBUS位 
+		ETH->DMARPDR=0;//恢复DMA接收
+	}
+	return p;
+} 
+
+//网卡接收数据(lwip直接调用)
+//netif:网卡结构体指针
+//返回值:ERR_OK,发送正常
+//       ERR_MEM,发送失败
+err_t ethernetif_input(struct netif *netif)
+{
+	err_t err;
+	struct pbuf *p;
+	p=low_level_input(netif);
+	if(p==NULL) return ERR_MEM;
+	err=netif->input(p, netif);
+	if(err!=ERR_OK)
+	{
+		LWIP_DEBUGF(NETIF_DEBUG,("ethernetif_input: IP input error\n"));
+		pbuf_free(p);
+		p = NULL;
+	} 
+	return err;
+} 
+
+//使用low_level_init()函数来初始化网络
+//netif:网卡结构体指针
+//返回值:ERR_OK,正常
+//       其他,失败
+err_t ethernetif_init(struct netif *netif)
+{
+	LWIP_ASSERT("netif!=NULL",(netif!=NULL));
+#if LWIP_NETIF_HOSTNAME			//LWIP_NETIF_HOSTNAME
+	netif->hostname="lwip";  	//初始化名称
+#endif 
+	netif->name[0]=IFNAME0; 	//初始化变量netif的name字段
+	netif->name[1]=IFNAME1; 	//在文件外定义这里不用关心具体值
+	netif->output=etharp_output;//IP层发送数据包函数
+	netif->linkoutput=low_level_output;//ARP模块发送数据包函数
+	low_level_init(netif); 		//底层硬件初始化函数
+	return ERR_OK;
+}
+
diff --git a/stm32f407zg/uniproton/board/ARCH/ethernetif.h b/stm32f407zg/uniproton/board/ARCH/ethernetif.h
new file mode 100644
index 0000000..71b2847
--- /dev/null
+++ b/stm32f407zg/uniproton/board/ARCH/ethernetif.h
@@ -0,0 +1,18 @@
+#ifndef __ETHERNETIF_H__
+#define __ETHERNETIF_H__
+#include "lwip/err.h"
+#include "lwip/netif.h"
+
+//网卡的名字
+#define IFNAME0 'e'
+#define IFNAME1 'n'
+
+#define NETIF_IN_TASK_STACK_SIZE        ( 1024 )
+#define NETIF_IN_TASK_PRIORITY          ( 3 )
+
+#define NETIF_OUT_TASK_STACK_SIZE       ( 1024 )
+#define NETIF_OUT_TASK_PRIORITY         ( 3 )
+
+err_t ethernetif_init(struct netif *netif);
+err_t ethernetif_input(struct netif *netif);
+#endif
diff --git a/stm32f407zg/uniproton/board/BUILD.gn b/stm32f407zg/uniproton/board/BUILD.gn
new file mode 100644
index 0000000..607a146
--- /dev/null
+++ b/stm32f407zg/uniproton/board/BUILD.gn
@@ -0,0 +1,124 @@
+# Copyright (c) 2022-2022 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+import("//kernel/uniproton/components/net/lwip-2.1/lwip_porting.gni")
+# import("//kernel/uniproton/components/net/test/lwip_test.gni")
+
+static_library("bsp_config") {
+  asmflags = board_asmflags
+  
+  sources = [
+    "ARCH/ethernetif.c",
+    "FWLIB/STM32F4x7_ETH_Driver/src/stm32f4x7_eth.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/misc.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_adc.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_can.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_crc.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_aes.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_des.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_tdes.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dbgmcu.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dcmi.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma2d.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_exti.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash_ramfunc.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fmc.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fsmc.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_gpio.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_md5.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_sha1.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_i2c.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_iwdg.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_ltdc.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rcc.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rng.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rtc.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sai.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sdio.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_spi.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_syscfg.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_tim.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_wwdg.c",
+    "HARDWARE/ETHERNET/lan8720.c",
+    "LWIP/lwip_comm.c",
+    "SYSTEM/sys/sys.c",
+    "SYSTEM/usart/usart.c",
+    "USER/board.c",
+    "USER/dprintf.c",
+    "USER/stm32f4xx_it.c",
+    "USER/system_stm32f4xx.c",
+  ]
+  
+  include_dirs = [
+    "ARCH",
+    "CORE",
+    "FWLIB/STM32F4xx_StdPeriph_Driver/inc",
+    "FWLIB/STM32F4x7_ETH_Driver/inc",
+    "HARDWARE/ETHERNET",
+    "LWIP",
+    "SYSTEM/sys",
+    "SYSTEM/usart",
+    "USER",
+  ]
+}
+
+config("public") {
+  include_dirs = [
+    ".",
+    "//third_party/cmsis/CMSIS/Core/Include",
+  ]
+
+  include_dirs += LWIP_PORTING_INCLUDE_DIRS + [ # LWIP_TEST_INCLUDE_DIRS
+    "//third_party/lwip/src/include",
+    "//third_party/cmsis/CMSIS/RTOS2/Include",
+    "//third_party/musl/porting/uniproton/include",
+    "//third_party/musl/include",  
+  ]
+  
+  ldflags = [
+    "-nostartfiles",
+    "-Wl,-T" + rebase_path("rtos.ld"),
+    "-nostdlib",
+    "-static",
+    "-N",
+    "-Wl,--gc-sections",
+    "-Wl,-Map=OHOS_Image.map",
+  ]
+
+  libs = [
+    "nosys",
+    "gcc",
+  ]
+}
diff --git a/stm32f407zg/uniproton/board/CORE/core_cm4.h b/stm32f407zg/uniproton/board/CORE/core_cm4.h
new file mode 100644
index 0000000..2c8b088
--- /dev/null
+++ b/stm32f407zg/uniproton/board/CORE/core_cm4.h
@@ -0,0 +1,1772 @@
+/**************************************************************************//**
+ * @file     core_cm4.h
+ * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM4_H_GENERIC
+#define __CORE_CM4_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup Cortex_M4
+  @{
+ */
+
+/*  CMSIS CM4 definitions */
+#define __CM4_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
+#define __CM4_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
+#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
+                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
+
+#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TMS470__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
+*/
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __TMS470__ )
+  #if defined __TI_VFP_SUPPORT__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+#include <core_cm4_simd.h>               /* Compiler specific SIMD Intrinsics               */
+
+#endif /* __CORE_CM4_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_CM4_H_DEPENDANT
+#define __CORE_CM4_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CM4_REV
+    #define __CM4_REV               0x0000
+    #warning "__CM4_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __FPU_PRESENT
+    #define __FPU_PRESENT             0
+    #warning "__FPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          4
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group Cortex_M4 */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core Debug Register
+  - Core MPU Register
+  - Core FPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[24];
+  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
+       uint32_t RSERVED1[24];
+  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
+       uint32_t RESERVED2[24];
+  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
+       uint32_t RESERVED3[24];
+  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
+       uint32_t RESERVED4[56];
+  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
+       uint32_t RESERVED5[644];
+  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
+}  NVIC_Type;
+
+/* Software Triggered Interrupt Register Definitions */
+#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
+#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
+  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
+  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
+  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
+  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
+  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
+  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
+  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
+  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
+  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
+  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
+       uint32_t RESERVED0[5];
+  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
+#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Vector Table Offset Register Definitions */
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
+#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
+#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
+#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
+
+#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
+#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
+#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
+
+#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
+#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
+#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
+
+#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
+#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
+
+#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
+#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
+
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
+#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
+
+#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
+#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
+
+#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
+#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
+
+#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
+#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
+
+#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
+#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
+
+#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
+#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
+
+#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
+#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
+
+#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
+#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
+
+#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
+#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
+
+#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
+#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
+
+/* SCB Configurable Fault Status Registers Definitions */
+#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
+#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
+
+#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
+#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
+
+#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
+#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
+
+/* SCB Hard Fault Status Registers Definitions */
+#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
+#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
+
+#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
+#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
+
+#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
+#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
+
+/* SCB Debug Fault Status Register Definitions */
+#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
+#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
+
+#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
+#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
+
+#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
+#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
+
+#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
+#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
+
+#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
+#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
+    \brief      Type definitions for the System Control and ID Register not in the SCB
+  @{
+ */
+
+/** \brief  Structure type to access the System Control and ID Register not in the SCB.
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
+  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
+} SCnSCB_Type;
+
+/* Interrupt Controller Type Register Definitions */
+#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
+#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
+
+/* Auxiliary Control Register Definitions */
+#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
+#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
+
+#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
+#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
+
+#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
+#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
+
+#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
+#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
+
+#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
+#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
+
+/*@} end of group CMSIS_SCnotSCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
+    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
+  @{
+ */
+
+/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
+ */
+typedef struct
+{
+  __O  union
+  {
+    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
+    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
+    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
+  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
+       uint32_t RESERVED0[864];
+  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
+       uint32_t RESERVED1[15];
+  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
+       uint32_t RESERVED2[15];
+  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
+       uint32_t RESERVED3[29];
+  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
+  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
+  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
+       uint32_t RESERVED4[43];
+  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
+  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
+       uint32_t RESERVED5[6];
+  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
+  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
+  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
+  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
+  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
+  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
+  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
+  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
+  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
+  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
+  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
+  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
+} ITM_Type;
+
+/* ITM Trace Privilege Register Definitions */
+#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
+#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
+
+/* ITM Trace Control Register Definitions */
+#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
+#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
+
+#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
+#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
+
+#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
+#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
+
+#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
+#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
+
+#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
+#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
+
+#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
+#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
+
+#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
+#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
+
+#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
+#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
+
+#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
+#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
+
+/* ITM Integration Write Register Definitions */
+#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
+#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
+
+/* ITM Integration Read Register Definitions */
+#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
+#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
+
+/* ITM Integration Mode Control Register Definitions */
+#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
+#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
+
+/* ITM Lock Status Register Definitions */
+#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
+#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
+
+#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
+#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
+
+#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
+#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
+
+/*@}*/ /* end of group CMSIS_ITM */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
+    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
+  @{
+ */
+
+/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
+  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
+  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
+  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
+  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
+  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
+  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
+  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
+  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
+  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
+  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
+       uint32_t RESERVED0[1];
+  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
+  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
+  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
+       uint32_t RESERVED1[1];
+  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
+  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
+  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
+       uint32_t RESERVED2[1];
+  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
+  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
+  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
+} DWT_Type;
+
+/* DWT Control Register Definitions */
+#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
+#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
+
+#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
+#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
+
+#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
+#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
+
+#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
+#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
+
+#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
+#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
+
+#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
+#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
+
+#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
+#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
+
+#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
+#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
+
+#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
+#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
+
+#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
+#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
+
+#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
+#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
+
+#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
+#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
+
+#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
+#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
+
+#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
+#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
+
+#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
+#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
+
+#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
+#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
+
+#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
+#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
+
+#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
+#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
+
+/* DWT CPI Count Register Definitions */
+#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
+#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
+
+/* DWT Exception Overhead Count Register Definitions */
+#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
+#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
+
+/* DWT Sleep Count Register Definitions */
+#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
+#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
+
+/* DWT LSU Count Register Definitions */
+#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
+#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
+
+/* DWT Folded-instruction Count Register Definitions */
+#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
+#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
+
+/* DWT Comparator Mask Register Definitions */
+#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
+#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
+
+/* DWT Comparator Function Register Definitions */
+#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
+#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
+
+#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
+#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
+
+#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
+#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
+
+#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
+#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
+
+#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
+#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
+
+#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
+#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
+
+#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
+#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
+
+#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
+#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
+
+#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
+#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
+
+/*@}*/ /* end of group CMSIS_DWT */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
+    \brief      Type definitions for the Trace Port Interface (TPI)
+  @{
+ */
+
+/** \brief  Structure type to access the Trace Port Interface Register (TPI).
+ */
+typedef struct
+{
+  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
+  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
+       uint32_t RESERVED0[2];
+  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
+       uint32_t RESERVED1[55];
+  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
+       uint32_t RESERVED2[131];
+  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
+  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
+  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
+       uint32_t RESERVED3[759];
+  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
+  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
+  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
+       uint32_t RESERVED4[1];
+  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
+  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
+  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
+       uint32_t RESERVED5[39];
+  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
+  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
+       uint32_t RESERVED7[8];
+  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
+  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
+} TPI_Type;
+
+/* TPI Asynchronous Clock Prescaler Register Definitions */
+#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
+#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
+
+/* TPI Selected Pin Protocol Register Definitions */
+#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
+#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
+
+/* TPI Formatter and Flush Status Register Definitions */
+#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
+#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
+
+#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
+#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
+
+#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
+#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
+
+#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
+#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
+
+/* TPI Formatter and Flush Control Register Definitions */
+#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
+#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
+
+#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
+#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
+
+/* TPI TRIGGER Register Definitions */
+#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
+#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
+
+/* TPI Integration ETM Data Register Definitions (FIFO0) */
+#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
+#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
+
+#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
+#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
+
+#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
+#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
+
+#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
+#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
+
+#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
+#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
+
+#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
+#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
+
+#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
+#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
+
+/* TPI ITATBCTR2 Register Definitions */
+#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
+#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
+
+/* TPI Integration ITM Data Register Definitions (FIFO1) */
+#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
+#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
+
+#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
+#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
+
+#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
+#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
+
+#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
+#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
+
+#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
+#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
+
+#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
+#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
+
+#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
+#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
+
+/* TPI ITATBCTR0 Register Definitions */
+#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
+#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
+
+/* TPI Integration Mode Control Register Definitions */
+#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
+#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
+
+/* TPI DEVID Register Definitions */
+#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
+#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
+
+#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
+#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
+
+#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
+#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
+
+#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
+#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
+
+#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
+#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
+
+#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
+#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
+
+/* TPI DEVTYPE Register Definitions */
+#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
+#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
+
+#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
+#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
+
+/*@}*/ /* end of group CMSIS_TPI */
+
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
+  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
+  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
+  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+#if (__FPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
+    \brief      Type definitions for the Floating Point Unit (FPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Floating Point Unit (FPU).
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
+  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
+  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
+  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
+  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
+} FPU_Type;
+
+/* Floating-Point Context Control Register */
+#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
+#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
+
+#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
+#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
+
+#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
+#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
+
+#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
+#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
+
+#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
+#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
+
+#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
+#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
+
+#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
+#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
+
+#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
+#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
+
+#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
+#define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCCR: Lazy state preservation active bit Mask */
+
+/* Floating-Point Context Address Register */
+#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
+#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
+
+/* Floating-Point Default Status Control Register */
+#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
+#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
+
+#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
+#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
+
+#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
+#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
+
+#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
+#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
+
+/* Media and FP Feature Register 0 */
+#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
+#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
+
+#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
+#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
+
+#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
+#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
+
+#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
+#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
+
+#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
+#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
+
+#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
+#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
+
+#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
+#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
+
+#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
+#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR0: A_SIMD registers bits Mask */
+
+/* Media and FP Feature Register 1 */
+#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
+#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
+
+#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
+#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
+
+#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
+#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
+
+#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
+#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR1: FtZ mode bits Mask */
+
+/*@} end of group CMSIS_FPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Type definitions for the Core Debug Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Core Debug Register (CoreDebug).
+ */
+typedef struct
+{
+  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
+  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
+  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
+  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
+} CoreDebug_Type;
+
+/* Debug Halting Control and Status Register */
+#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
+#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
+
+#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
+#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
+
+#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
+#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
+
+#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
+#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
+
+#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
+#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
+
+#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
+#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
+
+#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
+#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
+
+#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
+#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
+
+#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
+#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
+
+#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
+#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
+
+#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
+#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
+
+#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
+#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
+
+/* Debug Core Register Selector Register */
+#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
+#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
+
+#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
+#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
+
+/* Debug Exception and Monitor Control Register */
+#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
+#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
+
+#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
+#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
+
+#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
+#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
+
+#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
+#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
+
+#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
+#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
+
+#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
+#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
+
+#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
+#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
+
+#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
+#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
+
+#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
+#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
+
+#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
+#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
+
+#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
+#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
+
+#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
+#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
+
+#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
+#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
+
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M4 Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
+#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
+#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
+#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
+#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
+
+#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
+#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
+#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
+#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+#if (__FPU_PRESENT == 1)
+  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
+  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Debug Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/** \brief  Set Priority Grouping
+
+  The function sets the priority grouping field using the required unlock sequence.
+  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
+  Only values from 0..7 are used.
+  In case of a conflict between priority grouping and available
+  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
+
+    \param [in]      PriorityGroup  Priority grouping field.
+ */
+__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
+{
+  uint32_t reg_value;
+  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
+
+  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
+  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
+  reg_value  =  (reg_value                                 |
+                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
+                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
+  SCB->AIRCR =  reg_value;
+}
+
+
+/** \brief  Get Priority Grouping
+
+  The function reads the priority grouping field from the NVIC Interrupt Controller.
+
+    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
+{
+  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
+}
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
+  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Get Active Interrupt
+
+    The function reads the active register in NVIC and returns the active bit.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not active.
+    \return             1  Interrupt status is active.
+ */
+__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
+{
+  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
+  else {
+    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
+  else {
+    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  Encode Priority
+
+    The function encodes the priority for an interrupt with the given priority group,
+    preemptive priority value, and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
+
+    \param [in]     PriorityGroup  Used priority group.
+    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
+    \param [in]       SubPriority  Subpriority value (starting from 0).
+    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
+ */
+__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  return (
+           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
+           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
+         );
+}
+
+
+/** \brief  Decode Priority
+
+    The function decodes an interrupt priority value with a given priority group to
+    preemptive priority value and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+
+    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
+    \param [in]     PriorityGroup  Used priority group.
+    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
+    \param [out]     pSubPriority  Subpriority value (starting from 0).
+ */
+__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
+  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
+                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+/* ##################################### Debug In/Output function ########################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_core_DebugFunctions ITM Functions
+    \brief   Functions that access the ITM debug interface.
+  @{
+ */
+
+extern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
+#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
+
+
+/** \brief  ITM Send Character
+
+    The function transmits a character via the ITM channel 0, and
+    \li Just returns when no debugger is connected that has booked the output.
+    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
+
+    \param [in]     ch  Character to transmit.
+
+    \returns            Character to transmit.
+ */
+__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
+{
+  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
+      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
+  {
+    while (ITM->PORT[0].u32 == 0);
+    ITM->PORT[0].u8 = (uint8_t) ch;
+  }
+  return (ch);
+}
+
+
+/** \brief  ITM Receive Character
+
+    The function inputs a character via the external variable \ref ITM_RxBuffer.
+
+    \return             Received character.
+    \return         -1  No character pending.
+ */
+__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
+  int32_t ch = -1;                           /* no character available */
+
+  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
+    ch = ITM_RxBuffer;
+    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
+  }
+
+  return (ch);
+}
+
+
+/** \brief  ITM Check Character
+
+    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
+
+    \return          0  No character available.
+    \return          1  Character available.
+ */
+__STATIC_INLINE int32_t ITM_CheckChar (void) {
+
+  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
+    return (0);                                 /* no character available */
+  } else {
+    return (1);                                 /*    character available */
+  }
+}
+
+/*@} end of CMSIS_core_DebugFunctions */
+
+#endif /* __CORE_CM4_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/stm32f407zg/uniproton/board/CORE/core_cm4_simd.h b/stm32f407zg/uniproton/board/CORE/core_cm4_simd.h
new file mode 100644
index 0000000..af1831e
--- /dev/null
+++ b/stm32f407zg/uniproton/board/CORE/core_cm4_simd.h
@@ -0,0 +1,673 @@
+/**************************************************************************//**
+ * @file     core_cm4_simd.h
+ * @brief    CMSIS Cortex-M4 SIMD Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM4_SIMD_H
+#define __CORE_CM4_SIMD_H
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+ ******************************************************************************/
+
+
+/* ###################  Compiler specific Intrinsics  ########################### */
+/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
+  Access to dedicated SIMD instructions
+  @{
+*/
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#define __SADD8                           __sadd8
+#define __QADD8                           __qadd8
+#define __SHADD8                          __shadd8
+#define __UADD8                           __uadd8
+#define __UQADD8                          __uqadd8
+#define __UHADD8                          __uhadd8
+#define __SSUB8                           __ssub8
+#define __QSUB8                           __qsub8
+#define __SHSUB8                          __shsub8
+#define __USUB8                           __usub8
+#define __UQSUB8                          __uqsub8
+#define __UHSUB8                          __uhsub8
+#define __SADD16                          __sadd16
+#define __QADD16                          __qadd16
+#define __SHADD16                         __shadd16
+#define __UADD16                          __uadd16
+#define __UQADD16                         __uqadd16
+#define __UHADD16                         __uhadd16
+#define __SSUB16                          __ssub16
+#define __QSUB16                          __qsub16
+#define __SHSUB16                         __shsub16
+#define __USUB16                          __usub16
+#define __UQSUB16                         __uqsub16
+#define __UHSUB16                         __uhsub16
+#define __SASX                            __sasx
+#define __QASX                            __qasx
+#define __SHASX                           __shasx
+#define __UASX                            __uasx
+#define __UQASX                           __uqasx
+#define __UHASX                           __uhasx
+#define __SSAX                            __ssax
+#define __QSAX                            __qsax
+#define __SHSAX                           __shsax
+#define __USAX                            __usax
+#define __UQSAX                           __uqsax
+#define __UHSAX                           __uhsax
+#define __USAD8                           __usad8
+#define __USADA8                          __usada8
+#define __SSAT16                          __ssat16
+#define __USAT16                          __usat16
+#define __UXTB16                          __uxtb16
+#define __UXTAB16                         __uxtab16
+#define __SXTB16                          __sxtb16
+#define __SXTAB16                         __sxtab16
+#define __SMUAD                           __smuad
+#define __SMUADX                          __smuadx
+#define __SMLAD                           __smlad
+#define __SMLADX                          __smladx
+#define __SMLALD                          __smlald
+#define __SMLALDX                         __smlaldx
+#define __SMUSD                           __smusd
+#define __SMUSDX                          __smusdx
+#define __SMLSD                           __smlsd
+#define __SMLSDX                          __smlsdx
+#define __SMLSLD                          __smlsld
+#define __SMLSLDX                         __smlsldx
+#define __SEL                             __sel
+#define __QADD                            __qadd
+#define __QSUB                            __qsub
+
+#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
+                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
+
+#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
+                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
+
+#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
+                                                      ((int64_t)(ARG3) << 32)      ) >> 32))
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#include <cmsis_iar.h>
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#include <cmsis_ccs.h>
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SSAT16(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+#define __USAT16(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
+{
+  uint32_t result;
+
+  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
+{
+  uint32_t result;
+
+  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SMLALD(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+#define __SMLALDX(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SMLSLD(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+#define __SMLSLDX(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+#define __PKHBT(ARG1,ARG2,ARG3) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
+  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
+  __RES; \
+ })
+
+#define __PKHTB(ARG1,ARG2,ARG3) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
+  if (ARG3 == 0) \
+    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
+  else \
+    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
+  __RES; \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
+{
+ int32_t result;
+
+ __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
+ return(result);
+}
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+/* not yet supported */
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+#endif
+
+/*@} end of group CMSIS_SIMD_intrinsics */
+
+
+#endif /* __CORE_CM4_SIMD_H */
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/stm32f407zg/uniproton/board/CORE/core_cmFunc.h b/stm32f407zg/uniproton/board/CORE/core_cmFunc.h
new file mode 100644
index 0000000..139bc3c
--- /dev/null
+++ b/stm32f407zg/uniproton/board/CORE/core_cmFunc.h
@@ -0,0 +1,636 @@
+/**************************************************************************//**
+ * @file     core_cmFunc.h
+ * @brief    CMSIS Cortex-M Core Function Access Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMFUNC_H
+#define __CORE_CMFUNC_H
+
+
+/* ###########################  Core Function Access  ########################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
+  @{
+ */
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+/* intrinsic void __enable_irq();     */
+/* intrinsic void __disable_irq();    */
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  register uint32_t __regControl         __ASM("control");
+  return(__regControl);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  register uint32_t __regControl         __ASM("control");
+  __regControl = control;
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  register uint32_t __regIPSR          __ASM("ipsr");
+  return(__regIPSR);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__STATIC_INLINE uint32_t __get_APSR(void)
+{
+  register uint32_t __regAPSR          __ASM("apsr");
+  return(__regAPSR);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  register uint32_t __regXPSR          __ASM("xpsr");
+  return(__regXPSR);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  return(__regProcessStackPointer);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  __regProcessStackPointer = topOfProcStack;
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  return(__regMainStackPointer);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  __regMainStackPointer = topOfMainStack;
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  return(__regPriMask);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  __regPriMask = (priMask);
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __enable_fault_irq                __enable_fiq
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __disable_fault_irq               __disable_fiq
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__STATIC_INLINE uint32_t  __get_BASEPRI(void)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  return(__regBasePri);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  __regBasePri = (basePri & 0xff);
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  return(__regFaultMask);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  __regFaultMask = (faultMask & (uint32_t)1);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  return(__regfpscr);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  __regfpscr = (fpscr);
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/** \brief  Enable IRQ Interrupts
+
+  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
+{
+  __ASM volatile ("cpsie i" : : : "memory");
+}
+
+
+/** \brief  Disable IRQ Interrupts
+
+  This function disables IRQ interrupts by setting the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
+{
+  __ASM volatile ("cpsid i" : : : "memory");
+}
+
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, control" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, primask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
+{
+  __ASM volatile ("cpsie f" : : : "memory");
+}
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
+{
+  __ASM volatile ("cpsid f" : : : "memory");
+}
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
+{
+  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  uint32_t result;
+
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
+  __ASM volatile ("");
+  return(result);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
+  __ASM volatile ("");
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all instrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@} end of CMSIS_Core_RegAccFunctions */
+
+
+#endif /* __CORE_CMFUNC_H */
diff --git a/stm32f407zg/uniproton/board/CORE/core_cmInstr.h b/stm32f407zg/uniproton/board/CORE/core_cmInstr.h
new file mode 100644
index 0000000..8946c2c
--- /dev/null
+++ b/stm32f407zg/uniproton/board/CORE/core_cmInstr.h
@@ -0,0 +1,688 @@
+/**************************************************************************//**
+ * @file     core_cmInstr.h
+ * @brief    CMSIS Cortex-M Core Instruction Access Header File
+ * @version  V3.20
+ * @date     05. March 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMINSTR_H
+#define __CORE_CMINSTR_H
+
+
+/* ##########################  Core Instruction Access  ######################### */
+/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
+  Access to dedicated instructions
+  @{
+*/
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+#define __NOP                             __nop
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+#define __WFI                             __wfi
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+#define __WFE                             __wfe
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+#define __SEV                             __sev
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+#define __ISB()                           __isb(0xF)
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+#define __DSB()                           __dsb(0xF)
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+#define __DMB()                           __dmb(0xF)
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __REV                             __rev
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
+{
+  rev16 r0, r0
+  bx lr
+}
+#endif
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
+{
+  revsh r0, r0
+  bx lr
+}
+#endif
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+#define __ROR                             __ror
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __breakpoint(value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __RBIT                            __rbit
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXB(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXH(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXW(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+#define __CLREX                           __clrex
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT                            __ssat
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT                            __usat
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+#define __CLZ                             __clz
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/* Define macros for porting to both thumb1 and thumb2.
+ * For thumb1, use low register (r0-r7), specified by constrant "l"
+ * Otherwise, use general registers, specified by constrant "r" */
+#if defined (__thumb__) && !defined (__thumb2__)
+#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
+#define __CMSIS_GCC_USE_REG(r) "l" (r)
+#else
+#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
+#define __CMSIS_GCC_USE_REG(r) "r" (r)
+#endif
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
+{
+  __ASM volatile ("nop");
+}
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
+{
+  __ASM volatile ("wfi");
+}
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
+{
+  __ASM volatile ("wfe");
+}
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
+{
+  __ASM volatile ("sev");
+}
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
+{
+  __ASM volatile ("isb");
+}
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
+{
+  __ASM volatile ("dsb");
+}
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
+{
+  __ASM volatile ("dmb");
+}
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+  return __builtin_bswap32(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
+{
+  uint32_t result;
+
+  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+}
+
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+  return (short)__builtin_bswap16(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
+{
+  return (op1 >> op2) | (op1 << (32 - op2)); 
+}
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
+{
+  uint32_t result;
+
+   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
+{
+    uint32_t result;
+
+   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
+{
+  __ASM volatile ("clrex" ::: "memory");
+}
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
+{
+   uint32_t result;
+
+  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
+  return(result);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all intrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
+
+#endif /* __CORE_CMINSTR_H */
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/inc/stm32f4x7_eth.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/inc/stm32f4x7_eth.h
new file mode 100644
index 0000000..27553e4
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/inc/stm32f4x7_eth.h
@@ -0,0 +1,1883 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4x7_eth.h
+  * @author  MCD Application Team
+  * @version V1.0.0
+  * @date    14-October-2011
+  * @brief   This file contains all the functions prototypes for the Ethernet
+  *          firmware driver.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4x7_ETH_H
+#define __STM32F4x7_ETH_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4x7_eth_conf.h"
+
+/** @addtogroup STM32F4x7_ETH_Driver
+  * @{
+  */
+
+/** @defgroup ETH_Exported_Types
+  * @{
+  */
+
+/** 
+  * @brief  ETH MAC Init structure definition
+  * @note   The user should not configure all the ETH_InitTypeDef structure's fields. 
+  *   By calling the ETH_StructInit function the structure抯 fields are set to their default values.
+  *   Only the parameters that will be set to a non-default value should be configured.  
+  */ 
+typedef struct {
+/** 
+  * @brief / * MAC  
+  */ 
+  uint32_t             ETH_AutoNegotiation;           /*!< Selects or not the AutoNegotiation mode for the external PHY
+                                                           The AutoNegotiation allows an automatic setting of the Speed (10/100Mbps)
+                                                           and the mode (half/full-duplex).
+                                                           This parameter can be a value of @ref ETH_AutoNegotiation */
+
+  uint32_t             ETH_Watchdog;                  /*!< Selects or not the Watchdog timer
+                                                           When enabled, the MAC allows no more then 2048 bytes to be received.
+                                                           When disabled, the MAC can receive up to 16384 bytes.
+                                                           This parameter can be a value of @ref ETH_watchdog */  
+
+  uint32_t             ETH_Jabber;                    /*!< Selects or not Jabber timer
+                                                           When enabled, the MAC allows no more then 2048 bytes to be sent.
+                                                           When disabled, the MAC can send up to 16384 bytes.
+                                                           This parameter can be a value of @ref ETH_Jabber */
+
+  uint32_t             ETH_InterFrameGap;             /*!< Selects the minimum IFG between frames during transmission
+                                                           This parameter can be a value of @ref ETH_Inter_Frame_Gap */   
+
+  uint32_t             ETH_CarrierSense;              /*!< Selects or not the Carrier Sense
+                                                           This parameter can be a value of @ref ETH_Carrier_Sense */
+
+  uint32_t             ETH_Speed;                     /*!< Sets the Ethernet speed: 10/100 Mbps
+                                                           This parameter can be a value of @ref ETH_Speed */
+
+  uint32_t             ETH_ReceiveOwn;                /*!< Selects or not the ReceiveOwn
+                                                           ReceiveOwn allows the reception of frames when the TX_EN signal is asserted
+                                                           in Half-Duplex mode
+                                                           This parameter can be a value of @ref ETH_Receive_Own */  
+
+  uint32_t             ETH_LoopbackMode;              /*!< Selects or not the internal MAC MII Loopback mode
+                                                           This parameter can be a value of @ref ETH_Loop_Back_Mode */  
+
+  uint32_t             ETH_Mode;                      /*!< Selects the MAC duplex mode: Half-Duplex or Full-Duplex mode
+                                                           This parameter can be a value of @ref ETH_Duplex_Mode */  
+
+  uint32_t             ETH_ChecksumOffload;           /*!< Selects or not the IPv4 checksum checking for received frame payloads' TCP/UDP/ICMP headers.
+                                                           This parameter can be a value of @ref ETH_Checksum_Offload */    
+
+  uint32_t             ETH_RetryTransmission;         /*!< Selects or not the MAC attempt retries transmission, based on the settings of BL,
+                                                           when a collision occurs (Half-Duplex mode)
+                                                           This parameter can be a value of @ref ETH_Retry_Transmission */
+
+  uint32_t             ETH_AutomaticPadCRCStrip;      /*!< Selects or not the Automatic MAC Pad/CRC Stripping
+                                                           This parameter can be a value of @ref ETH_Automatic_Pad_CRC_Strip */ 
+
+  uint32_t             ETH_BackOffLimit;              /*!< Selects the BackOff limit value
+                                                           This parameter can be a value of @ref ETH_Back_Off_Limit */
+
+  uint32_t             ETH_DeferralCheck;             /*!< Selects or not the deferral check function (Half-Duplex mode)
+                                                           This parameter can be a value of @ref ETH_Deferral_Check */                                                                                                        
+
+  uint32_t             ETH_ReceiveAll;                /*!< Selects or not all frames reception by the MAC (No filtering)
+                                                           This parameter can be a value of @ref ETH_Receive_All */   
+
+  uint32_t             ETH_SourceAddrFilter;          /*!< Selects the Source Address Filter mode                                                           
+                                                           This parameter can be a value of @ref ETH_Source_Addr_Filter */                  
+
+  uint32_t             ETH_PassControlFrames;         /*!< Sets the forwarding mode of the control frames (including unicast and multicast PAUSE frames)                                                          
+                                                           This parameter can be a value of @ref ETH_Pass_Control_Frames */ 
+
+  uint32_t             ETH_BroadcastFramesReception;  /*!< Selects or not the reception of Broadcast Frames
+                                                           This parameter can be a value of @ref ETH_Broadcast_Frames_Reception */
+
+  uint32_t             ETH_DestinationAddrFilter;     /*!< Sets the destination filter mode for both unicast and multicast frames
+                                                           This parameter can be a value of @ref ETH_Destination_Addr_Filter */ 
+
+  uint32_t             ETH_PromiscuousMode;           /*!< Selects or not the Promiscuous Mode
+                                                           This parameter can be a value of @ref ETH_Promiscuous_Mode */
+
+  uint32_t             ETH_MulticastFramesFilter;     /*!< Selects the Multicast Frames filter mode: None/HashTableFilter/PerfectFilter/PerfectHashTableFilter
+                                                           This parameter can be a value of @ref ETH_Multicast_Frames_Filter */ 
+
+  uint32_t             ETH_UnicastFramesFilter;       /*!< Selects the Unicast Frames filter mode: HashTableFilter/PerfectFilter/PerfectHashTableFilter
+                                                           This parameter can be a value of @ref ETH_Unicast_Frames_Filter */ 
+
+  uint32_t             ETH_HashTableHigh;             /*!< This field holds the higher 32 bits of Hash table.  */    
+
+  uint32_t             ETH_HashTableLow;              /*!< This field holds the lower 32 bits of Hash table.  */    
+
+  uint32_t             ETH_PauseTime;                 /*!< This field holds the value to be used in the Pause Time field in the
+                                                           transmit control frame */
+
+  uint32_t             ETH_ZeroQuantaPause;           /*!< Selects or not the automatic generation of Zero-Quanta Pause Control frames
+                                                           This parameter can be a value of @ref ETH_Zero_Quanta_Pause */  
+
+  uint32_t             ETH_PauseLowThreshold;         /*!< This field configures the threshold of the PAUSE to be checked for
+                                                           automatic retransmission of PAUSE Frame
+                                                           This parameter can be a value of @ref ETH_Pause_Low_Threshold */
+                                                           
+  uint32_t             ETH_UnicastPauseFrameDetect;   /*!< Selects or not the MAC detection of the Pause frames (with MAC Address0
+                                                           unicast address and unique multicast address)
+                                                           This parameter can be a value of @ref ETH_Unicast_Pause_Frame_Detect */  
+
+  uint32_t             ETH_ReceiveFlowControl;        /*!< Enables or disables the MAC to decode the received Pause frame and
+                                                           disable its transmitter for a specified time (Pause Time)
+                                                           This parameter can be a value of @ref ETH_Receive_Flow_Control */
+
+  uint32_t             ETH_TransmitFlowControl;       /*!< Enables or disables the MAC to transmit Pause frames (Full-Duplex mode)
+                                                           or the MAC back-pressure operation (Half-Duplex mode)
+                                                           This parameter can be a value of @ref ETH_Transmit_Flow_Control */     
+
+  uint32_t             ETH_VLANTagComparison;         /*!< Selects the 12-bit VLAN identifier or the complete 16-bit VLAN tag for
+                                                           comparison and filtering
+                                                           This parameter can be a value of @ref ETH_VLAN_Tag_Comparison */ 
+
+  uint32_t             ETH_VLANTagIdentifier;         /*!< Holds the VLAN tag identifier for receive frames */
+
+/** 
+  * @brief / * DMA  
+  */ 
+
+  uint32_t             ETH_DropTCPIPChecksumErrorFrame; /*!< Selects or not the Dropping of TCP/IP Checksum Error Frames
+                                                             This parameter can be a value of @ref ETH_Drop_TCP_IP_Checksum_Error_Frame */ 
+
+  uint32_t             ETH_ReceiveStoreForward;         /*!< Enables or disables the Receive store and forward mode
+                                                             This parameter can be a value of @ref ETH_Receive_Store_Forward */ 
+
+  uint32_t             ETH_FlushReceivedFrame;          /*!< Enables or disables the flushing of received frames
+                                                             This parameter can be a value of @ref ETH_Flush_Received_Frame */ 
+
+  uint32_t             ETH_TransmitStoreForward;        /*!< Enables or disables Transmit store and forward mode
+                                                             This parameter can be a value of @ref ETH_Transmit_Store_Forward */ 
+
+  uint32_t             ETH_TransmitThresholdControl;    /*!< Selects or not the Transmit Threshold Control
+                                                             This parameter can be a value of @ref ETH_Transmit_Threshold_Control */
+
+  uint32_t             ETH_ForwardErrorFrames;          /*!< Selects or not the forward to the DMA of erroneous frames
+                                                             This parameter can be a value of @ref ETH_Forward_Error_Frames */
+
+  uint32_t             ETH_ForwardUndersizedGoodFrames; /*!< Enables or disables the Rx FIFO to forward Undersized frames (frames with no Error
+                                                             and length less than 64 bytes) including pad-bytes and CRC)
+                                                             This parameter can be a value of @ref ETH_Forward_Undersized_Good_Frames */
+
+  uint32_t             ETH_ReceiveThresholdControl;     /*!< Selects the threshold level of the Receive FIFO
+                                                             This parameter can be a value of @ref ETH_Receive_Threshold_Control */
+
+  uint32_t             ETH_SecondFrameOperate;          /*!< Selects or not the Operate on second frame mode, which allows the DMA to process a second
+                                                             frame of Transmit data even before obtaining the status for the first frame.
+                                                             This parameter can be a value of @ref ETH_Second_Frame_Operate */
+
+  uint32_t             ETH_AddressAlignedBeats;         /*!< Enables or disables the Address Aligned Beats
+                                                             This parameter can be a value of @ref ETH_Address_Aligned_Beats */
+
+  uint32_t             ETH_FixedBurst;                  /*!< Enables or disables the AHB Master interface fixed burst transfers
+                                                             This parameter can be a value of @ref ETH_Fixed_Burst */
+                       
+  uint32_t             ETH_RxDMABurstLength;            /*!< Indicates the maximum number of beats to be transferred in one Rx DMA transaction
+                                                             This parameter can be a value of @ref ETH_Rx_DMA_Burst_Length */ 
+
+  uint32_t             ETH_TxDMABurstLength;            /*!< Indicates the maximum number of beats to be transferred in one Tx DMA transaction
+                                                             This parameter can be a value of @ref ETH_Tx_DMA_Burst_Length */                                                   
+
+  uint32_t             ETH_DescriptorSkipLength;        /*!< Specifies the number of word to skip between two unchained descriptors (Ring mode) */                                                             
+
+  uint32_t             ETH_DMAArbitration;              /*!< Selects the DMA Tx/Rx arbitration
+                                                             This parameter can be a value of @ref ETH_DMA_Arbitration */  
+}ETH_InitTypeDef;
+
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                           DMA descriptors types
+  */ 
+/**--------------------------------------------------------------------------**/
+
+/** 
+  * @brief  ETH DMA Descriptors data structure definition
+  */ 
+typedef struct  {
+  __IO uint32_t   Status;                /*!< Status */
+  uint32_t   ControlBufferSize;     /*!< Control and Buffer1, Buffer2 lengths */
+  uint32_t   Buffer1Addr;           /*!< Buffer1 address pointer */
+  uint32_t   Buffer2NextDescAddr;   /*!< Buffer2 or next descriptor address pointer */
+/* Enhanced ETHERNET DMA PTP Descriptors */
+#ifdef USE_ENHANCED_DMA_DESCRIPTORS
+  uint32_t   ExtendedStatus;        /* Extended status for PTP receive descriptor */
+  uint32_t   Reserved1;             /* Reserved */
+  uint32_t   TimeStampLow;          /* Time Stamp Low value for transmit and receive */
+  uint32_t   TimeStampHigh;         /* Time Stamp High value for transmit and receive */
+#endif /* USE_ENHANCED_DMA_DESCRIPTORS */
+} ETH_DMADESCTypeDef;
+
+
+typedef struct{
+  u32 length;
+  u32 buffer;
+  __IO ETH_DMADESCTypeDef *descriptor;
+}FrameTypeDef;
+
+
+typedef struct  {
+  __IO ETH_DMADESCTypeDef *FS_Rx_Desc;          /*!< First Segment Rx Desc */
+  __IO ETH_DMADESCTypeDef *LS_Rx_Desc;          /*!< Last Segment Rx Desc */
+  __IO uint32_t  Seg_Count;                     /*!< Segment count */
+} ETH_DMA_Rx_Frame_infos;
+  
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Exported_Constants
+  * @{
+  */ 
+ 
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                          ETH Frames defines
+  */ 
+/**--------------------------------------------------------------------------**/
+
+/** @defgroup ENET_Buffers_setting 
+  * @{
+  */ 
+#define ETH_MAX_PACKET_SIZE    1524    /*!< ETH_HEADER + ETH_EXTRA + VLAN_TAG + MAX_ETH_PAYLOAD + ETH_CRC */
+#define ETH_HEADER               14    /*!< 6 byte Dest addr, 6 byte Src addr, 2 byte length/type */
+#define ETH_CRC                   4    /*!< Ethernet CRC */
+#define ETH_EXTRA                 2    /*!< Extra bytes in some cases */   
+#define VLAN_TAG                  4    /*!< optional 802.1q VLAN Tag */
+#define MIN_ETH_PAYLOAD          46    /*!< Minimum Ethernet payload size */
+#define MAX_ETH_PAYLOAD        1500    /*!< Maximum Ethernet payload size */
+#define JUMBO_FRAME_PAYLOAD    9000    /*!< Jumbo frame payload size */      
+
+ /* Ethernet driver receive buffers are organized in a chained linked-list, when
+    an ethernet packet is received, the Rx-DMA will transfer the packet from RxFIFO
+    to the driver receive buffers memory.
+    
+    Depending on the size of the received ethernet packet and the size of 
+    each ethernet driver receive buffer, the received packet can take one or more
+    ethernet driver receive buffer. 
+    
+    In below are defined the size of one ethernet driver receive buffer ETH_RX_BUF_SIZE 
+    and the total count of the driver receive buffers ETH_RXBUFNB.
+    
+    The configured value for ETH_RX_BUF_SIZE and ETH_RXBUFNB are only provided as 
+    example, they can be reconfigured in the application layer to fit the application 
+    needs */ 
+   
+/* Here we configure each Ethernet driver receive buffer to fit the Max size Ethernet
+   packet */    
+#ifndef ETH_RX_BUF_SIZE
+ #define ETH_RX_BUF_SIZE         ETH_MAX_PACKET_SIZE 
+#endif
+
+/* 5 Ethernet driver receive buffers are used (in a chained linked list)*/ 
+#ifndef ETH_RXBUFNB
+ #define ETH_RXBUFNB             5     /*  5 Rx buffers of size ETH_RX_BUF_SIZE */
+#endif
+
+
+ /* Ethernet driver transmit buffers are organized in a chained linked-list, when
+    an ethernet packet is transmitted, Tx-DMA will transfer the packet from the 
+    driver transmit buffers memory to the TxFIFO.
+    
+    Depending on the size of the Ethernet packet to be transmitted and the size of 
+    each ethernet driver transmit buffer, the packet to be transmitted can take 
+    one or more ethernet driver transmit buffer. 
+    
+    In below are defined the size of one ethernet driver transmit buffer ETH_TX_BUF_SIZE 
+    and the total count of the driver transmit buffers ETH_TXBUFNB.
+    
+    The configured value for ETH_TX_BUF_SIZE and ETH_TXBUFNB are only provided as 
+    example, they can be reconfigured in the application layer to fit the application 
+    needs */ 
+   
+/* Here we configure each Ethernet driver transmit buffer to fit the Max size Ethernet
+   packet */  
+#ifndef ETH_TX_BUF_SIZE 
+ #define ETH_TX_BUF_SIZE         ETH_MAX_PACKET_SIZE
+#endif
+
+/* 5 ethernet driver transmit buffers are used (in a chained linked list)*/ 
+#ifndef ETH_TXBUFNB
+ #define ETH_TXBUFNB             5      /* 5  Tx buffers of size ETH_TX_BUF_SIZE */
+#endif
+
+#define  ETH_DMARxDesc_FrameLengthShift           16
+
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                 Ethernet DMA descriptors registers bits definition
+  */ 
+/**--------------------------------------------------------------------------**/
+
+/**
+@code 
+   DMA Tx Desciptor
+  -----------------------------------------------------------------------------------------------
+  TDES0 | OWN(31) | CTRL[30:26] | Reserved[25:24] | CTRL[23:20] | Reserved[19:17] | Status[16:0] |
+  -----------------------------------------------------------------------------------------------
+  TDES1 | Reserved[31:29] | Buffer2 ByteCount[28:16] | Reserved[15:13] | Buffer1 ByteCount[12:0] |
+  -----------------------------------------------------------------------------------------------
+  TDES2 |                         Buffer1 Address [31:0]                                         |
+  -----------------------------------------------------------------------------------------------
+  TDES3 |                   Buffer2 Address [31:0] / Next Descriptor Address [31:0]              |
+  -----------------------------------------------------------------------------------------------
+@endcode
+*/
+
+/** 
+  * @brief  Bit definition of TDES0 register: DMA Tx descriptor status register
+  */ 
+#define ETH_DMATxDesc_OWN                     ((uint32_t)0x80000000)  /*!< OWN bit: descriptor is owned by DMA engine */
+#define ETH_DMATxDesc_IC                      ((uint32_t)0x40000000)  /*!< Interrupt on Completion */
+#define ETH_DMATxDesc_LS                      ((uint32_t)0x20000000)  /*!< Last Segment */
+#define ETH_DMATxDesc_FS                      ((uint32_t)0x10000000)  /*!< First Segment */
+#define ETH_DMATxDesc_DC                      ((uint32_t)0x08000000)  /*!< Disable CRC */
+#define ETH_DMATxDesc_DP                      ((uint32_t)0x04000000)  /*!< Disable Padding */
+#define ETH_DMATxDesc_TTSE                    ((uint32_t)0x02000000)  /*!< Transmit Time Stamp Enable */
+#define ETH_DMATxDesc_CIC                     ((uint32_t)0x00C00000)  /*!< Checksum Insertion Control: 4 cases */
+#define ETH_DMATxDesc_CIC_ByPass              ((uint32_t)0x00000000)  /*!< Do Nothing: Checksum Engine is bypassed */ 
+#define ETH_DMATxDesc_CIC_IPV4Header          ((uint32_t)0x00400000)  /*!< IPV4 header Checksum Insertion */ 
+#define ETH_DMATxDesc_CIC_TCPUDPICMP_Segment  ((uint32_t)0x00800000)  /*!< TCP/UDP/ICMP Checksum Insertion calculated over segment only */ 
+#define ETH_DMATxDesc_CIC_TCPUDPICMP_Full     ((uint32_t)0x00C00000)  /*!< TCP/UDP/ICMP Checksum Insertion fully calculated */ 
+#define ETH_DMATxDesc_TER                     ((uint32_t)0x00200000)  /*!< Transmit End of Ring */
+#define ETH_DMATxDesc_TCH                     ((uint32_t)0x00100000)  /*!< Second Address Chained */
+#define ETH_DMATxDesc_TTSS                    ((uint32_t)0x00020000)  /*!< Tx Time Stamp Status */
+#define ETH_DMATxDesc_IHE                     ((uint32_t)0x00010000)  /*!< IP Header Error */
+#define ETH_DMATxDesc_ES                      ((uint32_t)0x00008000)  /*!< Error summary: OR of the following bits: UE || ED || EC || LCO || NC || LCA || FF || JT */
+#define ETH_DMATxDesc_JT                      ((uint32_t)0x00004000)  /*!< Jabber Timeout */
+#define ETH_DMATxDesc_FF                      ((uint32_t)0x00002000)  /*!< Frame Flushed: DMA/MTL flushed the frame due to SW flush */
+#define ETH_DMATxDesc_PCE                     ((uint32_t)0x00001000)  /*!< Payload Checksum Error */
+#define ETH_DMATxDesc_LCA                     ((uint32_t)0x00000800)  /*!< Loss of Carrier: carrier lost during transmission */
+#define ETH_DMATxDesc_NC                      ((uint32_t)0x00000400)  /*!< No Carrier: no carrier signal from the transceiver */
+#define ETH_DMATxDesc_LCO                     ((uint32_t)0x00000200)  /*!< Late Collision: transmission aborted due to collision */
+#define ETH_DMATxDesc_EC                      ((uint32_t)0x00000100)  /*!< Excessive Collision: transmission aborted after 16 collisions */
+#define ETH_DMATxDesc_VF                      ((uint32_t)0x00000080)  /*!< VLAN Frame */
+#define ETH_DMATxDesc_CC                      ((uint32_t)0x00000078)  /*!< Collision Count */
+#define ETH_DMATxDesc_ED                      ((uint32_t)0x00000004)  /*!< Excessive Deferral */
+#define ETH_DMATxDesc_UF                      ((uint32_t)0x00000002)  /*!< Underflow Error: late data arrival from the memory */
+#define ETH_DMATxDesc_DB                      ((uint32_t)0x00000001)  /*!< Deferred Bit */
+
+/** 
+  * @brief  Bit definition of TDES1 register
+  */ 
+#define ETH_DMATxDesc_TBS2  ((uint32_t)0x1FFF0000)  /*!< Transmit Buffer2 Size */
+#define ETH_DMATxDesc_TBS1  ((uint32_t)0x00001FFF)  /*!< Transmit Buffer1 Size */
+
+/** 
+  * @brief  Bit definition of TDES2 register
+  */ 
+#define ETH_DMATxDesc_B1AP  ((uint32_t)0xFFFFFFFF)  /*!< Buffer1 Address Pointer */
+
+/** 
+  * @brief  Bit definition of TDES3 register
+  */ 
+#define ETH_DMATxDesc_B2AP  ((uint32_t)0xFFFFFFFF)  /*!< Buffer2 Address Pointer */
+
+  /*---------------------------------------------------------------------------------------------
+  TDES6 |                         Transmit Time Stamp Low [31:0]                                 |
+  -----------------------------------------------------------------------------------------------
+  TDES7 |                         Transmit Time Stamp High [31:0]                                |
+  ----------------------------------------------------------------------------------------------*/
+
+/* Bit definition of TDES6 register */
+ #define ETH_DMAPTPTxDesc_TTSL  ((uint32_t)0xFFFFFFFF)  /* Transmit Time Stamp Low */
+
+/* Bit definition of TDES7 register */
+ #define ETH_DMAPTPTxDesc_TTSH  ((uint32_t)0xFFFFFFFF)  /* Transmit Time Stamp High */
+
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_Rx_descriptor 
+  * @{
+  */
+
+/**
+@code 
+  DMA Rx Descriptor
+  --------------------------------------------------------------------------------------------------------------------
+  RDES0 | OWN(31) |                                             Status [30:0]                                          |
+  ---------------------------------------------------------------------------------------------------------------------
+  RDES1 | CTRL(31) | Reserved[30:29] | Buffer2 ByteCount[28:16] | CTRL[15:14] | Reserved(13) | Buffer1 ByteCount[12:0] |
+  ---------------------------------------------------------------------------------------------------------------------
+  RDES2 |                                       Buffer1 Address [31:0]                                                 |
+  ---------------------------------------------------------------------------------------------------------------------
+  RDES3 |                          Buffer2 Address [31:0] / Next Descriptor Address [31:0]                             |
+  ---------------------------------------------------------------------------------------------------------------------
+@endcode
+*/
+
+/** 
+  * @brief  Bit definition of RDES0 register: DMA Rx descriptor status register
+  */ 
+#define ETH_DMARxDesc_OWN         ((uint32_t)0x80000000)  /*!< OWN bit: descriptor is owned by DMA engine  */
+#define ETH_DMARxDesc_AFM         ((uint32_t)0x40000000)  /*!< DA Filter Fail for the rx frame  */
+#define ETH_DMARxDesc_FL          ((uint32_t)0x3FFF0000)  /*!< Receive descriptor frame length  */
+#define ETH_DMARxDesc_ES          ((uint32_t)0x00008000)  /*!< Error summary: OR of the following bits: DE || OE || IPC || LC || RWT || RE || CE */
+#define ETH_DMARxDesc_DE          ((uint32_t)0x00004000)  /*!< Descriptor error: no more descriptors for receive frame  */
+#define ETH_DMARxDesc_SAF         ((uint32_t)0x00002000)  /*!< SA Filter Fail for the received frame */
+#define ETH_DMARxDesc_LE          ((uint32_t)0x00001000)  /*!< Frame size not matching with length field */
+#define ETH_DMARxDesc_OE          ((uint32_t)0x00000800)  /*!< Overflow Error: Frame was damaged due to buffer overflow */
+#define ETH_DMARxDesc_VLAN        ((uint32_t)0x00000400)  /*!< VLAN Tag: received frame is a VLAN frame */
+#define ETH_DMARxDesc_FS          ((uint32_t)0x00000200)  /*!< First descriptor of the frame  */
+#define ETH_DMARxDesc_LS          ((uint32_t)0x00000100)  /*!< Last descriptor of the frame  */ 
+#define ETH_DMARxDesc_IPV4HCE     ((uint32_t)0x00000080)  /*!< IPC Checksum Error: Rx Ipv4 header checksum error   */    
+#define ETH_DMARxDesc_LC          ((uint32_t)0x00000040)  /*!< Late collision occurred during reception   */
+#define ETH_DMARxDesc_FT          ((uint32_t)0x00000020)  /*!< Frame type - Ethernet, otherwise 802.3    */
+#define ETH_DMARxDesc_RWT         ((uint32_t)0x00000010)  /*!< Receive Watchdog Timeout: watchdog timer expired during reception    */
+#define ETH_DMARxDesc_RE          ((uint32_t)0x00000008)  /*!< Receive error: error reported by MII interface  */
+#define ETH_DMARxDesc_DBE         ((uint32_t)0x00000004)  /*!< Dribble bit error: frame contains non int multiple of 8 bits  */
+#define ETH_DMARxDesc_CE          ((uint32_t)0x00000002)  /*!< CRC error */
+#define ETH_DMARxDesc_MAMPCE      ((uint32_t)0x00000001)  /*!< Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error */
+
+/** 
+  * @brief  Bit definition of RDES1 register
+  */ 
+#define ETH_DMARxDesc_DIC   ((uint32_t)0x80000000)  /*!< Disable Interrupt on Completion */
+#define ETH_DMARxDesc_RBS2  ((uint32_t)0x1FFF0000)  /*!< Receive Buffer2 Size */
+#define ETH_DMARxDesc_RER   ((uint32_t)0x00008000)  /*!< Receive End of Ring */
+#define ETH_DMARxDesc_RCH   ((uint32_t)0x00004000)  /*!< Second Address Chained */
+#define ETH_DMARxDesc_RBS1  ((uint32_t)0x00001FFF)  /*!< Receive Buffer1 Size */
+
+/** 
+  * @brief  Bit definition of RDES2 register  
+  */ 
+#define ETH_DMARxDesc_B1AP  ((uint32_t)0xFFFFFFFF)  /*!< Buffer1 Address Pointer */
+
+/** 
+  * @brief  Bit definition of RDES3 register  
+  */ 
+#define ETH_DMARxDesc_B2AP  ((uint32_t)0xFFFFFFFF)  /*!< Buffer2 Address Pointer */
+
+/*---------------------------------------------------------------------------------------------------------------------
+  RDES4 |                   Reserved[31:15]              |             Extended Status [14:0]                          |
+  ---------------------------------------------------------------------------------------------------------------------
+  RDES5 |                                            Reserved[31:0]                                                    |
+  ---------------------------------------------------------------------------------------------------------------------
+  RDES6 |                                       Receive Time Stamp Low [31:0]                                          |
+  ---------------------------------------------------------------------------------------------------------------------
+  RDES7 |                                       Receive Time Stamp High [31:0]                                         |
+  --------------------------------------------------------------------------------------------------------------------*/
+
+/* Bit definition of RDES4 register */
+#define ETH_DMAPTPRxDesc_PTPV     ((uint32_t)0x00002000)  /* PTP Version */
+#define ETH_DMAPTPRxDesc_PTPFT    ((uint32_t)0x00001000)  /* PTP Frame Type */
+#define ETH_DMAPTPRxDesc_PTPMT    ((uint32_t)0x00000F00)  /* PTP Message Type */
+  #define ETH_DMAPTPRxDesc_PTPMT_Sync                      ((uint32_t)0x00000100)  /* SYNC message (all clock types) */
+  #define ETH_DMAPTPRxDesc_PTPMT_FollowUp                  ((uint32_t)0x00000200)  /* FollowUp message (all clock types) */ 
+  #define ETH_DMAPTPRxDesc_PTPMT_DelayReq                  ((uint32_t)0x00000300)  /* DelayReq message (all clock types) */ 
+  #define ETH_DMAPTPRxDesc_PTPMT_DelayResp                 ((uint32_t)0x00000400)  /* DelayResp message (all clock types) */ 
+  #define ETH_DMAPTPRxDesc_PTPMT_PdelayReq_Announce        ((uint32_t)0x00000500)  /* PdelayReq message (peer-to-peer transparent clock) or Announce message (Ordinary or Boundary clock) */ 
+  #define ETH_DMAPTPRxDesc_PTPMT_PdelayResp_Manag          ((uint32_t)0x00000600)  /* PdelayResp message (peer-to-peer transparent clock) or Management message (Ordinary or Boundary clock)  */ 
+  #define ETH_DMAPTPRxDesc_PTPMT_PdelayRespFollowUp_Signal ((uint32_t)0x00000700)  /* PdelayRespFollowUp message (peer-to-peer transparent clock) or Signaling message (Ordinary or Boundary clock) */           
+#define ETH_DMAPTPRxDesc_IPV6PR   ((uint32_t)0x00000080)  /* IPv6 Packet Received */
+#define ETH_DMAPTPRxDesc_IPV4PR   ((uint32_t)0x00000040)  /* IPv4 Packet Received */
+#define ETH_DMAPTPRxDesc_IPCB  ((uint32_t)0x00000020)  /* IP Checksum Bypassed */
+#define ETH_DMAPTPRxDesc_IPPE  ((uint32_t)0x00000010)  /* IP Payload Error */
+#define ETH_DMAPTPRxDesc_IPHE  ((uint32_t)0x00000008)  /* IP Header Error */
+#define ETH_DMAPTPRxDesc_IPPT  ((uint32_t)0x00000007)  /* IP Payload Type */
+  #define ETH_DMAPTPRxDesc_IPPT_UDP                 ((uint32_t)0x00000001)  /* UDP payload encapsulated in the IP datagram */
+  #define ETH_DMAPTPRxDesc_IPPT_TCP                 ((uint32_t)0x00000002)  /* TCP payload encapsulated in the IP datagram */ 
+  #define ETH_DMAPTPRxDesc_IPPT_ICMP                ((uint32_t)0x00000003)  /* ICMP payload encapsulated in the IP datagram */
+
+/* Bit definition of RDES6 register */
+#define ETH_DMAPTPRxDesc_RTSL  ((uint32_t)0xFFFFFFFF)  /* Receive Time Stamp Low */
+
+/* Bit definition of RDES7 register */
+#define ETH_DMAPTPRxDesc_RTSH  ((uint32_t)0xFFFFFFFF)  /* Receive Time Stamp High */
+
+
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                     Description of common PHY registers
+  */ 
+/**--------------------------------------------------------------------------**/
+
+/**
+  * @}
+  */
+
+/** @defgroup PHY_Read_write_Timeouts 
+  * @{
+  */ 
+#define PHY_READ_TO                     ((uint32_t)0x0004FFFF)
+#define PHY_WRITE_TO                    ((uint32_t)0x0004FFFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup PHY_Register_address 
+  * @{
+  */ 
+#define PHY_BCR                          0          /*!< Transceiver Basic Control Register */
+#define PHY_BSR                          1          /*!< Transceiver Basic Status Register */
+
+#define IS_ETH_PHY_ADDRESS(ADDRESS) ((ADDRESS) <= 0x20)
+#define IS_ETH_PHY_REG(REG) (((REG) == PHY_BCR) || \
+                             ((REG) == PHY_BSR) || \
+                             ((REG) == PHY_SR))
+/**
+  * @}
+  */
+
+/** @defgroup PHY_basic_Control_register 
+  * @{
+  */ 
+#define PHY_Reset                       ((uint16_t)0x8000)      /*!< PHY Reset */
+#define PHY_Loopback                    ((uint16_t)0x4000)      /*!< Select loop-back mode */
+#define PHY_FULLDUPLEX_100M             ((uint16_t)0x2100)      /*!< Set the full-duplex mode at 100 Mb/s */
+#define PHY_HALFDUPLEX_100M             ((uint16_t)0x2000)      /*!< Set the half-duplex mode at 100 Mb/s */
+#define PHY_FULLDUPLEX_10M              ((uint16_t)0x0100)      /*!< Set the full-duplex mode at 10 Mb/s */
+#define PHY_HALFDUPLEX_10M              ((uint16_t)0x0000)      /*!< Set the half-duplex mode at 10 Mb/s */
+#define PHY_AutoNegotiation             ((uint16_t)0x1000)      /*!< Enable auto-negotiation function */
+#define PHY_Restart_AutoNegotiation     ((uint16_t)0x0200)      /*!< Restart auto-negotiation function */
+#define PHY_Powerdown                   ((uint16_t)0x0800)      /*!< Select the power down mode */
+#define PHY_Isolate                     ((uint16_t)0x0400)      /*!< Isolate PHY from MII */
+
+/**
+  * @}
+  */
+
+/** @defgroup PHY_basic_status_register 
+  * @{
+  */ 
+#define PHY_AutoNego_Complete           ((uint16_t)0x0020)      /*!< Auto-Negotiation process completed */
+#define PHY_Linked_Status               ((uint16_t)0x0004)      /*!< Valid link established */
+#define PHY_Jabber_detection            ((uint16_t)0x0002)      /*!< Jabber condition detected */
+
+/**
+  * @}
+  */
+
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                                  MAC defines
+  */ 
+/**--------------------------------------------------------------------------**/
+
+/** @defgroup ETH_AutoNegotiation 
+  * @{
+  */ 
+#define ETH_AutoNegotiation_Enable     ((uint32_t)0x00000001)
+#define ETH_AutoNegotiation_Disable    ((uint32_t)0x00000000)
+#define IS_ETH_AUTONEGOTIATION(CMD) (((CMD) == ETH_AutoNegotiation_Enable) || \
+                                     ((CMD) == ETH_AutoNegotiation_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_watchdog 
+  * @{
+  */ 
+#define ETH_Watchdog_Enable       ((uint32_t)0x00000000)
+#define ETH_Watchdog_Disable      ((uint32_t)0x00800000)
+#define IS_ETH_WATCHDOG(CMD) (((CMD) == ETH_Watchdog_Enable) || \
+                              ((CMD) == ETH_Watchdog_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Jabber 
+  * @{
+  */ 
+#define ETH_Jabber_Enable    ((uint32_t)0x00000000)
+#define ETH_Jabber_Disable   ((uint32_t)0x00400000)
+#define IS_ETH_JABBER(CMD) (((CMD) == ETH_Jabber_Enable) || \
+                            ((CMD) == ETH_Jabber_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Inter_Frame_Gap 
+  * @{
+  */ 
+#define ETH_InterFrameGap_96Bit   ((uint32_t)0x00000000)  /*!< minimum IFG between frames during transmission is 96Bit */
+#define ETH_InterFrameGap_88Bit   ((uint32_t)0x00020000)  /*!< minimum IFG between frames during transmission is 88Bit */
+#define ETH_InterFrameGap_80Bit   ((uint32_t)0x00040000)  /*!< minimum IFG between frames during transmission is 80Bit */
+#define ETH_InterFrameGap_72Bit   ((uint32_t)0x00060000)  /*!< minimum IFG between frames during transmission is 72Bit */
+#define ETH_InterFrameGap_64Bit   ((uint32_t)0x00080000)  /*!< minimum IFG between frames during transmission is 64Bit */
+#define ETH_InterFrameGap_56Bit   ((uint32_t)0x000A0000)  /*!< minimum IFG between frames during transmission is 56Bit */
+#define ETH_InterFrameGap_48Bit   ((uint32_t)0x000C0000)  /*!< minimum IFG between frames during transmission is 48Bit */
+#define ETH_InterFrameGap_40Bit   ((uint32_t)0x000E0000)  /*!< minimum IFG between frames during transmission is 40Bit */
+#define IS_ETH_INTER_FRAME_GAP(GAP) (((GAP) == ETH_InterFrameGap_96Bit) || \
+                                     ((GAP) == ETH_InterFrameGap_88Bit) || \
+                                     ((GAP) == ETH_InterFrameGap_80Bit) || \
+                                     ((GAP) == ETH_InterFrameGap_72Bit) || \
+                                     ((GAP) == ETH_InterFrameGap_64Bit) || \
+                                     ((GAP) == ETH_InterFrameGap_56Bit) || \
+                                     ((GAP) == ETH_InterFrameGap_48Bit) || \
+                                     ((GAP) == ETH_InterFrameGap_40Bit))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Carrier_Sense 
+  * @{
+  */ 
+#define ETH_CarrierSense_Enable   ((uint32_t)0x00000000)
+#define ETH_CarrierSense_Disable  ((uint32_t)0x00010000)
+#define IS_ETH_CARRIER_SENSE(CMD) (((CMD) == ETH_CarrierSense_Enable) || \
+                                   ((CMD) == ETH_CarrierSense_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Speed 
+  * @{
+  */ 
+#define ETH_Speed_10M        ((uint32_t)0x00000000)
+#define ETH_Speed_100M       ((uint32_t)0x00004000)
+#define IS_ETH_SPEED(SPEED) (((SPEED) == ETH_Speed_10M) || \
+                             ((SPEED) == ETH_Speed_100M))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Receive_Own 
+  * @{
+  */ 
+#define ETH_ReceiveOwn_Enable     ((uint32_t)0x00000000)
+#define ETH_ReceiveOwn_Disable    ((uint32_t)0x00002000)
+#define IS_ETH_RECEIVE_OWN(CMD) (((CMD) == ETH_ReceiveOwn_Enable) || \
+                                 ((CMD) == ETH_ReceiveOwn_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Loop_Back_Mode 
+  * @{
+  */ 
+#define ETH_LoopbackMode_Enable        ((uint32_t)0x00001000)
+#define ETH_LoopbackMode_Disable       ((uint32_t)0x00000000)
+#define IS_ETH_LOOPBACK_MODE(CMD) (((CMD) == ETH_LoopbackMode_Enable) || \
+                                   ((CMD) == ETH_LoopbackMode_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Duplex_Mode 
+  * @{
+  */ 
+#define ETH_Mode_FullDuplex       ((uint32_t)0x00000800)
+#define ETH_Mode_HalfDuplex       ((uint32_t)0x00000000)
+#define IS_ETH_DUPLEX_MODE(MODE) (((MODE) == ETH_Mode_FullDuplex) || \
+                                  ((MODE) == ETH_Mode_HalfDuplex))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Checksum_Offload 
+  * @{
+  */ 
+#define ETH_ChecksumOffload_Enable     ((uint32_t)0x00000400)
+#define ETH_ChecksumOffload_Disable    ((uint32_t)0x00000000)
+#define IS_ETH_CHECKSUM_OFFLOAD(CMD) (((CMD) == ETH_ChecksumOffload_Enable) || \
+                                      ((CMD) == ETH_ChecksumOffload_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Retry_Transmission 
+  * @{
+  */ 
+#define ETH_RetryTransmission_Enable   ((uint32_t)0x00000000)
+#define ETH_RetryTransmission_Disable  ((uint32_t)0x00000200)
+#define IS_ETH_RETRY_TRANSMISSION(CMD) (((CMD) == ETH_RetryTransmission_Enable) || \
+                                        ((CMD) == ETH_RetryTransmission_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Automatic_Pad_CRC_Strip 
+  * @{
+  */ 
+#define ETH_AutomaticPadCRCStrip_Enable     ((uint32_t)0x00000080)
+#define ETH_AutomaticPadCRCStrip_Disable    ((uint32_t)0x00000000)
+#define IS_ETH_AUTOMATIC_PADCRC_STRIP(CMD) (((CMD) == ETH_AutomaticPadCRCStrip_Enable) || \
+                                            ((CMD) == ETH_AutomaticPadCRCStrip_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Back_Off_Limit 
+  * @{
+  */ 
+#define ETH_BackOffLimit_10  ((uint32_t)0x00000000)
+#define ETH_BackOffLimit_8   ((uint32_t)0x00000020)
+#define ETH_BackOffLimit_4   ((uint32_t)0x00000040)
+#define ETH_BackOffLimit_1   ((uint32_t)0x00000060)
+#define IS_ETH_BACKOFF_LIMIT(LIMIT) (((LIMIT) == ETH_BackOffLimit_10) || \
+                                     ((LIMIT) == ETH_BackOffLimit_8) || \
+                                     ((LIMIT) == ETH_BackOffLimit_4) || \
+                                     ((LIMIT) == ETH_BackOffLimit_1))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Deferral_Check 
+  * @{
+  */
+#define ETH_DeferralCheck_Enable       ((uint32_t)0x00000010)
+#define ETH_DeferralCheck_Disable      ((uint32_t)0x00000000)
+#define IS_ETH_DEFERRAL_CHECK(CMD) (((CMD) == ETH_DeferralCheck_Enable) || \
+                                    ((CMD) == ETH_DeferralCheck_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Receive_All 
+  * @{
+  */ 
+#define ETH_ReceiveAll_Enable     ((uint32_t)0x80000000)
+#define ETH_ReceiveAll_Disable    ((uint32_t)0x00000000)
+#define IS_ETH_RECEIVE_ALL(CMD) (((CMD) == ETH_ReceiveAll_Enable) || \
+                                 ((CMD) == ETH_ReceiveAll_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Source_Addr_Filter 
+  * @{
+  */ 
+#define ETH_SourceAddrFilter_Normal_Enable       ((uint32_t)0x00000200)
+#define ETH_SourceAddrFilter_Inverse_Enable      ((uint32_t)0x00000300)
+#define ETH_SourceAddrFilter_Disable             ((uint32_t)0x00000000)
+#define IS_ETH_SOURCE_ADDR_FILTER(CMD) (((CMD) == ETH_SourceAddrFilter_Normal_Enable) || \
+                                        ((CMD) == ETH_SourceAddrFilter_Inverse_Enable) || \
+                                        ((CMD) == ETH_SourceAddrFilter_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Pass_Control_Frames 
+  * @{
+  */ 
+#define ETH_PassControlFrames_BlockAll                ((uint32_t)0x00000040)  /*!< MAC filters all control frames from reaching the application */
+#define ETH_PassControlFrames_ForwardAll              ((uint32_t)0x00000080)  /*!< MAC forwards all control frames to application even if they fail the Address Filter */
+#define ETH_PassControlFrames_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /*!< MAC forwards control frames that pass the Address Filter. */ 
+#define IS_ETH_CONTROL_FRAMES(PASS) (((PASS) == ETH_PassControlFrames_BlockAll) || \
+                                     ((PASS) == ETH_PassControlFrames_ForwardAll) || \
+                                     ((PASS) == ETH_PassControlFrames_ForwardPassedAddrFilter))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Broadcast_Frames_Reception 
+  * @{
+  */ 
+#define ETH_BroadcastFramesReception_Enable      ((uint32_t)0x00000000)
+#define ETH_BroadcastFramesReception_Disable     ((uint32_t)0x00000020)
+#define IS_ETH_BROADCAST_FRAMES_RECEPTION(CMD) (((CMD) == ETH_BroadcastFramesReception_Enable) || \
+                                                ((CMD) == ETH_BroadcastFramesReception_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Destination_Addr_Filter 
+  * @{
+  */ 
+#define ETH_DestinationAddrFilter_Normal    ((uint32_t)0x00000000)
+#define ETH_DestinationAddrFilter_Inverse   ((uint32_t)0x00000008)
+#define IS_ETH_DESTINATION_ADDR_FILTER(FILTER) (((FILTER) == ETH_DestinationAddrFilter_Normal) || \
+                                                ((FILTER) == ETH_DestinationAddrFilter_Inverse))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Promiscuous_Mode 
+  * @{
+  */ 
+#define ETH_PromiscuousMode_Enable     ((uint32_t)0x00000001)
+#define ETH_PromiscuousMode_Disable    ((uint32_t)0x00000000)
+#define IS_ETH_PROMISCUOUS_MODE(CMD) (((CMD) == ETH_PromiscuousMode_Enable) || \
+                                      ((CMD) == ETH_PromiscuousMode_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Multicast_Frames_Filter 
+  * @{
+  */ 
+#define ETH_MulticastFramesFilter_PerfectHashTable    ((uint32_t)0x00000404)
+#define ETH_MulticastFramesFilter_HashTable           ((uint32_t)0x00000004)
+#define ETH_MulticastFramesFilter_Perfect             ((uint32_t)0x00000000)
+#define ETH_MulticastFramesFilter_None                ((uint32_t)0x00000010)
+#define IS_ETH_MULTICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_MulticastFramesFilter_PerfectHashTable) || \
+                                                ((FILTER) == ETH_MulticastFramesFilter_HashTable) || \
+                                                ((FILTER) == ETH_MulticastFramesFilter_Perfect) || \
+                                                ((FILTER) == ETH_MulticastFramesFilter_None))
+                                                     
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Unicast_Frames_Filter 
+  * @{
+  */ 
+#define ETH_UnicastFramesFilter_PerfectHashTable ((uint32_t)0x00000402)
+#define ETH_UnicastFramesFilter_HashTable        ((uint32_t)0x00000002)
+#define ETH_UnicastFramesFilter_Perfect          ((uint32_t)0x00000000)
+#define IS_ETH_UNICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_UnicastFramesFilter_PerfectHashTable) || \
+                                              ((FILTER) == ETH_UnicastFramesFilter_HashTable) || \
+                                              ((FILTER) == ETH_UnicastFramesFilter_Perfect))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Pause_Time 
+  * @{
+  */ 
+#define IS_ETH_PAUSE_TIME(TIME) ((TIME) <= 0xFFFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Zero_Quanta_Pause 
+  * @{
+  */ 
+#define ETH_ZeroQuantaPause_Enable     ((uint32_t)0x00000000)
+#define ETH_ZeroQuantaPause_Disable    ((uint32_t)0x00000080)
+#define IS_ETH_ZEROQUANTA_PAUSE(CMD)   (((CMD) == ETH_ZeroQuantaPause_Enable) || \
+                                        ((CMD) == ETH_ZeroQuantaPause_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Pause_Low_Threshold 
+  * @{
+  */ 
+#define ETH_PauseLowThreshold_Minus4        ((uint32_t)0x00000000)  /*!< Pause time minus 4 slot times */
+#define ETH_PauseLowThreshold_Minus28       ((uint32_t)0x00000010)  /*!< Pause time minus 28 slot times */
+#define ETH_PauseLowThreshold_Minus144      ((uint32_t)0x00000020)  /*!< Pause time minus 144 slot times */
+#define ETH_PauseLowThreshold_Minus256      ((uint32_t)0x00000030)  /*!< Pause time minus 256 slot times */
+#define IS_ETH_PAUSE_LOW_THRESHOLD(THRESHOLD) (((THRESHOLD) == ETH_PauseLowThreshold_Minus4) || \
+                                               ((THRESHOLD) == ETH_PauseLowThreshold_Minus28) || \
+                                               ((THRESHOLD) == ETH_PauseLowThreshold_Minus144) || \
+                                               ((THRESHOLD) == ETH_PauseLowThreshold_Minus256))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Unicast_Pause_Frame_Detect 
+  * @{
+  */ 
+#define ETH_UnicastPauseFrameDetect_Enable  ((uint32_t)0x00000008)
+#define ETH_UnicastPauseFrameDetect_Disable ((uint32_t)0x00000000)
+#define IS_ETH_UNICAST_PAUSE_FRAME_DETECT(CMD) (((CMD) == ETH_UnicastPauseFrameDetect_Enable) || \
+                                                ((CMD) == ETH_UnicastPauseFrameDetect_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Receive_Flow_Control 
+  * @{
+  */ 
+#define ETH_ReceiveFlowControl_Enable       ((uint32_t)0x00000004)
+#define ETH_ReceiveFlowControl_Disable      ((uint32_t)0x00000000)
+#define IS_ETH_RECEIVE_FLOWCONTROL(CMD) (((CMD) == ETH_ReceiveFlowControl_Enable) || \
+                                         ((CMD) == ETH_ReceiveFlowControl_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Transmit_Flow_Control 
+  * @{
+  */ 
+#define ETH_TransmitFlowControl_Enable      ((uint32_t)0x00000002)
+#define ETH_TransmitFlowControl_Disable     ((uint32_t)0x00000000)
+#define IS_ETH_TRANSMIT_FLOWCONTROL(CMD) (((CMD) == ETH_TransmitFlowControl_Enable) || \
+                                          ((CMD) == ETH_TransmitFlowControl_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_VLAN_Tag_Comparison 
+  * @{
+  */ 
+#define ETH_VLANTagComparison_12Bit    ((uint32_t)0x00010000)
+#define ETH_VLANTagComparison_16Bit    ((uint32_t)0x00000000)
+#define IS_ETH_VLAN_TAG_COMPARISON(COMPARISON) (((COMPARISON) == ETH_VLANTagComparison_12Bit) || \
+                                                ((COMPARISON) == ETH_VLANTagComparison_16Bit))
+#define IS_ETH_VLAN_TAG_IDENTIFIER(IDENTIFIER) ((IDENTIFIER) <= 0xFFFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_MAC_Flags 
+  * @{
+  */ 
+#define ETH_MAC_FLAG_TST     ((uint32_t)0x00000200)  /*!< Time stamp trigger flag (on MAC) */
+#define ETH_MAC_FLAG_MMCT    ((uint32_t)0x00000040)  /*!< MMC transmit flag  */
+#define ETH_MAC_FLAG_MMCR    ((uint32_t)0x00000020)  /*!< MMC receive flag */
+#define ETH_MAC_FLAG_MMC     ((uint32_t)0x00000010)  /*!< MMC flag (on MAC) */
+#define ETH_MAC_FLAG_PMT     ((uint32_t)0x00000008)  /*!< PMT flag (on MAC) */
+#define IS_ETH_MAC_GET_FLAG(FLAG) (((FLAG) == ETH_MAC_FLAG_TST) || ((FLAG) == ETH_MAC_FLAG_MMCT) || \
+                                   ((FLAG) == ETH_MAC_FLAG_MMCR) || ((FLAG) == ETH_MAC_FLAG_MMC) || \
+                                   ((FLAG) == ETH_MAC_FLAG_PMT))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_MAC_Interrupts 
+  * @{
+  */ 
+#define ETH_MAC_IT_TST       ((uint32_t)0x00000200)  /*!< Time stamp trigger interrupt (on MAC) */
+#define ETH_MAC_IT_MMCT      ((uint32_t)0x00000040)  /*!< MMC transmit interrupt */
+#define ETH_MAC_IT_MMCR      ((uint32_t)0x00000020)  /*!< MMC receive interrupt */
+#define ETH_MAC_IT_MMC       ((uint32_t)0x00000010)  /*!< MMC interrupt (on MAC) */
+#define ETH_MAC_IT_PMT       ((uint32_t)0x00000008)  /*!< PMT interrupt (on MAC) */
+#define IS_ETH_MAC_IT(IT) ((((IT) & (uint32_t)0xFFFFFDF7) == 0x00) && ((IT) != 0x00))
+#define IS_ETH_MAC_GET_IT(IT) (((IT) == ETH_MAC_IT_TST) || ((IT) == ETH_MAC_IT_MMCT) || \
+                               ((IT) == ETH_MAC_IT_MMCR) || ((IT) == ETH_MAC_IT_MMC) || \
+                               ((IT) == ETH_MAC_IT_PMT))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_MAC_addresses 
+  * @{
+  */ 
+#define ETH_MAC_Address0     ((uint32_t)0x00000000)
+#define ETH_MAC_Address1     ((uint32_t)0x00000008)
+#define ETH_MAC_Address2     ((uint32_t)0x00000010)
+#define ETH_MAC_Address3     ((uint32_t)0x00000018)
+#define IS_ETH_MAC_ADDRESS0123(ADDRESS) (((ADDRESS) == ETH_MAC_Address0) || \
+                                         ((ADDRESS) == ETH_MAC_Address1) || \
+                                         ((ADDRESS) == ETH_MAC_Address2) || \
+                                         ((ADDRESS) == ETH_MAC_Address3))
+#define IS_ETH_MAC_ADDRESS123(ADDRESS) (((ADDRESS) == ETH_MAC_Address1) || \
+                                        ((ADDRESS) == ETH_MAC_Address2) || \
+                                        ((ADDRESS) == ETH_MAC_Address3))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_MAC_addresses_filter_SA_DA_filed_of_received_frames 
+  * @{
+  */ 
+#define ETH_MAC_AddressFilter_SA       ((uint32_t)0x00000000)
+#define ETH_MAC_AddressFilter_DA       ((uint32_t)0x00000008)
+#define IS_ETH_MAC_ADDRESS_FILTER(FILTER) (((FILTER) == ETH_MAC_AddressFilter_SA) || \
+                                           ((FILTER) == ETH_MAC_AddressFilter_DA))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_MAC_addresses_filter_Mask_bytes 
+  * @{
+  */ 
+#define ETH_MAC_AddressMask_Byte6      ((uint32_t)0x20000000)  /*!< Mask MAC Address high reg bits [15:8] */
+#define ETH_MAC_AddressMask_Byte5      ((uint32_t)0x10000000)  /*!< Mask MAC Address high reg bits [7:0] */
+#define ETH_MAC_AddressMask_Byte4      ((uint32_t)0x08000000)  /*!< Mask MAC Address low reg bits [31:24] */
+#define ETH_MAC_AddressMask_Byte3      ((uint32_t)0x04000000)  /*!< Mask MAC Address low reg bits [23:16] */
+#define ETH_MAC_AddressMask_Byte2      ((uint32_t)0x02000000)  /*!< Mask MAC Address low reg bits [15:8] */
+#define ETH_MAC_AddressMask_Byte1      ((uint32_t)0x01000000)  /*!< Mask MAC Address low reg bits [70] */
+#define IS_ETH_MAC_ADDRESS_MASK(MASK) (((MASK) == ETH_MAC_AddressMask_Byte6) || \
+                                       ((MASK) == ETH_MAC_AddressMask_Byte5) || \
+                                       ((MASK) == ETH_MAC_AddressMask_Byte4) || \
+                                       ((MASK) == ETH_MAC_AddressMask_Byte3) || \
+                                       ((MASK) == ETH_MAC_AddressMask_Byte2) || \
+                                       ((MASK) == ETH_MAC_AddressMask_Byte1))
+
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                      Ethernet DMA Descriptors defines
+  */ 
+/**--------------------------------------------------------------------------**/
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_Tx_descriptor_flags
+  * @{
+  */ 
+#define IS_ETH_DMATxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMATxDesc_OWN) || \
+                                         ((FLAG) == ETH_DMATxDesc_IC) || \
+                                         ((FLAG) == ETH_DMATxDesc_LS) || \
+                                         ((FLAG) == ETH_DMATxDesc_FS) || \
+                                         ((FLAG) == ETH_DMATxDesc_DC) || \
+                                         ((FLAG) == ETH_DMATxDesc_DP) || \
+                                         ((FLAG) == ETH_DMATxDesc_TTSE) || \
+                                         ((FLAG) == ETH_DMATxDesc_TER) || \
+                                         ((FLAG) == ETH_DMATxDesc_TCH) || \
+                                         ((FLAG) == ETH_DMATxDesc_TTSS) || \
+                                         ((FLAG) == ETH_DMATxDesc_IHE) || \
+                                         ((FLAG) == ETH_DMATxDesc_ES) || \
+                                         ((FLAG) == ETH_DMATxDesc_JT) || \
+                                         ((FLAG) == ETH_DMATxDesc_FF) || \
+                                         ((FLAG) == ETH_DMATxDesc_PCE) || \
+                                         ((FLAG) == ETH_DMATxDesc_LCA) || \
+                                         ((FLAG) == ETH_DMATxDesc_NC) || \
+                                         ((FLAG) == ETH_DMATxDesc_LCO) || \
+                                         ((FLAG) == ETH_DMATxDesc_EC) || \
+                                         ((FLAG) == ETH_DMATxDesc_VF) || \
+                                         ((FLAG) == ETH_DMATxDesc_CC) || \
+                                         ((FLAG) == ETH_DMATxDesc_ED) || \
+                                         ((FLAG) == ETH_DMATxDesc_UF) || \
+                                         ((FLAG) == ETH_DMATxDesc_DB))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_Tx_descriptor_segment 
+  * @{
+  */ 
+#define ETH_DMATxDesc_LastSegment      ((uint32_t)0x40000000)  /*!< Last Segment */
+#define ETH_DMATxDesc_FirstSegment     ((uint32_t)0x20000000)  /*!< First Segment */
+#define IS_ETH_DMA_TXDESC_SEGMENT(SEGMENT) (((SEGMENT) == ETH_DMATxDesc_LastSegment) || \
+                                            ((SEGMENT) == ETH_DMATxDesc_FirstSegment))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_Tx_descriptor_Checksum_Insertion_Control
+  * @{
+  */ 
+#define ETH_DMATxDesc_ChecksumByPass             ((uint32_t)0x00000000)   /*!< Checksum engine bypass */
+#define ETH_DMATxDesc_ChecksumIPV4Header         ((uint32_t)0x00400000)   /*!< IPv4 header checksum insertion  */
+#define ETH_DMATxDesc_ChecksumTCPUDPICMPSegment  ((uint32_t)0x00800000)   /*!< TCP/UDP/ICMP checksum insertion. Pseudo header checksum is assumed to be present */
+#define ETH_DMATxDesc_ChecksumTCPUDPICMPFull     ((uint32_t)0x00C00000)   /*!< TCP/UDP/ICMP checksum fully in hardware including pseudo header */
+#define IS_ETH_DMA_TXDESC_CHECKSUM(CHECKSUM) (((CHECKSUM) == ETH_DMATxDesc_ChecksumByPass) || \
+                                              ((CHECKSUM) == ETH_DMATxDesc_ChecksumIPV4Header) || \
+                                              ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPSegment) || \
+                                              ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPFull))
+/** 
+  * @brief  ETH DMA Tx Desciptor buffer size
+  */ 
+#define IS_ETH_DMATxDESC_BUFFER_SIZE(SIZE) ((SIZE) <= 0x1FFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_Rx_descriptor_flags
+  * @{
+  */ 
+#define IS_ETH_DMARxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMARxDesc_OWN) || \
+                                         ((FLAG) == ETH_DMARxDesc_AFM) || \
+                                         ((FLAG) == ETH_DMARxDesc_ES) || \
+                                         ((FLAG) == ETH_DMARxDesc_DE) || \
+                                         ((FLAG) == ETH_DMARxDesc_SAF) || \
+                                         ((FLAG) == ETH_DMARxDesc_LE) || \
+                                         ((FLAG) == ETH_DMARxDesc_OE) || \
+                                         ((FLAG) == ETH_DMARxDesc_VLAN) || \
+                                         ((FLAG) == ETH_DMARxDesc_FS) || \
+                                         ((FLAG) == ETH_DMARxDesc_LS) || \
+                                         ((FLAG) == ETH_DMARxDesc_IPV4HCE) || \
+                                         ((FLAG) == ETH_DMARxDesc_LC) || \
+                                         ((FLAG) == ETH_DMARxDesc_FT) || \
+                                         ((FLAG) == ETH_DMARxDesc_RWT) || \
+                                         ((FLAG) == ETH_DMARxDesc_RE) || \
+                                         ((FLAG) == ETH_DMARxDesc_DBE) || \
+                                         ((FLAG) == ETH_DMARxDesc_CE) || \
+                                         ((FLAG) == ETH_DMARxDesc_MAMPCE))
+
+/* ETHERNET DMA PTP Rx descriptor extended flags  --------------------------------*/
+#define IS_ETH_DMAPTPRxDESC_GET_EXTENDED_FLAG(FLAG) (((FLAG) == ETH_DMAPTPRxDesc_PTPV) || \
+                                                     ((FLAG) == ETH_DMAPTPRxDesc_PTPFT) || \
+                                                     ((FLAG) == ETH_DMAPTPRxDesc_PTPMT) || \
+                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPV6PR) || \
+                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPV4PR) || \
+                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPCB) || \
+                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPPE) || \
+                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPHE) || \
+                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPPT))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_Rx_descriptor_buffers_ 
+  * @{
+  */ 
+#define ETH_DMARxDesc_Buffer1     ((uint32_t)0x00000000)  /*!< DMA Rx Desc Buffer1 */
+#define ETH_DMARxDesc_Buffer2     ((uint32_t)0x00000001)  /*!< DMA Rx Desc Buffer2 */
+#define IS_ETH_DMA_RXDESC_BUFFER(BUFFER) (((BUFFER) == ETH_DMARxDesc_Buffer1) || \
+                                          ((BUFFER) == ETH_DMARxDesc_Buffer2))
+
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                           Ethernet DMA defines
+  */ 
+/**--------------------------------------------------------------------------**/
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Drop_TCP_IP_Checksum_Error_Frame 
+  * @{
+  */ 
+#define ETH_DropTCPIPChecksumErrorFrame_Enable   ((uint32_t)0x00000000)
+#define ETH_DropTCPIPChecksumErrorFrame_Disable  ((uint32_t)0x04000000)
+#define IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(CMD) (((CMD) == ETH_DropTCPIPChecksumErrorFrame_Enable) || \
+                                               ((CMD) == ETH_DropTCPIPChecksumErrorFrame_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Receive_Store_Forward 
+  * @{
+  */ 
+#define ETH_ReceiveStoreForward_Enable      ((uint32_t)0x02000000)
+#define ETH_ReceiveStoreForward_Disable     ((uint32_t)0x00000000)
+#define IS_ETH_RECEIVE_STORE_FORWARD(CMD) (((CMD) == ETH_ReceiveStoreForward_Enable) || \
+                                           ((CMD) == ETH_ReceiveStoreForward_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Flush_Received_Frame 
+  * @{
+  */ 
+#define ETH_FlushReceivedFrame_Enable       ((uint32_t)0x00000000)
+#define ETH_FlushReceivedFrame_Disable      ((uint32_t)0x01000000)
+#define IS_ETH_FLUSH_RECEIVE_FRAME(CMD) (((CMD) == ETH_FlushReceivedFrame_Enable) || \
+                                         ((CMD) == ETH_FlushReceivedFrame_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Transmit_Store_Forward 
+  * @{
+  */ 
+#define ETH_TransmitStoreForward_Enable     ((uint32_t)0x00200000)
+#define ETH_TransmitStoreForward_Disable    ((uint32_t)0x00000000)
+#define IS_ETH_TRANSMIT_STORE_FORWARD(CMD) (((CMD) == ETH_TransmitStoreForward_Enable) || \
+                                            ((CMD) == ETH_TransmitStoreForward_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Transmit_Threshold_Control 
+  * @{
+  */ 
+#define ETH_TransmitThresholdControl_64Bytes     ((uint32_t)0x00000000)  /*!< threshold level of the MTL Transmit FIFO is 64 Bytes */
+#define ETH_TransmitThresholdControl_128Bytes    ((uint32_t)0x00004000)  /*!< threshold level of the MTL Transmit FIFO is 128 Bytes */
+#define ETH_TransmitThresholdControl_192Bytes    ((uint32_t)0x00008000)  /*!< threshold level of the MTL Transmit FIFO is 192 Bytes */
+#define ETH_TransmitThresholdControl_256Bytes    ((uint32_t)0x0000C000)  /*!< threshold level of the MTL Transmit FIFO is 256 Bytes */
+#define ETH_TransmitThresholdControl_40Bytes     ((uint32_t)0x00010000)  /*!< threshold level of the MTL Transmit FIFO is 40 Bytes */
+#define ETH_TransmitThresholdControl_32Bytes     ((uint32_t)0x00014000)  /*!< threshold level of the MTL Transmit FIFO is 32 Bytes */
+#define ETH_TransmitThresholdControl_24Bytes     ((uint32_t)0x00018000)  /*!< threshold level of the MTL Transmit FIFO is 24 Bytes */
+#define ETH_TransmitThresholdControl_16Bytes     ((uint32_t)0x0001C000)  /*!< threshold level of the MTL Transmit FIFO is 16 Bytes */
+#define IS_ETH_TRANSMIT_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_TransmitThresholdControl_64Bytes) || \
+                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_128Bytes) || \
+                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_192Bytes) || \
+                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_256Bytes) || \
+                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_40Bytes) || \
+                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_32Bytes) || \
+                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_24Bytes) || \
+                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_16Bytes))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Forward_Error_Frames 
+  * @{
+  */ 
+#define ETH_ForwardErrorFrames_Enable       ((uint32_t)0x00000080)
+#define ETH_ForwardErrorFrames_Disable      ((uint32_t)0x00000000)
+#define IS_ETH_FORWARD_ERROR_FRAMES(CMD) (((CMD) == ETH_ForwardErrorFrames_Enable) || \
+                                          ((CMD) == ETH_ForwardErrorFrames_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Forward_Undersized_Good_Frames 
+  * @{
+  */ 
+#define ETH_ForwardUndersizedGoodFrames_Enable   ((uint32_t)0x00000040)
+#define ETH_ForwardUndersizedGoodFrames_Disable  ((uint32_t)0x00000000)     
+#define IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(CMD) (((CMD) == ETH_ForwardUndersizedGoodFrames_Enable) || \
+                                                    ((CMD) == ETH_ForwardUndersizedGoodFrames_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Receive_Threshold_Control 
+  * @{
+  */ 
+#define ETH_ReceiveThresholdControl_64Bytes      ((uint32_t)0x00000000)  /*!< threshold level of the MTL Receive FIFO is 64 Bytes */
+#define ETH_ReceiveThresholdControl_32Bytes      ((uint32_t)0x00000008)  /*!< threshold level of the MTL Receive FIFO is 32 Bytes */
+#define ETH_ReceiveThresholdControl_96Bytes      ((uint32_t)0x00000010)  /*!< threshold level of the MTL Receive FIFO is 96 Bytes */
+#define ETH_ReceiveThresholdControl_128Bytes     ((uint32_t)0x00000018)  /*!< threshold level of the MTL Receive FIFO is 128 Bytes */
+#define IS_ETH_RECEIVE_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_ReceiveThresholdControl_64Bytes) || \
+                                                     ((THRESHOLD) == ETH_ReceiveThresholdControl_32Bytes) || \
+                                                     ((THRESHOLD) == ETH_ReceiveThresholdControl_96Bytes) || \
+                                                     ((THRESHOLD) == ETH_ReceiveThresholdControl_128Bytes))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Second_Frame_Operate 
+  * @{
+  */ 
+#define ETH_SecondFrameOperate_Enable       ((uint32_t)0x00000004)
+#define ETH_SecondFrameOperate_Disable      ((uint32_t)0x00000000)  
+#define IS_ETH_SECOND_FRAME_OPERATE(CMD) (((CMD) == ETH_SecondFrameOperate_Enable) || \
+                                          ((CMD) == ETH_SecondFrameOperate_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Address_Aligned_Beats 
+  * @{
+  */ 
+#define ETH_AddressAlignedBeats_Enable      ((uint32_t)0x02000000)
+#define ETH_AddressAlignedBeats_Disable     ((uint32_t)0x00000000) 
+#define IS_ETH_ADDRESS_ALIGNED_BEATS(CMD) (((CMD) == ETH_AddressAlignedBeats_Enable) || \
+                                           ((CMD) == ETH_AddressAlignedBeats_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Fixed_Burst 
+  * @{
+  */ 
+#define ETH_FixedBurst_Enable     ((uint32_t)0x00010000)
+#define ETH_FixedBurst_Disable    ((uint32_t)0x00000000) 
+#define IS_ETH_FIXED_BURST(CMD) (((CMD) == ETH_FixedBurst_Enable) || \
+                                 ((CMD) == ETH_FixedBurst_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Rx_DMA_Burst_Length 
+  * @{
+  */ 
+#define ETH_RxDMABurstLength_1Beat          ((uint32_t)0x00020000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 1 */
+#define ETH_RxDMABurstLength_2Beat          ((uint32_t)0x00040000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 2 */
+#define ETH_RxDMABurstLength_4Beat          ((uint32_t)0x00080000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 4 */
+#define ETH_RxDMABurstLength_8Beat          ((uint32_t)0x00100000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 8 */
+#define ETH_RxDMABurstLength_16Beat         ((uint32_t)0x00200000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 16 */
+#define ETH_RxDMABurstLength_32Beat         ((uint32_t)0x00400000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 32 */                
+#define ETH_RxDMABurstLength_4xPBL_4Beat    ((uint32_t)0x01020000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 4 */
+#define ETH_RxDMABurstLength_4xPBL_8Beat    ((uint32_t)0x01040000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 8 */
+#define ETH_RxDMABurstLength_4xPBL_16Beat   ((uint32_t)0x01080000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 16 */
+#define ETH_RxDMABurstLength_4xPBL_32Beat   ((uint32_t)0x01100000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 32 */
+#define ETH_RxDMABurstLength_4xPBL_64Beat   ((uint32_t)0x01200000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 64 */
+#define ETH_RxDMABurstLength_4xPBL_128Beat  ((uint32_t)0x01400000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 128 */
+
+#define IS_ETH_RXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_RxDMABurstLength_1Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_2Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_4Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_8Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_16Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_32Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_4Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_8Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_16Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_32Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_64Beat) || \
+                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_128Beat))
+ 
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Tx_DMA_Burst_Length 
+  * @{
+  */ 
+#define ETH_TxDMABurstLength_1Beat          ((uint32_t)0x00000100)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
+#define ETH_TxDMABurstLength_2Beat          ((uint32_t)0x00000200)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
+#define ETH_TxDMABurstLength_4Beat          ((uint32_t)0x00000400)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
+#define ETH_TxDMABurstLength_8Beat          ((uint32_t)0x00000800)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
+#define ETH_TxDMABurstLength_16Beat         ((uint32_t)0x00001000)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
+#define ETH_TxDMABurstLength_32Beat         ((uint32_t)0x00002000)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
+#define ETH_TxDMABurstLength_4xPBL_4Beat    ((uint32_t)0x01000100)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
+#define ETH_TxDMABurstLength_4xPBL_8Beat    ((uint32_t)0x01000200)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
+#define ETH_TxDMABurstLength_4xPBL_16Beat   ((uint32_t)0x01000400)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
+#define ETH_TxDMABurstLength_4xPBL_32Beat   ((uint32_t)0x01000800)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
+#define ETH_TxDMABurstLength_4xPBL_64Beat   ((uint32_t)0x01001000)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
+#define ETH_TxDMABurstLength_4xPBL_128Beat  ((uint32_t)0x01002000)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
+
+#define IS_ETH_TXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_TxDMABurstLength_1Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_2Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_4Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_8Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_16Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_32Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_4Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_8Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_16Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_32Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_64Beat) || \
+                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_128Beat))
+/** 
+  * @brief  ETH DMA Descriptor SkipLength  
+  */ 
+#define IS_ETH_DMA_DESC_SKIP_LENGTH(LENGTH) ((LENGTH) <= 0x1F)
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_Arbitration 
+  * @{
+  */ 
+#define ETH_DMAArbitration_RoundRobin_RxTx_1_1   ((uint32_t)0x00000000)
+#define ETH_DMAArbitration_RoundRobin_RxTx_2_1   ((uint32_t)0x00004000)
+#define ETH_DMAArbitration_RoundRobin_RxTx_3_1   ((uint32_t)0x00008000)
+#define ETH_DMAArbitration_RoundRobin_RxTx_4_1   ((uint32_t)0x0000C000)
+#define ETH_DMAArbitration_RxPriorTx             ((uint32_t)0x00000002)
+#define IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(RATIO) (((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_1_1) || \
+                                                       ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_2_1) || \
+                                                       ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_3_1) || \
+                                                       ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_4_1) || \
+                                                       ((RATIO) == ETH_DMAArbitration_RxPriorTx))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_Flags 
+  * @{
+  */ 
+#define ETH_DMA_FLAG_TST               ((uint32_t)0x20000000)  /*!< Time-stamp trigger interrupt (on DMA) */
+#define ETH_DMA_FLAG_PMT               ((uint32_t)0x10000000)  /*!< PMT interrupt (on DMA) */
+#define ETH_DMA_FLAG_MMC               ((uint32_t)0x08000000)  /*!< MMC interrupt (on DMA) */
+#define ETH_DMA_FLAG_DataTransferError ((uint32_t)0x00800000)  /*!< Error bits 0-Rx DMA, 1-Tx DMA */
+#define ETH_DMA_FLAG_ReadWriteError    ((uint32_t)0x01000000)  /*!< Error bits 0-write trnsf, 1-read transfr */
+#define ETH_DMA_FLAG_AccessError       ((uint32_t)0x02000000)  /*!< Error bits 0-data buffer, 1-desc. access */
+#define ETH_DMA_FLAG_NIS               ((uint32_t)0x00010000)  /*!< Normal interrupt summary flag */
+#define ETH_DMA_FLAG_AIS               ((uint32_t)0x00008000)  /*!< Abnormal interrupt summary flag */
+#define ETH_DMA_FLAG_ER                ((uint32_t)0x00004000)  /*!< Early receive flag */
+#define ETH_DMA_FLAG_FBE               ((uint32_t)0x00002000)  /*!< Fatal bus error flag */
+#define ETH_DMA_FLAG_ET                ((uint32_t)0x00000400)  /*!< Early transmit flag */
+#define ETH_DMA_FLAG_RWT               ((uint32_t)0x00000200)  /*!< Receive watchdog timeout flag */
+#define ETH_DMA_FLAG_RPS               ((uint32_t)0x00000100)  /*!< Receive process stopped flag */
+#define ETH_DMA_FLAG_RBU               ((uint32_t)0x00000080)  /*!< Receive buffer unavailable flag */
+#define ETH_DMA_FLAG_R                 ((uint32_t)0x00000040)  /*!< Receive flag */
+#define ETH_DMA_FLAG_TU                ((uint32_t)0x00000020)  /*!< Underflow flag */
+#define ETH_DMA_FLAG_RO                ((uint32_t)0x00000010)  /*!< Overflow flag */
+#define ETH_DMA_FLAG_TJT               ((uint32_t)0x00000008)  /*!< Transmit jabber timeout flag */
+#define ETH_DMA_FLAG_TBU               ((uint32_t)0x00000004)  /*!< Transmit buffer unavailable flag */
+#define ETH_DMA_FLAG_TPS               ((uint32_t)0x00000002)  /*!< Transmit process stopped flag */
+#define ETH_DMA_FLAG_T                 ((uint32_t)0x00000001)  /*!< Transmit flag */
+
+#define IS_ETH_DMA_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFE1800) == 0x00) && ((FLAG) != 0x00)) 
+#define IS_ETH_DMA_GET_FLAG(FLAG) (((FLAG) == ETH_DMA_FLAG_TST) || ((FLAG) == ETH_DMA_FLAG_PMT) || \
+                                   ((FLAG) == ETH_DMA_FLAG_MMC) || ((FLAG) == ETH_DMA_FLAG_DataTransferError) || \
+                                   ((FLAG) == ETH_DMA_FLAG_ReadWriteError) || ((FLAG) == ETH_DMA_FLAG_AccessError) || \
+                                   ((FLAG) == ETH_DMA_FLAG_NIS) || ((FLAG) == ETH_DMA_FLAG_AIS) || \
+                                   ((FLAG) == ETH_DMA_FLAG_ER) || ((FLAG) == ETH_DMA_FLAG_FBE) || \
+                                   ((FLAG) == ETH_DMA_FLAG_ET) || ((FLAG) == ETH_DMA_FLAG_RWT) || \
+                                   ((FLAG) == ETH_DMA_FLAG_RPS) || ((FLAG) == ETH_DMA_FLAG_RBU) || \
+                                   ((FLAG) == ETH_DMA_FLAG_R) || ((FLAG) == ETH_DMA_FLAG_TU) || \
+                                   ((FLAG) == ETH_DMA_FLAG_RO) || ((FLAG) == ETH_DMA_FLAG_TJT) || \
+                                   ((FLAG) == ETH_DMA_FLAG_TBU) || ((FLAG) == ETH_DMA_FLAG_TPS) || \
+                                   ((FLAG) == ETH_DMA_FLAG_T))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_Interrupts 
+  * @{
+  */ 
+#define ETH_DMA_IT_TST       ((uint32_t)0x20000000)  /*!< Time-stamp trigger interrupt (on DMA) */
+#define ETH_DMA_IT_PMT       ((uint32_t)0x10000000)  /*!< PMT interrupt (on DMA) */
+#define ETH_DMA_IT_MMC       ((uint32_t)0x08000000)  /*!< MMC interrupt (on DMA) */
+#define ETH_DMA_IT_NIS       ((uint32_t)0x00010000)  /*!< Normal interrupt summary */
+#define ETH_DMA_IT_AIS       ((uint32_t)0x00008000)  /*!< Abnormal interrupt summary */
+#define ETH_DMA_IT_ER        ((uint32_t)0x00004000)  /*!< Early receive interrupt */
+#define ETH_DMA_IT_FBE       ((uint32_t)0x00002000)  /*!< Fatal bus error interrupt */
+#define ETH_DMA_IT_ET        ((uint32_t)0x00000400)  /*!< Early transmit interrupt */
+#define ETH_DMA_IT_RWT       ((uint32_t)0x00000200)  /*!< Receive watchdog timeout interrupt */
+#define ETH_DMA_IT_RPS       ((uint32_t)0x00000100)  /*!< Receive process stopped interrupt */
+#define ETH_DMA_IT_RBU       ((uint32_t)0x00000080)  /*!< Receive buffer unavailable interrupt */
+#define ETH_DMA_IT_R         ((uint32_t)0x00000040)  /*!< Receive interrupt */
+#define ETH_DMA_IT_TU        ((uint32_t)0x00000020)  /*!< Underflow interrupt */
+#define ETH_DMA_IT_RO        ((uint32_t)0x00000010)  /*!< Overflow interrupt */
+#define ETH_DMA_IT_TJT       ((uint32_t)0x00000008)  /*!< Transmit jabber timeout interrupt */
+#define ETH_DMA_IT_TBU       ((uint32_t)0x00000004)  /*!< Transmit buffer unavailable interrupt */
+#define ETH_DMA_IT_TPS       ((uint32_t)0x00000002)  /*!< Transmit process stopped interrupt */
+#define ETH_DMA_IT_T         ((uint32_t)0x00000001)  /*!< Transmit interrupt */
+
+#define IS_ETH_DMA_IT(IT) ((((IT) & (uint32_t)0xFFFE1800) == 0x00) && ((IT) != 0x00))
+#define IS_ETH_DMA_GET_IT(IT) (((IT) == ETH_DMA_IT_TST) || ((IT) == ETH_DMA_IT_PMT) || \
+                               ((IT) == ETH_DMA_IT_MMC) || ((IT) == ETH_DMA_IT_NIS) || \
+                               ((IT) == ETH_DMA_IT_AIS) || ((IT) == ETH_DMA_IT_ER) || \
+                               ((IT) == ETH_DMA_IT_FBE) || ((IT) == ETH_DMA_IT_ET) || \
+                               ((IT) == ETH_DMA_IT_RWT) || ((IT) == ETH_DMA_IT_RPS) || \
+                               ((IT) == ETH_DMA_IT_RBU) || ((IT) == ETH_DMA_IT_R) || \
+                               ((IT) == ETH_DMA_IT_TU) || ((IT) == ETH_DMA_IT_RO) || \
+                               ((IT) == ETH_DMA_IT_TJT) || ((IT) == ETH_DMA_IT_TBU) || \
+                               ((IT) == ETH_DMA_IT_TPS) || ((IT) == ETH_DMA_IT_T))
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_transmit_process_state_ 
+  * @{
+  */ 
+#define ETH_DMA_TransmitProcess_Stopped     ((uint32_t)0x00000000)  /*!< Stopped - Reset or Stop Tx Command issued */
+#define ETH_DMA_TransmitProcess_Fetching    ((uint32_t)0x00100000)  /*!< Running - fetching the Tx descriptor */
+#define ETH_DMA_TransmitProcess_Waiting     ((uint32_t)0x00200000)  /*!< Running - waiting for status */
+#define ETH_DMA_TransmitProcess_Reading     ((uint32_t)0x00300000)  /*!< Running - reading the data from host memory */
+#define ETH_DMA_TransmitProcess_Suspended   ((uint32_t)0x00600000)  /*!< Suspended - Tx Descriptor unavailable */
+#define ETH_DMA_TransmitProcess_Closing     ((uint32_t)0x00700000)  /*!< Running - closing Rx descriptor */
+
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ETH_DMA_receive_process_state_ 
+  * @{
+  */ 
+#define ETH_DMA_ReceiveProcess_Stopped      ((uint32_t)0x00000000)  /*!< Stopped - Reset or Stop Rx Command issued */
+#define ETH_DMA_ReceiveProcess_Fetching     ((uint32_t)0x00020000)  /*!< Running - fetching the Rx descriptor */
+#define ETH_DMA_ReceiveProcess_Waiting      ((uint32_t)0x00060000)  /*!< Running - waiting for packet */
+#define ETH_DMA_ReceiveProcess_Suspended    ((uint32_t)0x00080000)  /*!< Suspended - Rx Descriptor unavailable */
+#define ETH_DMA_ReceiveProcess_Closing      ((uint32_t)0x000A0000)  /*!< Running - closing descriptor */
+#define ETH_DMA_ReceiveProcess_Queuing      ((uint32_t)0x000E0000)  /*!< Running - queuing the receive frame into host memory */
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_DMA_overflow_ 
+  * @{
+  */ 
+#define ETH_DMA_Overflow_RxFIFOCounter      ((uint32_t)0x10000000)  /*!< Overflow bit for FIFO overflow counter */
+#define ETH_DMA_Overflow_MissedFrameCounter ((uint32_t)0x00010000)  /*!< Overflow bit for missed frame counter */
+#define IS_ETH_DMA_GET_OVERFLOW(OVERFLOW) (((OVERFLOW) == ETH_DMA_Overflow_RxFIFOCounter) || \
+                                           ((OVERFLOW) == ETH_DMA_Overflow_MissedFrameCounter))
+
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                           Ethernet PMT defines
+  */ 
+/**--------------------------------------------------------------------------**/
+/**
+  * @}
+  */
+
+/** @defgroup ETH_PMT_Flags 
+  * @{
+  */ 
+#define ETH_PMT_FLAG_WUFFRPR      ((uint32_t)0x80000000)  /*!< Wake-Up Frame Filter Register Pointer Reset */
+#define ETH_PMT_FLAG_WUFR         ((uint32_t)0x00000040)  /*!< Wake-Up Frame Received */
+#define ETH_PMT_FLAG_MPR          ((uint32_t)0x00000020)  /*!< Magic Packet Received */
+#define IS_ETH_PMT_GET_FLAG(FLAG) (((FLAG) == ETH_PMT_FLAG_WUFR) || \
+                                   ((FLAG) == ETH_PMT_FLAG_MPR))
+
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                           Ethernet MMC defines
+  */ 
+/**--------------------------------------------------------------------------**/
+/**
+  * @}
+  */
+
+/** @defgroup ETH_MMC_Tx_Interrupts 
+  * @{
+  */ 
+#define ETH_MMC_IT_TGF       ((uint32_t)0x00200000)  /*!< When Tx good frame counter reaches half the maximum value */
+#define ETH_MMC_IT_TGFMSC    ((uint32_t)0x00008000)  /*!< When Tx good multi col counter reaches half the maximum value */
+#define ETH_MMC_IT_TGFSC     ((uint32_t)0x00004000)  /*!< When Tx good single col counter reaches half the maximum value */
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_MMC_Rx_Interrupts 
+  * @{
+  */
+#define ETH_MMC_IT_RGUF      ((uint32_t)0x10020000)  /*!< When Rx good unicast frames counter reaches half the maximum value */
+#define ETH_MMC_IT_RFAE      ((uint32_t)0x10000040)  /*!< When Rx alignment error counter reaches half the maximum value */
+#define ETH_MMC_IT_RFCE      ((uint32_t)0x10000020)  /*!< When Rx crc error counter reaches half the maximum value */
+#define IS_ETH_MMC_IT(IT) (((((IT) & (uint32_t)0xFFDF3FFF) == 0x00) || (((IT) & (uint32_t)0xEFFDFF9F) == 0x00)) && \
+                           ((IT) != 0x00))
+#define IS_ETH_MMC_GET_IT(IT) (((IT) == ETH_MMC_IT_TGF) || ((IT) == ETH_MMC_IT_TGFMSC) || \
+                               ((IT) == ETH_MMC_IT_TGFSC) || ((IT) == ETH_MMC_IT_RGUF) || \
+                               ((IT) == ETH_MMC_IT_RFAE) || ((IT) == ETH_MMC_IT_RFCE))
+/**
+  * @}
+  */
+
+/** @defgroup ETH_MMC_Registers 
+  * @{
+  */ 
+#define ETH_MMCCR            ((uint32_t)0x00000100)  /*!< MMC CR register */
+#define ETH_MMCRIR           ((uint32_t)0x00000104)  /*!< MMC RIR register */
+#define ETH_MMCTIR           ((uint32_t)0x00000108)  /*!< MMC TIR register */
+#define ETH_MMCRIMR          ((uint32_t)0x0000010C)  /*!< MMC RIMR register */
+#define ETH_MMCTIMR          ((uint32_t)0x00000110)  /*!< MMC TIMR register */ 
+#define ETH_MMCTGFSCCR       ((uint32_t)0x0000014C)  /*!< MMC TGFSCCR register */
+#define ETH_MMCTGFMSCCR      ((uint32_t)0x00000150)  /*!< MMC TGFMSCCR register */ 
+#define ETH_MMCTGFCR         ((uint32_t)0x00000168)  /*!< MMC TGFCR register */
+#define ETH_MMCRFCECR        ((uint32_t)0x00000194)  /*!< MMC RFCECR register */
+#define ETH_MMCRFAECR        ((uint32_t)0x00000198)  /*!< MMC RFAECR register */
+#define ETH_MMCRGUFCR        ((uint32_t)0x000001C4)  /*!< MMC RGUFCR register */
+
+/** 
+  * @brief  ETH MMC registers  
+  */ 
+#define IS_ETH_MMC_REGISTER(REG) (((REG) == ETH_MMCCR)  || ((REG) == ETH_MMCRIR) || \
+                                  ((REG) == ETH_MMCTIR)  || ((REG) == ETH_MMCRIMR) || \
+                                  ((REG) == ETH_MMCTIMR) || ((REG) == ETH_MMCTGFSCCR) || \
+                                  ((REG) == ETH_MMCTGFMSCCR) || ((REG) == ETH_MMCTGFCR) || \
+                                  ((REG) == ETH_MMCRFCECR) || ((REG) == ETH_MMCRFAECR) || \
+                                  ((REG) == ETH_MMCRGUFCR)) 
+
+/**--------------------------------------------------------------------------**/
+/** 
+  * @brief                           Ethernet PTP defines
+  */ 
+/**--------------------------------------------------------------------------**/
+/**
+  * @}
+  */
+
+/** @defgroup ETH_PTP_time_update_method 
+  * @{
+  */ 
+#define ETH_PTP_FineUpdate        ((uint32_t)0x00000001)  /*!< Fine Update method */
+#define ETH_PTP_CoarseUpdate      ((uint32_t)0x00000000)  /*!< Coarse Update method */
+#define IS_ETH_PTP_UPDATE(UPDATE) (((UPDATE) == ETH_PTP_FineUpdate) || \
+                                   ((UPDATE) == ETH_PTP_CoarseUpdate))
+
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ETH_PTP_Flags 
+  * @{
+  */ 
+#define ETH_PTP_FLAG_TSARU        ((uint32_t)0x00000020)  /*!< Addend Register Update */
+#define ETH_PTP_FLAG_TSITE        ((uint32_t)0x00000010)  /*!< Time Stamp Interrupt Trigger */
+#define ETH_PTP_FLAG_TSSTU        ((uint32_t)0x00000008)  /*!< Time Stamp Update */
+#define ETH_PTP_FLAG_TSSTI        ((uint32_t)0x00000004)  /*!< Time Stamp Initialize */
+
+#define ETH_PTP_FLAG_TSTTR        ((uint32_t)0x10000002)  /* Time stamp target time reached */
+#define ETH_PTP_FLAG_TSSO         ((uint32_t)0x10000001)  /* Time stamp seconds overflow */
+
+#define IS_ETH_PTP_GET_FLAG(FLAG) (((FLAG) == ETH_PTP_FLAG_TSARU) || \
+                                    ((FLAG) == ETH_PTP_FLAG_TSITE) || \
+                                    ((FLAG) == ETH_PTP_FLAG_TSSTU) || \
+                                    ((FLAG) == ETH_PTP_FLAG_TSSTI) || \
+                                    ((FLAG) == ETH_PTP_FLAG_TSTTR) || \
+                                    ((FLAG) == ETH_PTP_FLAG_TSSO)) 
+
+/** 
+  * @brief  ETH PTP subsecond increment  
+  */ 
+#define IS_ETH_PTP_SUBSECOND_INCREMENT(SUBSECOND) ((SUBSECOND) <= 0xFF)
+
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ETH_PTP_time_sign 
+  * @{
+  */ 
+#define ETH_PTP_PositiveTime      ((uint32_t)0x00000000)  /*!< Positive time value */
+#define ETH_PTP_NegativeTime      ((uint32_t)0x80000000)  /*!< Negative time value */
+#define IS_ETH_PTP_TIME_SIGN(SIGN) (((SIGN) == ETH_PTP_PositiveTime) || \
+                                    ((SIGN) == ETH_PTP_NegativeTime))
+
+/** 
+  * @brief  ETH PTP time stamp low update  
+  */ 
+#define IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SUBSECOND) ((SUBSECOND) <= 0x7FFFFFFF)
+
+/** 
+  * @brief  ETH PTP registers  
+  */ 
+#define ETH_PTPTSCR     ((uint32_t)0x00000700)  /*!< PTP TSCR register */
+#define ETH_PTPSSIR     ((uint32_t)0x00000704)  /*!< PTP SSIR register */
+#define ETH_PTPTSHR     ((uint32_t)0x00000708)  /*!< PTP TSHR register */
+#define ETH_PTPTSLR     ((uint32_t)0x0000070C)  /*!< PTP TSLR register */
+#define ETH_PTPTSHUR    ((uint32_t)0x00000710)  /*!< PTP TSHUR register */
+#define ETH_PTPTSLUR    ((uint32_t)0x00000714)  /*!< PTP TSLUR register */
+#define ETH_PTPTSAR     ((uint32_t)0x00000718)  /*!< PTP TSAR register */
+#define ETH_PTPTTHR     ((uint32_t)0x0000071C)  /*!< PTP TTHR register */
+#define ETH_PTPTTLR     ((uint32_t)0x00000720)  /* PTP TTLR register */
+
+#define ETH_PTPTSSR     ((uint32_t)0x00000728)  /* PTP TSSR register */
+
+#define IS_ETH_PTP_REGISTER(REG) (((REG) == ETH_PTPTSCR) || ((REG) == ETH_PTPSSIR) || \
+                                   ((REG) == ETH_PTPTSHR) || ((REG) == ETH_PTPTSLR) || \
+                                   ((REG) == ETH_PTPTSHUR) || ((REG) == ETH_PTPTSLUR) || \
+                                   ((REG) == ETH_PTPTSAR) || ((REG) == ETH_PTPTTHR) || \
+                                   ((REG) == ETH_PTPTTLR) || ((REG) == ETH_PTPTSSR)) 
+
+/** 
+  * @brief  ETHERNET PTP clock  
+  */ 
+#define ETH_PTP_OrdinaryClock               ((uint32_t)0x00000000)  /* Ordinary Clock */
+#define ETH_PTP_BoundaryClock               ((uint32_t)0x00010000)  /* Boundary Clock */
+#define ETH_PTP_EndToEndTransparentClock    ((uint32_t)0x00020000)  /* End To End Transparent Clock */
+#define ETH_PTP_PeerToPeerTransparentClock  ((uint32_t)0x00030000)  /* Peer To Peer Transparent Clock */
+
+#define IS_ETH_PTP_TYPE_CLOCK(CLOCK) (((CLOCK) == ETH_PTP_OrdinaryClock) || \
+                          ((CLOCK) == ETH_PTP_BoundaryClock) || \
+                          ((CLOCK) == ETH_PTP_EndToEndTransparentClock) || \
+                                      ((CLOCK) == ETH_PTP_PeerToPeerTransparentClock))
+/** 
+  * @brief  ETHERNET snapshot
+  */
+#define ETH_PTP_SnapshotMasterMessage          ((uint32_t)0x00008000)  /* Time stamp snapshot for message relevant to master enable */
+#define ETH_PTP_SnapshotEventMessage           ((uint32_t)0x00004000)  /* Time stamp snapshot for event message enable */
+#define ETH_PTP_SnapshotIPV4Frames             ((uint32_t)0x00002000)  /* Time stamp snapshot for IPv4 frames enable */
+#define ETH_PTP_SnapshotIPV6Frames             ((uint32_t)0x00001000)  /* Time stamp snapshot for IPv6 frames enable */
+#define ETH_PTP_SnapshotPTPOverEthernetFrames  ((uint32_t)0x00000800)  /* Time stamp snapshot for PTP over ethernet frames enable */
+#define ETH_PTP_SnapshotAllReceivedFrames      ((uint32_t)0x00000100)  /* Time stamp snapshot for all received frames enable */
+
+#define IS_ETH_PTP_SNAPSHOT(SNAPSHOT) (((SNAPSHOT) == ETH_PTP_SnapshotMasterMessage) || \
+                           ((SNAPSHOT) == ETH_PTP_SnapshotEventMessage) || \
+                           ((SNAPSHOT) == ETH_PTP_SnapshotIPV4Frames) || \
+                           ((SNAPSHOT) == ETH_PTP_SnapshotIPV6Frames) || \
+                           ((SNAPSHOT) == ETH_PTP_SnapshotPTPOverEthernetFrames) || \
+                           ((SNAPSHOT) == ETH_PTP_SnapshotAllReceivedFrames))
+
+/**
+  * @}
+  */ 
+/* ETHERNET MAC address offsets */
+#define ETH_MAC_ADDR_HBASE   (ETH_MAC_BASE + 0x40)  /* ETHERNET MAC address high offset */
+#define ETH_MAC_ADDR_LBASE    (ETH_MAC_BASE + 0x44)  /* ETHERNET MAC address low offset */
+
+/* ETHERNET MACMIIAR register Mask */
+#define MACMIIAR_CR_MASK    ((uint32_t)0xFFFFFFE3)
+
+/* ETHERNET MACCR register Mask */
+#define MACCR_CLEAR_MASK    ((uint32_t)0xFF20810F)  
+
+/* ETHERNET MACFCR register Mask */
+#define MACFCR_CLEAR_MASK   ((uint32_t)0x0000FF41)
+
+
+/* ETHERNET DMAOMR register Mask */
+#define DMAOMR_CLEAR_MASK   ((uint32_t)0xF8DE3F23)
+
+
+/* ETHERNET Remote Wake-up frame register length */
+#define ETH_WAKEUP_REGISTER_LENGTH      8
+
+/* ETHERNET Missed frames counter Shift */
+#define  ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT     17
+
+/* ETHERNET DMA Tx descriptors Collision Count Shift */
+#define  ETH_DMATXDESC_COLLISION_COUNTSHIFT        3
+
+/* ETHERNET DMA Tx descriptors Buffer2 Size Shift */
+#define  ETH_DMATXDESC_BUFFER2_SIZESHIFT           16
+
+/* ETHERNET DMA Rx descriptors Frame Length Shift */
+#define  ETH_DMARXDESC_FRAME_LENGTHSHIFT           16
+
+/* ETHERNET DMA Rx descriptors Buffer2 Size Shift */
+#define  ETH_DMARXDESC_BUFFER2_SIZESHIFT           16
+
+/* ETHERNET errors */
+#define  ETH_ERROR              ((uint32_t)0)
+#define  ETH_SUCCESS            ((uint32_t)1)
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Exported_Macros
+  * @{
+  */ 
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Exported_Functions
+  * @{
+  */ 
+void ETH_DeInit(void);
+uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress);
+void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct);
+void ETH_SoftwareReset(void);
+FlagStatus ETH_GetSoftwareResetStatus(void);
+void  ETH_Start(void);
+uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc);
+
+
+#ifdef USE_ENHANCED_DMA_DESCRIPTORS
+ void ETH_EnhancedDescriptorCmd(FunctionalState NewState);
+#endif /* USE_ENHANCED_DMA_DESCRIPTORS */
+
+/** 
+  * @brief  PHY  
+  */ 
+uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg);
+uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue);
+uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState);
+
+/** 
+  * @brief  MAC  
+  */ 
+void ETH_MACTransmissionCmd(FunctionalState NewState);
+void ETH_MACReceptionCmd(FunctionalState NewState);
+FlagStatus ETH_GetFlowControlBusyStatus(void);
+void ETH_InitiatePauseControlFrame(void);  
+void ETH_BackPressureActivationCmd(FunctionalState NewState); 
+FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG);  
+ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT);
+void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState);
+void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr);
+void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr);
+void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState);
+void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter);
+void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte);
+
+/** 
+  * @brief  DMA Tx/Rx descriptors  
+  */ 
+void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount);
+void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount);
+uint32_t ETH_CheckFrameReceived(void);
+uint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength);
+FrameTypeDef ETH_Get_Received_Frame(void);
+FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag);
+uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc);
+void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc);
+void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
+void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment);
+void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum);
+void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
+void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
+void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
+void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2);
+FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag);
+#ifdef USE_ENHANCED_DMA_DESCRIPTORS
+ FlagStatus ETH_GetDMAPTPRxDescExtendedFlagStatus(ETH_DMADESCTypeDef *DMAPTPRxDesc, uint32_t ETH_DMAPTPRxDescExtendedFlag);
+#endif /* USE_ENHANCED_DMA_DESCRIPTORS */
+void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc);
+uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc);
+void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState);
+void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState);
+uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer);
+FrameTypeDef ETH_Get_Received_Frame_interrupt(void);
+/** 
+  * @brief  DMA
+  */ 
+FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG);
+void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG);
+ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT);
+void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT);
+uint32_t ETH_GetTransmitProcessState(void);
+uint32_t ETH_GetReceiveProcessState(void);
+void ETH_FlushTransmitFIFO(void);
+FlagStatus ETH_GetFlushTransmitFIFOStatus(void);
+void ETH_DMATransmissionCmd(FunctionalState NewState);
+void ETH_DMAReceptionCmd(FunctionalState NewState);
+void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState);
+FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow);
+uint32_t ETH_GetRxOverflowMissedFrameCounter(void);
+uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void);
+uint32_t ETH_GetCurrentTxDescStartAddress(void);
+uint32_t ETH_GetCurrentRxDescStartAddress(void);
+uint32_t ETH_GetCurrentTxBufferAddress(void);
+uint32_t ETH_GetCurrentRxBufferAddress(void);
+void ETH_ResumeDMATransmission(void);
+void ETH_ResumeDMAReception(void);
+void ETH_SetReceiveWatchdogTimer(uint8_t Value);
+
+
+/** 
+  * @brief  PMT  
+  */ 
+void ETH_ResetWakeUpFrameFilterRegisterPointer(void);
+void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer);
+void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState);
+FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG);
+void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState);
+void ETH_MagicPacketDetectionCmd(FunctionalState NewState);
+void ETH_PowerDownCmd(FunctionalState NewState);
+
+/** 
+  * @brief  MMC  
+  */ 
+void ETH_MMCCounterFullPreset(void);
+void ETH_MMCCounterHalfPreset(void);
+void ETH_MMCCounterFreezeCmd(FunctionalState NewState);
+void ETH_MMCResetOnReadCmd(FunctionalState NewState);
+void ETH_MMCCounterRolloverCmd(FunctionalState NewState);
+void ETH_MMCCountersReset(void);
+void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState);
+ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT);
+uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4x7_ETH_H */
+/**
+  * @}
+  */ 
+
+
+/**
+  * @}
+  */ 
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/inc/stm32f4x7_eth_conf.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/inc/stm32f4x7_eth_conf.h
new file mode 100644
index 0000000..5434622
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/inc/stm32f4x7_eth_conf.h
@@ -0,0 +1,43 @@
+
+#ifndef __STM32F4x7_ETH_CONF_H
+#define __STM32F4x7_ETH_CONF_H
+#include "stm32f4xx.h"
+
+#define USE_ENHANCED_DMA_DESCRIPTORS
+
+//如果使用自己定义的延时函数的话就注销掉下面一行代码，否则使用
+//默认的低精度延时函数
+
+//#define USE_Delay    	//使用默认延时函数，因此注销掉
+#ifdef USE_Delay
+	// #include "main.h"               
+	#define _eth_delay_    Delay     //Delay为用户自己提供的高精度延时函数
+                                    
+#else
+	#define _eth_delay_    ETH_Delay //默认的_eth_delay功能函数延时精度差
+#endif
+
+#ifdef  CUSTOM_DRIVER_BUFFERS_CONFIG
+	//重新定义以太网接收和发送缓冲区的大小和数量
+	#define ETH_RX_BUF_SIZE    ETH_MAX_PACKET_SIZE //接收缓冲区的大小
+	#define ETH_TX_BUF_SIZE    ETH_MAX_PACKET_SIZE //发送缓冲区的大小
+	#define ETH_RXBUFNB        20                  //接收缓冲区数量
+	#define ETH_TXBUFNB        5                   //发送缓冲区数量
+#endif
+
+//*******************PHY配置块*******************
+#ifdef USE_Delay
+	#define PHY_RESET_DELAY    ((uint32_t)0x000000FF)  	//PHY复位延时
+	#define PHY_CONFIG_DELAY   ((uint32_t)0x00000FFF) 	//PHY配置延时
+	#define ETH_REG_WRITE_DELAY ((uint32_t)0x00000001)	//向以太网寄存器写数据时的延时
+#else
+	#define PHY_RESET_DELAY    ((uint32_t)0x000FFFFF)	//PHY复位延时
+	#define PHY_CONFIG_DELAY   ((uint32_t)0x00FFFFFF)	//PHY配置延时
+	#define ETH_REG_WRITE_DELAY ((uint32_t)0x0000FFFF)	//向以太网寄存器写数据时的延时
+#endif
+
+//LAN8720 PHY芯片的状态寄存器
+#define PHY_SR				((uint16_t)31) 		//LAN8720的PHY状态寄存器地址
+#define PHY_SPEED_STATUS    ((uint16_t)0x0004) 	//LAN8720 PHY速度值掩码
+#define PHY_DUPLEX_STATUS   ((uint16_t)0x00010) //LAN8720 PHY连接状态值掩码  
+#endif 
\ No newline at end of file
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/src/stm32f4x7_eth.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/src/stm32f4x7_eth.c
new file mode 100644
index 0000000..3ec8b2d
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4x7_ETH_Driver/src/stm32f4x7_eth.c
@@ -0,0 +1,2702 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4x7_eth.c
+  * @author  MCD Application Team
+  * @version V1.0.0
+  * @date    14-October-2011
+  * @brief   This file is the low level driver for STM32F407xx/417xx Ethernet Controller.
+  *          This driver does not include low level functions for PTP time-stamp.            
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4x7_eth.h"
+#include "stm32f4xx_rcc.h"
+#include <string.h>
+
+#include "stm32f4xx_conf.h"
+
+/** @addtogroup STM32F4x7_ETH_Driver
+  * @brief ETH driver modules
+  * @{
+  */
+
+/** @defgroup ETH_Private_TypesDefinitions
+  * @{
+  */ 
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ETH_Private_Defines
+  * @{
+  */ 
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Private_Macros
+  * @{
+  */ 
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Private_Variables
+  * @{
+  */ 
+
+//#if defined   (__CC_ARM) /*!< ARM Compiler */
+//  __align(4) 
+//   ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+//  __align(4) 
+//   ETH_DMADESCTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+//  __align(4) 
+//   uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+//  __align(4) 
+//   uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+
+//#elif defined ( __ICCARM__ ) /*!< IAR Compiler */
+//  #pragma data_alignment=4
+//   ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+//  #pragma data_alignment=4
+//   ETH_DMADESCTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+//  #pragma data_alignment=4
+//   uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+//  #pragma data_alignment=4
+//   uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+
+//#elif defined (__GNUC__) /*!< GNU Compiler */
+//  ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__ ((aligned (4))); /* Ethernet Rx DMA Descriptor */
+//  ETH_DMADESCTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__ ((aligned (4))); /* Ethernet Tx DMA Descriptor */
+//  uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__ ((aligned (4))); /* Ethernet Receive Buffer */
+//  uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__ ((aligned (4))); /* Ethernet Transmit Buffer */
+
+//#elif defined  (__TASKING__) /*!< TASKING Compiler */                           
+//  __align(4) 
+//   ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+//  __align(4) 
+//   ETH_DMADESCTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+//  __align(4) 
+//   uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+//  __align(4) 
+//   uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+
+//#endif /* __CC_ARM */
+
+
+/* Global pointers on Tx and Rx descriptor used to track transmit and receive descriptors */
+__IO ETH_DMADESCTypeDef  *DMATxDescToSet;
+__IO ETH_DMADESCTypeDef  *DMARxDescToGet;
+
+
+/* Structure used to hold the last received packet descriptors info */
+
+ETH_DMA_Rx_Frame_infos RX_Frame_Descriptor;
+__IO ETH_DMA_Rx_Frame_infos *DMA_RX_FRAME_infos;
+__IO uint32_t Frame_Rx_index;
+
+
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Private_FunctionPrototypes
+  * @{
+  */ 
+/**
+  * @}
+  */
+
+/** @defgroup ETH_Private_Functions
+  * @{
+  */
+
+#ifndef USE_Delay
+/**
+  * @brief  Inserts a delay time.
+  * @param  nCount: specifies the delay time length.
+  * @retval None
+  */
+static void ETH_Delay(__IO uint32_t nCount)
+{
+  __IO uint32_t index = 0; 
+  for(index = nCount; index != 0; index--)
+  {
+  }
+}
+#endif /* USE_Delay*/
+
+
+
+/******************************************************************************/                             
+/*                           Global ETH MAC/DMA functions                     */
+/******************************************************************************/
+
+/**
+  * @brief  Deinitializes the ETHERNET peripheral registers to their default reset values.
+  * @param  None 
+  * @retval None
+  */
+void ETH_DeInit(void)
+{
+  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
+  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
+}
+
+
+/**
+  * @brief  Fills each ETH_InitStruct member with its default value.
+  * @param  ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
+{
+  /* ETH_InitStruct members default value */
+  /*------------------------   MAC Configuration   ---------------------------*/
+  
+  /* PHY Auto-negotiation enabled */
+  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable; 			//使能自适应模式       
+  /* MAC watchdog enabled: cuts-off long frame */
+  ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;										 	//使能看门?
+  /* MAC Jabber enabled in Half-duplex mode */					
+  ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;       									//使能Jabber                                                
+  /* Ethernet interframe gap set to 96 bits */
+  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;  					//设置帧间隔为96bit                                                                                                                          
+  /* Carrier Sense Enabled in Half-Duplex mode */ 
+  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable; 						//半双工模式下使能载波侦听功能                               
+  /* PHY speed configured to 100Mbit/s */
+  ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 														//PHY层速度?00M
+  /* Receive own Frames in Half-Duplex mode enabled */
+  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;                	//半双工模式下允许接收 own frame
+  /* MAC MII loopback disabled */ 
+  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable; 						//关闭MII接口的反馈功?            
+  /* Full-Duplex mode selected */
+  ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;   											//使用全双工模?                  
+  /* IPv4 and TCP/UDP/ICMP frame Checksum Offload disabled */
+  ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;   		//关闭ipv4和TCP/UDP/ICMP的帧校验和卸?                                                         
+  /* Retry Transmission enabled for half-duplex mode */ 
+  ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;   //开启半双工模式下的重试传输功能                                                                              
+  /* Automatic PAD/CRC strip disabled*/
+  ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;  //关闭自动去除PDA/CRC功能                                                        
+  /* half-duplex mode retransmission Backoff time_limit = 10 slot times*/ 
+  ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;     						//设置半双工模式下的最大重传回退事件10 slot times
+  /* half-duplex mode Deferral check disabled */
+  ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;          //关闭半双工模式下的延时检查功?                                                                                                     
+  /* Receive all frames disabled */ 
+  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;								//禁止接收所有帧
+  /* Source address filtering (on the optional MAC addresses) disabled */
+  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   	//关闭MAC地址的源地址过滤功能
+  /* Do not forward control frames that do not pass the address filtering */
+  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll; //
+  /* Disable reception of Broadcast frames */
+  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;//禁止接收所有的广播?
+  /* Normal Destination address filtering (not reverse addressing) */
+  ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;			//正常的远端地址过滤
+  /* Promiscuous address filtering mode disabled */
+  ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;			//关闭混合模式的地址过滤                                                            
+  /* Perfect address filtering for multicast addresses */
+  ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;  //对于组播地址使用完美地址过滤   
+  /* Perfect address filtering for unicast addresses */
+  ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;     	//对单播地址使用完美地址过滤 
+  /* Initialize hash table high and low regs */
+  ETH_InitStruct->ETH_HashTableHigh = 0x0;   											//初始化HASH表的高位寄存?            
+  ETH_InitStruct->ETH_HashTableLow = 0x0;                     		//初始化HASH表的低位位寄存器  
+  /* Flow control config (flow control disabled)*/
+  ETH_InitStruct->ETH_PauseTime = 0x0;                 					//流控配置 
+  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
+  ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;         
+  ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;   
+  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
+  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
+  /* VLANtag config (VLAN field not checked) */
+  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
+  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
+  
+  /*---------------------- DMA Configuration   -------------------------------*/
+
+  /* Drops frames with with TCP/IP checksum errors */
+  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; //关闭丢弃TCP/IP错误?
+  /* Store and forward mode enabled for receive */
+  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       //开启接收数据的存储转发功能
+  /* Flush received frame that created FIFO overflow */
+  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable; 
+  /* Store and forward mode enabled for transmit */
+  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;   	//开启发送模式的存储转发功能
+  /* Threshold TXFIFO level set to 64 bytes (used when threshold mode is enabled) */
+  ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  //设置阈值模式下的发送FIFO的阈值为64字节
+  /* Disable forwarding frames with errors (short frames, CRC,...)*/
+  ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;   //禁止转发错误?
+  /* Disable undersized good frames */
+  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; //不转发过小的好帧
+  /* Threshold RXFIFO level set to 64 bytes (used when Cut-through mode is enabled) */
+  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;    //设置直通模式下的发送FIFO阈值为64字节                        
+  /* Disable Operate on second frame (transmit a second frame to FIFO without 
+  waiting status of previous frame*/                           
+  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;							//关闭处理第二帧数?
+  /* DMA works on 32-bit aligned start source and destinations addresses */
+  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;						//开启DMA传输的地址对齐功能
+  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
+  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;    												//开启固定突发功?
+  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
+  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;    //DMA发送的最大突发长度为32
+  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;    //DMA接收的最大突发长度为32
+  /* DMA Ring mode skip length = 0 */
+  ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
+  /* Equal priority (round-robin) between transmit and receive DMA engines */
+  ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
+}
+
+
+/**
+  * @brief  Initializes the ETHERNET peripheral according to the specified
+  *   parameters in the ETH_InitStruct .
+  * @param ETH_InitStruct: pointer to a ETH_InitTypeDef structure that contains
+  *   the configuration information for the specified ETHERNET peripheral.
+  * @param PHYAddress: external PHY address                    
+  * @retval ETH_ERROR: Ethernet initialization failed
+  *         ETH_SUCCESS: Ethernet successfully initialized                 
+  */
+uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
+{
+  uint32_t RegValue = 0, tmpreg = 0;
+  __IO uint32_t i = 0;
+  RCC_ClocksTypeDef  rcc_clocks;
+  uint32_t hclk = 60000000;
+  __IO uint32_t timeout = 0;
+  /* Check the parameters */
+  /* MAC --------------------------*/ 
+  assert_param(IS_ETH_AUTONEGOTIATION(ETH_InitStruct->ETH_AutoNegotiation));
+  assert_param(IS_ETH_WATCHDOG(ETH_InitStruct->ETH_Watchdog));
+  assert_param(IS_ETH_JABBER(ETH_InitStruct->ETH_Jabber));
+  assert_param(IS_ETH_INTER_FRAME_GAP(ETH_InitStruct->ETH_InterFrameGap));
+  assert_param(IS_ETH_CARRIER_SENSE(ETH_InitStruct->ETH_CarrierSense));
+  assert_param(IS_ETH_SPEED(ETH_InitStruct->ETH_Speed));
+  assert_param(IS_ETH_RECEIVE_OWN(ETH_InitStruct->ETH_ReceiveOwn));
+  assert_param(IS_ETH_LOOPBACK_MODE(ETH_InitStruct->ETH_LoopbackMode));
+  assert_param(IS_ETH_DUPLEX_MODE(ETH_InitStruct->ETH_Mode));
+  assert_param(IS_ETH_CHECKSUM_OFFLOAD(ETH_InitStruct->ETH_ChecksumOffload));
+  assert_param(IS_ETH_RETRY_TRANSMISSION(ETH_InitStruct->ETH_RetryTransmission));
+  assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(ETH_InitStruct->ETH_AutomaticPadCRCStrip));
+  assert_param(IS_ETH_BACKOFF_LIMIT(ETH_InitStruct->ETH_BackOffLimit));
+  assert_param(IS_ETH_DEFERRAL_CHECK(ETH_InitStruct->ETH_DeferralCheck));
+  assert_param(IS_ETH_RECEIVE_ALL(ETH_InitStruct->ETH_ReceiveAll));
+  assert_param(IS_ETH_SOURCE_ADDR_FILTER(ETH_InitStruct->ETH_SourceAddrFilter));
+  assert_param(IS_ETH_CONTROL_FRAMES(ETH_InitStruct->ETH_PassControlFrames));
+  assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(ETH_InitStruct->ETH_BroadcastFramesReception));
+  assert_param(IS_ETH_DESTINATION_ADDR_FILTER(ETH_InitStruct->ETH_DestinationAddrFilter));
+  assert_param(IS_ETH_PROMISCIOUS_MODE(ETH_InitStruct->ETH_PromiscuousMode));
+  assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(ETH_InitStruct->ETH_MulticastFramesFilter));  
+  assert_param(IS_ETH_UNICAST_FRAMES_FILTER(ETH_InitStruct->ETH_UnicastFramesFilter));
+  assert_param(IS_ETH_PAUSE_TIME(ETH_InitStruct->ETH_PauseTime));
+  assert_param(IS_ETH_ZEROQUANTA_PAUSE(ETH_InitStruct->ETH_ZeroQuantaPause));
+  assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(ETH_InitStruct->ETH_PauseLowThreshold));
+  assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(ETH_InitStruct->ETH_UnicastPauseFrameDetect));
+  assert_param(IS_ETH_RECEIVE_FLOWCONTROL(ETH_InitStruct->ETH_ReceiveFlowControl));
+  assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(ETH_InitStruct->ETH_TransmitFlowControl));
+  assert_param(IS_ETH_VLAN_TAG_COMPARISON(ETH_InitStruct->ETH_VLANTagComparison));
+  assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(ETH_InitStruct->ETH_VLANTagIdentifier));
+  /* DMA --------------------------*/
+  assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame));
+  assert_param(IS_ETH_RECEIVE_STORE_FORWARD(ETH_InitStruct->ETH_ReceiveStoreForward));
+  assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(ETH_InitStruct->ETH_FlushReceivedFrame));
+  assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(ETH_InitStruct->ETH_TransmitStoreForward));
+  assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(ETH_InitStruct->ETH_TransmitThresholdControl));
+  assert_param(IS_ETH_FORWARD_ERROR_FRAMES(ETH_InitStruct->ETH_ForwardErrorFrames));
+  assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(ETH_InitStruct->ETH_ForwardUndersizedGoodFrames));
+  assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(ETH_InitStruct->ETH_ReceiveThresholdControl));
+  assert_param(IS_ETH_SECOND_FRAME_OPERATE(ETH_InitStruct->ETH_SecondFrameOperate));
+  assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(ETH_InitStruct->ETH_AddressAlignedBeats));
+  assert_param(IS_ETH_FIXED_BURST(ETH_InitStruct->ETH_FixedBurst));
+  assert_param(IS_ETH_RXDMA_BURST_LENGTH(ETH_InitStruct->ETH_RxDMABurstLength));
+  assert_param(IS_ETH_TXDMA_BURST_LENGTH(ETH_InitStruct->ETH_TxDMABurstLength)); 
+  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
+  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
+  /*-------------------------------- MAC Config ------------------------------*/   
+  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
+  /* Get the ETHERNET MACMIIAR value */
+  tmpreg = ETH->MACMIIAR;
+  /* Clear CSR Clock Range CR[2:0] bits */
+  tmpreg &= MACMIIAR_CR_MASK;
+  /* Get hclk frequency value */
+  RCC_GetClocksFreq(&rcc_clocks);
+  hclk = rcc_clocks.HCLK_Frequency;
+  
+  /* Set CR bits depending on hclk value */
+  if((hclk >= 20000000)&&(hclk < 35000000))
+  {
+    /* CSR Clock Range between 20-35 MHz */
+    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
+  }
+  else if((hclk >= 35000000)&&(hclk < 60000000))
+  {
+    /* CSR Clock Range between 35-60 MHz */ 
+    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;    
+  }  
+  else if((hclk >= 60000000)&&(hclk < 100000000))
+  {
+    /* CSR Clock Range between 60-100 MHz */ 
+    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
+  }  
+  else if((hclk >= 100000000)&&(hclk < 150000000))
+  {
+    /* CSR Clock Range between 100-150 MHz */ 
+    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;    
+  }   
+  else /* ((hclk >= 150000000)&&(hclk <= 168000000)) */
+  {
+    /* CSR Clock Range between 150-168 MHz */ 
+    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
+  }
+  
+  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
+  ETH->MACMIIAR = (uint32_t)tmpreg;  
+  /*-------------------- PHY initialization and configuration ----------------*/
+  /* Put the PHY in reset mode */
+  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
+  {
+    /* Return ERROR in case of write timeout */
+    return ETH_ERROR;
+  }
+  
+  /* Delay to assure PHY reset */
+  _eth_delay_(PHY_RESET_DELAY);
+    
+  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
+  {  
+    /* We wait for linked status... */
+    do
+    {
+      timeout++;
+    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
+
+    /* Return ERROR in case of timeout */
+    if(timeout == PHY_READ_TO)
+    {
+      return ETH_ERROR;
+    }
+
+    /* Reset Timeout counter */
+    timeout = 0; 
+    /* Enable Auto-Negotiation */
+    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
+    {
+      /* Return ERROR in case of write timeout */
+      return ETH_ERROR;
+    }
+
+    /* Wait until the auto-negotiation will be completed */
+    do
+    {
+      timeout++;
+    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
+
+    /* Return ERROR in case of timeout */
+    if(timeout == PHY_READ_TO)
+    {
+      return ETH_ERROR;
+    }
+
+    /* Reset Timeout counter */
+    timeout = 0;
+    
+    /* Read the result of the auto-negotiation */
+    RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
+  
+    /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
+    if((RegValue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
+    {
+      /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
+      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;  
+    }
+    else
+    {
+      /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
+      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
+    }
+
+    /* Configure the MAC with the speed fixed by the auto-negotiation process */
+    if(RegValue & PHY_SPEED_STATUS)
+    {  
+      /* Set Ethernet speed to 10M following the auto-negotiation */    
+      ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
+    }
+    else
+    {   
+      /* Set Ethernet speed to 100M following the auto-negotiation */ 
+      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
+    }    
+  }
+  else
+  {
+    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
+                                                   (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
+    {
+      /* Return ERROR in case of write timeout */
+      return ETH_ERROR;
+    }
+    /* Delay to assure PHY configuration */
+    _eth_delay_(PHY_CONFIG_DELAY);
+    
+  }
+  /*------------------------ ETHERNET MACCR Configuration --------------------*/
+  /* Get the ETHERNET MACCR value */  
+  tmpreg = ETH->MACCR;
+  /* Clear WD, PCE, PS, TE and RE bits */
+  tmpreg &= MACCR_CLEAR_MASK;
+  /* Set the WD bit according to ETH_Watchdog value */
+  /* Set the JD: bit according to ETH_Jabber value */
+  /* Set the IFG bit according to ETH_InterFrameGap value */ 
+  /* Set the DCRS bit according to ETH_CarrierSense value */  
+  /* Set the FES bit according to ETH_Speed value */ 
+  /* Set the DO bit according to ETH_ReceiveOwn value */ 
+  /* Set the LM bit according to ETH_LoopbackMode value */ 
+  /* Set the DM bit according to ETH_Mode value */ 
+  /* Set the IPCO bit according to ETH_ChecksumOffload value */                   
+  /* Set the DR bit according to ETH_RetryTransmission value */ 
+  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
+  /* Set the BL bit according to ETH_BackOffLimit value */ 
+  /* Set the DC bit according to ETH_DeferralCheck value */                          
+  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
+                  ETH_InitStruct->ETH_Jabber | 
+                  ETH_InitStruct->ETH_InterFrameGap |
+                  ETH_InitStruct->ETH_CarrierSense |
+                  ETH_InitStruct->ETH_Speed | 
+                  ETH_InitStruct->ETH_ReceiveOwn |
+                  ETH_InitStruct->ETH_LoopbackMode |
+                  ETH_InitStruct->ETH_Mode | 
+                  ETH_InitStruct->ETH_ChecksumOffload |    
+                  ETH_InitStruct->ETH_RetryTransmission | 
+                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
+                  ETH_InitStruct->ETH_BackOffLimit | 
+                  ETH_InitStruct->ETH_DeferralCheck);
+  /* Write to ETHERNET MACCR */
+  ETH->MACCR = (uint32_t)tmpreg;
+  
+  /*----------------------- ETHERNET MACFFR Configuration --------------------*/ 
+  /* Set the RA bit according to ETH_ReceiveAll value */
+  /* Set the SAF and SAIF bits according to ETH_SourceAddrFilter value */
+  /* Set the PCF bit according to ETH_PassControlFrames value */
+  /* Set the DBF bit according to ETH_BroadcastFramesReception value */
+  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
+  /* Set the PR bit according to ETH_PromiscuousMode value */
+  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
+  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
+  /* Write to ETHERNET MACFFR */  
+  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
+                          ETH_InitStruct->ETH_SourceAddrFilter |
+                          ETH_InitStruct->ETH_PassControlFrames |
+                          ETH_InitStruct->ETH_BroadcastFramesReception | 
+                          ETH_InitStruct->ETH_DestinationAddrFilter |
+                          ETH_InitStruct->ETH_PromiscuousMode |
+                          ETH_InitStruct->ETH_MulticastFramesFilter |
+                          ETH_InitStruct->ETH_UnicastFramesFilter); 
+  /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
+  /* Write to ETHERNET MACHTHR */
+  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
+  /* Write to ETHERNET MACHTLR */
+  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
+  /*----------------------- ETHERNET MACFCR Configuration --------------------*/
+  /* Get the ETHERNET MACFCR value */  
+  tmpreg = ETH->MACFCR;
+  /* Clear xx bits */
+  tmpreg &= MACFCR_CLEAR_MASK;
+  
+  /* Set the PT bit according to ETH_PauseTime value */
+  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
+  /* Set the PLT bit according to ETH_PauseLowThreshold value */
+  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
+  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
+  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
+  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
+                   ETH_InitStruct->ETH_ZeroQuantaPause |
+                   ETH_InitStruct->ETH_PauseLowThreshold |
+                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
+                   ETH_InitStruct->ETH_ReceiveFlowControl |
+                   ETH_InitStruct->ETH_TransmitFlowControl); 
+  /* Write to ETHERNET MACFCR */
+  ETH->MACFCR = (uint32_t)tmpreg;
+  /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
+  /* Set the ETV bit according to ETH_VLANTagComparison value */
+  /* Set the VL bit according to ETH_VLANTagIdentifier value */  
+  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
+                             ETH_InitStruct->ETH_VLANTagIdentifier); 
+       
+  /*-------------------------------- DMA Config ------------------------------*/
+  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
+  /* Get the ETHERNET DMAOMR value */  
+  tmpreg = ETH->DMAOMR;
+  /* Clear xx bits */
+  tmpreg &= DMAOMR_CLEAR_MASK;
+  
+  /* Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value */
+  /* Set the RSF bit according to ETH_ReceiveStoreForward value */
+  /* Set the DFF bit according to ETH_FlushReceivedFrame value */
+  /* Set the TSF bit according to ETH_TransmitStoreForward value */
+  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
+  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
+  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
+  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
+  /* Set the OSF bit according to ETH_SecondFrameOperate value */
+  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
+                  ETH_InitStruct->ETH_ReceiveStoreForward |
+                  ETH_InitStruct->ETH_FlushReceivedFrame |
+                  ETH_InitStruct->ETH_TransmitStoreForward | 
+                  ETH_InitStruct->ETH_TransmitThresholdControl |
+                  ETH_InitStruct->ETH_ForwardErrorFrames |
+                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
+                  ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
+                  ETH_InitStruct->ETH_SecondFrameOperate); 
+  /* Write to ETHERNET DMAOMR */
+  ETH->DMAOMR = (uint32_t)tmpreg;
+  
+  /*----------------------- ETHERNET DMABMR Configuration --------------------*/ 
+  /* Set the AAL bit according to ETH_AddressAlignedBeats value */
+  /* Set the FB bit according to ETH_FixedBurst value */
+  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
+  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
+  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
+  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
+  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
+                          ETH_InitStruct->ETH_FixedBurst |
+                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
+                          ETH_InitStruct->ETH_TxDMABurstLength | 
+                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
+                          ETH_InitStruct->ETH_DMAArbitration |
+                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
+                          
+  #ifdef USE_ENHANCED_DMA_DESCRIPTORS
+    /* Enable the Enhanced DMA descriptors */
+    ETH->DMABMR |= ETH_DMABMR_EDE;
+  #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
+                              
+  /* Return Ethernet configuration success */
+  return ETH_SUCCESS;
+}
+
+/**
+  * @brief  Enables ENET MAC and DMA reception/transmission 
+  * @param  None
+  * @retval None
+  */
+void ETH_Start(void)
+{
+  /* Enable transmit state machine of the MAC for transmission on the MII */  
+  ETH_MACTransmissionCmd(ENABLE);
+  /* Flush Transmit FIFO */
+  ETH_FlushTransmitFIFO();
+  /* Enable receive state machine of the MAC for reception from the MII */  
+  ETH_MACReceptionCmd(ENABLE);
+ 
+  /* Start DMA transmission */
+  ETH_DMATransmissionCmd(ENABLE); 
+  /* Start DMA reception */
+  ETH_DMAReceptionCmd(ENABLE);   
+}
+
+
+/**
+  * @brief  Enables or disables the MAC transmission.
+  * @param  NewState: new state of the MAC transmission.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_MACTransmissionCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the MAC transmission */
+    ETH->MACCR |= ETH_MACCR_TE;  
+  }
+  else
+  {
+    /* Disable the MAC transmission */
+    ETH->MACCR &= ~ETH_MACCR_TE;
+  }
+}
+
+
+/**
+  * @brief  Enables or disables the MAC reception.
+  * @param  NewState: new state of the MAC reception.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_MACReceptionCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the MAC reception */
+    ETH->MACCR |= ETH_MACCR_RE;  
+  }
+  else
+  {
+    /* Disable the MAC reception */
+    ETH->MACCR &= ~ETH_MACCR_RE;
+  }
+}
+
+
+/**
+  * @brief  Checks whether the ETHERNET flow control busy bit is set or not.
+  * @param  None
+  * @retval The new state of flow control busy status bit (SET or RESET).
+  */
+FlagStatus ETH_GetFlowControlBusyStatus(void)
+{
+  FlagStatus bitstatus = RESET;
+  /* The Flow Control register should not be written to until this bit is cleared */
+  if ((ETH->MACFCR & ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+
+/**
+  * @brief  Initiate a Pause Control Frame (Full-duplex only).
+  * @param  None
+  * @retval None
+  */
+void ETH_InitiatePauseControlFrame(void)  
+{ 
+  /* When Set In full duplex MAC initiates pause control frame */
+  ETH->MACFCR |= ETH_MACFCR_FCBBPA;  
+}
+
+
+/**
+  * @brief  Enables or disables the MAC BackPressure operation activation (Half-duplex only).
+  * @param  NewState: new state of the MAC BackPressure operation activation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_BackPressureActivationCmd(FunctionalState NewState)   
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  if (NewState != DISABLE)
+  {
+    /* Activate the MAC BackPressure operation */
+    /* In Half duplex: during backpressure, when the MAC receives a new frame,
+    the transmitter starts sending a JAM pattern resulting in a collision */
+    ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
+  }
+  else
+  {
+    /* Desactivate the MAC BackPressure operation */
+    ETH->MACFCR &= ~ETH_MACFCR_FCBBPA; 
+  } 
+}
+
+
+/**
+  * @brief  Checks whether the specified ETHERNET MAC flag is set or not.
+  * @param  ETH_MAC_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_MAC_FLAG_TST  : Time stamp trigger flag   
+  *     @arg ETH_MAC_FLAG_MMCT : MMC transmit flag  
+  *     @arg ETH_MAC_FLAG_MMCR : MMC receive flag   
+  *     @arg ETH_MAC_FLAG_MMC  : MMC flag  
+  *     @arg ETH_MAC_FLAG_PMT  : PMT flag  
+  * @retval The new state of ETHERNET MAC flag (SET or RESET).
+  */
+FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); 
+  if ((ETH->MACSR & ETH_MAC_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+
+/**
+  * @brief  Checks whether the specified ETHERNET MAC interrupt has occurred or not.
+  * @param  ETH_MAC_IT: specifies the interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_MAC_IT_TST   : Time stamp trigger interrupt  
+  *     @arg ETH_MAC_IT_MMCT : MMC transmit interrupt 
+  *     @arg ETH_MAC_IT_MMCR : MMC receive interrupt  
+  *     @arg ETH_MAC_IT_MMC  : MMC interrupt 
+  *     @arg ETH_MAC_IT_PMT  : PMT interrupt 
+  * @retval The new state of ETHERNET MAC interrupt (SET or RESET).
+  */
+ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
+{
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); 
+  if ((ETH->MACSR & ETH_MAC_IT) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+
+/**
+  * @brief  Enables or disables the specified ETHERNET MAC interrupts.
+  * @param  ETH_MAC_IT: specifies the ETHERNET MAC interrupt sources to be
+  *   enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg ETH_MAC_IT_TST : Time stamp trigger interrupt 
+  *     @arg ETH_MAC_IT_PMT : PMT interrupt 
+  * @param  NewState: new state of the specified ETHERNET MAC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));  
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ETHERNET MAC interrupts */
+    ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
+  }
+  else
+  {
+    /* Disable the selected ETHERNET MAC interrupts */
+    ETH->MACIMR |= ETH_MAC_IT;
+  }
+}
+
+
+/**
+  * @brief  Configures the selected MAC address.
+  * @param  MacAddr: The MAC address to configure.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_MAC_Address0 : MAC Address0 
+  *     @arg ETH_MAC_Address1 : MAC Address1 
+  *     @arg ETH_MAC_Address2 : MAC Address2
+  *     @arg ETH_MAC_Address3 : MAC Address3
+  * @param  Addr: Pointer on MAC address buffer data (6 bytes).
+  * @retval None
+  */
+void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr)
+{
+  uint32_t tmpreg;
+  /* Check the parameters */
+  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
+  
+  /* Calculate the selected MAC address high register */
+  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4]; //计算出所选择的MAC地址的高位寄存器?
+																												 //即ETH_MACA0HR?6位?
+  /* Load the selected MAC address high register */
+  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg; //将计算出的高位值写入ETH_MAC0HR?
+  /* Calculate the selected MAC address low register */
+	//计算出所选择的MAC地址的第位寄存器?即ETH_MACA0LR?6位?
+  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
+ 
+  /* Load the selected MAC address low register */
+  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;//将计算出的低位值写入ETH_MAC0LR?
+}
+
+
+/**
+  * @brief  Get the selected MAC address.
+  * @param  MacAddr: The MAC address to return.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_MAC_Address0 : MAC Address0 
+  *     @arg ETH_MAC_Address1 : MAC Address1 
+  *     @arg ETH_MAC_Address2 : MAC Address2
+  *     @arg ETH_MAC_Address3 : MAC Address3
+  * @param  Addr: Pointer on MAC address buffer data (6 bytes).
+  * @retval None
+  */
+void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr)
+{
+  uint32_t tmpreg;
+  /* Check the parameters */
+  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
+  
+  /* Get the selected MAC address high register */
+  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
+ 
+  /* Calculate the selected MAC address buffer */
+  Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
+  Addr[4] = (tmpreg & (uint8_t)0xFF);
+  /* Load the selected MAC address low register */
+  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
+  /* Calculate the selected MAC address buffer */
+  Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
+  Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
+  Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
+  Addr[0] = (tmpreg & (uint8_t)0xFF);
+}
+
+
+/**
+  * @brief  Enables or disables the Address filter module uses the specified
+  *   ETHERNET MAC address for perfect filtering 
+  * @param  MacAddr: specifies the ETHERNET MAC address to be used for perfect filtering.
+  *   This parameter can be one of the following values: 
+  *     @arg ETH_MAC_Address1 : MAC Address1 
+  *     @arg ETH_MAC_Address2 : MAC Address2
+  *     @arg ETH_MAC_Address3 : MAC Address3
+  * @param  NewState: new state of the specified ETHERNET MAC address use.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ETHERNET MAC address for perfect filtering */
+    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
+  }
+  else
+  {
+    /* Disable the selected ETHERNET MAC address for perfect filtering */
+    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_AE);
+  }
+}
+
+
+/**
+  * @brief  Set the filter type for the specified ETHERNET MAC address 
+  * @param  MacAddr: specifies the ETHERNET MAC address 
+  *   This parameter can be one of the following values: 
+  *     @arg ETH_MAC_Address1 : MAC Address1 
+  *     @arg ETH_MAC_Address2 : MAC Address2
+  *     @arg ETH_MAC_Address3 : MAC Address3
+  * @param  Filter: specifies the used frame received field for comparison 
+  *   This parameter can be one of the following values: 
+  *     @arg ETH_MAC_AddressFilter_SA : MAC Address is used to compare with the
+  *                                     SA fields of the received frame.
+  *     @arg ETH_MAC_AddressFilter_DA : MAC Address is used to compare with the
+  *                                     DA fields of the received frame.
+  * @retval None
+  */
+void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
+  assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter));
+  
+  if (Filter != ETH_MAC_AddressFilter_DA)
+  {
+    /* The selected ETHERNET MAC address is used to compare with the SA fields of the
+       received frame. */
+    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
+  }
+  else
+  {
+    /* The selected ETHERNET MAC address is used to compare with the DA fields of the
+       received frame. */
+    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
+  }
+}
+
+
+/**
+  * @brief  Set the filter type for the specified ETHERNET MAC address 
+  * @param  MacAddr: specifies the ETHERNET MAC address 
+  *   This parameter can be one of the following values: 
+  *     @arg ETH_MAC_Address1 : MAC Address1 
+  *     @arg ETH_MAC_Address2 : MAC Address2
+  *     @arg ETH_MAC_Address3 : MAC Address3
+  * @param  MaskByte: specifies the used address bytes for comparison 
+  *   This parameter can be any combination of the following values: 
+  *     @arg ETH_MAC_AddressMask_Byte6 : Mask MAC Address high reg bits [15:8].
+  *     @arg ETH_MAC_AddressMask_Byte5 : Mask MAC Address high reg bits [7:0].
+  *     @arg ETH_MAC_AddressMask_Byte4 : Mask MAC Address low reg bits [31:24].
+  *     @arg ETH_MAC_AddressMask_Byte3 : Mask MAC Address low reg bits [23:16].
+  *     @arg ETH_MAC_AddressMask_Byte2 : Mask MAC Address low reg bits [15:8].
+  *     @arg ETH_MAC_AddressMask_Byte1 : Mask MAC Address low reg bits [7:0].
+  * @retval None
+  */
+void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
+  assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));
+  
+  /* Clear MBC bits in the selected MAC address  high register */
+  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_MBC);
+  /* Set the selected Filter mask bytes */
+  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
+}
+
+
+/******************************************************************************/                             
+/*                           DMA Descriptors functions                        */
+/******************************************************************************/
+
+/**
+  * @brief  This function should be called to get the received frame (to be used 
+  * with polling method only).
+  * @param  none
+  * @retval Structure of type FrameTypeDef
+  */
+FrameTypeDef ETH_Get_Received_Frame(void)
+{ 
+  uint32_t framelength = 0;
+  FrameTypeDef frame = {0,0,0}; 
+  
+  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
+  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
+  frame.length = framelength;
+  
+  /* Get the address of the buffer start address */ 
+  /* Check if more than one segment in the frame */
+  if (DMA_RX_FRAME_infos->Seg_Count >1)
+  {
+    frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
+  }
+  else 
+  {
+    frame.buffer = DMARxDescToGet->Buffer1Addr;
+  }
+
+  frame.descriptor = DMARxDescToGet;
+  
+  /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
+  /* Chained Mode */    
+  /* Selects the next DMA Rx descriptor list for next buffer to read */ 
+  DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
+  
+  /* Return Frame */
+  return (frame);  
+}
+
+
+/**
+  * @brief  This function should be called when a frame is received using DMA 
+  *         Receive interrupt, it allows scanning of Rx descriptors to get the
+  *         the receive frame (should be used with interrupt mode only)
+  * @param  None
+  * @retval Structure of type FrameTypeDef
+  */
+FrameTypeDef ETH_Get_Received_Frame_interrupt(void)
+{ 
+  FrameTypeDef frame={0,0,0};
+  __IO uint32_t descriptor_scan_counter = 0; 
+  
+  /* scan descriptors owned by CPU */
+  while (((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET)&&
+        (descriptor_scan_counter<ETH_RXBUFNB))
+  {
+    
+    /* Just by security */
+    descriptor_scan_counter++;
+    
+    /* check if first segment in frame */
+    if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
+      ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
+    {
+      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
+      DMA_RX_FRAME_infos->Seg_Count = 1;   
+      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
+    }
+    
+    /* check if intermediate segment */
+    else if (((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET)&&
+            ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET))
+    {
+      (DMA_RX_FRAME_infos->Seg_Count) ++;
+      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
+    }
+
+    /* should be last segment */
+    else
+    { 
+      /* last segment */
+      DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
+      
+      (DMA_RX_FRAME_infos->Seg_Count)++;
+        
+      /* first segment is last segment */
+      if ((DMA_RX_FRAME_infos->Seg_Count)==1)
+        DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
+      
+      /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
+      frame.length = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
+
+  
+      /* Get the address of the buffer start address */ 
+      /* Check if more than one segment in the frame */
+      if (DMA_RX_FRAME_infos->Seg_Count >1)
+      {
+        frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
+      }
+      else 
+      {
+        frame.buffer = DMARxDescToGet->Buffer1Addr;
+      }
+      
+      frame.descriptor = DMARxDescToGet;
+  
+      /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
+      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
+     
+      /* Return Frame */
+      return (frame);  
+    }
+  }
+  return (frame); 
+}
+      
+          
+/**
+  * @brief  Prepares DMA Tx descriptors to transmit an ethernet frame
+  * @param  FrameLength : length of the frame to send
+  * @retval error status
+  */
+uint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength)
+{   
+  uint32_t buf_count =0, size=0,i=0;
+  __IO ETH_DMADESCTypeDef *DMATxNextDesc;
+  
+  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
+  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
+  {  
+    /* Return ERROR: OWN bit set */
+    return ETH_ERROR;
+  }
+  
+  DMATxNextDesc = DMATxDescToSet;
+  
+  if (FrameLength > ETH_TX_BUF_SIZE)
+  {
+    buf_count = FrameLength/ETH_TX_BUF_SIZE;
+    if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
+  }
+  else buf_count =1;
+  
+  if (buf_count ==1)
+  {
+    /*set LAST and FIRST segment */
+    DMATxDescToSet->Status |=ETH_DMATxDesc_FS|ETH_DMATxDesc_LS;
+    /* Set frame size */
+    DMATxDescToSet->ControlBufferSize = (FrameLength& ETH_DMATxDesc_TBS1);
+    /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
+    DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
+    DMATxDescToSet= (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
+  }
+  else
+  {
+    for (i=0; i< buf_count; i++)
+    {
+      if (i==0) 
+      {
+        /* Setting the first segment bit */
+        DMATxDescToSet->Status |= ETH_DMATxDesc_FS;  
+      }
+      
+      /* Program size */
+      DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
+       
+      if (i== (buf_count-1))
+      {
+        /* Setting the last segment bit */
+        DMATxNextDesc->Status |= ETH_DMATxDesc_LS;
+        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
+        DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
+      }
+        
+      /*give back descriptor to DMA */
+      DMATxNextDesc->Status |= ETH_DMATxDesc_OWN;
+      
+      DMATxNextDesc = (ETH_DMADESCTypeDef *)(DMATxNextDesc->Buffer2NextDescAddr);
+      /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
+     }
+    DMATxDescToSet = DMATxNextDesc ;
+  }
+    
+  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
+  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
+  {
+    /* Clear TBUS ETHERNET DMA flag */
+    ETH->DMASR = ETH_DMASR_TBUS;
+    /* Resume DMA transmission*/
+    ETH->DMATPDR = 0;
+  }
+  
+  /* Return SUCCESS */
+  return ETH_SUCCESS;   
+}
+
+
+/**
+  * @brief  Initializes the DMA Rx descriptors in chain mode.
+  * @param  DMARxDescTab: Pointer on the first Rx desc list 
+  * @param  RxBuff: Pointer on the first RxBuffer list
+  * @param  RxBuffCount: Number of the used Rx desc in the list
+  * @retval None
+  */
+void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
+{
+  uint32_t i = 0;
+  ETH_DMADESCTypeDef *DMARxDesc;
+  
+  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
+  DMARxDescToGet = DMARxDescTab; 
+  /* Fill each DMARxDesc descriptor with the right values */
+  for(i=0; i < RxBuffCount; i++)
+  {
+    /* Get the pointer on the ith member of the Rx Desc list */
+    DMARxDesc = DMARxDescTab+i;
+    /* Set Own bit of the Rx descriptor Status */
+    DMARxDesc->Status = ETH_DMARxDesc_OWN;
+
+    /* Set Buffer1 size and Second Address Chained bit */
+    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
+    /* Set Buffer1 address pointer */
+    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
+    
+    /* Initialize the next descriptor with the Next Descriptor Polling Enable */
+    if(i < (RxBuffCount-1))
+    {
+      /* Set next descriptor address register with next descriptor base address */
+      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
+    }
+    else
+    {
+      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
+      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
+    }
+  }
+   
+  /* Set Receive Descriptor List Address Register */
+  ETH->DMARDLAR = (uint32_t) DMARxDescTab; 
+  
+
+  DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
+
+}
+
+/**
+  * @brief  This function polls for a frame reception
+  * @param  None
+  * @retval Returns 1 when a frame is received, 0 if none.
+  */
+uint32_t ETH_CheckFrameReceived(void)
+{ 
+  /* check if last segment */
+  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
+     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
+    {   
+      DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
+      DMA_RX_FRAME_infos->Seg_Count++;
+      return 1;
+    }
+  
+    /* check if first segment */
+    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
+     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
+     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))      
+    {
+      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
+      DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
+      DMA_RX_FRAME_infos->Seg_Count = 1;   
+      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
+    }
+    
+    /* check if intermediate segment */ 
+    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
+     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
+     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
+    {
+      (DMA_RX_FRAME_infos->Seg_Count) ++;
+      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
+    } 
+    return 0;
+}
+
+
+
+/**
+  * @brief  Initializes the DMA Tx descriptors in chain mode.
+  * @param  DMATxDescTab: Pointer on the first Tx desc list 
+  * @param  TxBuff: Pointer on the first TxBuffer list
+  * @param  TxBuffCount: Number of the used Tx desc in the list
+  * @retval None
+  */
+void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
+{
+  uint32_t i = 0;
+  ETH_DMADESCTypeDef *DMATxDesc;
+  
+  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
+  DMATxDescToSet = DMATxDescTab;
+  /* Fill each DMATxDesc descriptor with the right values */   
+  for(i=0; i < TxBuffCount; i++)
+  {
+    /* Get the pointer on the ith member of the Tx Desc list */
+    DMATxDesc = DMATxDescTab + i;
+    /* Set Second Address Chained bit */
+    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
+       
+    /* Set Buffer1 address pointer */
+    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
+    
+    /* Initialize the next descriptor with the Next Descriptor Polling Enable */
+    if(i < (TxBuffCount-1))
+    {
+      /* Set next descriptor address register with next descriptor base address */
+      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
+    }
+    else
+    {
+      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
+      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
+    }
+  }
+   
+  /* Set Transmit Desciptor List Address Register */
+  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
+}
+
+
+
+
+/**
+  * @brief  Checks whether the specified ETHERNET DMA Tx Desc flag is set or not.
+  * @param  DMATxDesc: pointer on a DMA Tx descriptor
+  * @param  ETH_DMATxDescFlag: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_DMATxDesc_OWN : OWN bit: descriptor is owned by DMA engine
+  *     @arg ETH_DMATxDesc_IC  : Interrupt on completion
+  *     @arg ETH_DMATxDesc_LS  : Last Segment
+  *     @arg ETH_DMATxDesc_FS  : First Segment
+  *     @arg ETH_DMATxDesc_DC  : Disable CRC
+  *     @arg ETH_DMATxDesc_DP  : Disable Pad
+  *     @arg ETH_DMATxDesc_TTSE: Transmit Time Stamp Enable
+  *     @arg ETH_DMATxDesc_CIC : Checksum insertion control      
+  *     @arg ETH_DMATxDesc_TER : Transmit End of Ring
+  *     @arg ETH_DMATxDesc_TCH : Second Address Chained
+  *     @arg ETH_DMATxDesc_TTSS: Tx Time Stamp Status
+  *     @arg ETH_DMATxDesc_IHE : IP Header Error
+  *     @arg ETH_DMATxDesc_ES  : Error summary
+  *     @arg ETH_DMATxDesc_JT  : Jabber Timeout
+  *     @arg ETH_DMATxDesc_FF  : Frame Flushed: DMA/MTL flushed the frame due to SW flush
+  *     @arg ETH_DMATxDesc_PCE : Payload Checksum Error
+  *     @arg ETH_DMATxDesc_LCA : Loss of Carrier: carrier lost during transmission
+  *     @arg ETH_DMATxDesc_NC  : No Carrier: no carrier signal from the transceiver
+  *     @arg ETH_DMATxDesc_LCO : Late Collision: transmission aborted due to collision
+  *     @arg ETH_DMATxDesc_EC  : Excessive Collision: transmission aborted after 16 collisions
+  *     @arg ETH_DMATxDesc_VF  : VLAN Frame
+  *     @arg ETH_DMATxDesc_CC  : Collision Count 
+  *     @arg ETH_DMATxDesc_ED  : Excessive Deferral
+  *     @arg ETH_DMATxDesc_UF  : Underflow Error: late data arrival from the memory
+  *     @arg ETH_DMATxDesc_DB  : Deferred Bit
+  * @retval The new state of ETH_DMATxDescFlag (SET or RESET).
+  */
+FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag));
+  
+  if ((DMATxDesc->Status & ETH_DMATxDescFlag) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Returns the specified ETHERNET DMA Tx Desc collision count.
+  * @param  DMATxDesc: pointer on a DMA Tx descriptor                     
+  * @retval The Transmit descriptor collision counter value.
+  */
+uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
+{
+  /* Return the Receive descriptor frame length */
+  return ((DMATxDesc->Status & ETH_DMATxDesc_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT);
+}
+
+/**
+  * @brief  Set the specified DMA Tx Desc Own bit.
+  * @param  DMATxDesc: Pointer on a Tx desc
+  * @retval None
+  */
+void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc)
+{
+  /* Set the DMA Tx Desc Own bit */
+  DMATxDesc->Status |= ETH_DMATxDesc_OWN;
+}
+
+/**
+  * @brief  Enables or disables the specified DMA Tx Desc Transmit interrupt.
+  * @param  DMATxDesc: Pointer on a Tx desc
+  * @param  NewState: new state of the DMA Tx Desc transmit interrupt.
+  *   This parameter can be: ENABLE or DISABLE.                   
+  * @retval None
+  */
+void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA Tx Desc Transmit interrupt */
+    DMATxDesc->Status |= ETH_DMATxDesc_IC;
+  }
+  else
+  {
+    /* Disable the DMA Tx Desc Transmit interrupt */
+    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_IC);
+  }
+}
+
+/**
+  * @brief  configure Tx descriptor as last or first segment
+  * @param  DMATxDesc: Pointer on a Tx desc
+  * @param  DMATxDesc_FrameSegment: specifies is the actual Tx desc contain last or first segment.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_DMATxDesc_LastSegment  : actual Tx desc contain last segment 
+  *     @arg ETH_DMATxDesc_FirstSegment : actual Tx desc contain first segment                   
+  * @retval None
+  */
+void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment));
+  
+  /* Selects the DMA Tx Desc Frame segment */
+  DMATxDesc->Status |= DMATxDesc_FrameSegment;
+}
+
+/**
+  * @brief  Selects the specified ETHERNET DMA Tx Desc Checksum Insertion.
+  * @param  DMATxDesc: pointer on a DMA Tx descriptor 
+  * @param  DMATxDesc_Checksum: specifies is the DMA Tx desc checksum insertion.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_DMATxDesc_ChecksumByPass : Checksum bypass
+  *     @arg ETH_DMATxDesc_ChecksumIPV4Header : IPv4 header checksum
+  *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPSegment : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present
+  *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPFull : TCP/UDP/ICMP checksum fully in hardware including pseudo header                                                                
+  * @retval None
+  */
+void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
+  
+  /* Set the selected DMA Tx desc checksum insertion control */
+  DMATxDesc->Status |= DMATxDesc_Checksum;
+}
+
+/**
+  * @brief  Enables or disables the DMA Tx Desc CRC.
+  * @param  DMATxDesc: pointer on a DMA Tx descriptor
+  * @param  NewState: new state of the specified DMA Tx Desc CRC.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMA Tx Desc CRC */
+    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
+  }
+  else
+  {
+    /* Disable the selected DMA Tx Desc CRC */
+    DMATxDesc->Status |= ETH_DMATxDesc_DC; 
+  }
+}
+
+
+/**
+  * @brief  Enables or disables the DMA Tx Desc second address chained.
+  * @param  DMATxDesc: pointer on a DMA Tx descriptor
+  * @param  NewState: new state of the specified DMA Tx Desc second address chained.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMA Tx Desc second address chained */
+    DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
+  }
+  else
+  {
+    /* Disable the selected DMA Tx Desc second address chained */
+    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TCH); 
+  }
+}
+
+/**
+  * @brief  Enables or disables the DMA Tx Desc padding for frame shorter than 64 bytes.
+  * @param  DMATxDesc: pointer on a DMA Tx descriptor
+  * @param  NewState: new state of the specified DMA Tx Desc padding for frame shorter than 64 bytes.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
+    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
+  }
+  else
+  {
+    /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/
+    DMATxDesc->Status |= ETH_DMATxDesc_DP; 
+  }
+}
+
+
+/**
+  * @brief  Configures the specified DMA Tx Desc buffer1 and buffer2 sizes.
+  * @param  DMATxDesc: Pointer on a Tx desc
+  * @param  BufferSize1: specifies the Tx desc buffer1 size.
+  * @param  BufferSize2: specifies the Tx desc buffer2 size (put "0" if not used).
+  * @retval None
+  */
+void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
+  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));
+  
+  /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */
+  DMATxDesc->ControlBufferSize |= (BufferSize1 | (BufferSize2 << ETH_DMATXDESC_BUFFER2_SIZESHIFT));
+}
+
+
+/**
+  * @brief  Checks whether the specified ETHERNET Rx Desc flag is set or not.
+  * @param  DMARxDesc: pointer on a DMA Rx descriptor
+  * @param  ETH_DMARxDescFlag: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_DMARxDesc_OWN:         OWN bit: descriptor is owned by DMA engine 
+  *     @arg ETH_DMARxDesc_AFM:         DA Filter Fail for the rx frame
+  *     @arg ETH_DMARxDesc_ES:          Error summary
+  *     @arg ETH_DMARxDesc_DE:          Descriptor error: no more descriptors for receive frame
+  *     @arg ETH_DMARxDesc_SAF:         SA Filter Fail for the received frame
+  *     @arg ETH_DMARxDesc_LE:          Frame size not matching with length field
+  *     @arg ETH_DMARxDesc_OE:          Overflow Error: Frame was damaged due to buffer overflow
+  *     @arg ETH_DMARxDesc_VLAN:        VLAN Tag: received frame is a VLAN frame
+  *     @arg ETH_DMARxDesc_FS:          First descriptor of the frame
+  *     @arg ETH_DMARxDesc_LS:          Last descriptor of the frame
+  *     @arg ETH_DMARxDesc_IPV4HCE:     IPC Checksum Error/Giant Frame: Rx Ipv4 header checksum error 
+  *     @arg ETH_DMARxDesc_LC:          Late collision occurred during reception
+  *     @arg ETH_DMARxDesc_FT:          Frame type - Ethernet, otherwise 802.3
+  *     @arg ETH_DMARxDesc_RWT:         Receive Watchdog Timeout: watchdog timer expired during reception
+  *     @arg ETH_DMARxDesc_RE:          Receive error: error reported by MII interface
+  *     @arg ETH_DMARxDesc_DE:          Dribble bit error: frame contains non int multiple of 8 bits
+  *     @arg ETH_DMARxDesc_CE:          CRC error
+  *     @arg ETH_DMARxDesc_MAMPCE:      Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error
+  * @retval The new state of ETH_DMARxDescFlag (SET or RESET).
+  */
+FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag));
+  if ((DMARxDesc->Status & ETH_DMARxDescFlag) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+#ifdef USE_ENHANCED_DMA_DESCRIPTORS
+/**
+  * @brief  Checks whether the specified ETHERNET PTP Rx Desc extended flag is set or not.
+  * @param  DMAPTPRxDesc: pointer on a DMA PTP Rx descriptor
+  * @param  ETH_DMAPTPRxDescFlag: specifies the extended flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_DMAPTPRxDesc_PTPV:   PTP version  
+  *     @arg ETH_DMAPTPRxDesc_PTPFT:  PTP frame type
+  *     @arg ETH_DMAPTPRxDesc_PTPMT:  PTP message type   
+  *     @arg ETH_DMAPTPRxDesc_IPV6PR: IPv6 packet received   
+  *     @arg ETH_DMAPTPRxDesc_IPV4PR: IPv4 packet received    
+  *     @arg ETH_DMAPTPRxDesc_IPCB:   IP checksum bypassed  
+  *     @arg ETH_DMAPTPRxDesc_IPPE:   IP payload error
+  *     @arg ETH_DMAPTPRxDesc_IPHE:   IP header error 
+  *     @arg ETH_DMAPTPRxDesc_IPPT:   IP payload type 
+  * @retval The new state of ETH_DMAPTPRxDescExtendedFlag (SET or RESET).
+  */
+FlagStatus ETH_GetDMAPTPRxDescExtendedFlagStatus(ETH_DMADESCTypeDef *DMAPTPRxDesc, uint32_t ETH_DMAPTPRxDescExtendedFlag)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_ETH_DMAPTPRxDESC_GET_EXTENDED_FLAG(ETH_DMAPTPRxDescExtendedFlag));
+
+  if ((DMAPTPRxDesc->ExtendedStatus & ETH_DMAPTPRxDescExtendedFlag) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+#endif /* USE_ENHANCED_DMA_DESCRIPTORS */
+
+/**
+  * @brief  Set the specified DMA Rx Desc Own bit.
+  * @param  DMARxDesc: Pointer on a Rx desc
+  * @retval None
+  */
+void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
+{
+  /* Set the DMA Rx Desc Own bit */
+  DMARxDesc->Status |= ETH_DMARxDesc_OWN;
+}
+
+/**
+  * @brief  Returns the specified DMA Rx Desc frame length.
+  * @param  DMARxDesc: pointer on a DMA Rx descriptor                     
+  * @retval The Rx descriptor received frame length.
+  */
+uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
+{
+  /* Return the Receive descriptor frame length */
+  return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
+}
+
+/**
+  * @brief  Enables or disables the specified DMA Rx Desc receive interrupt.
+  * @param  DMARxDesc: Pointer on a Rx desc
+  * @param  NewState: new state of the specified DMA Rx Desc interrupt.
+  *   This parameter can be: ENABLE or DISABLE.                   
+  * @retval None
+  */
+void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA Rx Desc receive interrupt */
+    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
+  }
+  else
+  {
+    /* Disable the DMA Rx Desc receive interrupt */
+    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_DIC;
+  }
+}
+
+
+/**
+  * @brief  Returns the specified ETHERNET DMA Rx Desc buffer size.
+  * @param  DMARxDesc: pointer on a DMA Rx descriptor 
+  * @param  DMARxDesc_Buffer: specifies the DMA Rx Desc buffer.
+  *   This parameter can be any one of the following values:
+  *     @arg ETH_DMARxDesc_Buffer1 : DMA Rx Desc Buffer1
+  *     @arg ETH_DMARxDesc_Buffer2 : DMA Rx Desc Buffer2                     
+  * @retval The Receive descriptor frame length.
+  */
+uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
+  
+  if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
+  {
+    /* Return the DMA Rx Desc buffer2 size */
+    return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
+  }
+  else
+  {
+    /* Return the DMA Rx Desc buffer1 size */
+    return (DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS1); 
+  }
+}
+
+
+/**
+  * @brief  Get the size of the received packet.
+  * @param  None
+  * @retval framelength: received packet size 
+  */
+uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc)
+{
+  uint32_t frameLength = 0;
+  if(((DMARxDesc->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
+     ((DMARxDesc->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
+     ((DMARxDesc->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
+  {
+    /* Get the size of the packet: including 4 bytes of the CRC */
+    frameLength =  ETH_GetDMARxDescFrameLength(DMARxDesc);
+  }
+  
+  /* Return Frame Length */ 
+  return frameLength;
+}
+
+#ifdef USE_ENHANCED_DMA_DESCRIPTORS
+/**
+  * @brief  Enables or disables the Enhanced descriptor structure.
+  * @param  NewState: new state of the Enhanced descriptor structure.
+  *   This parameter can be: ENABLE or DISABLE. 
+  * @retval None
+  */
+void ETH_EnhancedDescriptorCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable enhanced descriptor structure */
+    ETH->DMABMR |= ETH_DMABMR_EDE;  
+  }
+  else
+  {
+    /* Disable enhanced descriptor structure */
+    ETH->DMABMR &= ~ETH_DMABMR_EDE;
+  }
+}
+#endif /* USE_ENHANCED_DMA_DESCRIPTORS */
+
+/******************************************************************************/                             
+/*                           DMA functions                                    */
+/******************************************************************************/
+/**
+  * @brief  Resets all MAC subsystem internal registers and logic.
+  * @param  None
+  * @retval None
+  */
+void ETH_SoftwareReset(void)
+{
+  /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
+  /* After reset all the registers holds their respective reset values */
+  ETH->DMABMR |= ETH_DMABMR_SR;
+}
+
+/**
+  * @brief  Checks whether the ETHERNET software reset bit is set or not.
+  * @param  None
+  * @retval The new state of DMA Bus Mode register SR bit (SET or RESET).
+  */
+FlagStatus ETH_GetSoftwareResetStatus(void)
+{
+  FlagStatus bitstatus = RESET;
+  if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Checks whether the specified ETHERNET DMA flag is set or not.
+  * @param  ETH_DMA_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_DMA_FLAG_TST : Time-stamp trigger flag
+  *     @arg ETH_DMA_FLAG_PMT : PMT flag 
+  *     @arg ETH_DMA_FLAG_MMC : MMC flag 
+  *     @arg ETH_DMA_FLAG_DataTransferError : Error bits 0-data buffer, 1-desc. access
+  *     @arg ETH_DMA_FLAG_ReadWriteError    : Error bits 0-write trnsf, 1-read transfr
+  *     @arg ETH_DMA_FLAG_AccessError       : Error bits 0-Rx DMA, 1-Tx DMA
+  *     @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag
+  *     @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag  
+  *     @arg ETH_DMA_FLAG_ER  : Early receive flag 
+  *     @arg ETH_DMA_FLAG_FBE : Fatal bus error flag 
+  *     @arg ETH_DMA_FLAG_ET  : Early transmit flag 
+  *     @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag 
+  *     @arg ETH_DMA_FLAG_RPS : Receive process stopped flag 
+  *     @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag 
+  *     @arg ETH_DMA_FLAG_R   : Receive flag 
+  *     @arg ETH_DMA_FLAG_TU  : Underflow flag 
+  *     @arg ETH_DMA_FLAG_RO  : Overflow flag 
+  *     @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag 
+  *     @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag 
+  *     @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag 
+  *     @arg ETH_DMA_FLAG_T   : Transmit flag 
+  * @retval The new state of ETH_DMA_FLAG (SET or RESET).
+  */
+FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG)
+{  
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG));
+  if ((ETH->DMASR & ETH_DMA_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the ETHERNET?DMA pending flag.
+  * @param  ETH_DMA_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg ETH_DMA_FLAG_NIS : Normal interrupt summary flag
+  *     @arg ETH_DMA_FLAG_AIS : Abnormal interrupt summary flag 
+  *     @arg ETH_DMA_FLAG_ER  : Early receive flag 
+  *     @arg ETH_DMA_FLAG_FBE : Fatal bus error flag 
+  *     @arg ETH_DMA_FLAG_ETI : Early transmit flag 
+  *     @arg ETH_DMA_FLAG_RWT : Receive watchdog timeout flag 
+  *     @arg ETH_DMA_FLAG_RPS : Receive process stopped flag 
+  *     @arg ETH_DMA_FLAG_RBU : Receive buffer unavailable flag 
+  *     @arg ETH_DMA_FLAG_R   : Receive flag 
+  *     @arg ETH_DMA_FLAG_TU  : Transmit Underflow flag 
+  *     @arg ETH_DMA_FLAG_RO  : Receive Overflow flag 
+  *     @arg ETH_DMA_FLAG_TJT : Transmit jabber timeout flag 
+  *     @arg ETH_DMA_FLAG_TBU : Transmit buffer unavailable flag 
+  *     @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag 
+  *     @arg ETH_DMA_FLAG_T   : Transmit flag
+  * @retval None
+  */
+void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG));
+  
+  /* Clear the selected ETHERNET DMA FLAG */
+  ETH->DMASR = (uint32_t) ETH_DMA_FLAG;
+}
+
+/**
+  * @brief  Enables or disables the specified ETHERNET DMA interrupts.
+  * @param  ETH_DMA_IT: specifies the ETHERNET DMA interrupt sources to be
+  *   enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg ETH_DMA_IT_NIS : Normal interrupt summary 
+  *     @arg ETH_DMA_IT_AIS : Abnormal interrupt summary  
+  *     @arg ETH_DMA_IT_ER  : Early receive interrupt 
+  *     @arg ETH_DMA_IT_FBE : Fatal bus error interrupt 
+  *     @arg ETH_DMA_IT_ET  : Early transmit interrupt 
+  *     @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt 
+  *     @arg ETH_DMA_IT_RPS : Receive process stopped interrupt 
+  *     @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt 
+  *     @arg ETH_DMA_IT_R   : Receive interrupt 
+  *     @arg ETH_DMA_IT_TU  : Underflow interrupt 
+  *     @arg ETH_DMA_IT_RO  : Overflow interrupt 
+  *     @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt 
+  *     @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt 
+  *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
+  *     @arg ETH_DMA_IT_T   : Transmit interrupt
+  * @param  NewState: new state of the specified ETHERNET DMA interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));  
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ETHERNET DMA interrupts */
+    ETH->DMAIER |= ETH_DMA_IT;
+  }
+  else
+  {
+    /* Disable the selected ETHERNET DMA interrupts */
+    ETH->DMAIER &=(~(uint32_t)ETH_DMA_IT);
+  }
+}
+
+/**
+  * @brief  Checks whether the specified ETHERNET DMA interrupt has occurred or not.
+  * @param  ETH_DMA_IT: specifies the interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_DMA_IT_TST : Time-stamp trigger interrupt
+  *     @arg ETH_DMA_IT_PMT : PMT interrupt 
+  *     @arg ETH_DMA_IT_MMC : MMC interrupt
+  *     @arg ETH_DMA_IT_NIS : Normal interrupt summary 
+  *     @arg ETH_DMA_IT_AIS : Abnormal interrupt summary  
+  *     @arg ETH_DMA_IT_ER  : Early receive interrupt 
+  *     @arg ETH_DMA_IT_FBE : Fatal bus error interrupt 
+  *     @arg ETH_DMA_IT_ET  : Early transmit interrupt 
+  *     @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt 
+  *     @arg ETH_DMA_IT_RPS : Receive process stopped interrupt 
+  *     @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt 
+  *     @arg ETH_DMA_IT_R   : Receive interrupt 
+  *     @arg ETH_DMA_IT_TU  : Underflow interrupt 
+  *     @arg ETH_DMA_IT_RO  : Overflow interrupt 
+  *     @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt 
+  *     @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt 
+  *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
+  *     @arg ETH_DMA_IT_T   : Transmit interrupt 
+  * @retval The new state of ETH_DMA_IT (SET or RESET).
+  */
+ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
+{  
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT));
+  if ((ETH->DMASR & ETH_DMA_IT) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the ETHERNET?DMA IT pending bit.
+  * @param  ETH_DMA_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg ETH_DMA_IT_NIS : Normal interrupt summary 
+  *     @arg ETH_DMA_IT_AIS : Abnormal interrupt summary  
+  *     @arg ETH_DMA_IT_ER  : Early receive interrupt 
+  *     @arg ETH_DMA_IT_FBE : Fatal bus error interrupt 
+  *     @arg ETH_DMA_IT_ETI : Early transmit interrupt 
+  *     @arg ETH_DMA_IT_RWT : Receive watchdog timeout interrupt 
+  *     @arg ETH_DMA_IT_RPS : Receive process stopped interrupt 
+  *     @arg ETH_DMA_IT_RBU : Receive buffer unavailable interrupt 
+  *     @arg ETH_DMA_IT_R   : Receive interrupt 
+  *     @arg ETH_DMA_IT_TU  : Transmit Underflow interrupt 
+  *     @arg ETH_DMA_IT_RO  : Receive Overflow interrupt 
+  *     @arg ETH_DMA_IT_TJT : Transmit jabber timeout interrupt 
+  *     @arg ETH_DMA_IT_TBU : Transmit buffer unavailable interrupt 
+  *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
+  *     @arg ETH_DMA_IT_T   : Transmit interrupt
+  * @retval None
+  */
+void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
+  
+  /* Clear the selected ETHERNET DMA IT */
+  ETH->DMASR = (uint32_t) ETH_DMA_IT;
+}
+
+/**
+  * @brief  Returns the ETHERNET DMA Transmit Process State.
+  * @param  None
+  * @retval The new ETHERNET DMA Transmit Process State:
+  *   This can be one of the following values:
+  *     - ETH_DMA_TransmitProcess_Stopped   : Stopped - Reset or Stop Tx Command issued
+  *     - ETH_DMA_TransmitProcess_Fetching  : Running - fetching the Tx descriptor 
+  *     - ETH_DMA_TransmitProcess_Waiting   : Running - waiting for status
+  *     - ETH_DMA_TransmitProcess_Reading   : Running - reading the data from host memory
+  *     - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Descriptor unavailable
+  *     - ETH_DMA_TransmitProcess_Closing   : Running - closing Rx descriptor  
+  */
+uint32_t ETH_GetTransmitProcessState(void)
+{
+  return ((uint32_t)(ETH->DMASR & ETH_DMASR_TS)); 
+}
+
+/**
+  * @brief  Returns the ETHERNET DMA Receive Process State.
+  * @param  None
+  * @retval The new ETHERNET DMA Receive Process State:
+  *   This can be one of the following values:
+  *     - ETH_DMA_ReceiveProcess_Stopped   : Stopped - Reset or Stop Rx Command issued
+  *     - ETH_DMA_ReceiveProcess_Fetching  : Running - fetching the Rx descriptor 
+  *     - ETH_DMA_ReceiveProcess_Waiting   : Running - waiting for packet
+  *     - ETH_DMA_ReceiveProcess_Suspended : Suspended - Rx Descriptor unavailable
+  *     - ETH_DMA_ReceiveProcess_Closing   : Running - closing descriptor
+  *     - ETH_DMA_ReceiveProcess_Queuing   : Running - queuing the receive frame into host memory  
+  */
+uint32_t ETH_GetReceiveProcessState(void)
+{
+  return ((uint32_t)(ETH->DMASR & ETH_DMASR_RS)); 
+}
+
+/**
+  * @brief  Clears the ETHERNET transmit FIFO.
+  * @param  None                
+  * @retval None
+  */
+void ETH_FlushTransmitFIFO(void)
+{
+  /* Set the Flush Transmit FIFO bit */
+  ETH->DMAOMR |= ETH_DMAOMR_FTF;  
+}
+
+/**
+  * @brief  Checks whether the ETHERNET flush transmit FIFO bit is cleared or not.
+  * @param  None                
+  * @retval The new state of ETHERNET flush transmit FIFO bit (SET or RESET).
+  */
+FlagStatus ETH_GetFlushTransmitFIFOStatus(void)
+{   
+  FlagStatus bitstatus = RESET;
+  if ((ETH->DMAOMR & ETH_DMAOMR_FTF) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus; 
+}
+
+/**
+  * @brief  Enables or disables the DMA transmission.
+  * @param  NewState: new state of the DMA transmission.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_DMATransmissionCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA transmission */
+    ETH->DMAOMR |= ETH_DMAOMR_ST;  
+  }
+  else
+  {
+    /* Disable the DMA transmission */
+    ETH->DMAOMR &= ~ETH_DMAOMR_ST;
+  }
+}
+
+/**
+  * @brief  Enables or disables the DMA reception.
+  * @param  NewState: new state of the DMA reception.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_DMAReceptionCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA reception */
+    ETH->DMAOMR |= ETH_DMAOMR_SR;  
+  }
+  else
+  {
+    /* Disable the DMA reception */
+    ETH->DMAOMR &= ~ETH_DMAOMR_SR;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified ETHERNET DMA overflow flag is set or not.
+  * @param  ETH_DMA_Overflow: specifies the DMA overflow flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_DMA_Overflow_RxFIFOCounter : Overflow for FIFO Overflows Counter
+  *     @arg ETH_DMA_Overflow_MissedFrameCounter : Overflow for Buffer Unavailable Missed Frame Counter
+  * @retval The new state of ETHERNET DMA overflow Flag (SET or RESET).
+  */
+FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow));
+  
+  if ((ETH->DMAMFBOCR & ETH_DMA_Overflow) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Get the ETHERNET DMA Rx Overflow Missed Frame Counter value.
+  * @param  None
+  * @retval The value of Rx overflow Missed Frame Counter.
+  */
+uint32_t ETH_GetRxOverflowMissedFrameCounter(void)
+{
+  return ((uint32_t)((ETH->DMAMFBOCR & ETH_DMAMFBOCR_MFA)>>ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
+}
+
+/**
+  * @brief  Get the ETHERNET DMA Buffer Unavailable Missed Frame Counter value.
+  * @param  None
+  * @retval The value of Buffer unavailable Missed Frame Counter.
+  */
+uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void)
+{
+  return ((uint32_t)(ETH->DMAMFBOCR) & ETH_DMAMFBOCR_MFC);
+}
+
+/**
+  * @brief  Get the ETHERNET DMA DMACHTDR register value.
+  * @param  None
+  * @retval The value of the current Tx desc start address.
+  */
+uint32_t ETH_GetCurrentTxDescStartAddress(void)
+{
+  return ((uint32_t)(ETH->DMACHTDR));
+}
+
+/**
+  * @brief  Get the ETHERNET DMA DMACHRDR register value.
+  * @param  None
+  * @retval The value of the current Rx desc start address.
+  */
+uint32_t ETH_GetCurrentRxDescStartAddress(void)
+{
+  return ((uint32_t)(ETH->DMACHRDR));
+}
+
+/**
+  * @brief  Get the ETHERNET DMA DMACHTBAR register value.
+  * @param  None
+  * @retval The value of the current transmit descriptor data buffer address.
+  */
+uint32_t ETH_GetCurrentTxBufferAddress(void)
+{
+  return ((uint32_t)(ETH->DMACHTBAR));
+}
+
+/**
+  * @brief  Get the ETHERNET DMA DMACHRBAR register value.
+  * @param  None
+  * @retval The value of the current receive descriptor data buffer address.
+  */
+uint32_t ETH_GetCurrentRxBufferAddress(void)
+{
+  return ((uint32_t)(ETH->DMACHRBAR));
+}
+
+/**
+  * @brief  Resumes the DMA Transmission by writing to the DmaTxPollDemand register
+  *   (the data written could be anything). This forces  the DMA to resume transmission.
+  * @param  None
+  * @retval None.
+  */
+void ETH_ResumeDMATransmission(void)
+{
+  ETH->DMATPDR = 0;
+}
+
+/**
+  * @brief  Resumes the DMA Transmission by writing to the DmaRxPollDemand register
+  *   (the data written could be anything). This forces the DMA to resume reception.
+  * @param  None
+  * @retval None.
+  */
+void ETH_ResumeDMAReception(void)
+{
+  ETH->DMARPDR = 0;
+}
+
+/**
+  * @brief  Set the DMA Receive status watchdog timer register value
+  * @param  Value: DMA Receive status watchdog timer register value   
+  * @retval None
+  */
+void ETH_SetReceiveWatchdogTimer(uint8_t Value)
+{
+  /* Set the DMA Receive status watchdog timer register */
+  ETH->DMARSWTR = Value;
+}
+
+/******************************************************************************/                             
+/*                                PHY functions                               */
+/******************************************************************************/
+
+/**
+  * @brief  Read a PHY register
+  * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. 
+  *   This parameter can be one of the following values: 0,..,31                  
+  * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. 
+  *   This parameter can be one of the following values: 
+  *     @arg PHY_BCR: Transceiver Basic Control Register 
+  *     @arg PHY_BSR: Transceiver Basic Status Register 
+  *     @arg PHY_SR : Transceiver Status Register    
+  *     @arg More PHY register could be read depending on the used PHY
+  * @retval ETH_ERROR: in case of timeout
+  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
+  */
+uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
+{
+  uint32_t tmpreg = 0;     
+__IO uint32_t timeout = 0;
+  /* Check the parameters */
+  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
+  assert_param(IS_ETH_PHY_REG(PHYReg));
+  
+  /* Get the ETHERNET MACMIIAR value */
+  tmpreg = ETH->MACMIIAR;
+  /* Keep only the CSR Clock Range CR[2:0] bits value */
+  tmpreg &= ~MACMIIAR_CR_MASK;
+  /* Prepare the MII address register value */
+  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
+  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
+  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
+  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
+  /* Write the result value into the MII Address register */
+  ETH->MACMIIAR = tmpreg;
+  /* Check for the Busy flag */
+  do
+  {
+    timeout++;
+    tmpreg = ETH->MACMIIAR;
+  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
+  /* Return ERROR in case of timeout */
+  if(timeout == PHY_READ_TO)
+  {
+    return (uint16_t)ETH_ERROR;
+  }
+  
+  /* Return data register value */
+  return (uint16_t)(ETH->MACMIIDR);
+}
+
+/**
+  * @brief  Write to a PHY register
+  * @param PHYAddress: PHY device address, is the index of one of supported 32 PHY devices. 
+  *   This parameter can be one of the following values: 0,..,31
+  * @param PHYReg: PHY register address, is the index of one of the 32 PHY register. 
+  *   This parameter can be one of the following values: 
+  *     @arg PHY_BCR    : Transceiver Control Register  
+  *     @arg More PHY register could be written depending on the used PHY
+  * @param  PHYValue: the value to write
+  * @retval ETH_ERROR: in case of timeout
+  *         ETH_SUCCESS: for correct write
+  */
+uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
+{
+  uint32_t tmpreg = 0;     
+  __IO uint32_t timeout = 0;
+  /* Check the parameters */
+  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
+  assert_param(IS_ETH_PHY_REG(PHYReg));
+  
+  /* Get the ETHERNET MACMIIAR value */
+  tmpreg = ETH->MACMIIAR;
+  /* Keep only the CSR Clock Range CR[2:0] bits value */
+  tmpreg &= ~MACMIIAR_CR_MASK;
+  /* Prepare the MII register address value */
+  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
+  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
+  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
+  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
+  /* Give the value to the MII data register */
+  ETH->MACMIIDR = PHYValue;
+  /* Write the result value into the MII Address register */
+  ETH->MACMIIAR = tmpreg;
+  /* Check for the Busy flag */
+  do
+  {
+    timeout++;
+    tmpreg = ETH->MACMIIAR;
+  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
+  /* Return ERROR in case of timeout */
+  if(timeout == PHY_WRITE_TO)
+  {
+    return ETH_ERROR;
+  }
+  
+  /* Return SUCCESS */
+  return ETH_SUCCESS;  
+}
+
+/**
+  * @brief  Enables or disables the PHY loopBack mode.
+  * @Note: Don't be confused with ETH_MACLoopBackCmd function which enables internal
+  *  loopback at MII level
+  * @param  PHYAddress: PHY device address, is the index of one of supported 32 PHY devices.                   
+  * @param  NewState: new state of the PHY loopBack mode.
+  *   This parameter can be: ENABLE or DISABLE.    
+  * @retval ETH_ERROR: in case of bad PHY configuration
+  *         ETH_SUCCESS: for correct PHY configuration
+  */
+uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
+{
+  uint16_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  /* Get the PHY configuration to update it */
+  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the PHY loopback mode */
+    tmpreg |= PHY_Loopback;  
+  }
+  else
+  {
+    /* Disable the PHY loopback mode: normal mode */
+    tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
+  }
+  /* Update the PHY control register with the new configuration */
+  if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
+  {
+    return ETH_SUCCESS;
+  }
+  else
+  {
+    /* Return SUCCESS */
+    return ETH_ERROR; 
+  }   
+} 
+
+/******************************************************************************/                             
+/*                           Power Management(PMT) functions                  */
+/******************************************************************************/    
+/**
+  * @brief  Reset Wakeup frame filter register pointer.
+  * @param  None
+  * @retval None
+  */
+void ETH_ResetWakeUpFrameFilterRegisterPointer(void)
+{  
+  /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */
+  ETH->MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;  
+}
+
+/**
+  * @brief  Populates the remote wakeup frame registers.
+  * @param  Buffer: Pointer on remote WakeUp Frame Filter Register buffer data (8 words).
+  * @retval None
+  */
+void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
+{
+  uint32_t i = 0;
+  
+  /* Fill Remote Wake-up Frame Filter register with Buffer data */
+  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
+  {
+    /* Write each time to the same register */ 
+    ETH->MACRWUFFR = Buffer[i];
+  }
+}
+
+/**
+  * @brief  Enables or disables any unicast packet filtered by the MAC address
+  *   recognition to be a wake-up frame.
+  * @param  NewState: new state of the MAC Global Unicast Wake-Up.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the MAC Global Unicast Wake-Up */
+    ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;  
+  }
+  else
+  {
+    /* Disable the MAC Global Unicast Wake-Up */ 
+    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_GU;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified ETHERNET PMT flag is set or not.
+  * @param  ETH_PMT_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_PMT_FLAG_WUFFRPR : Wake-Up Frame Filter Register Pointer Reset 
+  *     @arg ETH_PMT_FLAG_WUFR    : Wake-Up Frame Received 
+  *     @arg ETH_PMT_FLAG_MPR     : Magic Packet Received
+  * @retval The new state of ETHERNET PMT Flag (SET or RESET).
+  */
+FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG));
+  
+  if ((ETH->MACPMTCSR & ETH_PMT_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Enables or disables the MAC Wake-Up Frame Detection.
+  * @param  NewState: new state of the MAC Wake-Up Frame Detection.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the MAC Wake-Up Frame Detection */
+    ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;  
+  }
+  else
+  {
+    /* Disable the MAC Wake-Up Frame Detection */ 
+    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_WFE;
+  }
+}
+
+/**
+  * @brief  Enables or disables the MAC Magic Packet Detection.
+  * @param  NewState: new state of the MAC Magic Packet Detection.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_MagicPacketDetectionCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the MAC Magic Packet Detection */
+    ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;  
+  }
+  else
+  {
+    /* Disable the MAC Magic Packet Detection */ 
+    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_MPE;
+  }
+}
+
+/**
+  * @brief  Enables or disables the MAC Power Down.
+  * @param  NewState: new state of the MAC Power Down.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_PowerDownCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the MAC Power Down */
+    /* This puts the MAC in power down mode */
+    ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;  
+  }
+  else
+  {
+    /* Disable the MAC Power Down */ 
+    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_PD;
+  }
+} 
+
+/******************************************************************************/                             
+/*                              MMC functions                                 */
+/******************************************************************************/                            
+/**
+  * @brief  Preset and Initialize the MMC counters to almost-full value: 0xFFFF_FFF0 (full - 16)   
+  * @param  None
+  * @retval None
+  */
+void ETH_MMCCounterFullPreset(void)
+{
+  /* Preset and Initialize the MMC counters to almost-full value */
+  ETH->MMCCR |= ETH_MMCCR_MCFHP | ETH_MMCCR_MCP;
+}
+
+/**
+  * @brief  Preset and Initialize the MMC counters to almost-hal value: 0x7FFF_FFF0 (half - 16). 
+  * @param  None
+  * @retval None
+  */
+void ETH_MMCCounterHalfPreset(void)
+{
+  /* Preset the MMC counters to almost-full value */
+  ETH->MMCCR &= ~ETH_MMCCR_MCFHP;
+  /* Initialize the MMC counters to almost-half value */
+  ETH->MMCCR |= ETH_MMCCR_MCP;
+}
+
+ /**
+  * @brief  Enables or disables the MMC Counter Freeze.
+  * @param  NewState: new state of the MMC Counter Freeze.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_MMCCounterFreezeCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the MMC Counter Freeze */
+    ETH->MMCCR |= ETH_MMCCR_MCF;
+  }
+  else
+  {
+    /* Disable the MMC Counter Freeze */
+    ETH->MMCCR &= ~ETH_MMCCR_MCF;
+  }
+}
+
+/**
+  * @brief  Enables or disables the MMC Reset On Read.
+  * @param  NewState: new state of the MMC Reset On Read.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_MMCResetOnReadCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the MMC Counter reset on read */
+    ETH->MMCCR |= ETH_MMCCR_ROR; 
+  }
+  else
+  {
+    /* Disable the MMC Counter reset on read */
+    ETH->MMCCR &= ~ETH_MMCCR_ROR;
+  }
+}
+
+/**
+  * @brief  Enables or disables the MMC Counter Stop Rollover.
+  * @param  NewState: new state of the MMC Counter Stop Rollover.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_MMCCounterRolloverCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Disable the MMC Counter Stop Rollover  */
+    ETH->MMCCR &= ~ETH_MMCCR_CSR;
+  }
+  else
+  {
+    /* Enable the MMC Counter Stop Rollover */
+    ETH->MMCCR |= ETH_MMCCR_CSR; 
+  }
+}
+
+/**
+  * @brief  Resets the MMC Counters.
+  * @param  None
+  * @retval None
+  */
+void ETH_MMCCountersReset(void)
+{
+  /* Resets the MMC Counters */
+  ETH->MMCCR |= ETH_MMCCR_CR; 
+}
+
+/**
+  * @brief  Enables or disables the specified ETHERNET MMC interrupts.
+  * @param  ETH_MMC_IT: specifies the ETHERNET MMC interrupt sources to be enabled or disabled.
+  *   This parameter can be any combination of Tx interrupt or 
+  *   any combination of Rx interrupt (but not both)of the following values: 
+  *     @arg ETH_MMC_IT_TGF   : When Tx good frame counter reaches half the maximum value 
+  *     @arg ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value 
+  *     @arg ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value 
+  *     @arg ETH_MMC_IT_RGUF  : When Rx good unicast frames counter reaches half the maximum value  
+  *     @arg ETH_MMC_IT_RFAE  : When Rx alignment error counter reaches half the maximum value 
+  *     @arg ETH_MMC_IT_RFCE  : When Rx crc error counter reaches half the maximum value
+  * @param  NewState: new state of the specified ETHERNET MMC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_ETH_MMC_IT(ETH_MMC_IT));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+   
+  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
+  {
+    /* Remove Register mak from IT */
+    ETH_MMC_IT &= 0xEFFFFFFF;
+  
+    /* ETHERNET MMC Rx interrupts selected */
+    if (NewState != DISABLE)
+    {
+      /* Enable the selected ETHERNET MMC interrupts */
+      ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
+    }
+    else
+    {
+      /* Disable the selected ETHERNET MMC interrupts */
+      ETH->MMCRIMR |= ETH_MMC_IT;    
+    }
+  }
+  else
+  {
+    /* ETHERNET MMC Tx interrupts selected */
+    if (NewState != DISABLE)
+    {
+      /* Enable the selected ETHERNET MMC interrupts */
+      ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
+    }
+    else
+    {
+      /* Disable the selected ETHERNET MMC interrupts */
+      ETH->MMCTIMR |= ETH_MMC_IT;    
+    }  
+  }
+}
+
+/**
+  * @brief  Checks whether the specified ETHERNET MMC IT is set or not.
+  * @param  ETH_MMC_IT: specifies the ETHERNET MMC interrupt.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_MMC_IT_TxFCGC: When Tx good frame counter reaches half the maximum value 
+  *     @arg ETH_MMC_IT_TxMCGC: When Tx good multi col counter reaches half the maximum value 
+  *     @arg ETH_MMC_IT_TxSCGC: When Tx good single col counter reaches half the maximum value 
+  *     @arg ETH_MMC_IT_RxUGFC: When Rx good unicast frames counter reaches half the maximum value  
+  *     @arg ETH_MMC_IT_RxAEC : When Rx alignment error counter reaches half the maximum value 
+  *     @arg ETH_MMC_IT_RxCEC : When Rx crc error counter reaches half the maximum value 
+  * @retval The value of ETHERNET MMC IT (SET or RESET).
+  */
+ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT)
+{
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); 
+  
+  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
+  {
+    /* ETHERNET MMC Rx interrupts selected */
+    /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occurred */ 
+    if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
+    {
+      bitstatus = SET;
+    }
+    else
+    {
+      bitstatus = RESET;
+    }
+  }
+  else
+  {
+    /* ETHERNET MMC Tx interrupts selected */
+    /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occurred */  
+    if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
+    {
+      bitstatus = SET;
+    }
+    else
+    {
+      bitstatus = RESET;
+    }  
+  }    
+    
+  return bitstatus;
+}
+
+/**
+  * @brief  Get the specified ETHERNET MMC register value.
+  * @param  ETH_MMCReg: specifies the ETHERNET MMC register.
+  *   This parameter can be one of the following values:
+  *     @arg ETH_MMCCR      : MMC CR register 
+  *     @arg ETH_MMCRIR     : MMC RIR register 
+  *     @arg ETH_MMCTIR     : MMC TIR register 
+  *     @arg ETH_MMCRIMR    : MMC RIMR register 
+  *     @arg ETH_MMCTIMR    : MMC TIMR register 
+  *     @arg ETH_MMCTGFSCCR : MMC TGFSCCR register 
+  *     @arg ETH_MMCTGFMSCCR: MMC TGFMSCCR register  
+  *     @arg ETH_MMCTGFCR   : MMC TGFCR register
+  *     @arg ETH_MMCRFCECR  : MMC RFCECR register 
+  *     @arg ETH_MMCRFAECR  : MMC RFAECR register 
+  *     @arg ETH_MMCRGUFCR  : MMC RGUFCRregister 
+  * @retval The value of ETHERNET MMC Register value.
+  */
+uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg)
+{
+  /* Check the parameters */
+  assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));
+  
+  /* Return the selected register value */
+  return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
+}
+
+
+                                                   
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/misc.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/misc.h
new file mode 100644
index 0000000..1e39f18
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/misc.h
@@ -0,0 +1,178 @@
+/**
+  ******************************************************************************
+  * @file    misc.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the miscellaneous
+  *          firmware library functions (add-on to CMSIS functions).
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __MISC_H
+#define __MISC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup MISC
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  NVIC Init Structure definition  
+  */
+
+typedef struct
+{
+  uint8_t NVIC_IRQChannel;                    /*!< Specifies the IRQ channel to be enabled or disabled.
+                                                   This parameter can be an enumerator of @ref IRQn_Type 
+                                                   enumeration (For the complete STM32 Devices IRQ Channels
+                                                   list, please refer to stm32f4xx.h file) */
+
+  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!< Specifies the pre-emption priority for the IRQ channel
+                                                   specified in NVIC_IRQChannel. This parameter can be a value
+                                                   between 0 and 15 as described in the table @ref MISC_NVIC_Priority_Table
+                                                   A lower priority value indicates a higher priority */
+
+  uint8_t NVIC_IRQChannelSubPriority;         /*!< Specifies the subpriority level for the IRQ channel specified
+                                                   in NVIC_IRQChannel. This parameter can be a value
+                                                   between 0 and 15 as described in the table @ref MISC_NVIC_Priority_Table
+                                                   A lower priority value indicates a higher priority */
+
+  FunctionalState NVIC_IRQChannelCmd;         /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel
+                                                   will be enabled or disabled. 
+                                                   This parameter can be set either to ENABLE or DISABLE */   
+} NVIC_InitTypeDef;
+ 
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup MISC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup MISC_Vector_Table_Base 
+  * @{
+  */
+
+#define NVIC_VectTab_RAM             ((uint32_t)0x20000000)
+#define NVIC_VectTab_FLASH           ((uint32_t)0x08000000)
+#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
+                                  ((VECTTAB) == NVIC_VectTab_FLASH))
+/**
+  * @}
+  */
+
+/** @defgroup MISC_System_Low_Power 
+  * @{
+  */
+
+#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)
+#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)
+#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)
+#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
+                        ((LP) == NVIC_LP_SLEEPDEEP) || \
+                        ((LP) == NVIC_LP_SLEEPONEXIT))
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Preemption_Priority_Group 
+  * @{
+  */
+
+#define NVIC_PriorityGroup_0         ((uint32_t)0x700) /*!< 0 bits for pre-emption priority
+                                                            4 bits for subpriority */
+#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!< 1 bits for pre-emption priority
+                                                            3 bits for subpriority */
+#define NVIC_PriorityGroup_2         ((uint32_t)0x500) /*!< 2 bits for pre-emption priority
+                                                            2 bits for subpriority */
+#define NVIC_PriorityGroup_3         ((uint32_t)0x400) /*!< 3 bits for pre-emption priority
+                                                            1 bits for subpriority */
+#define NVIC_PriorityGroup_4         ((uint32_t)0x300) /*!< 4 bits for pre-emption priority
+                                                            0 bits for subpriority */
+
+#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
+                                       ((GROUP) == NVIC_PriorityGroup_1) || \
+                                       ((GROUP) == NVIC_PriorityGroup_2) || \
+                                       ((GROUP) == NVIC_PriorityGroup_3) || \
+                                       ((GROUP) == NVIC_PriorityGroup_4))
+
+#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
+
+#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
+
+#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x000FFFFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_SysTick_clock_source 
+  * @{
+  */
+
+#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)
+#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)
+#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
+                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+
+void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);
+void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
+void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);
+void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
+void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __MISC_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_adc.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_adc.h
new file mode 100644
index 0000000..1d6ea02
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_adc.h
@@ -0,0 +1,656 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_adc.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the ADC firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_ADC_H
+#define __STM32F4xx_ADC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup ADC
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief   ADC Init structure definition  
+  */ 
+typedef struct
+{
+  uint32_t ADC_Resolution;                /*!< Configures the ADC resolution dual mode. 
+                                               This parameter can be a value of @ref ADC_resolution */                                   
+  FunctionalState ADC_ScanConvMode;       /*!< Specifies whether the conversion 
+                                               is performed in Scan (multichannels) 
+                                               or Single (one channel) mode.
+                                               This parameter can be set to ENABLE or DISABLE */ 
+  FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion 
+                                               is performed in Continuous or Single mode.
+                                               This parameter can be set to ENABLE or DISABLE. */
+  uint32_t ADC_ExternalTrigConvEdge;      /*!< Select the external trigger edge and
+                                               enable the trigger of a regular group. 
+                                               This parameter can be a value of 
+                                               @ref ADC_external_trigger_edge_for_regular_channels_conversion */
+  uint32_t ADC_ExternalTrigConv;          /*!< Select the external event used to trigger 
+                                               the start of conversion of a regular group.
+                                               This parameter can be a value of 
+                                               @ref ADC_extrenal_trigger_sources_for_regular_channels_conversion */
+  uint32_t ADC_DataAlign;                 /*!< Specifies whether the ADC data  alignment
+                                               is left or right. This parameter can be 
+                                               a value of @ref ADC_data_align */
+  uint8_t  ADC_NbrOfConversion;           /*!< Specifies the number of ADC conversions
+                                               that will be done using the sequencer for
+                                               regular channel group.
+                                               This parameter must range from 1 to 16. */
+}ADC_InitTypeDef;
+  
+/** 
+  * @brief   ADC Common Init structure definition  
+  */ 
+typedef struct 
+{
+  uint32_t ADC_Mode;                      /*!< Configures the ADC to operate in 
+                                               independent or multi mode. 
+                                               This parameter can be a value of @ref ADC_Common_mode */                                              
+  uint32_t ADC_Prescaler;                 /*!< Select the frequency of the clock 
+                                               to the ADC. The clock is common for all the ADCs.
+                                               This parameter can be a value of @ref ADC_Prescaler */
+  uint32_t ADC_DMAAccessMode;             /*!< Configures the Direct memory access 
+                                              mode for multi ADC mode.
+                                               This parameter can be a value of 
+                                               @ref ADC_Direct_memory_access_mode_for_multi_mode */
+  uint32_t ADC_TwoSamplingDelay;          /*!< Configures the Delay between 2 sampling phases.
+                                               This parameter can be a value of 
+                                               @ref ADC_delay_between_2_sampling_phases */
+  
+}ADC_CommonInitTypeDef;
+
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup ADC_Exported_Constants
+  * @{
+  */ 
+#define IS_ADC_ALL_PERIPH(PERIPH) (((PERIPH) == ADC1) || \
+                                   ((PERIPH) == ADC2) || \
+                                   ((PERIPH) == ADC3))  
+
+/** @defgroup ADC_Common_mode 
+  * @{
+  */ 
+#define ADC_Mode_Independent                       ((uint32_t)0x00000000)       
+#define ADC_DualMode_RegSimult_InjecSimult         ((uint32_t)0x00000001)
+#define ADC_DualMode_RegSimult_AlterTrig           ((uint32_t)0x00000002)
+#define ADC_DualMode_InjecSimult                   ((uint32_t)0x00000005)
+#define ADC_DualMode_RegSimult                     ((uint32_t)0x00000006)
+#define ADC_DualMode_Interl                        ((uint32_t)0x00000007)
+#define ADC_DualMode_AlterTrig                     ((uint32_t)0x00000009)
+#define ADC_TripleMode_RegSimult_InjecSimult       ((uint32_t)0x00000011)
+#define ADC_TripleMode_RegSimult_AlterTrig         ((uint32_t)0x00000012)
+#define ADC_TripleMode_InjecSimult                 ((uint32_t)0x00000015)
+#define ADC_TripleMode_RegSimult                   ((uint32_t)0x00000016)
+#define ADC_TripleMode_Interl                      ((uint32_t)0x00000017)
+#define ADC_TripleMode_AlterTrig                   ((uint32_t)0x00000019)
+#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \
+                           ((MODE) == ADC_DualMode_RegSimult_InjecSimult) || \
+                           ((MODE) == ADC_DualMode_RegSimult_AlterTrig) || \
+                           ((MODE) == ADC_DualMode_InjecSimult) || \
+                           ((MODE) == ADC_DualMode_RegSimult) || \
+                           ((MODE) == ADC_DualMode_Interl) || \
+                           ((MODE) == ADC_DualMode_AlterTrig) || \
+                           ((MODE) == ADC_TripleMode_RegSimult_InjecSimult) || \
+                           ((MODE) == ADC_TripleMode_RegSimult_AlterTrig) || \
+                           ((MODE) == ADC_TripleMode_InjecSimult) || \
+                           ((MODE) == ADC_TripleMode_RegSimult) || \
+                           ((MODE) == ADC_TripleMode_Interl) || \
+                           ((MODE) == ADC_TripleMode_AlterTrig))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_Prescaler 
+  * @{
+  */ 
+#define ADC_Prescaler_Div2                         ((uint32_t)0x00000000)
+#define ADC_Prescaler_Div4                         ((uint32_t)0x00010000)
+#define ADC_Prescaler_Div6                         ((uint32_t)0x00020000)
+#define ADC_Prescaler_Div8                         ((uint32_t)0x00030000)
+#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_Div2) || \
+                                     ((PRESCALER) == ADC_Prescaler_Div4) || \
+                                     ((PRESCALER) == ADC_Prescaler_Div6) || \
+                                     ((PRESCALER) == ADC_Prescaler_Div8))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_Direct_memory_access_mode_for_multi_mode 
+  * @{
+  */ 
+#define ADC_DMAAccessMode_Disabled      ((uint32_t)0x00000000)     /* DMA mode disabled */
+#define ADC_DMAAccessMode_1             ((uint32_t)0x00004000)     /* DMA mode 1 enabled (2 / 3 half-words one by one - 1 then 2 then 3)*/
+#define ADC_DMAAccessMode_2             ((uint32_t)0x00008000)     /* DMA mode 2 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)*/
+#define ADC_DMAAccessMode_3             ((uint32_t)0x0000C000)     /* DMA mode 3 enabled (2 / 3 bytes by pairs - 2&1 then 1&3 then 3&2) */
+#define IS_ADC_DMA_ACCESS_MODE(MODE) (((MODE) == ADC_DMAAccessMode_Disabled) || \
+                                      ((MODE) == ADC_DMAAccessMode_1) || \
+                                      ((MODE) == ADC_DMAAccessMode_2) || \
+                                      ((MODE) == ADC_DMAAccessMode_3))
+                                     
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_delay_between_2_sampling_phases 
+  * @{
+  */ 
+#define ADC_TwoSamplingDelay_5Cycles               ((uint32_t)0x00000000)
+#define ADC_TwoSamplingDelay_6Cycles               ((uint32_t)0x00000100)
+#define ADC_TwoSamplingDelay_7Cycles               ((uint32_t)0x00000200)
+#define ADC_TwoSamplingDelay_8Cycles               ((uint32_t)0x00000300)
+#define ADC_TwoSamplingDelay_9Cycles               ((uint32_t)0x00000400)
+#define ADC_TwoSamplingDelay_10Cycles              ((uint32_t)0x00000500)
+#define ADC_TwoSamplingDelay_11Cycles              ((uint32_t)0x00000600)
+#define ADC_TwoSamplingDelay_12Cycles              ((uint32_t)0x00000700)
+#define ADC_TwoSamplingDelay_13Cycles              ((uint32_t)0x00000800)
+#define ADC_TwoSamplingDelay_14Cycles              ((uint32_t)0x00000900)
+#define ADC_TwoSamplingDelay_15Cycles              ((uint32_t)0x00000A00)
+#define ADC_TwoSamplingDelay_16Cycles              ((uint32_t)0x00000B00)
+#define ADC_TwoSamplingDelay_17Cycles              ((uint32_t)0x00000C00)
+#define ADC_TwoSamplingDelay_18Cycles              ((uint32_t)0x00000D00)
+#define ADC_TwoSamplingDelay_19Cycles              ((uint32_t)0x00000E00)
+#define ADC_TwoSamplingDelay_20Cycles              ((uint32_t)0x00000F00)
+#define IS_ADC_SAMPLING_DELAY(DELAY) (((DELAY) == ADC_TwoSamplingDelay_5Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_6Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_7Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_8Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_9Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_10Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_11Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_12Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_13Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_14Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_15Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_16Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_17Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_18Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_19Cycles) || \
+                                      ((DELAY) == ADC_TwoSamplingDelay_20Cycles))
+                                     
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_resolution 
+  * @{
+  */ 
+#define ADC_Resolution_12b                         ((uint32_t)0x00000000)
+#define ADC_Resolution_10b                         ((uint32_t)0x01000000)
+#define ADC_Resolution_8b                          ((uint32_t)0x02000000)
+#define ADC_Resolution_6b                          ((uint32_t)0x03000000)
+#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) || \
+                                       ((RESOLUTION) == ADC_Resolution_10b) || \
+                                       ((RESOLUTION) == ADC_Resolution_8b) || \
+                                       ((RESOLUTION) == ADC_Resolution_6b))
+                                      
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_external_trigger_edge_for_regular_channels_conversion 
+  * @{
+  */ 
+#define ADC_ExternalTrigConvEdge_None          ((uint32_t)0x00000000)
+#define ADC_ExternalTrigConvEdge_Rising        ((uint32_t)0x10000000)
+#define ADC_ExternalTrigConvEdge_Falling       ((uint32_t)0x20000000)
+#define ADC_ExternalTrigConvEdge_RisingFalling ((uint32_t)0x30000000)
+#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) || \
+                             ((EDGE) == ADC_ExternalTrigConvEdge_Rising) || \
+                             ((EDGE) == ADC_ExternalTrigConvEdge_Falling) || \
+                             ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_extrenal_trigger_sources_for_regular_channels_conversion 
+  * @{
+  */ 
+#define ADC_ExternalTrigConv_T1_CC1                ((uint32_t)0x00000000)
+#define ADC_ExternalTrigConv_T1_CC2                ((uint32_t)0x01000000)
+#define ADC_ExternalTrigConv_T1_CC3                ((uint32_t)0x02000000)
+#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x03000000)
+#define ADC_ExternalTrigConv_T2_CC3                ((uint32_t)0x04000000)
+#define ADC_ExternalTrigConv_T2_CC4                ((uint32_t)0x05000000)
+#define ADC_ExternalTrigConv_T2_TRGO               ((uint32_t)0x06000000)
+#define ADC_ExternalTrigConv_T3_CC1                ((uint32_t)0x07000000)
+#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)0x08000000)
+#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x09000000)
+#define ADC_ExternalTrigConv_T5_CC1                ((uint32_t)0x0A000000)
+#define ADC_ExternalTrigConv_T5_CC2                ((uint32_t)0x0B000000)
+#define ADC_ExternalTrigConv_T5_CC3                ((uint32_t)0x0C000000)
+#define ADC_ExternalTrigConv_T8_CC1                ((uint32_t)0x0D000000)
+#define ADC_ExternalTrigConv_T8_TRGO               ((uint32_t)0x0E000000)
+#define ADC_ExternalTrigConv_Ext_IT11              ((uint32_t)0x0F000000)
+#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC4) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_TRGO) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC2) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_data_align 
+  * @{
+  */ 
+#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
+#define ADC_DataAlign_Left                         ((uint32_t)0x00000800)
+#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
+                                  ((ALIGN) == ADC_DataAlign_Left))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_channels 
+  * @{
+  */ 
+#define ADC_Channel_0                               ((uint8_t)0x00)
+#define ADC_Channel_1                               ((uint8_t)0x01)
+#define ADC_Channel_2                               ((uint8_t)0x02)
+#define ADC_Channel_3                               ((uint8_t)0x03)
+#define ADC_Channel_4                               ((uint8_t)0x04)
+#define ADC_Channel_5                               ((uint8_t)0x05)
+#define ADC_Channel_6                               ((uint8_t)0x06)
+#define ADC_Channel_7                               ((uint8_t)0x07)
+#define ADC_Channel_8                               ((uint8_t)0x08)
+#define ADC_Channel_9                               ((uint8_t)0x09)
+#define ADC_Channel_10                              ((uint8_t)0x0A)
+#define ADC_Channel_11                              ((uint8_t)0x0B)
+#define ADC_Channel_12                              ((uint8_t)0x0C)
+#define ADC_Channel_13                              ((uint8_t)0x0D)
+#define ADC_Channel_14                              ((uint8_t)0x0E)
+#define ADC_Channel_15                              ((uint8_t)0x0F)
+#define ADC_Channel_16                              ((uint8_t)0x10)
+#define ADC_Channel_17                              ((uint8_t)0x11)
+#define ADC_Channel_18                              ((uint8_t)0x12)
+
+#if defined (STM32F40_41xxx)
+#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_16)
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx) || defined (STM32F401xx) || defined (STM32F411xE)
+#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_18)
+#endif /* STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
+
+#define ADC_Channel_Vrefint                         ((uint8_t)ADC_Channel_17)
+#define ADC_Channel_Vbat                            ((uint8_t)ADC_Channel_18)
+
+#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || \
+                                 ((CHANNEL) == ADC_Channel_1) || \
+                                 ((CHANNEL) == ADC_Channel_2) || \
+                                 ((CHANNEL) == ADC_Channel_3) || \
+                                 ((CHANNEL) == ADC_Channel_4) || \
+                                 ((CHANNEL) == ADC_Channel_5) || \
+                                 ((CHANNEL) == ADC_Channel_6) || \
+                                 ((CHANNEL) == ADC_Channel_7) || \
+                                 ((CHANNEL) == ADC_Channel_8) || \
+                                 ((CHANNEL) == ADC_Channel_9) || \
+                                 ((CHANNEL) == ADC_Channel_10) || \
+                                 ((CHANNEL) == ADC_Channel_11) || \
+                                 ((CHANNEL) == ADC_Channel_12) || \
+                                 ((CHANNEL) == ADC_Channel_13) || \
+                                 ((CHANNEL) == ADC_Channel_14) || \
+                                 ((CHANNEL) == ADC_Channel_15) || \
+                                 ((CHANNEL) == ADC_Channel_16) || \
+                                 ((CHANNEL) == ADC_Channel_17) || \
+                                 ((CHANNEL) == ADC_Channel_18))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_sampling_times 
+  * @{
+  */ 
+#define ADC_SampleTime_3Cycles                    ((uint8_t)0x00)
+#define ADC_SampleTime_15Cycles                   ((uint8_t)0x01)
+#define ADC_SampleTime_28Cycles                   ((uint8_t)0x02)
+#define ADC_SampleTime_56Cycles                   ((uint8_t)0x03)
+#define ADC_SampleTime_84Cycles                   ((uint8_t)0x04)
+#define ADC_SampleTime_112Cycles                  ((uint8_t)0x05)
+#define ADC_SampleTime_144Cycles                  ((uint8_t)0x06)
+#define ADC_SampleTime_480Cycles                  ((uint8_t)0x07)
+#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_3Cycles) || \
+                                  ((TIME) == ADC_SampleTime_15Cycles) || \
+                                  ((TIME) == ADC_SampleTime_28Cycles) || \
+                                  ((TIME) == ADC_SampleTime_56Cycles) || \
+                                  ((TIME) == ADC_SampleTime_84Cycles) || \
+                                  ((TIME) == ADC_SampleTime_112Cycles) || \
+                                  ((TIME) == ADC_SampleTime_144Cycles) || \
+                                  ((TIME) == ADC_SampleTime_480Cycles))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_external_trigger_edge_for_injected_channels_conversion 
+  * @{
+  */ 
+#define ADC_ExternalTrigInjecConvEdge_None          ((uint32_t)0x00000000)
+#define ADC_ExternalTrigInjecConvEdge_Rising        ((uint32_t)0x00100000)
+#define ADC_ExternalTrigInjecConvEdge_Falling       ((uint32_t)0x00200000)
+#define ADC_ExternalTrigInjecConvEdge_RisingFalling ((uint32_t)0x00300000)
+#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigInjecConvEdge_None) || \
+                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Rising) || \
+                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Falling) || \
+                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_RisingFalling))
+                                            
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_extrenal_trigger_sources_for_injected_channels_conversion 
+  * @{
+  */ 
+#define ADC_ExternalTrigInjecConv_T1_CC4            ((uint32_t)0x00000000)
+#define ADC_ExternalTrigInjecConv_T1_TRGO           ((uint32_t)0x00010000)
+#define ADC_ExternalTrigInjecConv_T2_CC1            ((uint32_t)0x00020000)
+#define ADC_ExternalTrigInjecConv_T2_TRGO           ((uint32_t)0x00030000)
+#define ADC_ExternalTrigInjecConv_T3_CC2            ((uint32_t)0x00040000)
+#define ADC_ExternalTrigInjecConv_T3_CC4            ((uint32_t)0x00050000)
+#define ADC_ExternalTrigInjecConv_T4_CC1            ((uint32_t)0x00060000)
+#define ADC_ExternalTrigInjecConv_T4_CC2            ((uint32_t)0x00070000)
+#define ADC_ExternalTrigInjecConv_T4_CC3            ((uint32_t)0x00080000)
+#define ADC_ExternalTrigInjecConv_T4_TRGO           ((uint32_t)0x00090000)
+#define ADC_ExternalTrigInjecConv_T5_CC4            ((uint32_t)0x000A0000)
+#define ADC_ExternalTrigInjecConv_T5_TRGO           ((uint32_t)0x000B0000)
+#define ADC_ExternalTrigInjecConv_T8_CC2            ((uint32_t)0x000C0000)
+#define ADC_ExternalTrigInjecConv_T8_CC3            ((uint32_t)0x000D0000)
+#define ADC_ExternalTrigInjecConv_T8_CC4            ((uint32_t)0x000E0000)
+#define ADC_ExternalTrigInjecConv_Ext_IT15          ((uint32_t)0x000F0000)
+#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC2) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC1) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC2) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC3) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_injected_channel_selection 
+  * @{
+  */ 
+#define ADC_InjectedChannel_1                       ((uint8_t)0x14)
+#define ADC_InjectedChannel_2                       ((uint8_t)0x18)
+#define ADC_InjectedChannel_3                       ((uint8_t)0x1C)
+#define ADC_InjectedChannel_4                       ((uint8_t)0x20)
+#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
+                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
+                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
+                                          ((CHANNEL) == ADC_InjectedChannel_4))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_analog_watchdog_selection 
+  * @{
+  */ 
+#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)
+#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)
+#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200)
+#define ADC_AnalogWatchdog_AllRegEnable            ((uint32_t)0x00800000)
+#define ADC_AnalogWatchdog_AllInjecEnable          ((uint32_t)0x00400000)
+#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)
+#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)
+#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_interrupts_definition 
+  * @{
+  */ 
+#define ADC_IT_EOC                                 ((uint16_t)0x0205)  
+#define ADC_IT_AWD                                 ((uint16_t)0x0106)  
+#define ADC_IT_JEOC                                ((uint16_t)0x0407)  
+#define ADC_IT_OVR                                 ((uint16_t)0x201A)  
+#define IS_ADC_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
+                       ((IT) == ADC_IT_JEOC)|| ((IT) == ADC_IT_OVR)) 
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_flags_definition 
+  * @{
+  */ 
+#define ADC_FLAG_AWD                               ((uint8_t)0x01)
+#define ADC_FLAG_EOC                               ((uint8_t)0x02)
+#define ADC_FLAG_JEOC                              ((uint8_t)0x04)
+#define ADC_FLAG_JSTRT                             ((uint8_t)0x08)
+#define ADC_FLAG_STRT                              ((uint8_t)0x10)
+#define ADC_FLAG_OVR                               ((uint8_t)0x20)   
+  
+#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint8_t)0xC0) == 0x00) && ((FLAG) != 0x00))   
+#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || \
+                               ((FLAG) == ADC_FLAG_EOC) || \
+                               ((FLAG) == ADC_FLAG_JEOC) || \
+                               ((FLAG)== ADC_FLAG_JSTRT) || \
+                               ((FLAG) == ADC_FLAG_STRT) || \
+                               ((FLAG)== ADC_FLAG_OVR))     
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_thresholds 
+  * @{
+  */ 
+#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_injected_offset 
+  * @{
+  */ 
+#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_injected_length 
+  * @{
+  */ 
+#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_injected_rank 
+  * @{
+  */ 
+#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_regular_length 
+  * @{
+  */ 
+#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_regular_rank 
+  * @{
+  */ 
+#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup ADC_regular_discontinuous_mode_number 
+  * @{
+  */ 
+#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
+/**
+  * @}
+  */ 
+
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/  
+
+/*  Function used to set the ADC configuration to the default reset state *****/  
+void ADC_DeInit(void);
+
+/* Initialization and Configuration functions *********************************/
+void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
+void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
+void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
+void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
+void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+
+/* Analog Watchdog configuration functions ************************************/
+void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);
+void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,uint16_t LowThreshold);
+void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);
+
+/* Temperature Sensor, Vrefint and VBAT management functions ******************/
+void ADC_TempSensorVrefintCmd(FunctionalState NewState);
+void ADC_VBATCmd(FunctionalState NewState);
+
+/* Regular Channels Configuration functions ***********************************/
+void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
+void ADC_SoftwareStartConv(ADC_TypeDef* ADCx);
+FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
+void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);
+void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
+uint32_t ADC_GetMultiModeConversionValue(void);
+
+/* Regular Channels DMA Configuration functions *******************************/
+void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState);
+
+/* Injected channels Configuration functions **********************************/
+void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
+void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);
+void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset);
+void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
+void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge);
+void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx);
+FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
+void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);
+
+/* Interrupts and flags management functions **********************************/
+void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
+FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
+void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
+ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);
+void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_ADC_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_can.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_can.h
new file mode 100644
index 0000000..5733ac7
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_can.h
@@ -0,0 +1,644 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_can.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the CAN firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_CAN_H
+#define __STM32F4xx_CAN_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup CAN
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) || \
+                                   ((PERIPH) == CAN2))
+
+/** 
+  * @brief  CAN init structure definition
+  */
+typedef struct
+{
+  uint16_t CAN_Prescaler;   /*!< Specifies the length of a time quantum. 
+                                 It ranges from 1 to 1024. */
+  
+  uint8_t CAN_Mode;         /*!< Specifies the CAN operating mode.
+                                 This parameter can be a value of @ref CAN_operating_mode */
+
+  uint8_t CAN_SJW;          /*!< Specifies the maximum number of time quanta 
+                                 the CAN hardware is allowed to lengthen or 
+                                 shorten a bit to perform resynchronization.
+                                 This parameter can be a value of @ref CAN_synchronisation_jump_width */
+
+  uint8_t CAN_BS1;          /*!< Specifies the number of time quanta in Bit 
+                                 Segment 1. This parameter can be a value of 
+                                 @ref CAN_time_quantum_in_bit_segment_1 */
+
+  uint8_t CAN_BS2;          /*!< Specifies the number of time quanta in Bit Segment 2.
+                                 This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_2 */
+  
+  FunctionalState CAN_TTCM; /*!< Enable or disable the time triggered communication mode.
+                                This parameter can be set either to ENABLE or DISABLE. */
+  
+  FunctionalState CAN_ABOM;  /*!< Enable or disable the automatic bus-off management.
+                                  This parameter can be set either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_AWUM;  /*!< Enable or disable the automatic wake-up mode. 
+                                  This parameter can be set either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_NART;  /*!< Enable or disable the non-automatic retransmission mode.
+                                  This parameter can be set either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_RFLM;  /*!< Enable or disable the Receive FIFO Locked mode.
+                                  This parameter can be set either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_TXFP;  /*!< Enable or disable the transmit FIFO priority.
+                                  This parameter can be set either to ENABLE or DISABLE. */
+} CAN_InitTypeDef;
+
+/** 
+  * @brief  CAN filter init structure definition
+  */
+typedef struct
+{
+  uint16_t CAN_FilterIdHigh;         /*!< Specifies the filter identification number (MSBs for a 32-bit
+                                              configuration, first one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterIdLow;          /*!< Specifies the filter identification number (LSBs for a 32-bit
+                                              configuration, second one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterMaskIdHigh;     /*!< Specifies the filter mask number or identification number,
+                                              according to the mode (MSBs for a 32-bit configuration,
+                                              first one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterMaskIdLow;      /*!< Specifies the filter mask number or identification number,
+                                              according to the mode (LSBs for a 32-bit configuration,
+                                              second one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterFIFOAssignment; /*!< Specifies the FIFO (0 or 1) which will be assigned to the filter.
+                                              This parameter can be a value of @ref CAN_filter_FIFO */
+  
+  uint8_t CAN_FilterNumber;          /*!< Specifies the filter which will be initialized. It ranges from 0 to 13. */
+
+  uint8_t CAN_FilterMode;            /*!< Specifies the filter mode to be initialized.
+                                              This parameter can be a value of @ref CAN_filter_mode */
+
+  uint8_t CAN_FilterScale;           /*!< Specifies the filter scale.
+                                              This parameter can be a value of @ref CAN_filter_scale */
+
+  FunctionalState CAN_FilterActivation; /*!< Enable or disable the filter.
+                                              This parameter can be set either to ENABLE or DISABLE. */
+} CAN_FilterInitTypeDef;
+
+/** 
+  * @brief  CAN Tx message structure definition  
+  */
+typedef struct
+{
+  uint32_t StdId;  /*!< Specifies the standard identifier.
+                        This parameter can be a value between 0 to 0x7FF. */
+
+  uint32_t ExtId;  /*!< Specifies the extended identifier.
+                        This parameter can be a value between 0 to 0x1FFFFFFF. */
+
+  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
+                        will be transmitted. This parameter can be a value 
+                        of @ref CAN_identifier_type */
+
+  uint8_t RTR;     /*!< Specifies the type of frame for the message that will 
+                        be transmitted. This parameter can be a value of 
+                        @ref CAN_remote_transmission_request */
+
+  uint8_t DLC;     /*!< Specifies the length of the frame that will be 
+                        transmitted. This parameter can be a value between 
+                        0 to 8 */
+
+  uint8_t Data[8]; /*!< Contains the data to be transmitted. It ranges from 0 
+                        to 0xFF. */
+} CanTxMsg;
+
+/** 
+  * @brief  CAN Rx message structure definition  
+  */
+typedef struct
+{
+  uint32_t StdId;  /*!< Specifies the standard identifier.
+                        This parameter can be a value between 0 to 0x7FF. */
+
+  uint32_t ExtId;  /*!< Specifies the extended identifier.
+                        This parameter can be a value between 0 to 0x1FFFFFFF. */
+
+  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
+                        will be received. This parameter can be a value of 
+                        @ref CAN_identifier_type */
+
+  uint8_t RTR;     /*!< Specifies the type of frame for the received message.
+                        This parameter can be a value of 
+                        @ref CAN_remote_transmission_request */
+
+  uint8_t DLC;     /*!< Specifies the length of the frame that will be received.
+                        This parameter can be a value between 0 to 8 */
+
+  uint8_t Data[8]; /*!< Contains the data to be received. It ranges from 0 to 
+                        0xFF. */
+
+  uint8_t FMI;     /*!< Specifies the index of the filter the message stored in 
+                        the mailbox passes through. This parameter can be a 
+                        value between 0 to 0xFF */
+} CanRxMsg;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup CAN_Exported_Constants
+  * @{
+  */
+
+/** @defgroup CAN_InitStatus 
+  * @{
+  */
+
+#define CAN_InitStatus_Failed              ((uint8_t)0x00) /*!< CAN initialization failed */
+#define CAN_InitStatus_Success             ((uint8_t)0x01) /*!< CAN initialization OK */
+
+
+/* Legacy defines */
+#define CANINITFAILED    CAN_InitStatus_Failed
+#define CANINITOK        CAN_InitStatus_Success
+/**
+  * @}
+  */
+
+/** @defgroup CAN_operating_mode 
+  * @{
+  */
+
+#define CAN_Mode_Normal             ((uint8_t)0x00)  /*!< normal mode */
+#define CAN_Mode_LoopBack           ((uint8_t)0x01)  /*!< loopback mode */
+#define CAN_Mode_Silent             ((uint8_t)0x02)  /*!< silent mode */
+#define CAN_Mode_Silent_LoopBack    ((uint8_t)0x03)  /*!< loopback combined with silent mode */
+
+#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || \
+                           ((MODE) == CAN_Mode_LoopBack)|| \
+                           ((MODE) == CAN_Mode_Silent) || \
+                           ((MODE) == CAN_Mode_Silent_LoopBack))
+/**
+  * @}
+  */
+
+
+ /**
+  * @defgroup CAN_operating_mode 
+  * @{
+  */  
+#define CAN_OperatingMode_Initialization  ((uint8_t)0x00) /*!< Initialization mode */
+#define CAN_OperatingMode_Normal          ((uint8_t)0x01) /*!< Normal mode */
+#define CAN_OperatingMode_Sleep           ((uint8_t)0x02) /*!< sleep mode */
+
+
+#define IS_CAN_OPERATING_MODE(MODE) (((MODE) == CAN_OperatingMode_Initialization) ||\
+                                    ((MODE) == CAN_OperatingMode_Normal)|| \
+																		((MODE) == CAN_OperatingMode_Sleep))
+/**
+  * @}
+  */
+  
+/**
+  * @defgroup CAN_operating_mode_status
+  * @{
+  */  
+
+#define CAN_ModeStatus_Failed    ((uint8_t)0x00)                /*!< CAN entering the specific mode failed */
+#define CAN_ModeStatus_Success   ((uint8_t)!CAN_ModeStatus_Failed)   /*!< CAN entering the specific mode Succeed */
+/**
+  * @}
+  */
+
+/** @defgroup CAN_synchronisation_jump_width 
+  * @{
+  */
+#define CAN_SJW_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
+#define CAN_SJW_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
+#define CAN_SJW_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
+#define CAN_SJW_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
+
+#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)|| \
+                         ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_time_quantum_in_bit_segment_1 
+  * @{
+  */
+#define CAN_BS1_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
+#define CAN_BS1_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
+#define CAN_BS1_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
+#define CAN_BS1_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
+#define CAN_BS1_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
+#define CAN_BS1_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
+#define CAN_BS1_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
+#define CAN_BS1_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
+#define CAN_BS1_9tq                 ((uint8_t)0x08)  /*!< 9 time quantum */
+#define CAN_BS1_10tq                ((uint8_t)0x09)  /*!< 10 time quantum */
+#define CAN_BS1_11tq                ((uint8_t)0x0A)  /*!< 11 time quantum */
+#define CAN_BS1_12tq                ((uint8_t)0x0B)  /*!< 12 time quantum */
+#define CAN_BS1_13tq                ((uint8_t)0x0C)  /*!< 13 time quantum */
+#define CAN_BS1_14tq                ((uint8_t)0x0D)  /*!< 14 time quantum */
+#define CAN_BS1_15tq                ((uint8_t)0x0E)  /*!< 15 time quantum */
+#define CAN_BS1_16tq                ((uint8_t)0x0F)  /*!< 16 time quantum */
+
+#define IS_CAN_BS1(BS1) ((BS1) <= CAN_BS1_16tq)
+/**
+  * @}
+  */
+
+/** @defgroup CAN_time_quantum_in_bit_segment_2 
+  * @{
+  */
+#define CAN_BS2_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
+#define CAN_BS2_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
+#define CAN_BS2_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
+#define CAN_BS2_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
+#define CAN_BS2_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
+#define CAN_BS2_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
+#define CAN_BS2_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
+#define CAN_BS2_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
+
+#define IS_CAN_BS2(BS2) ((BS2) <= CAN_BS2_8tq)
+/**
+  * @}
+  */
+
+/** @defgroup CAN_clock_prescaler 
+  * @{
+  */
+#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_filter_number 
+  * @{
+  */
+#define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 27)
+/**
+  * @}
+  */
+
+/** @defgroup CAN_filter_mode 
+  * @{
+  */
+#define CAN_FilterMode_IdMask       ((uint8_t)0x00)  /*!< identifier/mask mode */
+#define CAN_FilterMode_IdList       ((uint8_t)0x01)  /*!< identifier list mode */
+
+#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) || \
+                                  ((MODE) == CAN_FilterMode_IdList))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_filter_scale 
+  * @{
+  */
+#define CAN_FilterScale_16bit       ((uint8_t)0x00) /*!< Two 16-bit filters */
+#define CAN_FilterScale_32bit       ((uint8_t)0x01) /*!< One 32-bit filter */
+
+#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) || \
+                                    ((SCALE) == CAN_FilterScale_32bit))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_filter_FIFO
+  * @{
+  */
+#define CAN_Filter_FIFO0             ((uint8_t)0x00)  /*!< Filter FIFO 0 assignment for filter x */
+#define CAN_Filter_FIFO1             ((uint8_t)0x01)  /*!< Filter FIFO 1 assignment for filter x */
+#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) || \
+                                  ((FIFO) == CAN_FilterFIFO1))
+
+/* Legacy defines */
+#define CAN_FilterFIFO0  CAN_Filter_FIFO0
+#define CAN_FilterFIFO1  CAN_Filter_FIFO1
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Start_bank_filter_for_slave_CAN 
+  * @{
+  */
+#define IS_CAN_BANKNUMBER(BANKNUMBER) (((BANKNUMBER) >= 1) && ((BANKNUMBER) <= 27))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Tx 
+  * @{
+  */
+#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= ((uint8_t)0x02))
+#define IS_CAN_STDID(STDID)   ((STDID) <= ((uint32_t)0x7FF))
+#define IS_CAN_EXTID(EXTID)   ((EXTID) <= ((uint32_t)0x1FFFFFFF))
+#define IS_CAN_DLC(DLC)       ((DLC) <= ((uint8_t)0x08))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_identifier_type 
+  * @{
+  */
+#define CAN_Id_Standard             ((uint32_t)0x00000000)  /*!< Standard Id */
+#define CAN_Id_Extended             ((uint32_t)0x00000004)  /*!< Extended Id */
+#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_Id_Standard) || \
+                               ((IDTYPE) == CAN_Id_Extended))
+
+/* Legacy defines */
+#define CAN_ID_STD      CAN_Id_Standard           
+#define CAN_ID_EXT      CAN_Id_Extended
+/**
+  * @}
+  */
+
+/** @defgroup CAN_remote_transmission_request 
+  * @{
+  */
+#define CAN_RTR_Data                ((uint32_t)0x00000000)  /*!< Data frame */
+#define CAN_RTR_Remote              ((uint32_t)0x00000002)  /*!< Remote frame */
+#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_Data) || ((RTR) == CAN_RTR_Remote))
+
+/* Legacy defines */
+#define CAN_RTR_DATA     CAN_RTR_Data         
+#define CAN_RTR_REMOTE   CAN_RTR_Remote
+/**
+  * @}
+  */
+
+/** @defgroup CAN_transmit_constants 
+  * @{
+  */
+#define CAN_TxStatus_Failed         ((uint8_t)0x00)/*!< CAN transmission failed */
+#define CAN_TxStatus_Ok             ((uint8_t)0x01) /*!< CAN transmission succeeded */
+#define CAN_TxStatus_Pending        ((uint8_t)0x02) /*!< CAN transmission pending */
+#define CAN_TxStatus_NoMailBox      ((uint8_t)0x04) /*!< CAN cell did not provide 
+                                                         an empty mailbox */
+/* Legacy defines */	
+#define CANTXFAILED                  CAN_TxStatus_Failed
+#define CANTXOK                      CAN_TxStatus_Ok
+#define CANTXPENDING                 CAN_TxStatus_Pending
+#define CAN_NO_MB                    CAN_TxStatus_NoMailBox
+/**
+  * @}
+  */
+
+/** @defgroup CAN_receive_FIFO_number_constants 
+  * @{
+  */
+#define CAN_FIFO0                 ((uint8_t)0x00) /*!< CAN FIFO 0 used to receive */
+#define CAN_FIFO1                 ((uint8_t)0x01) /*!< CAN FIFO 1 used to receive */
+
+#define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_sleep_constants 
+  * @{
+  */
+#define CAN_Sleep_Failed     ((uint8_t)0x00) /*!< CAN did not enter the sleep mode */
+#define CAN_Sleep_Ok         ((uint8_t)0x01) /*!< CAN entered the sleep mode */
+
+/* Legacy defines */	
+#define CANSLEEPFAILED   CAN_Sleep_Failed
+#define CANSLEEPOK       CAN_Sleep_Ok
+/**
+  * @}
+  */
+
+/** @defgroup CAN_wake_up_constants 
+  * @{
+  */
+#define CAN_WakeUp_Failed        ((uint8_t)0x00) /*!< CAN did not leave the sleep mode */
+#define CAN_WakeUp_Ok            ((uint8_t)0x01) /*!< CAN leaved the sleep mode */
+
+/* Legacy defines */
+#define CANWAKEUPFAILED   CAN_WakeUp_Failed        
+#define CANWAKEUPOK       CAN_WakeUp_Ok        
+/**
+  * @}
+  */
+
+/**
+  * @defgroup CAN_Error_Code_constants
+  * @{
+  */                                                         
+#define CAN_ErrorCode_NoErr           ((uint8_t)0x00) /*!< No Error */ 
+#define	CAN_ErrorCode_StuffErr        ((uint8_t)0x10) /*!< Stuff Error */ 
+#define	CAN_ErrorCode_FormErr         ((uint8_t)0x20) /*!< Form Error */ 
+#define	CAN_ErrorCode_ACKErr          ((uint8_t)0x30) /*!< Acknowledgment Error */ 
+#define	CAN_ErrorCode_BitRecessiveErr ((uint8_t)0x40) /*!< Bit Recessive Error */ 
+#define	CAN_ErrorCode_BitDominantErr  ((uint8_t)0x50) /*!< Bit Dominant Error */ 
+#define	CAN_ErrorCode_CRCErr          ((uint8_t)0x60) /*!< CRC Error  */ 
+#define	CAN_ErrorCode_SoftwareSetErr  ((uint8_t)0x70) /*!< Software Set Error */ 
+/**
+  * @}
+  */
+
+/** @defgroup CAN_flags 
+  * @{
+  */
+/* If the flag is 0x3XXXXXXX, it means that it can be used with CAN_GetFlagStatus()
+   and CAN_ClearFlag() functions. */
+/* If the flag is 0x1XXXXXXX, it means that it can only be used with 
+   CAN_GetFlagStatus() function.  */
+
+/* Transmit Flags */
+#define CAN_FLAG_RQCP0             ((uint32_t)0x38000001) /*!< Request MailBox0 Flag */
+#define CAN_FLAG_RQCP1             ((uint32_t)0x38000100) /*!< Request MailBox1 Flag */
+#define CAN_FLAG_RQCP2             ((uint32_t)0x38010000) /*!< Request MailBox2 Flag */
+
+/* Receive Flags */
+#define CAN_FLAG_FMP0              ((uint32_t)0x12000003) /*!< FIFO 0 Message Pending Flag */
+#define CAN_FLAG_FF0               ((uint32_t)0x32000008) /*!< FIFO 0 Full Flag            */
+#define CAN_FLAG_FOV0              ((uint32_t)0x32000010) /*!< FIFO 0 Overrun Flag         */
+#define CAN_FLAG_FMP1              ((uint32_t)0x14000003) /*!< FIFO 1 Message Pending Flag */
+#define CAN_FLAG_FF1               ((uint32_t)0x34000008) /*!< FIFO 1 Full Flag            */
+#define CAN_FLAG_FOV1              ((uint32_t)0x34000010) /*!< FIFO 1 Overrun Flag         */
+
+/* Operating Mode Flags */
+#define CAN_FLAG_WKU               ((uint32_t)0x31000008) /*!< Wake up Flag */
+#define CAN_FLAG_SLAK              ((uint32_t)0x31000012) /*!< Sleep acknowledge Flag */
+/* @note When SLAK interrupt is disabled (SLKIE=0), no polling on SLAKI is possible. 
+         In this case the SLAK bit can be polled.*/
+
+/* Error Flags */
+#define CAN_FLAG_EWG               ((uint32_t)0x10F00001) /*!< Error Warning Flag   */
+#define CAN_FLAG_EPV               ((uint32_t)0x10F00002) /*!< Error Passive Flag   */
+#define CAN_FLAG_BOF               ((uint32_t)0x10F00004) /*!< Bus-Off Flag         */
+#define CAN_FLAG_LEC               ((uint32_t)0x30F00070) /*!< Last error code Flag */
+
+#define IS_CAN_GET_FLAG(FLAG) (((FLAG) == CAN_FLAG_LEC)  || ((FLAG) == CAN_FLAG_BOF)   || \
+                               ((FLAG) == CAN_FLAG_EPV)  || ((FLAG) == CAN_FLAG_EWG)   || \
+                               ((FLAG) == CAN_FLAG_WKU)  || ((FLAG) == CAN_FLAG_FOV0)  || \
+                               ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FMP0)  || \
+                               ((FLAG) == CAN_FLAG_FOV1) || ((FLAG) == CAN_FLAG_FF1)   || \
+                               ((FLAG) == CAN_FLAG_FMP1) || ((FLAG) == CAN_FLAG_RQCP2) || \
+                               ((FLAG) == CAN_FLAG_RQCP1)|| ((FLAG) == CAN_FLAG_RQCP0) || \
+                               ((FLAG) == CAN_FLAG_SLAK ))
+
+#define IS_CAN_CLEAR_FLAG(FLAG)(((FLAG) == CAN_FLAG_LEC) || ((FLAG) == CAN_FLAG_RQCP2) || \
+                                ((FLAG) == CAN_FLAG_RQCP1)  || ((FLAG) == CAN_FLAG_RQCP0) || \
+                                ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FOV0) ||\
+                                ((FLAG) == CAN_FLAG_FF1) || ((FLAG) == CAN_FLAG_FOV1) || \
+                                ((FLAG) == CAN_FLAG_WKU) || ((FLAG) == CAN_FLAG_SLAK))
+/**
+  * @}
+  */
+
+  
+/** @defgroup CAN_interrupts 
+  * @{
+  */ 
+#define CAN_IT_TME                  ((uint32_t)0x00000001) /*!< Transmit mailbox empty Interrupt*/
+
+/* Receive Interrupts */
+#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!< FIFO 0 message pending Interrupt*/
+#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!< FIFO 0 full Interrupt*/
+#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!< FIFO 0 overrun Interrupt*/
+#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/
+#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/
+#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/
+
+/* Operating Mode Interrupts */
+#define CAN_IT_WKU                  ((uint32_t)0x00010000) /*!< Wake-up Interrupt*/
+#define CAN_IT_SLK                  ((uint32_t)0x00020000) /*!< Sleep acknowledge Interrupt*/
+
+/* Error Interrupts */
+#define CAN_IT_EWG                  ((uint32_t)0x00000100) /*!< Error warning Interrupt*/
+#define CAN_IT_EPV                  ((uint32_t)0x00000200) /*!< Error passive Interrupt*/
+#define CAN_IT_BOF                  ((uint32_t)0x00000400) /*!< Bus-off Interrupt*/
+#define CAN_IT_LEC                  ((uint32_t)0x00000800) /*!< Last error code Interrupt*/
+#define CAN_IT_ERR                  ((uint32_t)0x00008000) /*!< Error Interrupt*/
+
+/* Flags named as Interrupts : kept only for FW compatibility */
+#define CAN_IT_RQCP0   CAN_IT_TME
+#define CAN_IT_RQCP1   CAN_IT_TME
+#define CAN_IT_RQCP2   CAN_IT_TME
+
+
+#define IS_CAN_IT(IT)        (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FMP0)  ||\
+                             ((IT) == CAN_IT_FF0)  || ((IT) == CAN_IT_FOV0)  ||\
+                             ((IT) == CAN_IT_FMP1) || ((IT) == CAN_IT_FF1)   ||\
+                             ((IT) == CAN_IT_FOV1) || ((IT) == CAN_IT_EWG)   ||\
+                             ((IT) == CAN_IT_EPV)  || ((IT) == CAN_IT_BOF)   ||\
+                             ((IT) == CAN_IT_LEC)  || ((IT) == CAN_IT_ERR)   ||\
+                             ((IT) == CAN_IT_WKU)  || ((IT) == CAN_IT_SLK))
+
+#define IS_CAN_CLEAR_IT(IT) (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FF0)    ||\
+                             ((IT) == CAN_IT_FOV0)|| ((IT) == CAN_IT_FF1)    ||\
+                             ((IT) == CAN_IT_FOV1)|| ((IT) == CAN_IT_EWG)    ||\
+                             ((IT) == CAN_IT_EPV) || ((IT) == CAN_IT_BOF)    ||\
+                             ((IT) == CAN_IT_LEC) || ((IT) == CAN_IT_ERR)    ||\
+                             ((IT) == CAN_IT_WKU) || ((IT) == CAN_IT_SLK))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/  
+
+/*  Function used to set the CAN configuration to the default reset state *****/ 
+void CAN_DeInit(CAN_TypeDef* CANx);
+
+/* Initialization and Configuration functions *********************************/ 
+uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct);
+void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct);
+void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct);
+void CAN_SlaveStartBank(uint8_t CAN_BankNumber); 
+void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState);
+void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState);
+
+/* CAN Frames Transmission functions ******************************************/
+uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage);
+uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox);
+void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox);
+
+/* CAN Frames Reception functions *********************************************/
+void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage);
+void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber);
+uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber);
+
+/* Operation modes functions **************************************************/
+uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode);
+uint8_t CAN_Sleep(CAN_TypeDef* CANx);
+uint8_t CAN_WakeUp(CAN_TypeDef* CANx);
+
+/* CAN Bus Error management functions *****************************************/
+uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx);
+uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx);
+uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx);
+
+/* Interrupts and flags management functions **********************************/
+void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState);
+FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
+void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
+ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT);
+void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_CAN_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_crc.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_crc.h
new file mode 100644
index 0000000..fb95193
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_crc.h
@@ -0,0 +1,83 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_crc.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the CRC firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_CRC_H
+#define __STM32F4xx_CRC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup CRC
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup CRC_Exported_Constants
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/  
+
+void CRC_ResetDR(void);
+uint32_t CRC_CalcCRC(uint32_t Data);
+uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);
+uint32_t CRC_GetCRC(void);
+void CRC_SetIDRegister(uint8_t IDValue);
+uint8_t CRC_GetIDRegister(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_CRC_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_cryp.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_cryp.h
new file mode 100644
index 0000000..110b7f3
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_cryp.h
@@ -0,0 +1,384 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_cryp.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the Cryptographic
+  *          processor(CRYP) firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_CRYP_H
+#define __STM32F4xx_CRYP_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup CRYP
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief   CRYP Init structure definition  
+  */ 
+typedef struct
+{
+  uint32_t CRYP_AlgoDir;   /*!< Encrypt or Decrypt. This parameter can be a 
+                                value of @ref CRYP_Algorithm_Direction */
+  uint32_t CRYP_AlgoMode;  /*!< TDES-ECB, TDES-CBC, DES-ECB, DES-CBC, AES-ECB, 
+                                AES-CBC, AES-CTR, AES-Key, AES-GCM and AES-CCM.
+                                This parameter can be a value of @ref CRYP_Algorithm_Mode */
+  uint32_t CRYP_DataType;  /*!< 32-bit data, 16-bit data, bit data or bit string.
+                                This parameter can be a value of @ref CRYP_Data_Type */ 
+  uint32_t CRYP_KeySize;   /*!< Used only in AES mode only : 128, 192 or 256 bit 
+                                key length. This parameter can be a value of 
+                                @ref CRYP_Key_Size_for_AES_only */
+}CRYP_InitTypeDef;
+
+/** 
+  * @brief   CRYP Key(s) structure definition  
+  */ 
+typedef struct
+{
+  uint32_t CRYP_Key0Left;  /*!< Key 0 Left  */
+  uint32_t CRYP_Key0Right; /*!< Key 0 Right */
+  uint32_t CRYP_Key1Left;  /*!< Key 1 left  */
+  uint32_t CRYP_Key1Right; /*!< Key 1 Right */
+  uint32_t CRYP_Key2Left;  /*!< Key 2 left  */
+  uint32_t CRYP_Key2Right; /*!< Key 2 Right */
+  uint32_t CRYP_Key3Left;  /*!< Key 3 left  */
+  uint32_t CRYP_Key3Right; /*!< Key 3 Right */
+}CRYP_KeyInitTypeDef;
+/** 
+  * @brief   CRYP Initialization Vectors (IV) structure definition  
+  */ 
+typedef struct
+{
+  uint32_t CRYP_IV0Left;  /*!< Init Vector 0 Left  */
+  uint32_t CRYP_IV0Right; /*!< Init Vector 0 Right */
+  uint32_t CRYP_IV1Left;  /*!< Init Vector 1 left  */
+  uint32_t CRYP_IV1Right; /*!< Init Vector 1 Right */
+}CRYP_IVInitTypeDef;
+
+/** 
+  * @brief  CRYP context swapping structure definition  
+  */ 
+typedef struct
+{
+  /*!< Current Configuration */
+  uint32_t CR_CurrentConfig;
+  /*!< IV */
+  uint32_t CRYP_IV0LR;
+  uint32_t CRYP_IV0RR;
+  uint32_t CRYP_IV1LR;
+  uint32_t CRYP_IV1RR;
+  /*!< KEY */
+  uint32_t CRYP_K0LR;
+  uint32_t CRYP_K0RR;
+  uint32_t CRYP_K1LR;
+  uint32_t CRYP_K1RR;
+  uint32_t CRYP_K2LR;
+  uint32_t CRYP_K2RR;
+  uint32_t CRYP_K3LR;
+  uint32_t CRYP_K3RR;
+  uint32_t CRYP_CSGCMCCMR[8];
+  uint32_t CRYP_CSGCMR[8];
+}CRYP_Context;
+
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup CRYP_Exported_Constants
+  * @{
+  */
+
+/** @defgroup CRYP_Algorithm_Direction 
+  * @{
+  */
+#define CRYP_AlgoDir_Encrypt      ((uint16_t)0x0000)
+#define CRYP_AlgoDir_Decrypt      ((uint16_t)0x0004)
+#define IS_CRYP_ALGODIR(ALGODIR) (((ALGODIR) == CRYP_AlgoDir_Encrypt) || \
+                                  ((ALGODIR) == CRYP_AlgoDir_Decrypt))
+
+/**
+  * @}
+  */ 
+ 
+/** @defgroup CRYP_Algorithm_Mode 
+  * @{
+  */
+
+/*!< TDES Modes */
+#define CRYP_AlgoMode_TDES_ECB    ((uint32_t)0x00000000)
+#define CRYP_AlgoMode_TDES_CBC    ((uint32_t)0x00000008)
+
+/*!< DES Modes */
+#define CRYP_AlgoMode_DES_ECB     ((uint32_t)0x00000010)
+#define CRYP_AlgoMode_DES_CBC     ((uint32_t)0x00000018)
+
+/*!< AES Modes */
+#define CRYP_AlgoMode_AES_ECB     ((uint32_t)0x00000020)
+#define CRYP_AlgoMode_AES_CBC     ((uint32_t)0x00000028)
+#define CRYP_AlgoMode_AES_CTR     ((uint32_t)0x00000030)
+#define CRYP_AlgoMode_AES_Key     ((uint32_t)0x00000038)
+#define CRYP_AlgoMode_AES_GCM     ((uint32_t)0x00080000)
+#define CRYP_AlgoMode_AES_CCM     ((uint32_t)0x00080008)
+
+#define IS_CRYP_ALGOMODE(ALGOMODE) (((ALGOMODE) == CRYP_AlgoMode_TDES_ECB) || \
+                                   ((ALGOMODE) == CRYP_AlgoMode_TDES_CBC)|| \
+                                   ((ALGOMODE) == CRYP_AlgoMode_DES_ECB) || \
+                                   ((ALGOMODE) == CRYP_AlgoMode_DES_CBC) || \
+                                   ((ALGOMODE) == CRYP_AlgoMode_AES_ECB) || \
+                                   ((ALGOMODE) == CRYP_AlgoMode_AES_CBC) || \
+                                   ((ALGOMODE) == CRYP_AlgoMode_AES_CTR) || \
+                                   ((ALGOMODE) == CRYP_AlgoMode_AES_Key) || \
+                                   ((ALGOMODE) == CRYP_AlgoMode_AES_GCM) || \
+                                   ((ALGOMODE) == CRYP_AlgoMode_AES_CCM))
+/**
+  * @}
+  */ 
+
+/** @defgroup CRYP_Phase 
+  * @{
+  */
+
+/*!< The phases are valid only for AES-GCM and AES-CCM modes */
+#define CRYP_Phase_Init           ((uint32_t)0x00000000)
+#define CRYP_Phase_Header         CRYP_CR_GCM_CCMPH_0
+#define CRYP_Phase_Payload        CRYP_CR_GCM_CCMPH_1
+#define CRYP_Phase_Final          CRYP_CR_GCM_CCMPH
+
+#define IS_CRYP_PHASE(PHASE) (((PHASE) == CRYP_Phase_Init)    || \
+                              ((PHASE) == CRYP_Phase_Header)  || \
+                              ((PHASE) == CRYP_Phase_Payload) || \
+                              ((PHASE) == CRYP_Phase_Final))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup CRYP_Data_Type 
+  * @{
+  */
+#define CRYP_DataType_32b         ((uint16_t)0x0000)
+#define CRYP_DataType_16b         ((uint16_t)0x0040)
+#define CRYP_DataType_8b          ((uint16_t)0x0080)
+#define CRYP_DataType_1b          ((uint16_t)0x00C0)
+#define IS_CRYP_DATATYPE(DATATYPE) (((DATATYPE) == CRYP_DataType_32b) || \
+                                    ((DATATYPE) == CRYP_DataType_16b)|| \
+                                    ((DATATYPE) == CRYP_DataType_8b)|| \
+                                    ((DATATYPE) == CRYP_DataType_1b))  
+/**
+  * @}
+  */
+                                     
+/** @defgroup CRYP_Key_Size_for_AES_only 
+  * @{
+  */
+#define CRYP_KeySize_128b         ((uint16_t)0x0000)
+#define CRYP_KeySize_192b         ((uint16_t)0x0100)
+#define CRYP_KeySize_256b         ((uint16_t)0x0200)
+#define IS_CRYP_KEYSIZE(KEYSIZE) (((KEYSIZE) == CRYP_KeySize_128b)|| \
+                                  ((KEYSIZE) == CRYP_KeySize_192b)|| \
+                                  ((KEYSIZE) == CRYP_KeySize_256b))
+/**
+  * @}
+  */
+
+/** @defgroup CRYP_flags_definition 
+  * @{
+  */
+#define CRYP_FLAG_BUSY            ((uint8_t)0x10)  /*!< The CRYP core is currently 
+                                                        processing a block of data 
+                                                        or a key preparation (for 
+                                                        AES decryption). */
+#define CRYP_FLAG_IFEM            ((uint8_t)0x01)  /*!< Input Fifo Empty */
+#define CRYP_FLAG_IFNF            ((uint8_t)0x02)  /*!< Input Fifo is Not Full */
+#define CRYP_FLAG_INRIS           ((uint8_t)0x22)  /*!< Raw interrupt pending */
+#define CRYP_FLAG_OFNE            ((uint8_t)0x04)  /*!< Input Fifo service raw 
+                                                        interrupt status */
+#define CRYP_FLAG_OFFU            ((uint8_t)0x08)  /*!< Output Fifo is Full */
+#define CRYP_FLAG_OUTRIS          ((uint8_t)0x21)  /*!< Output Fifo service raw 
+                                                        interrupt status */
+
+#define IS_CRYP_GET_FLAG(FLAG) (((FLAG) == CRYP_FLAG_IFEM)  || \
+                                ((FLAG) == CRYP_FLAG_IFNF)  || \
+                                ((FLAG) == CRYP_FLAG_OFNE)  || \
+                                ((FLAG) == CRYP_FLAG_OFFU)  || \
+                                ((FLAG) == CRYP_FLAG_BUSY)  || \
+                                ((FLAG) == CRYP_FLAG_OUTRIS)|| \
+                                ((FLAG) == CRYP_FLAG_INRIS))
+/**
+  * @}
+  */
+
+/** @defgroup CRYP_interrupts_definition 
+  * @{
+  */
+#define CRYP_IT_INI               ((uint8_t)0x01) /*!< IN Fifo Interrupt */
+#define CRYP_IT_OUTI              ((uint8_t)0x02) /*!< OUT Fifo Interrupt */
+#define IS_CRYP_CONFIG_IT(IT) ((((IT) & (uint8_t)0xFC) == 0x00) && ((IT) != 0x00))
+#define IS_CRYP_GET_IT(IT) (((IT) == CRYP_IT_INI) || ((IT) == CRYP_IT_OUTI))
+
+/**
+  * @}
+  */
+
+/** @defgroup CRYP_Encryption_Decryption_modes_definition 
+  * @{
+  */
+#define MODE_ENCRYPT             ((uint8_t)0x01)
+#define MODE_DECRYPT             ((uint8_t)0x00)
+
+/**
+  * @}
+  */
+
+/** @defgroup CRYP_DMA_transfer_requests 
+  * @{
+  */
+#define CRYP_DMAReq_DataIN             ((uint8_t)0x01)
+#define CRYP_DMAReq_DataOUT            ((uint8_t)0x02)
+#define IS_CRYP_DMAREQ(DMAREQ) ((((DMAREQ) & (uint8_t)0xFC) == 0x00) && ((DMAREQ) != 0x00))
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+
+/*  Function used to set the CRYP configuration to the default reset state ****/
+void CRYP_DeInit(void);
+
+/* CRYP Initialization and Configuration functions ****************************/
+void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct);
+void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct);
+void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct);
+void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct);
+void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct);
+void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct);
+void CRYP_Cmd(FunctionalState NewState);
+void CRYP_PhaseConfig(uint32_t CRYP_Phase);
+void CRYP_FIFOFlush(void);
+/* CRYP Data processing functions *********************************************/
+void CRYP_DataIn(uint32_t Data);
+uint32_t CRYP_DataOut(void);
+
+/* CRYP Context swapping functions ********************************************/
+ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
+                             CRYP_KeyInitTypeDef* CRYP_KeyInitStruct);
+void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore);
+
+/* CRYP DMA interface function ************************************************/
+void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState);
+
+/* Interrupts and flags management functions **********************************/
+void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState);
+ITStatus CRYP_GetITStatus(uint8_t CRYP_IT);
+FunctionalState CRYP_GetCmdStatus(void);
+FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG);
+
+/* High Level AES functions **************************************************/
+ErrorStatus CRYP_AES_ECB(uint8_t Mode,
+                         uint8_t *Key, uint16_t Keysize,
+                         uint8_t *Input, uint32_t Ilength,
+                         uint8_t *Output);
+
+ErrorStatus CRYP_AES_CBC(uint8_t Mode,
+                         uint8_t InitVectors[16],
+                         uint8_t *Key, uint16_t Keysize,
+                         uint8_t *Input, uint32_t Ilength,
+                         uint8_t *Output);
+
+ErrorStatus CRYP_AES_CTR(uint8_t Mode,
+                         uint8_t InitVectors[16],
+                         uint8_t *Key, uint16_t Keysize,
+                         uint8_t *Input, uint32_t Ilength,
+                         uint8_t *Output);
+
+ErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
+                         uint8_t *Key, uint16_t Keysize,
+                         uint8_t *Input, uint32_t ILength,
+                         uint8_t *Header, uint32_t HLength,
+                         uint8_t *Output, uint8_t *AuthTAG);
+
+ErrorStatus CRYP_AES_CCM(uint8_t Mode, 
+                         uint8_t* Nonce, uint32_t NonceSize,
+                         uint8_t* Key, uint16_t Keysize,
+                         uint8_t* Input, uint32_t ILength,
+                         uint8_t* Header, uint32_t HLength, uint8_t *HBuffer,
+                         uint8_t* Output,
+                         uint8_t* AuthTAG, uint32_t TAGSize);
+
+/* High Level TDES functions **************************************************/
+ErrorStatus CRYP_TDES_ECB(uint8_t Mode,
+                           uint8_t Key[24], 
+                           uint8_t *Input, uint32_t Ilength,
+                           uint8_t *Output);
+
+ErrorStatus CRYP_TDES_CBC(uint8_t Mode,
+                          uint8_t Key[24],
+                          uint8_t InitVectors[8],
+                          uint8_t *Input, uint32_t Ilength,
+                          uint8_t *Output);
+
+/* High Level DES functions **************************************************/
+ErrorStatus CRYP_DES_ECB(uint8_t Mode,
+                         uint8_t Key[8],
+                         uint8_t *Input, uint32_t Ilength,
+                         uint8_t *Output);
+
+ErrorStatus CRYP_DES_CBC(uint8_t Mode,
+                         uint8_t Key[8],
+                         uint8_t InitVectors[8],
+                         uint8_t *Input,uint32_t Ilength,
+                         uint8_t *Output);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_CRYP_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dac.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dac.h
new file mode 100644
index 0000000..e185a2a
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dac.h
@@ -0,0 +1,304 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dac.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the DAC firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_DAC_H
+#define __STM32F4xx_DAC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DAC
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  DAC Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t DAC_Trigger;                      /*!< Specifies the external trigger for the selected DAC channel.
+                                                  This parameter can be a value of @ref DAC_trigger_selection */
+
+  uint32_t DAC_WaveGeneration;               /*!< Specifies whether DAC channel noise waves or triangle waves
+                                                  are generated, or whether no wave is generated.
+                                                  This parameter can be a value of @ref DAC_wave_generation */
+
+  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!< Specifies the LFSR mask for noise wave generation or
+                                                  the maximum amplitude triangle generation for the DAC channel. 
+                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */
+
+  uint32_t DAC_OutputBuffer;                 /*!< Specifies whether the DAC channel output buffer is enabled or disabled.
+                                                  This parameter can be a value of @ref DAC_output_buffer */
+}DAC_InitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup DAC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup DAC_trigger_selection 
+  * @{
+  */
+
+#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!< Conversion is automatic once the DAC1_DHRxxxx register 
+                                                                       has been loaded, and not by external trigger */
+#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!< TIM2 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!< TIM4 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C) /*!< TIM5 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!< TIM6 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!< TIM7 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel */                                                                       
+
+#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!< EXTI Line9 event selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!< Conversion started by software trigger for DAC channel */
+
+#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
+                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T8_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T5_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
+                                 ((TRIGGER) == DAC_Trigger_Software))
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_wave_generation 
+  * @{
+  */
+
+#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)
+#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)
+#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)
+#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
+                                    ((WAVE) == DAC_WaveGeneration_Noise) || \
+                                    ((WAVE) == DAC_WaveGeneration_Triangle))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_lfsrunmask_triangleamplitude
+  * @{
+  */
+
+#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */
+#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */
+#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */
+#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!< Select max triangle amplitude of 3 */
+#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!< Select max triangle amplitude of 7 */
+#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!< Select max triangle amplitude of 15 */
+#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!< Select max triangle amplitude of 31 */
+#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!< Select max triangle amplitude of 63 */
+#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!< Select max triangle amplitude of 127 */
+#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!< Select max triangle amplitude of 255 */
+#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!< Select max triangle amplitude of 511 */
+#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!< Select max triangle amplitude of 1023 */
+#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!< Select max triangle amplitude of 2047 */
+#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!< Select max triangle amplitude of 4095 */
+
+#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_4095))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_output_buffer 
+  * @{
+  */
+
+#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)
+#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)
+#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
+                                           ((STATE) == DAC_OutputBuffer_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Channel_selection 
+  * @{
+  */
+
+#define DAC_Channel_1                      ((uint32_t)0x00000000)
+#define DAC_Channel_2                      ((uint32_t)0x00000010)
+#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
+                                 ((CHANNEL) == DAC_Channel_2))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_data_alignement 
+  * @{
+  */
+
+#define DAC_Align_12b_R                    ((uint32_t)0x00000000)
+#define DAC_Align_12b_L                    ((uint32_t)0x00000004)
+#define DAC_Align_8b_R                     ((uint32_t)0x00000008)
+#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
+                             ((ALIGN) == DAC_Align_12b_L) || \
+                             ((ALIGN) == DAC_Align_8b_R))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_wave_generation 
+  * @{
+  */
+
+#define DAC_Wave_Noise                     ((uint32_t)0x00000040)
+#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)
+#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
+                           ((WAVE) == DAC_Wave_Triangle))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_data 
+  * @{
+  */
+
+#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0) 
+/**
+  * @}
+  */
+  
+/** @defgroup DAC_interrupts_definition 
+  * @{
+  */   
+#define DAC_IT_DMAUDR                      ((uint32_t)0x00002000)  
+#define IS_DAC_IT(IT) (((IT) == DAC_IT_DMAUDR)) 
+
+/**
+  * @}
+  */ 
+
+/** @defgroup DAC_flags_definition 
+  * @{
+  */ 
+  
+#define DAC_FLAG_DMAUDR                    ((uint32_t)0x00002000)  
+#define IS_DAC_FLAG(FLAG) (((FLAG) == DAC_FLAG_DMAUDR))  
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/  
+
+/*  Function used to set the DAC configuration to the default reset state *****/  
+void DAC_DeInit(void);
+
+/*  DAC channels configuration: trigger, output buffer, data format functions */
+void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
+void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
+void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState);
+void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState);
+void DAC_DualSoftwareTriggerCmd(FunctionalState NewState);
+void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);
+void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data);
+void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data);
+void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);
+uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel);
+
+/* DMA management functions ***************************************************/
+void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);
+
+/* Interrupts and flags management functions **********************************/
+void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState);
+FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG);
+void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG);
+ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT);
+void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_DAC_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dbgmcu.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dbgmcu.h
new file mode 100644
index 0000000..80859b8
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dbgmcu.h
@@ -0,0 +1,109 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dbgmcu.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the DBGMCU firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_DBGMCU_H
+#define __STM32F4xx_DBGMCU_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DBGMCU
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup DBGMCU_Exported_Constants
+  * @{
+  */ 
+#define DBGMCU_SLEEP                 ((uint32_t)0x00000001)
+#define DBGMCU_STOP                  ((uint32_t)0x00000002)
+#define DBGMCU_STANDBY               ((uint32_t)0x00000004)
+#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFF8) == 0x00) && ((PERIPH) != 0x00))
+
+#define DBGMCU_TIM2_STOP             ((uint32_t)0x00000001)
+#define DBGMCU_TIM3_STOP             ((uint32_t)0x00000002)
+#define DBGMCU_TIM4_STOP             ((uint32_t)0x00000004)
+#define DBGMCU_TIM5_STOP             ((uint32_t)0x00000008)
+#define DBGMCU_TIM6_STOP             ((uint32_t)0x00000010)
+#define DBGMCU_TIM7_STOP             ((uint32_t)0x00000020)
+#define DBGMCU_TIM12_STOP            ((uint32_t)0x00000040)
+#define DBGMCU_TIM13_STOP            ((uint32_t)0x00000080)
+#define DBGMCU_TIM14_STOP            ((uint32_t)0x00000100)
+#define DBGMCU_RTC_STOP              ((uint32_t)0x00000400)
+#define DBGMCU_WWDG_STOP             ((uint32_t)0x00000800)
+#define DBGMCU_IWDG_STOP             ((uint32_t)0x00001000)
+#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00200000)
+#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00400000)
+#define DBGMCU_I2C3_SMBUS_TIMEOUT    ((uint32_t)0x00800000)
+#define DBGMCU_CAN1_STOP             ((uint32_t)0x02000000)
+#define DBGMCU_CAN2_STOP             ((uint32_t)0x04000000)
+#define IS_DBGMCU_APB1PERIPH(PERIPH) ((((PERIPH) & 0xF91FE200) == 0x00) && ((PERIPH) != 0x00))
+
+#define DBGMCU_TIM1_STOP             ((uint32_t)0x00000001)
+#define DBGMCU_TIM8_STOP             ((uint32_t)0x00000002)
+#define DBGMCU_TIM9_STOP             ((uint32_t)0x00010000)
+#define DBGMCU_TIM10_STOP            ((uint32_t)0x00020000)
+#define DBGMCU_TIM11_STOP            ((uint32_t)0x00040000)
+#define IS_DBGMCU_APB2PERIPH(PERIPH) ((((PERIPH) & 0xFFF8FFFC) == 0x00) && ((PERIPH) != 0x00))
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+uint32_t DBGMCU_GetREVID(void);
+uint32_t DBGMCU_GetDEVID(void);
+void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
+void DBGMCU_APB1PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
+void DBGMCU_APB2PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_DBGMCU_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dcmi.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dcmi.h
new file mode 100644
index 0000000..8e46d49
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dcmi.h
@@ -0,0 +1,312 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dcmi.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the DCMI firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_DCMI_H
+#define __STM32F4xx_DCMI_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DCMI
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+/** 
+  * @brief   DCMI Init structure definition  
+  */ 
+typedef struct
+{
+  uint16_t DCMI_CaptureMode;      /*!< Specifies the Capture Mode: Continuous or Snapshot.
+                                       This parameter can be a value of @ref DCMI_Capture_Mode */
+
+  uint16_t DCMI_SynchroMode;      /*!< Specifies the Synchronization Mode: Hardware or Embedded.
+                                       This parameter can be a value of @ref DCMI_Synchronization_Mode */
+
+  uint16_t DCMI_PCKPolarity;      /*!< Specifies the Pixel clock polarity: Falling or Rising.
+                                       This parameter can be a value of @ref DCMI_PIXCK_Polarity */
+
+  uint16_t DCMI_VSPolarity;       /*!< Specifies the Vertical synchronization polarity: High or Low.
+                                       This parameter can be a value of @ref DCMI_VSYNC_Polarity */
+
+  uint16_t DCMI_HSPolarity;       /*!< Specifies the Horizontal synchronization polarity: High or Low.
+                                       This parameter can be a value of @ref DCMI_HSYNC_Polarity */
+
+  uint16_t DCMI_CaptureRate;      /*!< Specifies the frequency of frame capture: All, 1/2 or 1/4.
+                                       This parameter can be a value of @ref DCMI_Capture_Rate */
+
+  uint16_t DCMI_ExtendedDataMode; /*!< Specifies the data width: 8-bit, 10-bit, 12-bit or 14-bit.
+                                       This parameter can be a value of @ref DCMI_Extended_Data_Mode */
+} DCMI_InitTypeDef;
+
+/** 
+  * @brief   DCMI CROP Init structure definition  
+  */ 
+typedef struct
+{
+  uint16_t DCMI_VerticalStartLine;      /*!< Specifies the Vertical start line count from which the image capture
+                                             will start. This parameter can be a value between 0x00 and 0x1FFF */
+
+  uint16_t DCMI_HorizontalOffsetCount;  /*!< Specifies the number of pixel clocks to count before starting a capture.
+                                             This parameter can be a value between 0x00 and 0x3FFF */
+
+  uint16_t DCMI_VerticalLineCount;      /*!< Specifies the number of lines to be captured from the starting point.
+                                             This parameter can be a value between 0x00 and 0x3FFF */
+
+  uint16_t DCMI_CaptureCount;           /*!< Specifies the number of pixel clocks to be captured from the starting
+                                             point on the same line.
+                                             This parameter can be a value between 0x00 and 0x3FFF */
+} DCMI_CROPInitTypeDef;
+
+/** 
+  * @brief   DCMI Embedded Synchronisation CODE Init structure definition  
+  */ 
+typedef struct
+{
+  uint8_t DCMI_FrameStartCode; /*!< Specifies the code of the frame start delimiter. */
+  uint8_t DCMI_LineStartCode;  /*!< Specifies the code of the line start delimiter. */
+  uint8_t DCMI_LineEndCode;    /*!< Specifies the code of the line end delimiter. */
+  uint8_t DCMI_FrameEndCode;   /*!< Specifies the code of the frame end delimiter. */
+} DCMI_CodesInitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup DCMI_Exported_Constants
+  * @{
+  */
+
+/** @defgroup DCMI_Capture_Mode 
+  * @{
+  */ 
+#define DCMI_CaptureMode_Continuous    ((uint16_t)0x0000) /*!< The received data are transferred continuously 
+                                                               into the destination memory through the DMA */
+#define DCMI_CaptureMode_SnapShot      ((uint16_t)0x0002) /*!< Once activated, the interface waits for the start of 
+                                                               frame and then transfers a single frame through the DMA */
+#define IS_DCMI_CAPTURE_MODE(MODE)(((MODE) == DCMI_CaptureMode_Continuous) || \
+                                   ((MODE) == DCMI_CaptureMode_SnapShot))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DCMI_Synchronization_Mode
+  * @{
+  */ 
+#define DCMI_SynchroMode_Hardware    ((uint16_t)0x0000) /*!< Hardware synchronization data capture (frame/line start/stop)
+                                                             is synchronized with the HSYNC/VSYNC signals */
+#define DCMI_SynchroMode_Embedded    ((uint16_t)0x0010) /*!< Embedded synchronization data capture is synchronized with 
+                                                             synchronization codes embedded in the data flow */
+#define IS_DCMI_SYNCHRO(MODE)(((MODE) == DCMI_SynchroMode_Hardware) || \
+                              ((MODE) == DCMI_SynchroMode_Embedded))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DCMI_PIXCK_Polarity 
+  * @{
+  */ 
+#define DCMI_PCKPolarity_Falling    ((uint16_t)0x0000) /*!< Pixel clock active on Falling edge */
+#define DCMI_PCKPolarity_Rising     ((uint16_t)0x0020) /*!< Pixel clock active on Rising edge */
+#define IS_DCMI_PCKPOLARITY(POLARITY)(((POLARITY) == DCMI_PCKPolarity_Falling) || \
+                                      ((POLARITY) == DCMI_PCKPolarity_Rising))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DCMI_VSYNC_Polarity 
+  * @{
+  */ 
+#define DCMI_VSPolarity_Low     ((uint16_t)0x0000) /*!< Vertical synchronization active Low */
+#define DCMI_VSPolarity_High    ((uint16_t)0x0080) /*!< Vertical synchronization active High */
+#define IS_DCMI_VSPOLARITY(POLARITY)(((POLARITY) == DCMI_VSPolarity_Low) || \
+                                     ((POLARITY) == DCMI_VSPolarity_High))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DCMI_HSYNC_Polarity 
+  * @{
+  */ 
+#define DCMI_HSPolarity_Low     ((uint16_t)0x0000) /*!< Horizontal synchronization active Low */
+#define DCMI_HSPolarity_High    ((uint16_t)0x0040) /*!< Horizontal synchronization active High */
+#define IS_DCMI_HSPOLARITY(POLARITY)(((POLARITY) == DCMI_HSPolarity_Low) || \
+                                     ((POLARITY) == DCMI_HSPolarity_High))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DCMI_Capture_Rate 
+  * @{
+  */ 
+#define DCMI_CaptureRate_All_Frame     ((uint16_t)0x0000) /*!< All frames are captured */
+#define DCMI_CaptureRate_1of2_Frame    ((uint16_t)0x0100) /*!< Every alternate frame captured */
+#define DCMI_CaptureRate_1of4_Frame    ((uint16_t)0x0200) /*!< One frame in 4 frames captured */
+#define IS_DCMI_CAPTURE_RATE(RATE) (((RATE) == DCMI_CaptureRate_All_Frame) || \
+                                    ((RATE) == DCMI_CaptureRate_1of2_Frame) ||\
+                                    ((RATE) == DCMI_CaptureRate_1of4_Frame))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DCMI_Extended_Data_Mode 
+  * @{
+  */ 
+#define DCMI_ExtendedDataMode_8b     ((uint16_t)0x0000) /*!< Interface captures 8-bit data on every pixel clock */
+#define DCMI_ExtendedDataMode_10b    ((uint16_t)0x0400) /*!< Interface captures 10-bit data on every pixel clock */
+#define DCMI_ExtendedDataMode_12b    ((uint16_t)0x0800) /*!< Interface captures 12-bit data on every pixel clock */
+#define DCMI_ExtendedDataMode_14b    ((uint16_t)0x0C00) /*!< Interface captures 14-bit data on every pixel clock */
+#define IS_DCMI_EXTENDED_DATA(DATA)(((DATA) == DCMI_ExtendedDataMode_8b) || \
+                                    ((DATA) == DCMI_ExtendedDataMode_10b) ||\
+                                    ((DATA) == DCMI_ExtendedDataMode_12b) ||\
+                                    ((DATA) == DCMI_ExtendedDataMode_14b))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DCMI_interrupt_sources 
+  * @{
+  */ 
+#define DCMI_IT_FRAME    ((uint16_t)0x0001)
+#define DCMI_IT_OVF      ((uint16_t)0x0002)
+#define DCMI_IT_ERR      ((uint16_t)0x0004)
+#define DCMI_IT_VSYNC    ((uint16_t)0x0008)
+#define DCMI_IT_LINE     ((uint16_t)0x0010)
+#define IS_DCMI_CONFIG_IT(IT) ((((IT) & (uint16_t)0xFFE0) == 0x0000) && ((IT) != 0x0000))
+#define IS_DCMI_GET_IT(IT) (((IT) == DCMI_IT_FRAME) || \
+                            ((IT) == DCMI_IT_OVF) || \
+                            ((IT) == DCMI_IT_ERR) || \
+                            ((IT) == DCMI_IT_VSYNC) || \
+                            ((IT) == DCMI_IT_LINE))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DCMI_Flags 
+  * @{
+  */ 
+/** 
+  * @brief   DCMI SR register  
+  */ 
+#define DCMI_FLAG_HSYNC     ((uint16_t)0x2001)
+#define DCMI_FLAG_VSYNC     ((uint16_t)0x2002)
+#define DCMI_FLAG_FNE       ((uint16_t)0x2004)
+/** 
+  * @brief   DCMI RISR register  
+  */ 
+#define DCMI_FLAG_FRAMERI    ((uint16_t)0x0001)
+#define DCMI_FLAG_OVFRI      ((uint16_t)0x0002)
+#define DCMI_FLAG_ERRRI      ((uint16_t)0x0004)
+#define DCMI_FLAG_VSYNCRI    ((uint16_t)0x0008)
+#define DCMI_FLAG_LINERI     ((uint16_t)0x0010)
+/** 
+  * @brief   DCMI MISR register  
+  */ 
+#define DCMI_FLAG_FRAMEMI    ((uint16_t)0x1001)
+#define DCMI_FLAG_OVFMI      ((uint16_t)0x1002)
+#define DCMI_FLAG_ERRMI      ((uint16_t)0x1004)
+#define DCMI_FLAG_VSYNCMI    ((uint16_t)0x1008)
+#define DCMI_FLAG_LINEMI     ((uint16_t)0x1010)
+#define IS_DCMI_GET_FLAG(FLAG) (((FLAG) == DCMI_FLAG_HSYNC) || \
+                                ((FLAG) == DCMI_FLAG_VSYNC) || \
+                                ((FLAG) == DCMI_FLAG_FNE) || \
+                                ((FLAG) == DCMI_FLAG_FRAMERI) || \
+                                ((FLAG) == DCMI_FLAG_OVFRI) || \
+                                ((FLAG) == DCMI_FLAG_ERRRI) || \
+                                ((FLAG) == DCMI_FLAG_VSYNCRI) || \
+                                ((FLAG) == DCMI_FLAG_LINERI) || \
+                                ((FLAG) == DCMI_FLAG_FRAMEMI) || \
+                                ((FLAG) == DCMI_FLAG_OVFMI) || \
+                                ((FLAG) == DCMI_FLAG_ERRMI) || \
+                                ((FLAG) == DCMI_FLAG_VSYNCMI) || \
+                                ((FLAG) == DCMI_FLAG_LINEMI))
+                                
+#define IS_DCMI_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFE0) == 0x0000) && ((FLAG) != 0x0000))
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/*  Function used to set the DCMI configuration to the default reset state ****/ 
+void DCMI_DeInit(void);
+
+/* Initialization and Configuration functions *********************************/
+void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct);
+void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct);
+void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct);
+void DCMI_CROPCmd(FunctionalState NewState);
+void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct);
+void DCMI_JPEGCmd(FunctionalState NewState);
+
+/* Image capture functions ****************************************************/
+void DCMI_Cmd(FunctionalState NewState);
+void DCMI_CaptureCmd(FunctionalState NewState);
+uint32_t DCMI_ReadData(void);
+
+/* Interrupts and flags management functions **********************************/
+void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState);
+FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG);
+void DCMI_ClearFlag(uint16_t DCMI_FLAG);
+ITStatus DCMI_GetITStatus(uint16_t DCMI_IT);
+void DCMI_ClearITPendingBit(uint16_t DCMI_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_DCMI_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma.h
new file mode 100644
index 0000000..577a3c9
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma.h
@@ -0,0 +1,609 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dma.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the DMA firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_DMA_H
+#define __STM32F4xx_DMA_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DMA
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  DMA Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t DMA_Channel;            /*!< Specifies the channel used for the specified stream. 
+                                        This parameter can be a value of @ref DMA_channel */
+ 
+  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Streamx. */
+
+  uint32_t DMA_Memory0BaseAddr;    /*!< Specifies the memory 0 base address for DMAy Streamx. 
+                                        This memory is the default memory used when double buffer mode is
+                                        not enabled. */
+
+  uint32_t DMA_DIR;                /*!< Specifies if the data will be transferred from memory to peripheral, 
+                                        from memory to memory or from peripheral to memory.
+                                        This parameter can be a value of @ref DMA_data_transfer_direction */
+
+  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Stream. 
+                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
+                                        or DMA_MemoryDataSize members depending in the transfer direction. */
+
+  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register should be incremented or not.
+                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */
+
+  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register should be incremented or not.
+                                        This parameter can be a value of @ref DMA_memory_incremented_mode */
+
+  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.
+                                        This parameter can be a value of @ref DMA_peripheral_data_size */
+
+  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.
+                                        This parameter can be a value of @ref DMA_memory_data_size */
+
+  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Streamx.
+                                        This parameter can be a value of @ref DMA_circular_normal_mode
+                                        @note The circular buffer mode cannot be used if the memory-to-memory
+                                              data transfer is configured on the selected Stream */
+
+  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Streamx.
+                                        This parameter can be a value of @ref DMA_priority_level */
+
+  uint32_t DMA_FIFOMode;          /*!< Specifies if the FIFO mode or Direct mode will be used for the specified Stream.
+                                        This parameter can be a value of @ref DMA_fifo_direct_mode
+                                        @note The Direct mode (FIFO mode disabled) cannot be used if the 
+                                               memory-to-memory data transfer is configured on the selected Stream */
+
+  uint32_t DMA_FIFOThreshold;      /*!< Specifies the FIFO threshold level.
+                                        This parameter can be a value of @ref DMA_fifo_threshold_level */
+
+  uint32_t DMA_MemoryBurst;        /*!< Specifies the Burst transfer configuration for the memory transfers. 
+                                        It specifies the amount of data to be transferred in a single non interruptable 
+                                        transaction. This parameter can be a value of @ref DMA_memory_burst 
+                                        @note The burst mode is possible only if the address Increment mode is enabled. */
+
+  uint32_t DMA_PeripheralBurst;    /*!< Specifies the Burst transfer configuration for the peripheral transfers. 
+                                        It specifies the amount of data to be transferred in a single non interruptable 
+                                        transaction. This parameter can be a value of @ref DMA_peripheral_burst
+                                        @note The burst mode is possible only if the address Increment mode is enabled. */  
+}DMA_InitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup DMA_Exported_Constants
+  * @{
+  */
+
+#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Stream0) || \
+                                   ((PERIPH) == DMA1_Stream1) || \
+                                   ((PERIPH) == DMA1_Stream2) || \
+                                   ((PERIPH) == DMA1_Stream3) || \
+                                   ((PERIPH) == DMA1_Stream4) || \
+                                   ((PERIPH) == DMA1_Stream5) || \
+                                   ((PERIPH) == DMA1_Stream6) || \
+                                   ((PERIPH) == DMA1_Stream7) || \
+                                   ((PERIPH) == DMA2_Stream0) || \
+                                   ((PERIPH) == DMA2_Stream1) || \
+                                   ((PERIPH) == DMA2_Stream2) || \
+                                   ((PERIPH) == DMA2_Stream3) || \
+                                   ((PERIPH) == DMA2_Stream4) || \
+                                   ((PERIPH) == DMA2_Stream5) || \
+                                   ((PERIPH) == DMA2_Stream6) || \
+                                   ((PERIPH) == DMA2_Stream7))
+
+#define IS_DMA_ALL_CONTROLLER(CONTROLLER) (((CONTROLLER) == DMA1) || \
+                                           ((CONTROLLER) == DMA2))
+
+/** @defgroup DMA_channel 
+  * @{
+  */ 
+#define DMA_Channel_0                     ((uint32_t)0x00000000)
+#define DMA_Channel_1                     ((uint32_t)0x02000000)
+#define DMA_Channel_2                     ((uint32_t)0x04000000)
+#define DMA_Channel_3                     ((uint32_t)0x06000000)
+#define DMA_Channel_4                     ((uint32_t)0x08000000)
+#define DMA_Channel_5                     ((uint32_t)0x0A000000)
+#define DMA_Channel_6                     ((uint32_t)0x0C000000)
+#define DMA_Channel_7                     ((uint32_t)0x0E000000)
+
+#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_Channel_0) || \
+                                 ((CHANNEL) == DMA_Channel_1) || \
+                                 ((CHANNEL) == DMA_Channel_2) || \
+                                 ((CHANNEL) == DMA_Channel_3) || \
+                                 ((CHANNEL) == DMA_Channel_4) || \
+                                 ((CHANNEL) == DMA_Channel_5) || \
+                                 ((CHANNEL) == DMA_Channel_6) || \
+                                 ((CHANNEL) == DMA_Channel_7))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_data_transfer_direction 
+  * @{
+  */ 
+#define DMA_DIR_PeripheralToMemory        ((uint32_t)0x00000000)
+#define DMA_DIR_MemoryToPeripheral        ((uint32_t)0x00000040) 
+#define DMA_DIR_MemoryToMemory            ((uint32_t)0x00000080)
+
+#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_DIR_PeripheralToMemory ) || \
+                                     ((DIRECTION) == DMA_DIR_MemoryToPeripheral)  || \
+                                     ((DIRECTION) == DMA_DIR_MemoryToMemory)) 
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_data_buffer_size 
+  * @{
+  */ 
+#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_peripheral_incremented_mode 
+  * @{
+  */ 
+#define DMA_PeripheralInc_Enable          ((uint32_t)0x00000200)
+#define DMA_PeripheralInc_Disable         ((uint32_t)0x00000000)
+
+#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
+                                            ((STATE) == DMA_PeripheralInc_Disable))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_memory_incremented_mode 
+  * @{
+  */ 
+#define DMA_MemoryInc_Enable              ((uint32_t)0x00000400)
+#define DMA_MemoryInc_Disable             ((uint32_t)0x00000000)
+
+#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
+                                        ((STATE) == DMA_MemoryInc_Disable))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_peripheral_data_size 
+  * @{
+  */ 
+#define DMA_PeripheralDataSize_Byte       ((uint32_t)0x00000000) 
+#define DMA_PeripheralDataSize_HalfWord   ((uint32_t)0x00000800) 
+#define DMA_PeripheralDataSize_Word       ((uint32_t)0x00001000)
+
+#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte)  || \
+                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
+                                           ((SIZE) == DMA_PeripheralDataSize_Word))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_memory_data_size 
+  * @{
+  */ 
+#define DMA_MemoryDataSize_Byte           ((uint32_t)0x00000000) 
+#define DMA_MemoryDataSize_HalfWord       ((uint32_t)0x00002000) 
+#define DMA_MemoryDataSize_Word           ((uint32_t)0x00004000)
+
+#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte)  || \
+                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
+                                       ((SIZE) == DMA_MemoryDataSize_Word ))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_circular_normal_mode 
+  * @{
+  */ 
+#define DMA_Mode_Normal                   ((uint32_t)0x00000000) 
+#define DMA_Mode_Circular                 ((uint32_t)0x00000100)
+
+#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Normal ) || \
+                           ((MODE) == DMA_Mode_Circular)) 
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_priority_level 
+  * @{
+  */ 
+#define DMA_Priority_Low                  ((uint32_t)0x00000000)
+#define DMA_Priority_Medium               ((uint32_t)0x00010000) 
+#define DMA_Priority_High                 ((uint32_t)0x00020000)
+#define DMA_Priority_VeryHigh             ((uint32_t)0x00030000)
+
+#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_Low )   || \
+                                   ((PRIORITY) == DMA_Priority_Medium) || \
+                                   ((PRIORITY) == DMA_Priority_High)   || \
+                                   ((PRIORITY) == DMA_Priority_VeryHigh)) 
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_fifo_direct_mode 
+  * @{
+  */ 
+#define DMA_FIFOMode_Disable              ((uint32_t)0x00000000) 
+#define DMA_FIFOMode_Enable               ((uint32_t)0x00000004)
+
+#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMode_Disable ) || \
+                                       ((STATE) == DMA_FIFOMode_Enable)) 
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_fifo_threshold_level 
+  * @{
+  */ 
+#define DMA_FIFOThreshold_1QuarterFull    ((uint32_t)0x00000000)
+#define DMA_FIFOThreshold_HalfFull        ((uint32_t)0x00000001) 
+#define DMA_FIFOThreshold_3QuartersFull   ((uint32_t)0x00000002)
+#define DMA_FIFOThreshold_Full            ((uint32_t)0x00000003)
+
+#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFOThreshold_1QuarterFull ) || \
+                                          ((THRESHOLD) == DMA_FIFOThreshold_HalfFull)      || \
+                                          ((THRESHOLD) == DMA_FIFOThreshold_3QuartersFull) || \
+                                          ((THRESHOLD) == DMA_FIFOThreshold_Full)) 
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_memory_burst 
+  * @{
+  */ 
+#define DMA_MemoryBurst_Single            ((uint32_t)0x00000000)
+#define DMA_MemoryBurst_INC4              ((uint32_t)0x00800000)  
+#define DMA_MemoryBurst_INC8              ((uint32_t)0x01000000)
+#define DMA_MemoryBurst_INC16             ((uint32_t)0x01800000)
+
+#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MemoryBurst_Single) || \
+                                    ((BURST) == DMA_MemoryBurst_INC4)  || \
+                                    ((BURST) == DMA_MemoryBurst_INC8)  || \
+                                    ((BURST) == DMA_MemoryBurst_INC16))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_peripheral_burst 
+  * @{
+  */ 
+#define DMA_PeripheralBurst_Single        ((uint32_t)0x00000000)
+#define DMA_PeripheralBurst_INC4          ((uint32_t)0x00200000)  
+#define DMA_PeripheralBurst_INC8          ((uint32_t)0x00400000)
+#define DMA_PeripheralBurst_INC16         ((uint32_t)0x00600000)
+
+#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PeripheralBurst_Single) || \
+                                        ((BURST) == DMA_PeripheralBurst_INC4)  || \
+                                        ((BURST) == DMA_PeripheralBurst_INC8)  || \
+                                        ((BURST) == DMA_PeripheralBurst_INC16))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_fifo_status_level 
+  * @{
+  */
+#define DMA_FIFOStatus_Less1QuarterFull   ((uint32_t)0x00000000 << 3)
+#define DMA_FIFOStatus_1QuarterFull       ((uint32_t)0x00000001 << 3)
+#define DMA_FIFOStatus_HalfFull           ((uint32_t)0x00000002 << 3) 
+#define DMA_FIFOStatus_3QuartersFull      ((uint32_t)0x00000003 << 3)
+#define DMA_FIFOStatus_Empty              ((uint32_t)0x00000004 << 3)
+#define DMA_FIFOStatus_Full               ((uint32_t)0x00000005 << 3)
+
+#define IS_DMA_FIFO_STATUS(STATUS) (((STATUS) == DMA_FIFOStatus_Less1QuarterFull ) || \
+                                    ((STATUS) == DMA_FIFOStatus_HalfFull)          || \
+                                    ((STATUS) == DMA_FIFOStatus_1QuarterFull)      || \
+                                    ((STATUS) == DMA_FIFOStatus_3QuartersFull)     || \
+                                    ((STATUS) == DMA_FIFOStatus_Full)              || \
+                                    ((STATUS) == DMA_FIFOStatus_Empty)) 
+/**
+  * @}
+  */ 
+
+/** @defgroup DMA_flags_definition 
+  * @{
+  */
+#define DMA_FLAG_FEIF0                    ((uint32_t)0x10800001)
+#define DMA_FLAG_DMEIF0                   ((uint32_t)0x10800004)
+#define DMA_FLAG_TEIF0                    ((uint32_t)0x10000008)
+#define DMA_FLAG_HTIF0                    ((uint32_t)0x10000010)
+#define DMA_FLAG_TCIF0                    ((uint32_t)0x10000020)
+#define DMA_FLAG_FEIF1                    ((uint32_t)0x10000040)
+#define DMA_FLAG_DMEIF1                   ((uint32_t)0x10000100)
+#define DMA_FLAG_TEIF1                    ((uint32_t)0x10000200)
+#define DMA_FLAG_HTIF1                    ((uint32_t)0x10000400)
+#define DMA_FLAG_TCIF1                    ((uint32_t)0x10000800)
+#define DMA_FLAG_FEIF2                    ((uint32_t)0x10010000)
+#define DMA_FLAG_DMEIF2                   ((uint32_t)0x10040000)
+#define DMA_FLAG_TEIF2                    ((uint32_t)0x10080000)
+#define DMA_FLAG_HTIF2                    ((uint32_t)0x10100000)
+#define DMA_FLAG_TCIF2                    ((uint32_t)0x10200000)
+#define DMA_FLAG_FEIF3                    ((uint32_t)0x10400000)
+#define DMA_FLAG_DMEIF3                   ((uint32_t)0x11000000)
+#define DMA_FLAG_TEIF3                    ((uint32_t)0x12000000)
+#define DMA_FLAG_HTIF3                    ((uint32_t)0x14000000)
+#define DMA_FLAG_TCIF3                    ((uint32_t)0x18000000)
+#define DMA_FLAG_FEIF4                    ((uint32_t)0x20000001)
+#define DMA_FLAG_DMEIF4                   ((uint32_t)0x20000004)
+#define DMA_FLAG_TEIF4                    ((uint32_t)0x20000008)
+#define DMA_FLAG_HTIF4                    ((uint32_t)0x20000010)
+#define DMA_FLAG_TCIF4                    ((uint32_t)0x20000020)
+#define DMA_FLAG_FEIF5                    ((uint32_t)0x20000040)
+#define DMA_FLAG_DMEIF5                   ((uint32_t)0x20000100)
+#define DMA_FLAG_TEIF5                    ((uint32_t)0x20000200)
+#define DMA_FLAG_HTIF5                    ((uint32_t)0x20000400)
+#define DMA_FLAG_TCIF5                    ((uint32_t)0x20000800)
+#define DMA_FLAG_FEIF6                    ((uint32_t)0x20010000)
+#define DMA_FLAG_DMEIF6                   ((uint32_t)0x20040000)
+#define DMA_FLAG_TEIF6                    ((uint32_t)0x20080000)
+#define DMA_FLAG_HTIF6                    ((uint32_t)0x20100000)
+#define DMA_FLAG_TCIF6                    ((uint32_t)0x20200000)
+#define DMA_FLAG_FEIF7                    ((uint32_t)0x20400000)
+#define DMA_FLAG_DMEIF7                   ((uint32_t)0x21000000)
+#define DMA_FLAG_TEIF7                    ((uint32_t)0x22000000)
+#define DMA_FLAG_HTIF7                    ((uint32_t)0x24000000)
+#define DMA_FLAG_TCIF7                    ((uint32_t)0x28000000)
+
+#define IS_DMA_CLEAR_FLAG(FLAG) ((((FLAG) & 0x30000000) != 0x30000000) && (((FLAG) & 0x30000000) != 0) && \
+                                 (((FLAG) & 0xC002F082) == 0x00) && ((FLAG) != 0x00))
+
+#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA_FLAG_TCIF0)  || ((FLAG) == DMA_FLAG_HTIF0)  || \
+                               ((FLAG) == DMA_FLAG_TEIF0)  || ((FLAG) == DMA_FLAG_DMEIF0) || \
+                               ((FLAG) == DMA_FLAG_FEIF0)  || ((FLAG) == DMA_FLAG_TCIF1)  || \
+                               ((FLAG) == DMA_FLAG_HTIF1)  || ((FLAG) == DMA_FLAG_TEIF1)  || \
+                               ((FLAG) == DMA_FLAG_DMEIF1) || ((FLAG) == DMA_FLAG_FEIF1)  || \
+                               ((FLAG) == DMA_FLAG_TCIF2)  || ((FLAG) == DMA_FLAG_HTIF2)  || \
+                               ((FLAG) == DMA_FLAG_TEIF2)  || ((FLAG) == DMA_FLAG_DMEIF2) || \
+                               ((FLAG) == DMA_FLAG_FEIF2)  || ((FLAG) == DMA_FLAG_TCIF3)  || \
+                               ((FLAG) == DMA_FLAG_HTIF3)  || ((FLAG) == DMA_FLAG_TEIF3)  || \
+                               ((FLAG) == DMA_FLAG_DMEIF3) || ((FLAG) == DMA_FLAG_FEIF3)  || \
+                               ((FLAG) == DMA_FLAG_TCIF4)  || ((FLAG) == DMA_FLAG_HTIF4)  || \
+                               ((FLAG) == DMA_FLAG_TEIF4)  || ((FLAG) == DMA_FLAG_DMEIF4) || \
+                               ((FLAG) == DMA_FLAG_FEIF4)  || ((FLAG) == DMA_FLAG_TCIF5)  || \
+                               ((FLAG) == DMA_FLAG_HTIF5)  || ((FLAG) == DMA_FLAG_TEIF5)  || \
+                               ((FLAG) == DMA_FLAG_DMEIF5) || ((FLAG) == DMA_FLAG_FEIF5)  || \
+                               ((FLAG) == DMA_FLAG_TCIF6)  || ((FLAG) == DMA_FLAG_HTIF6)  || \
+                               ((FLAG) == DMA_FLAG_TEIF6)  || ((FLAG) == DMA_FLAG_DMEIF6) || \
+                               ((FLAG) == DMA_FLAG_FEIF6)  || ((FLAG) == DMA_FLAG_TCIF7)  || \
+                               ((FLAG) == DMA_FLAG_HTIF7)  || ((FLAG) == DMA_FLAG_TEIF7)  || \
+                               ((FLAG) == DMA_FLAG_DMEIF7) || ((FLAG) == DMA_FLAG_FEIF7))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_interrupt_enable_definitions 
+  * @{
+  */ 
+#define DMA_IT_TC                         ((uint32_t)0x00000010)
+#define DMA_IT_HT                         ((uint32_t)0x00000008)
+#define DMA_IT_TE                         ((uint32_t)0x00000004)
+#define DMA_IT_DME                        ((uint32_t)0x00000002)
+#define DMA_IT_FE                         ((uint32_t)0x00000080)
+
+#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFF61) == 0x00) && ((IT) != 0x00))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_interrupts_definitions 
+  * @{
+  */ 
+#define DMA_IT_FEIF0                      ((uint32_t)0x90000001)
+#define DMA_IT_DMEIF0                     ((uint32_t)0x10001004)
+#define DMA_IT_TEIF0                      ((uint32_t)0x10002008)
+#define DMA_IT_HTIF0                      ((uint32_t)0x10004010)
+#define DMA_IT_TCIF0                      ((uint32_t)0x10008020)
+#define DMA_IT_FEIF1                      ((uint32_t)0x90000040)
+#define DMA_IT_DMEIF1                     ((uint32_t)0x10001100)
+#define DMA_IT_TEIF1                      ((uint32_t)0x10002200)
+#define DMA_IT_HTIF1                      ((uint32_t)0x10004400)
+#define DMA_IT_TCIF1                      ((uint32_t)0x10008800)
+#define DMA_IT_FEIF2                      ((uint32_t)0x90010000)
+#define DMA_IT_DMEIF2                     ((uint32_t)0x10041000)
+#define DMA_IT_TEIF2                      ((uint32_t)0x10082000)
+#define DMA_IT_HTIF2                      ((uint32_t)0x10104000)
+#define DMA_IT_TCIF2                      ((uint32_t)0x10208000)
+#define DMA_IT_FEIF3                      ((uint32_t)0x90400000)
+#define DMA_IT_DMEIF3                     ((uint32_t)0x11001000)
+#define DMA_IT_TEIF3                      ((uint32_t)0x12002000)
+#define DMA_IT_HTIF3                      ((uint32_t)0x14004000)
+#define DMA_IT_TCIF3                      ((uint32_t)0x18008000)
+#define DMA_IT_FEIF4                      ((uint32_t)0xA0000001)
+#define DMA_IT_DMEIF4                     ((uint32_t)0x20001004)
+#define DMA_IT_TEIF4                      ((uint32_t)0x20002008)
+#define DMA_IT_HTIF4                      ((uint32_t)0x20004010)
+#define DMA_IT_TCIF4                      ((uint32_t)0x20008020)
+#define DMA_IT_FEIF5                      ((uint32_t)0xA0000040)
+#define DMA_IT_DMEIF5                     ((uint32_t)0x20001100)
+#define DMA_IT_TEIF5                      ((uint32_t)0x20002200)
+#define DMA_IT_HTIF5                      ((uint32_t)0x20004400)
+#define DMA_IT_TCIF5                      ((uint32_t)0x20008800)
+#define DMA_IT_FEIF6                      ((uint32_t)0xA0010000)
+#define DMA_IT_DMEIF6                     ((uint32_t)0x20041000)
+#define DMA_IT_TEIF6                      ((uint32_t)0x20082000)
+#define DMA_IT_HTIF6                      ((uint32_t)0x20104000)
+#define DMA_IT_TCIF6                      ((uint32_t)0x20208000)
+#define DMA_IT_FEIF7                      ((uint32_t)0xA0400000)
+#define DMA_IT_DMEIF7                     ((uint32_t)0x21001000)
+#define DMA_IT_TEIF7                      ((uint32_t)0x22002000)
+#define DMA_IT_HTIF7                      ((uint32_t)0x24004000)
+#define DMA_IT_TCIF7                      ((uint32_t)0x28008000)
+
+#define IS_DMA_CLEAR_IT(IT) ((((IT) & 0x30000000) != 0x30000000) && \
+                             (((IT) & 0x30000000) != 0) && ((IT) != 0x00) && \
+                             (((IT) & 0x40820082) == 0x00))
+
+#define IS_DMA_GET_IT(IT) (((IT) == DMA_IT_TCIF0) || ((IT) == DMA_IT_HTIF0)  || \
+                           ((IT) == DMA_IT_TEIF0) || ((IT) == DMA_IT_DMEIF0) || \
+                           ((IT) == DMA_IT_FEIF0) || ((IT) == DMA_IT_TCIF1)  || \
+                           ((IT) == DMA_IT_HTIF1) || ((IT) == DMA_IT_TEIF1)  || \
+                           ((IT) == DMA_IT_DMEIF1)|| ((IT) == DMA_IT_FEIF1)  || \
+                           ((IT) == DMA_IT_TCIF2) || ((IT) == DMA_IT_HTIF2)  || \
+                           ((IT) == DMA_IT_TEIF2) || ((IT) == DMA_IT_DMEIF2) || \
+                           ((IT) == DMA_IT_FEIF2) || ((IT) == DMA_IT_TCIF3)  || \
+                           ((IT) == DMA_IT_HTIF3) || ((IT) == DMA_IT_TEIF3)  || \
+                           ((IT) == DMA_IT_DMEIF3)|| ((IT) == DMA_IT_FEIF3)  || \
+                           ((IT) == DMA_IT_TCIF4) || ((IT) == DMA_IT_HTIF4)  || \
+                           ((IT) == DMA_IT_TEIF4) || ((IT) == DMA_IT_DMEIF4) || \
+                           ((IT) == DMA_IT_FEIF4) || ((IT) == DMA_IT_TCIF5)  || \
+                           ((IT) == DMA_IT_HTIF5) || ((IT) == DMA_IT_TEIF5)  || \
+                           ((IT) == DMA_IT_DMEIF5)|| ((IT) == DMA_IT_FEIF5)  || \
+                           ((IT) == DMA_IT_TCIF6) || ((IT) == DMA_IT_HTIF6)  || \
+                           ((IT) == DMA_IT_TEIF6) || ((IT) == DMA_IT_DMEIF6) || \
+                           ((IT) == DMA_IT_FEIF6) || ((IT) == DMA_IT_TCIF7)  || \
+                           ((IT) == DMA_IT_HTIF7) || ((IT) == DMA_IT_TEIF7)  || \
+                           ((IT) == DMA_IT_DMEIF7)|| ((IT) == DMA_IT_FEIF7))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_peripheral_increment_offset 
+  * @{
+  */ 
+#define DMA_PINCOS_Psize                  ((uint32_t)0x00000000)
+#define DMA_PINCOS_WordAligned            ((uint32_t)0x00008000)
+
+#define IS_DMA_PINCOS_SIZE(SIZE) (((SIZE) == DMA_PINCOS_Psize) || \
+                                  ((SIZE) == DMA_PINCOS_WordAligned))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_flow_controller_definitions 
+  * @{
+  */ 
+#define DMA_FlowCtrl_Memory               ((uint32_t)0x00000000)
+#define DMA_FlowCtrl_Peripheral           ((uint32_t)0x00000020)
+
+#define IS_DMA_FLOW_CTRL(CTRL) (((CTRL) == DMA_FlowCtrl_Memory) || \
+                                ((CTRL) == DMA_FlowCtrl_Peripheral))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup DMA_memory_targets_definitions 
+  * @{
+  */ 
+#define DMA_Memory_0                      ((uint32_t)0x00000000)
+#define DMA_Memory_1                      ((uint32_t)0x00080000)
+
+#define IS_DMA_CURRENT_MEM(MEM) (((MEM) == DMA_Memory_0) || ((MEM) == DMA_Memory_1))
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/*  Function used to set the DMA configuration to the default reset state *****/ 
+void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx);
+
+/* Initialization and Configuration functions *********************************/
+void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct);
+void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
+void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
+
+/* Optional Configuration functions *******************************************/
+void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos);
+void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl);
+
+/* Data Counter functions *****************************************************/
+void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter);
+uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx);
+
+/* Double Buffer mode functions ***********************************************/
+void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
+                                uint32_t DMA_CurrentMemory);
+void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
+void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
+                            uint32_t DMA_MemoryTarget);
+uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx);
+
+/* Interrupts and flags management functions **********************************/
+FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx);
+uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx);
+FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
+void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
+void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState);
+ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
+void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_DMA_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma2d.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma2d.h
new file mode 100644
index 0000000..0e456ed
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma2d.h
@@ -0,0 +1,475 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dma2d.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the DMA2D firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_DMA2D_H
+#define __STM32F4xx_DMA2D_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DMA2D
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+ 
+/** 
+  * @brief  DMA2D Init structure definition  
+  */
+
+typedef struct
+{
+  uint32_t DMA2D_Mode;                           /*!< configures the DMA2D transfer mode.
+                                                 This parameter can be one value of @ref DMA2D_MODE */
+  
+  uint32_t DMA2D_CMode;                          /*!< configures the color format of the output image.
+                                                 This parameter can be one value of @ref DMA2D_CMODE */
+
+  uint32_t DMA2D_OutputBlue;                     /*!< configures the blue value of the output image. 
+                                                 This parameter must range:
+                                                 - from 0x00 to 0xFF if ARGB8888 color mode is slected
+                                                 - from 0x00 to 0xFF if RGB888 color mode is slected
+                                                 - from 0x00 to 0x1F if RGB565 color mode is slected
+                                                 - from 0x00 to 0x1F if ARGB1555 color mode is slected
+                                                 - from 0x00 to 0x0F if ARGB4444 color mode is slected  */
+
+  uint32_t DMA2D_OutputGreen;                    /*!< configures the green value of the output image. 
+                                                 This parameter must range:
+                                                 - from 0x00 to 0xFF if ARGB8888 color mode is slected
+                                                 - from 0x00 to 0xFF if RGB888 color mode is slected
+                                                 - from 0x00 to 0x2F if RGB565 color mode is slected
+                                                 - from 0x00 to 0x1F if ARGB1555 color mode is slected
+                                                 - from 0x00 to 0x0F if ARGB4444 color mode is slected  */
+            
+  uint32_t DMA2D_OutputRed;                      /*!< configures the red value of the output image. 
+                                                 This parameter must range:
+                                                 - from 0x00 to 0xFF if ARGB8888 color mode is slected
+                                                 - from 0x00 to 0xFF if RGB888 color mode is slected
+                                                 - from 0x00 to 0x1F if RGB565 color mode is slected
+                                                 - from 0x00 to 0x1F if ARGB1555 color mode is slected
+                                                 - from 0x00 to 0x0F if ARGB4444 color mode is slected  */
+  
+  uint32_t DMA2D_OutputAlpha;                    /*!< configures the alpha channel of the output color. 
+                                                 This parameter must range:
+                                                 - from 0x00 to 0xFF if ARGB8888 color mode is slected
+                                                 - from 0x00 to 0x01 if ARGB1555 color mode is slected
+                                                 - from 0x00 to 0x0F if ARGB4444 color mode is slected  */
+
+  uint32_t DMA2D_OutputMemoryAdd;                /*!< Specifies the memory address. This parameter 
+                                                 must be range from 0x00000000 to 0xFFFFFFFF. */
+
+  uint32_t DMA2D_OutputOffset;                   /*!< Specifies the Offset value. This parameter must be range from
+                                                 0x0000 to 0x3FFF. */
+
+  uint32_t DMA2D_NumberOfLine;                   /*!< Configures the number of line of the area to be transfered.
+                                                 This parameter must range from 0x0000 to 0xFFFF */
+            
+  uint32_t DMA2D_PixelPerLine;                   /*!< Configures the number pixel per line of the area to be transfered.
+                                                 This parameter must range from 0x0000 to 0x3FFF */
+} DMA2D_InitTypeDef;
+
+
+
+typedef struct
+{
+  uint32_t DMA2D_FGMA;                           /*!< configures the DMA2D foreground memory address.
+                                                 This parameter must be range from 0x00000000 to 0xFFFFFFFF. */
+  
+  uint32_t DMA2D_FGO;                            /*!< configures the DMA2D foreground offset.
+                                                 This parameter must be range from 0x0000 to 0x3FFF. */
+
+  uint32_t DMA2D_FGCM;                           /*!< configures the DMA2D foreground color mode . 
+                                                 This parameter can be one value of @ref DMA2D_FGCM */
+
+  uint32_t DMA2D_FG_CLUT_CM;                     /*!< configures the DMA2D foreground CLUT color mode. 
+                                                 This parameter can be one value of @ref DMA2D_FG_CLUT_CM */
+            
+  uint32_t DMA2D_FG_CLUT_SIZE;                   /*!< configures the DMA2D foreground CLUT size. 
+                                                 This parameter must range from 0x00 to 0xFF. */
+  
+  uint32_t DMA2D_FGPFC_ALPHA_MODE;               /*!< configures the DMA2D foreground alpha mode. 
+                                                 This parameter can be one value of @ref DMA2D_FGPFC_ALPHA_MODE */
+
+  uint32_t DMA2D_FGPFC_ALPHA_VALUE;              /*!< Specifies the DMA2D foreground alpha value 
+                                                 must be range from 0x00 to 0xFF. */
+
+  uint32_t DMA2D_FGC_BLUE;                       /*!< Specifies the DMA2D foreground blue value 
+                                                 must be range from 0x00 to 0xFF. */
+
+  uint32_t DMA2D_FGC_GREEN;                      /*!< Specifies the DMA2D foreground green value 
+                                                 must be range from 0x00 to 0xFF. */
+
+  uint32_t DMA2D_FGC_RED;                        /*!< Specifies the DMA2D foreground red value 
+                                                 must be range from 0x00 to 0xFF. */
+            
+  uint32_t DMA2D_FGCMAR;                         /*!< Configures the DMA2D foreground CLUT memory address.
+                                                 This parameter must range from 0x00000000 to 0xFFFFFFFF. */
+} DMA2D_FG_InitTypeDef;
+
+
+typedef struct
+{
+  uint32_t DMA2D_BGMA;                           /*!< configures the DMA2D background memory address.
+                                                 This parameter must be range from 0x00000000 to 0xFFFFFFFF. */
+  
+  uint32_t DMA2D_BGO;                            /*!< configures the DMA2D background offset.
+                                                 This parameter must be range from 0x0000 to 0x3FFF. */
+
+  uint32_t DMA2D_BGCM;                           /*!< configures the DMA2D background color mode . 
+                                                 This parameter can be one value of @ref DMA2D_FGCM */
+
+  uint32_t DMA2D_BG_CLUT_CM;                     /*!< configures the DMA2D background CLUT color mode. 
+                                                 This parameter can be one value of @ref DMA2D_FG_CLUT_CM */
+            
+  uint32_t DMA2D_BG_CLUT_SIZE;                   /*!< configures the DMA2D background CLUT size. 
+                                                 This parameter must range from 0x00 to 0xFF. */
+  
+  uint32_t DMA2D_BGPFC_ALPHA_MODE;               /*!< configures the DMA2D background alpha mode. 
+                                                 This parameter can be one value of @ref DMA2D_FGPFC_ALPHA_MODE */
+
+  uint32_t DMA2D_BGPFC_ALPHA_VALUE;              /*!< Specifies the DMA2D background alpha value 
+                                                 must be range from 0x00 to 0xFF. */
+
+  uint32_t DMA2D_BGC_BLUE;                       /*!< Specifies the DMA2D background blue value 
+                                                 must be range from 0x00 to 0xFF. */
+
+  uint32_t DMA2D_BGC_GREEN;                      /*!< Specifies the DMA2D background green value 
+                                                 must be range from 0x00 to 0xFF. */
+
+  uint32_t DMA2D_BGC_RED;                        /*!< Specifies the DMA2D background red value 
+                                                 must be range from 0x00 to 0xFF. */
+            
+  uint32_t DMA2D_BGCMAR;                         /*!< Configures the DMA2D background CLUT memory address.
+                                                 This parameter must range from 0x00000000 to 0xFFFFFFFF. */
+} DMA2D_BG_InitTypeDef;
+
+
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup DMA2D_Exported_Constants
+  * @{
+  */  
+
+/** @defgroup DMA2D_MODE 
+  * @{
+  */
+
+
+#define DMA2D_M2M                            ((uint32_t)0x00000000)
+#define DMA2D_M2M_PFC                        ((uint32_t)0x00010000)
+#define DMA2D_M2M_BLEND                      ((uint32_t)0x00020000)
+#define DMA2D_R2M                            ((uint32_t)0x00030000)
+
+#define IS_DMA2D_MODE(MODE) (((MODE) == DMA2D_M2M) || ((MODE) == DMA2D_M2M_PFC) || \
+                             ((MODE) == DMA2D_M2M_BLEND) || ((MODE) == DMA2D_R2M))
+
+
+/**
+  * @}
+  */  
+
+/** @defgroup DMA2D_CMODE 
+  * @{
+  */
+#define DMA2D_ARGB8888                       ((uint32_t)0x00000000)
+#define DMA2D_RGB888                         ((uint32_t)0x00000001)
+#define DMA2D_RGB565                         ((uint32_t)0x00000002)
+#define DMA2D_ARGB1555                       ((uint32_t)0x00000003)
+#define DMA2D_ARGB4444                       ((uint32_t)0x00000004)
+
+#define IS_DMA2D_CMODE(MODE_ARGB) (((MODE_ARGB) == DMA2D_ARGB8888) || ((MODE_ARGB) == DMA2D_RGB888) || \
+                                   ((MODE_ARGB) == DMA2D_RGB565) || ((MODE_ARGB) == DMA2D_ARGB1555) || \
+                                   ((MODE_ARGB) == DMA2D_ARGB4444))
+
+
+/**
+  * @}
+  */  
+
+/** @defgroup DMA2D_OUTPUT_COLOR 
+  * @{
+  */
+#define DMA2D_Output_Color                 ((uint32_t)0x000000FF)
+
+#define IS_DMA2D_OGREEN(OGREEN) ((OGREEN) <= DMA2D_Output_Color)
+#define IS_DMA2D_ORED(ORED)     ((ORED) <= DMA2D_Output_Color)
+#define IS_DMA2D_OBLUE(OBLUE)   ((OBLUE) <= DMA2D_Output_Color)
+#define IS_DMA2D_OALPHA(OALPHA) ((OALPHA) <= DMA2D_Output_Color)
+
+/**
+  * @}
+  */  
+
+/** @defgroup DMA2D_OUTPUT_OFFSET 
+  * @{
+  */
+#define DMA2D_OUTPUT_OFFSET      ((uint32_t)0x00003FFF)
+
+#define IS_DMA2D_OUTPUT_OFFSET(OOFFSET) ((OOFFSET) <= DMA2D_OUTPUT_OFFSET)
+
+
+/**
+  * @}
+  */  
+
+/** @defgroup DMA2D_SIZE 
+  * @{
+  */
+
+#define DMA2D_pixel          ((uint32_t)0x00003FFF)
+#define DMA2D_Line           ((uint32_t)0x0000FFFF)
+
+#define IS_DMA2D_LINE(LINE)  ((LINE) <= DMA2D_Line)
+#define IS_DMA2D_PIXEL(PIXEL) ((PIXEL) <= DMA2D_pixel)
+
+
+/**
+  * @}
+  */  
+
+/** @defgroup DMA2D_OFFSET
+  * @{
+  */
+#define OFFSET               ((uint32_t)0x00003FFF)
+
+#define IS_DMA2D_FGO(FGO)  ((FGO) <= OFFSET)
+
+#define IS_DMA2D_BGO(BGO)  ((BGO) <= OFFSET) 
+
+/**
+  * @}
+  */  
+
+
+/** @defgroup DMA2D_FGCM
+  * @{
+  */
+
+#define CM_ARGB8888        ((uint32_t)0x00000000)
+#define CM_RGB888          ((uint32_t)0x00000001)
+#define CM_RGB565          ((uint32_t)0x00000002)
+#define CM_ARGB1555        ((uint32_t)0x00000003)
+#define CM_ARGB4444        ((uint32_t)0x00000004)
+#define CM_L8              ((uint32_t)0x00000005)
+#define CM_AL44            ((uint32_t)0x00000006)
+#define CM_AL88            ((uint32_t)0x00000007)
+#define CM_L4              ((uint32_t)0x00000008)
+#define CM_A8              ((uint32_t)0x00000009)
+#define CM_A4              ((uint32_t)0x0000000A)
+
+#define IS_DMA2D_FGCM(FGCM) (((FGCM) == CM_ARGB8888) || ((FGCM) == CM_RGB888) || \
+                             ((FGCM) == CM_RGB565) || ((FGCM) == CM_ARGB1555) || \
+                             ((FGCM) == CM_ARGB4444) || ((FGCM) == CM_L8) || \
+                             ((FGCM) == CM_AL44) || ((FGCM) == CM_AL88) || \
+                             ((FGCM) == CM_L4) || ((FGCM) == CM_A8) || \
+                             ((FGCM) == CM_A4))
+
+#define IS_DMA2D_BGCM(BGCM) (((BGCM) == CM_ARGB8888) || ((BGCM) == CM_RGB888) || \
+                             ((BGCM) == CM_RGB565) || ((BGCM) == CM_ARGB1555) || \
+                             ((BGCM) == CM_ARGB4444) || ((BGCM) == CM_L8) || \
+                             ((BGCM) == CM_AL44) || ((BGCM) == CM_AL88) || \
+                             ((BGCM) == CM_L4) || ((BGCM) == CM_A8) || \
+                             ((BGCM) == CM_A4))
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA2D_FG_CLUT_CM
+  * @{
+  */
+
+#define CLUT_CM_ARGB8888        ((uint32_t)0x00000000)
+#define CLUT_CM_RGB888          ((uint32_t)0x00000001)
+
+#define IS_DMA2D_FG_CLUT_CM(FG_CLUT_CM) (((FG_CLUT_CM) == CLUT_CM_ARGB8888) || ((FG_CLUT_CM) == CLUT_CM_RGB888))
+
+#define IS_DMA2D_BG_CLUT_CM(BG_CLUT_CM) (((BG_CLUT_CM) == CLUT_CM_ARGB8888) || ((BG_CLUT_CM) == CLUT_CM_RGB888))
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA2D_FG_COLOR_VALUE
+  * @{
+  */
+
+#define COLOR_VALUE             ((uint32_t)0x000000FF)
+
+#define IS_DMA2D_FG_CLUT_SIZE(FG_CLUT_SIZE) ((FG_CLUT_SIZE) <= COLOR_VALUE)
+
+#define IS_DMA2D_FG_ALPHA_VALUE(FG_ALPHA_VALUE) ((FG_ALPHA_VALUE) <= COLOR_VALUE)
+#define IS_DMA2D_FGC_BLUE(FGC_BLUE) ((FGC_BLUE) <= COLOR_VALUE)
+#define IS_DMA2D_FGC_GREEN(FGC_GREEN) ((FGC_GREEN) <= COLOR_VALUE)
+#define IS_DMA2D_FGC_RED(FGC_RED) ((FGC_RED) <= COLOR_VALUE)
+
+#define IS_DMA2D_BG_CLUT_SIZE(BG_CLUT_SIZE) ((BG_CLUT_SIZE) <= COLOR_VALUE)
+
+#define IS_DMA2D_BG_ALPHA_VALUE(BG_ALPHA_VALUE) ((BG_ALPHA_VALUE) <= COLOR_VALUE)
+#define IS_DMA2D_BGC_BLUE(BGC_BLUE) ((BGC_BLUE) <= COLOR_VALUE)
+#define IS_DMA2D_BGC_GREEN(BGC_GREEN) ((BGC_GREEN) <= COLOR_VALUE)
+#define IS_DMA2D_BGC_RED(BGC_RED) ((BGC_RED) <= COLOR_VALUE)
+
+/**
+  * @}
+  */
+
+/** DMA2D_FGPFC_ALPHA_MODE
+  * @{
+  */
+
+#define NO_MODIF_ALPHA_VALUE       ((uint32_t)0x00000000)
+#define REPLACE_ALPHA_VALUE        ((uint32_t)0x00000001)
+#define COMBINE_ALPHA_VALUE        ((uint32_t)0x00000002)
+
+#define IS_DMA2D_FG_ALPHA_MODE(FG_ALPHA_MODE) (((FG_ALPHA_MODE) ==  NO_MODIF_ALPHA_VALUE) || \
+                                              ((FG_ALPHA_MODE) == REPLACE_ALPHA_VALUE) || \
+                                              ((FG_ALPHA_MODE) == COMBINE_ALPHA_VALUE))
+
+#define IS_DMA2D_BG_ALPHA_MODE(BG_ALPHA_MODE) (((BG_ALPHA_MODE) ==  NO_MODIF_ALPHA_VALUE) || \
+                                              ((BG_ALPHA_MODE) == REPLACE_ALPHA_VALUE) || \
+                                              ((BG_ALPHA_MODE) == COMBINE_ALPHA_VALUE))
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA2D_Interrupts 
+  * @{
+  */
+
+#define DMA2D_IT_CE                      DMA2D_CR_CEIE
+#define DMA2D_IT_CTC                     DMA2D_CR_CTCIE
+#define DMA2D_IT_CAE                     DMA2D_CR_CAEIE
+#define DMA2D_IT_TW                      DMA2D_CR_TWIE
+#define DMA2D_IT_TC                      DMA2D_CR_TCIE
+#define DMA2D_IT_TE                      DMA2D_CR_TEIE
+
+#define IS_DMA2D_IT(IT) (((IT) == DMA2D_IT_CTC) || ((IT) == DMA2D_IT_CAE) || \
+                        ((IT) == DMA2D_IT_TW) || ((IT) == DMA2D_IT_TC) || \
+                        ((IT) == DMA2D_IT_TE) || ((IT) == DMA2D_IT_CE))
+
+/**
+  * @}
+  */
+      
+/** @defgroup DMA2D_Flag 
+  * @{
+  */
+
+#define DMA2D_FLAG_CE                      DMA2D_ISR_CEIF
+#define DMA2D_FLAG_CTC                     DMA2D_ISR_CTCIF
+#define DMA2D_FLAG_CAE                     DMA2D_ISR_CAEIF
+#define DMA2D_FLAG_TW                      DMA2D_ISR_TWIF
+#define DMA2D_FLAG_TC                      DMA2D_ISR_TCIF
+#define DMA2D_FLAG_TE                      DMA2D_ISR_TEIF
+
+
+#define IS_DMA2D_GET_FLAG(FLAG) (((FLAG) == DMA2D_FLAG_CTC) || ((FLAG) == DMA2D_FLAG_CAE) || \
+                                ((FLAG) == DMA2D_FLAG_TW) || ((FLAG) == DMA2D_FLAG_TC) || \
+                                ((FLAG) == DMA2D_FLAG_TE) || ((FLAG) == DMA2D_FLAG_CE)) 
+
+
+/**
+  * @}
+  */
+      
+/** @defgroup DMA2D_DeadTime 
+  * @{
+  */
+
+#define DEADTIME                  ((uint32_t)0x000000FF)
+  
+#define IS_DMA2D_DEAD_TIME(DEAD_TIME) ((DEAD_TIME) <= DEADTIME)
+
+
+#define LINE_WATERMARK            DMA2D_LWR_LW
+
+#define IS_DMA2D_LineWatermark(LineWatermark) ((LineWatermark) <= LINE_WATERMARK)
+
+/**
+  * @}
+  */
+  
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions ------------------------------------------------------- */
+
+/*  Function used to set the DMA2D configuration to the default reset state *****/
+void DMA2D_DeInit(void);
+
+/* Initialization and Configuration functions *********************************/
+void DMA2D_Init(DMA2D_InitTypeDef* DMA2D_InitStruct);
+void DMA2D_StructInit(DMA2D_InitTypeDef* DMA2D_InitStruct);
+void DMA2D_StartTransfer(void);
+void DMA2D_AbortTransfer(void);
+void DMA2D_Suspend(FunctionalState NewState);
+void DMA2D_FGConfig(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct);
+void DMA2D_FG_StructInit(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct);
+void DMA2D_BGConfig(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct);
+void DMA2D_BG_StructInit(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct);
+void DMA2D_FGStart(FunctionalState NewState);
+void DMA2D_BGStart(FunctionalState NewState);
+void DMA2D_DeadTimeConfig(uint32_t DMA2D_DeadTime, FunctionalState NewState);
+void DMA2D_LineWatermarkConfig(uint32_t DMA2D_LWatermarkConfig);
+
+/* Interrupts and flags management functions **********************************/
+void DMA2D_ITConfig(uint32_t DMA2D_IT, FunctionalState NewState);
+FlagStatus DMA2D_GetFlagStatus(uint32_t DMA2D_FLAG);
+void DMA2D_ClearFlag(uint32_t DMA2D_FLAG);
+ITStatus DMA2D_GetITStatus(uint32_t DMA2D_IT);
+void DMA2D_ClearITPendingBit(uint32_t DMA2D_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_DMA2D_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_exti.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_exti.h
new file mode 100644
index 0000000..588ed29
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_exti.h
@@ -0,0 +1,183 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_exti.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the EXTI firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_EXTI_H
+#define __STM32F4xx_EXTI_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup EXTI
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  EXTI mode enumeration  
+  */
+
+typedef enum
+{
+  EXTI_Mode_Interrupt = 0x00,
+  EXTI_Mode_Event = 0x04
+}EXTIMode_TypeDef;
+
+#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
+
+/** 
+  * @brief  EXTI Trigger enumeration  
+  */
+
+typedef enum
+{
+  EXTI_Trigger_Rising = 0x08,
+  EXTI_Trigger_Falling = 0x0C,  
+  EXTI_Trigger_Rising_Falling = 0x10
+}EXTITrigger_TypeDef;
+
+#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
+                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
+                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
+/** 
+  * @brief  EXTI Init Structure definition  
+  */
+
+typedef struct
+{
+  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.
+                                         This parameter can be any combination value of @ref EXTI_Lines */
+   
+  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.
+                                         This parameter can be a value of @ref EXTIMode_TypeDef */
+
+  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.
+                                         This parameter can be a value of @ref EXTITrigger_TypeDef */
+
+  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.
+                                         This parameter can be set either to ENABLE or DISABLE */ 
+}EXTI_InitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup EXTI_Exported_Constants
+  * @{
+  */
+
+/** @defgroup EXTI_Lines 
+  * @{
+  */
+
+#define EXTI_Line0       ((uint32_t)0x00001)     /*!< External interrupt line 0 */
+#define EXTI_Line1       ((uint32_t)0x00002)     /*!< External interrupt line 1 */
+#define EXTI_Line2       ((uint32_t)0x00004)     /*!< External interrupt line 2 */
+#define EXTI_Line3       ((uint32_t)0x00008)     /*!< External interrupt line 3 */
+#define EXTI_Line4       ((uint32_t)0x00010)     /*!< External interrupt line 4 */
+#define EXTI_Line5       ((uint32_t)0x00020)     /*!< External interrupt line 5 */
+#define EXTI_Line6       ((uint32_t)0x00040)     /*!< External interrupt line 6 */
+#define EXTI_Line7       ((uint32_t)0x00080)     /*!< External interrupt line 7 */
+#define EXTI_Line8       ((uint32_t)0x00100)     /*!< External interrupt line 8 */
+#define EXTI_Line9       ((uint32_t)0x00200)     /*!< External interrupt line 9 */
+#define EXTI_Line10      ((uint32_t)0x00400)     /*!< External interrupt line 10 */
+#define EXTI_Line11      ((uint32_t)0x00800)     /*!< External interrupt line 11 */
+#define EXTI_Line12      ((uint32_t)0x01000)     /*!< External interrupt line 12 */
+#define EXTI_Line13      ((uint32_t)0x02000)     /*!< External interrupt line 13 */
+#define EXTI_Line14      ((uint32_t)0x04000)     /*!< External interrupt line 14 */
+#define EXTI_Line15      ((uint32_t)0x08000)     /*!< External interrupt line 15 */
+#define EXTI_Line16      ((uint32_t)0x10000)     /*!< External interrupt line 16 Connected to the PVD Output */
+#define EXTI_Line17      ((uint32_t)0x20000)     /*!< External interrupt line 17 Connected to the RTC Alarm event */
+#define EXTI_Line18      ((uint32_t)0x40000)     /*!< External interrupt line 18 Connected to the USB OTG FS Wakeup from suspend event */                                    
+#define EXTI_Line19      ((uint32_t)0x80000)     /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */
+#define EXTI_Line20      ((uint32_t)0x00100000)  /*!< External interrupt line 20 Connected to the USB OTG HS (configured in FS) Wakeup event  */
+#define EXTI_Line21      ((uint32_t)0x00200000)  /*!< External interrupt line 21 Connected to the RTC Tamper and Time Stamp events */                                               
+#define EXTI_Line22      ((uint32_t)0x00400000)  /*!< External interrupt line 22 Connected to the RTC Wakeup event */                                               
+                                          
+#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0xFF800000) == 0x00) && ((LINE) != (uint16_t)0x00))
+
+#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
+                                ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
+                                ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
+                                ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
+                                ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
+                                ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
+                                ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
+                                ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
+                                ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
+                                ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) || \
+                                ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) ||\
+                                ((LINE) == EXTI_Line22))
+                    
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+
+/*  Function used to set the EXTI configuration to the default reset state *****/
+void EXTI_DeInit(void);
+
+/* Initialization and Configuration functions *********************************/
+void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
+void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
+void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);
+
+/* Interrupts and flags management functions **********************************/
+FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
+void EXTI_ClearFlag(uint32_t EXTI_Line);
+ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
+void EXTI_ClearITPendingBit(uint32_t EXTI_Line);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_EXTI_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash.h
new file mode 100644
index 0000000..a56a064
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash.h
@@ -0,0 +1,488 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_flash.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the FLASH 
+  *          firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_FLASH_H
+#define __STM32F4xx_FLASH_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup FLASH
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+/** 
+  * @brief FLASH Status  
+  */ 
+typedef enum
+{ 
+  FLASH_BUSY = 1,
+  FLASH_ERROR_RD,
+  FLASH_ERROR_PGS,
+  FLASH_ERROR_PGP,
+  FLASH_ERROR_PGA,
+  FLASH_ERROR_WRP,
+  FLASH_ERROR_PROGRAM,
+  FLASH_ERROR_OPERATION,
+  FLASH_COMPLETE
+}FLASH_Status;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup FLASH_Exported_Constants
+  * @{
+  */  
+
+/** @defgroup Flash_Latency 
+  * @{
+  */ 
+#define FLASH_Latency_0                ((uint8_t)0x0000)  /*!< FLASH Zero Latency cycle      */
+#define FLASH_Latency_1                ((uint8_t)0x0001)  /*!< FLASH One Latency cycle       */
+#define FLASH_Latency_2                ((uint8_t)0x0002)  /*!< FLASH Two Latency cycles      */
+#define FLASH_Latency_3                ((uint8_t)0x0003)  /*!< FLASH Three Latency cycles    */
+#define FLASH_Latency_4                ((uint8_t)0x0004)  /*!< FLASH Four Latency cycles     */
+#define FLASH_Latency_5                ((uint8_t)0x0005)  /*!< FLASH Five Latency cycles     */
+#define FLASH_Latency_6                ((uint8_t)0x0006)  /*!< FLASH Six Latency cycles      */
+#define FLASH_Latency_7                ((uint8_t)0x0007)  /*!< FLASH Seven Latency cycles    */
+#define FLASH_Latency_8                ((uint8_t)0x0008)  /*!< FLASH Eight Latency cycles    */
+#define FLASH_Latency_9                ((uint8_t)0x0009)  /*!< FLASH Nine Latency cycles     */
+#define FLASH_Latency_10               ((uint8_t)0x000A)  /*!< FLASH Ten Latency cycles      */
+#define FLASH_Latency_11               ((uint8_t)0x000B)  /*!< FLASH Eleven Latency cycles   */
+#define FLASH_Latency_12               ((uint8_t)0x000C)  /*!< FLASH Twelve Latency cycles   */
+#define FLASH_Latency_13               ((uint8_t)0x000D)  /*!< FLASH Thirteen Latency cycles */
+#define FLASH_Latency_14               ((uint8_t)0x000E)  /*!< FLASH Fourteen Latency cycles */
+#define FLASH_Latency_15               ((uint8_t)0x000F)  /*!< FLASH Fifteen Latency cycles  */
+
+
+#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0)  || \
+                                   ((LATENCY) == FLASH_Latency_1)  || \
+                                   ((LATENCY) == FLASH_Latency_2)  || \
+                                   ((LATENCY) == FLASH_Latency_3)  || \
+                                   ((LATENCY) == FLASH_Latency_4)  || \
+                                   ((LATENCY) == FLASH_Latency_5)  || \
+                                   ((LATENCY) == FLASH_Latency_6)  || \
+                                   ((LATENCY) == FLASH_Latency_7)  || \
+                                   ((LATENCY) == FLASH_Latency_8)  || \
+                                   ((LATENCY) == FLASH_Latency_9)  || \
+                                   ((LATENCY) == FLASH_Latency_10) || \
+                                   ((LATENCY) == FLASH_Latency_11) || \
+                                   ((LATENCY) == FLASH_Latency_12) || \
+                                   ((LATENCY) == FLASH_Latency_13) || \
+                                   ((LATENCY) == FLASH_Latency_14) || \
+                                   ((LATENCY) == FLASH_Latency_15))
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Voltage_Range 
+  * @{
+  */ 
+#define VoltageRange_1        ((uint8_t)0x00)  /*!< Device operating range: 1.8V to 2.1V */
+#define VoltageRange_2        ((uint8_t)0x01)  /*!<Device operating range: 2.1V to 2.7V */
+#define VoltageRange_3        ((uint8_t)0x02)  /*!<Device operating range: 2.7V to 3.6V */
+#define VoltageRange_4        ((uint8_t)0x03)  /*!<Device operating range: 2.7V to 3.6V + External Vpp */
+
+#define IS_VOLTAGERANGE(RANGE)(((RANGE) == VoltageRange_1) || \
+                               ((RANGE) == VoltageRange_2) || \
+                               ((RANGE) == VoltageRange_3) || \
+                               ((RANGE) == VoltageRange_4))
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Sectors
+  * @{
+  */
+#define FLASH_Sector_0     ((uint16_t)0x0000) /*!< Sector Number 0   */
+#define FLASH_Sector_1     ((uint16_t)0x0008) /*!< Sector Number 1   */
+#define FLASH_Sector_2     ((uint16_t)0x0010) /*!< Sector Number 2   */
+#define FLASH_Sector_3     ((uint16_t)0x0018) /*!< Sector Number 3   */
+#define FLASH_Sector_4     ((uint16_t)0x0020) /*!< Sector Number 4   */
+#define FLASH_Sector_5     ((uint16_t)0x0028) /*!< Sector Number 5   */
+#define FLASH_Sector_6     ((uint16_t)0x0030) /*!< Sector Number 6   */
+#define FLASH_Sector_7     ((uint16_t)0x0038) /*!< Sector Number 7   */
+#define FLASH_Sector_8     ((uint16_t)0x0040) /*!< Sector Number 8   */
+#define FLASH_Sector_9     ((uint16_t)0x0048) /*!< Sector Number 9   */
+#define FLASH_Sector_10    ((uint16_t)0x0050) /*!< Sector Number 10  */
+#define FLASH_Sector_11    ((uint16_t)0x0058) /*!< Sector Number 11  */
+#define FLASH_Sector_12    ((uint16_t)0x0080) /*!< Sector Number 12  */
+#define FLASH_Sector_13    ((uint16_t)0x0088) /*!< Sector Number 13  */
+#define FLASH_Sector_14    ((uint16_t)0x0090) /*!< Sector Number 14  */
+#define FLASH_Sector_15    ((uint16_t)0x0098) /*!< Sector Number 15  */
+#define FLASH_Sector_16    ((uint16_t)0x00A0) /*!< Sector Number 16  */
+#define FLASH_Sector_17    ((uint16_t)0x00A8) /*!< Sector Number 17  */
+#define FLASH_Sector_18    ((uint16_t)0x00B0) /*!< Sector Number 18  */
+#define FLASH_Sector_19    ((uint16_t)0x00B8) /*!< Sector Number 19  */
+#define FLASH_Sector_20    ((uint16_t)0x00C0) /*!< Sector Number 20  */
+#define FLASH_Sector_21    ((uint16_t)0x00C8) /*!< Sector Number 21  */
+#define FLASH_Sector_22    ((uint16_t)0x00D0) /*!< Sector Number 22  */
+#define FLASH_Sector_23    ((uint16_t)0x00D8) /*!< Sector Number 23  */
+
+#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_Sector_0)   || ((SECTOR) == FLASH_Sector_1)   ||\
+                                 ((SECTOR) == FLASH_Sector_2)   || ((SECTOR) == FLASH_Sector_3)   ||\
+                                 ((SECTOR) == FLASH_Sector_4)   || ((SECTOR) == FLASH_Sector_5)   ||\
+                                 ((SECTOR) == FLASH_Sector_6)   || ((SECTOR) == FLASH_Sector_7)   ||\
+                                 ((SECTOR) == FLASH_Sector_8)   || ((SECTOR) == FLASH_Sector_9)   ||\
+                                 ((SECTOR) == FLASH_Sector_10)  || ((SECTOR) == FLASH_Sector_11)  ||\
+                                 ((SECTOR) == FLASH_Sector_12)  || ((SECTOR) == FLASH_Sector_13)  ||\
+                                 ((SECTOR) == FLASH_Sector_14)  || ((SECTOR) == FLASH_Sector_15)  ||\
+                                 ((SECTOR) == FLASH_Sector_16)  || ((SECTOR) == FLASH_Sector_17)  ||\
+                                 ((SECTOR) == FLASH_Sector_18)  || ((SECTOR) == FLASH_Sector_19)  ||\
+                                 ((SECTOR) == FLASH_Sector_20)  || ((SECTOR) == FLASH_Sector_21)  ||\
+                                 ((SECTOR) == FLASH_Sector_22)  || ((SECTOR) == FLASH_Sector_23))
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x081FFFFF)) ||\
+                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))  
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+#if defined (STM32F40_41xxx)
+#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x080FFFFF)) ||\
+                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F))) 
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F401xx)
+#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0803FFFF)) ||\
+                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
+#endif /* STM32F401xx */
+
+#if defined (STM32F411xE)
+#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0807FFFF)) ||\
+                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
+#endif /* STM32F411xE */
+
+/**
+  * @}
+  */ 
+
+/** @defgroup Option_Bytes_Write_Protection 
+  * @{
+  */ 
+#define OB_WRP_Sector_0       ((uint32_t)0x00000001) /*!< Write protection of Sector0     */
+#define OB_WRP_Sector_1       ((uint32_t)0x00000002) /*!< Write protection of Sector1     */
+#define OB_WRP_Sector_2       ((uint32_t)0x00000004) /*!< Write protection of Sector2     */
+#define OB_WRP_Sector_3       ((uint32_t)0x00000008) /*!< Write protection of Sector3     */
+#define OB_WRP_Sector_4       ((uint32_t)0x00000010) /*!< Write protection of Sector4     */
+#define OB_WRP_Sector_5       ((uint32_t)0x00000020) /*!< Write protection of Sector5     */
+#define OB_WRP_Sector_6       ((uint32_t)0x00000040) /*!< Write protection of Sector6     */
+#define OB_WRP_Sector_7       ((uint32_t)0x00000080) /*!< Write protection of Sector7     */
+#define OB_WRP_Sector_8       ((uint32_t)0x00000100) /*!< Write protection of Sector8     */
+#define OB_WRP_Sector_9       ((uint32_t)0x00000200) /*!< Write protection of Sector9     */
+#define OB_WRP_Sector_10      ((uint32_t)0x00000400) /*!< Write protection of Sector10    */
+#define OB_WRP_Sector_11      ((uint32_t)0x00000800) /*!< Write protection of Sector11    */
+#define OB_WRP_Sector_12      ((uint32_t)0x00000001) /*!< Write protection of Sector12    */
+#define OB_WRP_Sector_13      ((uint32_t)0x00000002) /*!< Write protection of Sector13    */
+#define OB_WRP_Sector_14      ((uint32_t)0x00000004) /*!< Write protection of Sector14    */
+#define OB_WRP_Sector_15      ((uint32_t)0x00000008) /*!< Write protection of Sector15    */
+#define OB_WRP_Sector_16      ((uint32_t)0x00000010) /*!< Write protection of Sector16    */
+#define OB_WRP_Sector_17      ((uint32_t)0x00000020) /*!< Write protection of Sector17    */
+#define OB_WRP_Sector_18      ((uint32_t)0x00000040) /*!< Write protection of Sector18    */
+#define OB_WRP_Sector_19      ((uint32_t)0x00000080) /*!< Write protection of Sector19    */
+#define OB_WRP_Sector_20      ((uint32_t)0x00000100) /*!< Write protection of Sector20    */
+#define OB_WRP_Sector_21      ((uint32_t)0x00000200) /*!< Write protection of Sector21    */
+#define OB_WRP_Sector_22      ((uint32_t)0x00000400) /*!< Write protection of Sector22    */
+#define OB_WRP_Sector_23      ((uint32_t)0x00000800) /*!< Write protection of Sector23    */
+#define OB_WRP_Sector_All     ((uint32_t)0x00000FFF) /*!< Write protection of all Sectors */
+
+#define IS_OB_WRP(SECTOR)((((SECTOR) & (uint32_t)0xFFFFF000) == 0x00000000) && ((SECTOR) != 0x00000000))
+/**
+  * @}
+  */
+
+/** @defgroup  Selection_Protection_Mode
+  * @{
+  */
+#define OB_PcROP_Disable   ((uint8_t)0x00) /*!< Disabled PcROP, nWPRi bits used for Write Protection on sector i */
+#define OB_PcROP_Enable    ((uint8_t)0x80) /*!< Enable PcROP, nWPRi bits used for PCRoP Protection on sector i   */
+#define IS_OB_PCROP_SELECT(PCROP) (((PCROP) == OB_PcROP_Disable) || ((PCROP) == OB_PcROP_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup Option_Bytes_PC_ReadWrite_Protection 
+  * @{
+  */ 
+#define OB_PCROP_Sector_0        ((uint32_t)0x00000001) /*!< PC Read/Write protection of Sector0      */
+#define OB_PCROP_Sector_1        ((uint32_t)0x00000002) /*!< PC Read/Write protection of Sector1      */
+#define OB_PCROP_Sector_2        ((uint32_t)0x00000004) /*!< PC Read/Write protection of Sector2      */
+#define OB_PCROP_Sector_3        ((uint32_t)0x00000008) /*!< PC Read/Write protection of Sector3      */
+#define OB_PCROP_Sector_4        ((uint32_t)0x00000010) /*!< PC Read/Write protection of Sector4      */
+#define OB_PCROP_Sector_5        ((uint32_t)0x00000020) /*!< PC Read/Write protection of Sector5      */
+#define OB_PCROP_Sector_6        ((uint32_t)0x00000040) /*!< PC Read/Write protection of Sector6      */
+#define OB_PCROP_Sector_7        ((uint32_t)0x00000080) /*!< PC Read/Write protection of Sector7      */
+#define OB_PCROP_Sector_8        ((uint32_t)0x00000100) /*!< PC Read/Write protection of Sector8      */
+#define OB_PCROP_Sector_9        ((uint32_t)0x00000200) /*!< PC Read/Write protection of Sector9      */
+#define OB_PCROP_Sector_10       ((uint32_t)0x00000400) /*!< PC Read/Write protection of Sector10     */
+#define OB_PCROP_Sector_11       ((uint32_t)0x00000800) /*!< PC Read/Write protection of Sector11     */
+#define OB_PCROP_Sector_12       ((uint32_t)0x00000001) /*!< PC Read/Write protection of Sector12     */
+#define OB_PCROP_Sector_13       ((uint32_t)0x00000002) /*!< PC Read/Write protection of Sector13     */
+#define OB_PCROP_Sector_14       ((uint32_t)0x00000004) /*!< PC Read/Write protection of Sector14     */
+#define OB_PCROP_Sector_15       ((uint32_t)0x00000008) /*!< PC Read/Write protection of Sector15     */
+#define OB_PCROP_Sector_16       ((uint32_t)0x00000010) /*!< PC Read/Write protection of Sector16     */
+#define OB_PCROP_Sector_17       ((uint32_t)0x00000020) /*!< PC Read/Write protection of Sector17     */
+#define OB_PCROP_Sector_18       ((uint32_t)0x00000040) /*!< PC Read/Write protection of Sector18     */
+#define OB_PCROP_Sector_19       ((uint32_t)0x00000080) /*!< PC Read/Write protection of Sector19     */
+#define OB_PCROP_Sector_20       ((uint32_t)0x00000100) /*!< PC Read/Write protection of Sector20     */
+#define OB_PCROP_Sector_21       ((uint32_t)0x00000200) /*!< PC Read/Write protection of Sector21     */
+#define OB_PCROP_Sector_22       ((uint32_t)0x00000400) /*!< PC Read/Write protection of Sector22     */
+#define OB_PCROP_Sector_23       ((uint32_t)0x00000800) /*!< PC Read/Write protection of Sector23     */
+#define OB_PCROP_Sector_All      ((uint32_t)0x00000FFF) /*!< PC Read/Write protection of all Sectors  */
+
+#define IS_OB_PCROP(SECTOR)((((SECTOR) & (uint32_t)0xFFFFF000) == 0x00000000) && ((SECTOR) != 0x00000000))
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Option_Bytes_Read_Protection 
+  * @{
+  */
+#define OB_RDP_Level_0   ((uint8_t)0xAA)
+#define OB_RDP_Level_1   ((uint8_t)0x55)
+/*#define OB_RDP_Level_2   ((uint8_t)0xCC)*/ /*!< Warning: When enabling read protection level 2 
+                                                  it's no more possible to go back to level 1 or 0 */
+#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||\
+                          ((LEVEL) == OB_RDP_Level_1))/*||\
+                          ((LEVEL) == OB_RDP_Level_2))*/
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Option_Bytes_IWatchdog 
+  * @{
+  */ 
+#define OB_IWDG_SW                     ((uint8_t)0x20)  /*!< Software IWDG selected */
+#define OB_IWDG_HW                     ((uint8_t)0x00)  /*!< Hardware IWDG selected */
+#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Option_Bytes_nRST_STOP 
+  * @{
+  */ 
+#define OB_STOP_NoRST                  ((uint8_t)0x40) /*!< No reset generated when entering in STOP */
+#define OB_STOP_RST                    ((uint8_t)0x00) /*!< Reset generated when entering in STOP */
+#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup FLASH_Option_Bytes_nRST_STDBY 
+  * @{
+  */ 
+#define OB_STDBY_NoRST                 ((uint8_t)0x80) /*!< No reset generated when entering in STANDBY */
+#define OB_STDBY_RST                   ((uint8_t)0x00) /*!< Reset generated when entering in STANDBY */
+#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
+/**
+  * @}
+  */
+  
+/** @defgroup FLASH_BOR_Reset_Level 
+  * @{
+  */  
+#define OB_BOR_LEVEL3          ((uint8_t)0x00)  /*!< Supply voltage ranges from 2.70 to 3.60 V */
+#define OB_BOR_LEVEL2          ((uint8_t)0x04)  /*!< Supply voltage ranges from 2.40 to 2.70 V */
+#define OB_BOR_LEVEL1          ((uint8_t)0x08)  /*!< Supply voltage ranges from 2.10 to 2.40 V */
+#define OB_BOR_OFF             ((uint8_t)0x0C)  /*!< Supply voltage ranges from 1.62 to 2.10 V */
+#define IS_OB_BOR(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||\
+                          ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
+/**
+  * @}
+  */
+  
+/** @defgroup FLASH_Dual_Boot
+  * @{
+  */
+#define OB_Dual_BootEnabled   ((uint8_t)0x10) /*!< Dual Bank Boot Enable                             */
+#define OB_Dual_BootDisabled  ((uint8_t)0x00) /*!< Dual Bank Boot Disable, always boot on User Flash */
+#define IS_OB_BOOT(BOOT) (((BOOT) == OB_Dual_BootEnabled) || ((BOOT) == OB_Dual_BootDisabled))
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Interrupts 
+  * @{
+  */ 
+#define FLASH_IT_EOP                   ((uint32_t)0x01000000)  /*!< End of FLASH Operation Interrupt source */
+#define FLASH_IT_ERR                   ((uint32_t)0x02000000)  /*!< Error Interrupt source */
+#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFCFFFFFF) == 0x00000000) && ((IT) != 0x00000000))
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Flags 
+  * @{
+  */ 
+#define FLASH_FLAG_EOP                 ((uint32_t)0x00000001)  /*!< FLASH End of Operation flag               */
+#define FLASH_FLAG_OPERR               ((uint32_t)0x00000002)  /*!< FLASH operation Error flag                */
+#define FLASH_FLAG_WRPERR              ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag          */
+#define FLASH_FLAG_PGAERR              ((uint32_t)0x00000020)  /*!< FLASH Programming Alignment error flag    */
+#define FLASH_FLAG_PGPERR              ((uint32_t)0x00000040)  /*!< FLASH Programming Parallelism error flag  */
+#define FLASH_FLAG_PGSERR              ((uint32_t)0x00000080)  /*!< FLASH Programming Sequence error flag     */
+#define FLASH_FLAG_RDERR               ((uint32_t)0x00000100)  /*!< Read Protection error flag (PCROP)        */
+#define FLASH_FLAG_BSY                 ((uint32_t)0x00010000)  /*!< FLASH Busy flag                           */ 
+#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFE0C) == 0x00000000) && ((FLAG) != 0x00000000))
+#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_EOP)    || ((FLAG) == FLASH_FLAG_OPERR)  || \
+                                  ((FLAG) == FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_PGAERR) || \
+                                  ((FLAG) == FLASH_FLAG_PGPERR) || ((FLAG) == FLASH_FLAG_PGSERR) || \
+                                  ((FLAG) == FLASH_FLAG_BSY)    || ((FLAG) == FLASH_FLAG_RDERR))
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Program_Parallelism   
+  * @{
+  */
+#define FLASH_PSIZE_BYTE           ((uint32_t)0x00000000)
+#define FLASH_PSIZE_HALF_WORD      ((uint32_t)0x00000100)
+#define FLASH_PSIZE_WORD           ((uint32_t)0x00000200)
+#define FLASH_PSIZE_DOUBLE_WORD    ((uint32_t)0x00000300)
+#define CR_PSIZE_MASK              ((uint32_t)0xFFFFFCFF)
+/**
+  * @}
+  */ 
+
+/** @defgroup FLASH_Keys 
+  * @{
+  */ 
+#define RDP_KEY                  ((uint16_t)0x00A5)
+#define FLASH_KEY1               ((uint32_t)0x45670123)
+#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
+#define FLASH_OPT_KEY1           ((uint32_t)0x08192A3B)
+#define FLASH_OPT_KEY2           ((uint32_t)0x4C5D6E7F)
+/**
+  * @}
+  */ 
+
+/** 
+  * @brief   ACR register byte 0 (Bits[7:0]) base address  
+  */ 
+#define ACR_BYTE0_ADDRESS           ((uint32_t)0x40023C00) 
+/** 
+  * @brief   OPTCR register byte 0 (Bits[7:0]) base address  
+  */ 
+#define OPTCR_BYTE0_ADDRESS         ((uint32_t)0x40023C14)
+/** 
+  * @brief   OPTCR register byte 1 (Bits[15:8]) base address  
+  */ 
+#define OPTCR_BYTE1_ADDRESS         ((uint32_t)0x40023C15)
+/** 
+  * @brief   OPTCR register byte 2 (Bits[23:16]) base address  
+  */ 
+#define OPTCR_BYTE2_ADDRESS         ((uint32_t)0x40023C16)
+/** 
+  * @brief   OPTCR register byte 3 (Bits[31:24]) base address  
+  */ 
+#define OPTCR_BYTE3_ADDRESS         ((uint32_t)0x40023C17)
+
+/** 
+  * @brief   OPTCR1 register byte 0 (Bits[7:0]) base address  
+  */ 
+#define OPTCR1_BYTE2_ADDRESS         ((uint32_t)0x40023C1A)
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+ 
+/* FLASH Interface configuration functions ************************************/
+void FLASH_SetLatency(uint32_t FLASH_Latency);
+void FLASH_PrefetchBufferCmd(FunctionalState NewState);
+void FLASH_InstructionCacheCmd(FunctionalState NewState);
+void FLASH_DataCacheCmd(FunctionalState NewState);
+void FLASH_InstructionCacheReset(void);
+void FLASH_DataCacheReset(void);
+
+/* FLASH Memory Programming functions *****************************************/   
+void         FLASH_Unlock(void);
+void         FLASH_Lock(void);
+FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange);
+FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange);
+FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange);
+FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange);
+FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data);
+FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
+FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);
+FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data);
+
+/* Option Bytes Programming functions *****************************************/ 
+void         FLASH_OB_Unlock(void);
+void         FLASH_OB_Lock(void);
+void         FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState);
+void         FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState);
+void         FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP);
+void         FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState);
+void         FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState);
+void         FLASH_OB_RDPConfig(uint8_t OB_RDP);
+void         FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
+void         FLASH_OB_BORConfig(uint8_t OB_BOR);
+void         FLASH_OB_BootConfig(uint8_t OB_BOOT);
+FLASH_Status FLASH_OB_Launch(void);
+uint8_t      FLASH_OB_GetUser(void);
+uint16_t     FLASH_OB_GetWRP(void);
+uint16_t     FLASH_OB_GetWRP1(void);
+uint16_t     FLASH_OB_GetPCROP(void);
+uint16_t     FLASH_OB_GetPCROP1(void);
+FlagStatus   FLASH_OB_GetRDP(void);
+uint8_t      FLASH_OB_GetBOR(void);
+
+/* Interrupts and flags management functions **********************************/
+void         FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
+FlagStatus   FLASH_GetFlagStatus(uint32_t FLASH_FLAG);
+void         FLASH_ClearFlag(uint32_t FLASH_FLAG);
+FLASH_Status FLASH_GetStatus(void);
+FLASH_Status FLASH_WaitForLastOperation(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_FLASH_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash_ramfunc.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash_ramfunc.h
new file mode 100644
index 0000000..9035cb8
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash_ramfunc.h
@@ -0,0 +1,103 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_flash_ramfunc.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   Header file of FLASH RAMFUNC driver.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_FLASH_RAMFUNC_H
+#define __STM32F4xx_FLASH_RAMFUNC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup FLASH RAMFUNC
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/** 
+  * @brief  __RAM_FUNC definition
+  */ 
+#if defined ( __CC_ARM   )
+/* ARM Compiler
+   ------------
+   RAM functions are defined using the toolchain options. 
+   Functions that are executed in RAM should reside in a separate source module.
+   Using the 'Options for File' dialog you can simply change the 'Code / Const' 
+   area of a module to a memory space in physical RAM.
+   Available memory areas are declared in the 'Target' tab of the 'Options for Target'
+   dialog. 
+*/
+#define __RAM_FUNC void 
+
+#elif defined ( __ICCARM__ )
+/* ICCARM Compiler
+   ---------------
+   RAM functions are defined using a specific toolchain keyword "__ramfunc". 
+*/
+#define __RAM_FUNC __ramfunc void
+
+#elif defined   (  __GNUC__  )
+/* GNU Compiler
+   ------------
+  RAM functions are defined using a specific toolchain attribute 
+   "__attribute__((section(".RamFunc")))".
+*/
+#define __RAM_FUNC void  __attribute__((section(".RamFunc")))
+
+#endif
+/* Exported constants --------------------------------------------------------*/
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+__RAM_FUNC FLASH_FlashInterfaceCmd(FunctionalState NewState);
+__RAM_FUNC FLASH_FlashSleepModeCmd(FunctionalState NewState);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_FLASH_RAMFUNC_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fmc.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fmc.h
new file mode 100644
index 0000000..41b3c64
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fmc.h
@@ -0,0 +1,1143 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_fmc.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the FMC firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_FMC_H
+#define __STM32F4xx_FMC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup FMC
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/  
+
+/** 
+  * @brief  Timing parameters For NOR/SRAM Banks  
+  */
+typedef struct
+{
+  uint32_t FMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the address setup time. 
+                                             This parameter can be a value between 0 and 15.
+                                             @note This parameter is not used with synchronous NOR Flash memories. */
+
+  uint32_t FMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the address hold time.
+                                             This parameter can be a value between 1 and 15. 
+                                             @note This parameter is not used with synchronous NOR Flash memories.*/
+
+  uint32_t FMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the data setup time.
+                                             This parameter can be a value between 1 and 255.
+                                             @note This parameter is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */
+
+  uint32_t FMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the bus turnaround.
+                                             This parameter can be a value between 0 and 15.
+                                             @note This parameter is only used for multiplexed NOR Flash memories. */
+
+  uint32_t FMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
+                                             This parameter can be a value between 1 and 15.
+                                             @note This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */
+
+  uint32_t FMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue
+                                             to the memory before getting the first data.
+                                             The parameter value depends on the memory type as shown below:
+                                              - It must be set to 0 in case of a CRAM
+                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
+                                              - It may assume a value between 0 and 15 in NOR Flash memories
+                                                with synchronous burst mode enable */
+
+  uint32_t FMC_AccessMode;             /*!< Specifies the asynchronous access mode. 
+                                             This parameter can be a value of @ref FMC_Access_Mode */
+}FMC_NORSRAMTimingInitTypeDef;
+
+/** 
+  * @brief  FMC NOR/SRAM Init structure definition
+  */
+typedef struct
+{
+  uint32_t FMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.
+                                          This parameter can be a value of @ref FMC_NORSRAM_Bank */
+
+  uint32_t FMC_DataAddressMux;      /*!< Specifies whether the address and data values are
+                                          multiplexed on the databus or not. 
+                                          This parameter can be a value of @ref FMC_Data_Address_Bus_Multiplexing */
+
+  uint32_t FMC_MemoryType;          /*!< Specifies the type of external memory attached to
+                                          the corresponding memory bank.
+                                          This parameter can be a value of @ref FMC_Memory_Type */
+
+  uint32_t FMC_MemoryDataWidth;     /*!< Specifies the external memory device width.
+                                          This parameter can be a value of @ref FMC_NORSRAM_Data_Width */
+
+  uint32_t FMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,
+                                          valid only with synchronous burst Flash memories.
+                                          This parameter can be a value of @ref FMC_Burst_Access_Mode */                                        
+
+  uint32_t FMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing
+                                          the Flash memory in burst mode.
+                                          This parameter can be a value of @ref FMC_Wait_Signal_Polarity */
+
+  uint32_t FMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash
+                                          memory, valid only when accessing Flash memories in burst mode.
+                                          This parameter can be a value of @ref FMC_Wrap_Mode */
+
+  uint32_t FMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one
+                                          clock cycle before the wait state or during the wait state,
+                                          valid only when accessing memories in burst mode. 
+                                          This parameter can be a value of @ref FMC_Wait_Timing */
+
+  uint32_t FMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FMC. 
+                                          This parameter can be a value of @ref FMC_Write_Operation */
+
+  uint32_t FMC_WaitSignal;          /*!< Enables or disables the wait state insertion via wait
+                                          signal, valid for Flash memory access in burst mode. 
+                                          This parameter can be a value of @ref FMC_Wait_Signal */
+
+  uint32_t FMC_ExtendedMode;        /*!< Enables or disables the extended mode.
+                                          This parameter can be a value of @ref FMC_Extended_Mode */
+  
+  uint32_t FMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,
+                                          valid only with asynchronous Flash memories.
+                                          This parameter can be a value of @ref FMC_AsynchronousWait */  
+
+  uint32_t FMC_WriteBurst;          /*!< Enables or disables the write burst operation.
+                                          This parameter can be a value of @ref FMC_Write_Burst */ 
+
+  uint32_t FMC_ContinousClock;       /*!< Enables or disables the FMC clock output to external memory devices.
+                                          This parameter is only enabled through the FMC_BCR1 register, and don't care 
+                                          through FMC_BCR2..4 registers.
+                                          This parameter can be a value of @ref FMC_Continous_Clock */ 
+
+  
+  FMC_NORSRAMTimingInitTypeDef* FMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  Extended Mode is not used*/  
+
+  FMC_NORSRAMTimingInitTypeDef* FMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  Extended Mode is used*/      
+}FMC_NORSRAMInitTypeDef;
+
+/** 
+  * @brief  Timing parameters For FMC NAND and PCCARD Banks
+  */
+typedef struct
+{
+  uint32_t FMC_SetupTime;      /*!< Defines the number of HCLK cycles to setup address before
+                                     the command assertion for NAND-Flash read or write access
+                                     to common/Attribute or I/O memory space (depending on
+                                     the memory space timing to be configured).
+                                     This parameter can be a value between 0 and 255.*/
+
+  uint32_t FMC_WaitSetupTime;  /*!< Defines the minimum number of HCLK cycles to assert the
+                                     command for NAND-Flash read or write access to
+                                     common/Attribute or I/O memory space (depending on the
+                                     memory space timing to be configured). 
+                                     This parameter can be a number between 0 and 255 */
+
+  uint32_t FMC_HoldSetupTime;  /*!< Defines the number of HCLK clock cycles to hold address
+                                     (and data for write access) after the command de-assertion
+                                     for NAND-Flash read or write access to common/Attribute
+                                     or I/O memory space (depending on the memory space timing
+                                     to be configured).
+                                     This parameter can be a number between 0 and 255 */
+
+  uint32_t FMC_HiZSetupTime;   /*!< Defines the number of HCLK clock cycles during which the
+                                     databus is kept in HiZ after the start of a NAND-Flash
+                                     write access to common/Attribute or I/O memory space (depending
+                                     on the memory space timing to be configured).
+                                     This parameter can be a number between 0 and 255 */
+}FMC_NAND_PCCARDTimingInitTypeDef;
+
+/** 
+  * @brief  FMC NAND Init structure definition
+  */
+typedef struct
+{
+  uint32_t FMC_Bank;              /*!< Specifies the NAND memory bank that will be used.
+                                      This parameter can be a value of @ref FMC_NAND_Bank */
+
+  uint32_t FMC_Waitfeature;      /*!< Enables or disables the Wait feature for the NAND Memory Bank.
+                                       This parameter can be any value of @ref FMC_Wait_feature */
+
+  uint32_t FMC_MemoryDataWidth;  /*!< Specifies the external memory device width.
+                                       This parameter can be any value of @ref FMC_NAND_Data_Width */
+
+  uint32_t FMC_ECC;              /*!< Enables or disables the ECC computation.
+                                       This parameter can be any value of @ref FMC_ECC */
+
+  uint32_t FMC_ECCPageSize;      /*!< Defines the page size for the extended ECC.
+                                       This parameter can be any value of @ref FMC_ECC_Page_Size */
+
+  uint32_t FMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the
+                                       delay between CLE low and RE low.
+                                       This parameter can be a value between 0 and 255. */
+
+  uint32_t FMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the
+                                       delay between ALE low and RE low.
+                                       This parameter can be a number between 0 and 255 */ 
+
+  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_CommonSpaceTimingStruct;   /*!< FMC Common Space Timing */ 
+
+  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_AttributeSpaceTimingStruct; /*!< FMC Attribute Space Timing */
+}FMC_NANDInitTypeDef;
+
+/** 
+  * @brief  FMC PCCARD Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t FMC_Waitfeature;    /*!< Enables or disables the Wait feature for the Memory Bank.
+                                    This parameter can be any value of @ref FMC_Wait_feature */
+
+  uint32_t FMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the
+                                     delay between CLE low and RE low.
+                                     This parameter can be a value between 0 and 255. */
+
+  uint32_t FMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the
+                                     delay between ALE low and RE low.
+                                     This parameter can be a number between 0 and 255 */ 
+
+  
+  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_CommonSpaceTimingStruct; /*!< FMC Common Space Timing */
+
+  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_AttributeSpaceTimingStruct;  /*!< FMC Attribute Space Timing */ 
+  
+  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_IOSpaceTimingStruct; /*!< FMC IO Space Timing */  
+}FMC_PCCARDInitTypeDef;
+
+/** 
+  * @brief  Timing parameters for FMC SDRAM Banks
+  */
+  
+typedef struct
+{
+  uint32_t FMC_LoadToActiveDelay;      /*!< Defines the delay between a Load Mode Register command and 
+                                            an active or Refresh command in number of memory clock cycles.
+                                            This parameter can be a value between 1 and 16. */
+  
+  uint32_t FMC_ExitSelfRefreshDelay;   /*!< Defines the delay from releasing the self refresh command to 
+                                            issuing the Activate command in number of memory clock cycles.
+                                            This parameter can be a value between 1 and 16. */
+   
+  uint32_t FMC_SelfRefreshTime;        /*!< Defines the minimum Self Refresh period in number of memory clock 
+                                            cycles.
+                                            This parameter can be a value between 1 and 16. */
+                                            
+  uint32_t FMC_RowCycleDelay;          /*!< Defines the delay between the Refresh command and the Activate command
+                                            and the delay between two consecutive Refresh commands in number of 
+                                            memory clock cycles.
+                                            This parameter can be a value between 1 and 16. */
+                                            
+  uint32_t FMC_WriteRecoveryTime;      /*!< Defines the Write recovery Time in number of memory clock cycles.
+                                            This parameter can be a value between 1 and 16. */
+                                            
+  uint32_t FMC_RPDelay;                /*!< Defines the delay between a Precharge Command and an other command 
+                                            in number of memory clock cycles.
+                                            This parameter can be a value between 1 and 16. */
+                                            
+  uint32_t FMC_RCDDelay;               /*!< Defines the delay between the Activate Command and a Read/Write command
+                                            in number of memory clock cycles.
+                                            This parameter can be a value between 1 and 16. */
+                                            
+}FMC_SDRAMTimingInitTypeDef;
+
+/** 
+  * @brief  Command parameters for FMC SDRAM Banks
+  */
+
+
+typedef struct
+{
+  uint32_t FMC_CommandMode;            /*!< Defines the command issued to the SDRAM device.
+                                            This parameter can be a value of @ref FMC_Command_Mode. */
+                                            
+  uint32_t FMC_CommandTarget;          /*!< Defines which bank (1 or 2) the command will be issued to.
+                                            This parameter can be a value of @ref FMC_Command_Target. */
+                                            
+  uint32_t FMC_AutoRefreshNumber;      /*!< Defines the number of consecutive auto refresh command issued
+                                            in auto refresh mode.
+                                            This parameter can be a value between 1 and 16. */                                           
+                                                                                                             
+  uint32_t FMC_ModeRegisterDefinition; /*!< Defines the SDRAM Mode register content */
+  
+}FMC_SDRAMCommandTypeDef;
+
+/** 
+  * @brief  FMC SDRAM Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t FMC_Bank;                   /*!< Specifies the SDRAM memory bank that will be used.
+                                          This parameter can be a value of @ref FMC_SDRAM_Bank */
+
+  uint32_t FMC_ColumnBitsNumber;       /*!< Defines the number of bits of column address.
+                                            This parameter can be a value of @ref FMC_ColumnBits_Number. */
+                                            
+  uint32_t FMC_RowBitsNumber;          /*!< Defines the number of bits of column address..
+                                            This parameter can be a value of @ref FMC_RowBits_Number. */
+                                            
+  uint32_t FMC_SDMemoryDataWidth;        /*!< Defines the memory device width.
+                                            This parameter can be a value of @ref FMC_SDMemory_Data_Width. */
+                                            
+  uint32_t FMC_InternalBankNumber;     /*!< Defines the number of bits of column address.
+                                            This parameter can be of @ref FMC_InternalBank_Number. */
+                                            
+  uint32_t FMC_CASLatency;             /*!< Defines the SDRAM CAS latency in number of memory clock cycles.
+                                            This parameter can be a value of @ref FMC_CAS_Latency. */
+                                            
+  uint32_t FMC_WriteProtection;        /*!< Enables the SDRAM bank to be accessed in write mode.
+                                            This parameter can be a value of @ref FMC_Write_Protection. */
+                                            
+  uint32_t FMC_SDClockPeriod;          /*!< Define the SDRAM Clock Period for both SDRAM Banks and they allow to disable
+                                            the clock before changing frequency.
+                                            This parameter can be a value of @ref FMC_SDClock_Period. */
+                                            
+  uint32_t FMC_ReadBurst;              /*!< This bit enable the SDRAM controller to anticipate the next read commands 
+                                            during the CAS latency and stores data in the Read FIFO.
+                                            This parameter can be a value of @ref FMC_Read_Burst. */
+                                            
+  uint32_t FMC_ReadPipeDelay;          /*!< Define the delay in system clock cycles on read data path.
+                                            This parameter can be a value of @ref FMC_ReadPipe_Delay. */
+                                            
+  FMC_SDRAMTimingInitTypeDef* FMC_SDRAMTimingStruct;   /*!< Timing Parameters for write and read access*/                                            
+  
+}FMC_SDRAMInitTypeDef;
+
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup FMC_Exported_Constants
+  * @{
+  */ 
+
+/** @defgroup FMC_NORSRAM_Bank 
+  * @{
+  */
+#define FMC_Bank1_NORSRAM1                      ((uint32_t)0x00000000)
+#define FMC_Bank1_NORSRAM2                      ((uint32_t)0x00000002)
+#define FMC_Bank1_NORSRAM3                      ((uint32_t)0x00000004)
+#define FMC_Bank1_NORSRAM4                      ((uint32_t)0x00000006)
+
+#define IS_FMC_NORSRAM_BANK(BANK) (((BANK) == FMC_Bank1_NORSRAM1) || \
+                                   ((BANK) == FMC_Bank1_NORSRAM2) || \
+                                   ((BANK) == FMC_Bank1_NORSRAM3) || \
+                                   ((BANK) == FMC_Bank1_NORSRAM4))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_NAND_Bank 
+  * @{
+  */  
+#define FMC_Bank2_NAND                          ((uint32_t)0x00000010)
+#define FMC_Bank3_NAND                          ((uint32_t)0x00000100)
+
+#define IS_FMC_NAND_BANK(BANK) (((BANK) == FMC_Bank2_NAND) || \
+                                ((BANK) == FMC_Bank3_NAND))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_PCCARD_Bank 
+  * @{
+  */    
+#define FMC_Bank4_PCCARD                        ((uint32_t)0x00001000)
+/**
+  * @}                                                         
+  */
+
+/** @defgroup FMC_SDRAM_Bank
+  * @{
+  */
+#define FMC_Bank1_SDRAM                    ((uint32_t)0x00000000)
+#define FMC_Bank2_SDRAM                    ((uint32_t)0x00000001)
+
+#define IS_FMC_SDRAM_BANK(BANK) (((BANK) == FMC_Bank1_SDRAM) || \
+                                 ((BANK) == FMC_Bank2_SDRAM)) 
+
+/**
+  * @}
+  */                               
+
+                              
+/** @defgroup FMC_NOR_SRAM_Controller 
+  * @{
+  */
+
+/** @defgroup FMC_Data_Address_Bus_Multiplexing 
+  * @{
+  */
+
+#define FMC_DataAddressMux_Disable                ((uint32_t)0x00000000)
+#define FMC_DataAddressMux_Enable                 ((uint32_t)0x00000002)
+
+#define IS_FMC_MUX(MUX) (((MUX) == FMC_DataAddressMux_Disable) || \
+                         ((MUX) == FMC_DataAddressMux_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Memory_Type 
+  * @{
+  */
+
+#define FMC_MemoryType_SRAM                     ((uint32_t)0x00000000)
+#define FMC_MemoryType_PSRAM                    ((uint32_t)0x00000004)
+#define FMC_MemoryType_NOR                      ((uint32_t)0x00000008)
+
+#define IS_FMC_MEMORY(MEMORY) (((MEMORY) == FMC_MemoryType_SRAM) || \
+                               ((MEMORY) == FMC_MemoryType_PSRAM)|| \
+                               ((MEMORY) == FMC_MemoryType_NOR))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_NORSRAM_Data_Width 
+  * @{
+  */
+
+#define FMC_NORSRAM_MemoryDataWidth_8b                  ((uint32_t)0x00000000)
+#define FMC_NORSRAM_MemoryDataWidth_16b                 ((uint32_t)0x00000010)
+#define FMC_NORSRAM_MemoryDataWidth_32b                 ((uint32_t)0x00000020)
+
+#define IS_FMC_NORSRAM_MEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_NORSRAM_MemoryDataWidth_8b)  || \
+                                            ((WIDTH) == FMC_NORSRAM_MemoryDataWidth_16b) || \
+                                            ((WIDTH) == FMC_NORSRAM_MemoryDataWidth_32b))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Burst_Access_Mode 
+  * @{
+  */
+
+#define FMC_BurstAccessMode_Disable             ((uint32_t)0x00000000) 
+#define FMC_BurstAccessMode_Enable              ((uint32_t)0x00000100)
+
+#define IS_FMC_BURSTMODE(STATE) (((STATE) == FMC_BurstAccessMode_Disable) || \
+                                  ((STATE) == FMC_BurstAccessMode_Enable))
+/**
+  * @}
+  */
+    
+/** @defgroup FMC_AsynchronousWait 
+  * @{
+  */
+#define FMC_AsynchronousWait_Disable            ((uint32_t)0x00000000)
+#define FMC_AsynchronousWait_Enable             ((uint32_t)0x00008000)
+
+#define IS_FMC_ASYNWAIT(STATE) (((STATE) == FMC_AsynchronousWait_Disable) || \
+                                 ((STATE) == FMC_AsynchronousWait_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Wait_Signal_Polarity 
+  * @{
+  */
+#define FMC_WaitSignalPolarity_Low              ((uint32_t)0x00000000)
+#define FMC_WaitSignalPolarity_High             ((uint32_t)0x00000200)
+
+#define IS_FMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FMC_WaitSignalPolarity_Low) || \
+                                         ((POLARITY) == FMC_WaitSignalPolarity_High))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Wrap_Mode 
+  * @{
+  */
+#define FMC_WrapMode_Disable                    ((uint32_t)0x00000000)
+#define FMC_WrapMode_Enable                     ((uint32_t)0x00000400) 
+
+#define IS_FMC_WRAP_MODE(MODE) (((MODE) == FMC_WrapMode_Disable) || \
+                                 ((MODE) == FMC_WrapMode_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Wait_Timing 
+  * @{
+  */
+#define FMC_WaitSignalActive_BeforeWaitState    ((uint32_t)0x00000000)
+#define FMC_WaitSignalActive_DuringWaitState    ((uint32_t)0x00000800) 
+
+#define IS_FMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FMC_WaitSignalActive_BeforeWaitState) || \
+                                            ((ACTIVE) == FMC_WaitSignalActive_DuringWaitState))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Write_Operation 
+  * @{
+  */
+#define FMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
+#define FMC_WriteOperation_Enable                      ((uint32_t)0x00001000)
+
+#define IS_FMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FMC_WriteOperation_Disable) || \
+                                            ((OPERATION) == FMC_WriteOperation_Enable))                         
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Wait_Signal 
+  * @{
+  */
+#define FMC_WaitSignal_Disable                  ((uint32_t)0x00000000)
+#define FMC_WaitSignal_Enable                   ((uint32_t)0x00002000) 
+
+#define IS_FMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FMC_WaitSignal_Disable) || \
+                                      ((SIGNAL) == FMC_WaitSignal_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Extended_Mode 
+  * @{
+  */
+#define FMC_ExtendedMode_Disable                ((uint32_t)0x00000000)
+#define FMC_ExtendedMode_Enable                 ((uint32_t)0x00004000)
+
+#define IS_FMC_EXTENDED_MODE(MODE) (((MODE) == FMC_ExtendedMode_Disable) || \
+                                     ((MODE) == FMC_ExtendedMode_Enable)) 
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Write_Burst 
+  * @{
+  */
+
+#define FMC_WriteBurst_Disable                  ((uint32_t)0x00000000)
+#define FMC_WriteBurst_Enable                   ((uint32_t)0x00080000) 
+
+#define IS_FMC_WRITE_BURST(BURST) (((BURST) == FMC_WriteBurst_Disable) || \
+                                    ((BURST) == FMC_WriteBurst_Enable))
+/**
+  * @}
+  */
+  
+/** @defgroup FMC_Continous_Clock 
+  * @{
+  */
+
+#define FMC_CClock_SyncOnly                     ((uint32_t)0x00000000)
+#define FMC_CClock_SyncAsync                    ((uint32_t)0x00100000) 
+
+#define IS_FMC_CONTINOUS_CLOCK(CCLOCK) (((CCLOCK) == FMC_CClock_SyncOnly) || \
+                                        ((CCLOCK) == FMC_CClock_SyncAsync))
+/**
+  * @}
+  */  
+
+/** @defgroup FMC_Address_Setup_Time 
+  * @{
+  */
+#define IS_FMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 15)
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Address_Hold_Time 
+  * @{
+  */
+#define IS_FMC_ADDRESS_HOLD_TIME(TIME) (((TIME) > 0) && ((TIME) <= 15))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Data_Setup_Time 
+  * @{
+  */
+#define IS_FMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 255))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Bus_Turn_around_Duration 
+  * @{
+  */
+#define IS_FMC_TURNAROUND_TIME(TIME) ((TIME) <= 15)
+/**
+  * @}
+  */
+
+/** @defgroup FMC_CLK_Division 
+  * @{
+  */
+#define IS_FMC_CLK_DIV(DIV) (((DIV) > 0) && ((DIV) <= 15))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Data_Latency 
+  * @{
+  */
+#define IS_FMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 15)
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Access_Mode 
+  * @{
+  */
+#define FMC_AccessMode_A                        ((uint32_t)0x00000000)
+#define FMC_AccessMode_B                        ((uint32_t)0x10000000) 
+#define FMC_AccessMode_C                        ((uint32_t)0x20000000)
+#define FMC_AccessMode_D                        ((uint32_t)0x30000000)
+
+#define IS_FMC_ACCESS_MODE(MODE) (((MODE) == FMC_AccessMode_A)  || \
+                                   ((MODE) == FMC_AccessMode_B) || \
+                                   ((MODE) == FMC_AccessMode_C) || \
+                                   ((MODE) == FMC_AccessMode_D))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+  
+/** @defgroup FMC_NAND_PCCARD_Controller 
+  * @{
+  */
+
+/** @defgroup FMC_Wait_feature 
+  * @{
+  */
+#define FMC_Waitfeature_Disable                 ((uint32_t)0x00000000)
+#define FMC_Waitfeature_Enable                  ((uint32_t)0x00000002)
+
+#define IS_FMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FMC_Waitfeature_Disable) || \
+                                       ((FEATURE) == FMC_Waitfeature_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_NAND_Data_Width 
+  * @{
+  */
+#define FMC_NAND_MemoryDataWidth_8b             ((uint32_t)0x00000000)
+#define FMC_NAND_MemoryDataWidth_16b            ((uint32_t)0x00000010)
+
+#define IS_FMC_NAND_MEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_NAND_MemoryDataWidth_8b) || \
+                                         ((WIDTH) == FMC_NAND_MemoryDataWidth_16b))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_ECC 
+  * @{
+  */
+#define FMC_ECC_Disable                         ((uint32_t)0x00000000)
+#define FMC_ECC_Enable                          ((uint32_t)0x00000040)
+
+#define IS_FMC_ECC_STATE(STATE) (((STATE) == FMC_ECC_Disable) || \
+                                  ((STATE) == FMC_ECC_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_ECC_Page_Size 
+  * @{
+  */
+#define FMC_ECCPageSize_256Bytes                ((uint32_t)0x00000000)
+#define FMC_ECCPageSize_512Bytes                ((uint32_t)0x00020000)
+#define FMC_ECCPageSize_1024Bytes               ((uint32_t)0x00040000)
+#define FMC_ECCPageSize_2048Bytes               ((uint32_t)0x00060000)
+#define FMC_ECCPageSize_4096Bytes               ((uint32_t)0x00080000)
+#define FMC_ECCPageSize_8192Bytes               ((uint32_t)0x000A0000)
+
+#define IS_FMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FMC_ECCPageSize_256Bytes)   || \
+                                    ((SIZE) == FMC_ECCPageSize_512Bytes)  || \
+                                    ((SIZE) == FMC_ECCPageSize_1024Bytes) || \
+                                    ((SIZE) == FMC_ECCPageSize_2048Bytes) || \
+                                    ((SIZE) == FMC_ECCPageSize_4096Bytes) || \
+                                    ((SIZE) == FMC_ECCPageSize_8192Bytes))
+/**
+  * @}
+  */
+
+/** @defgroup FMC_TCLR_Setup_Time 
+  * @{
+  */
+#define IS_FMC_TCLR_TIME(TIME) ((TIME) <= 255)
+/**
+  * @}
+  */
+
+/** @defgroup FMC_TAR_Setup_Time 
+  * @{
+  */
+#define IS_FMC_TAR_TIME(TIME) ((TIME) <= 255)
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Setup_Time 
+  * @{
+  */
+#define IS_FMC_SETUP_TIME(TIME) ((TIME) <= 255)
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Wait_Setup_Time 
+  * @{
+  */
+#define IS_FMC_WAIT_TIME(TIME) ((TIME) <= 255)
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Hold_Setup_Time 
+  * @{
+  */
+#define IS_FMC_HOLD_TIME(TIME) ((TIME) <= 255)
+/**
+  * @}
+  */
+
+/** @defgroup FMC_HiZ_Setup_Time 
+  * @{
+  */
+#define IS_FMC_HIZ_TIME(TIME) ((TIME) <= 255)
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */  
+
+
+/** @defgroup FMC_NOR_SRAM_Controller 
+  * @{
+  */
+        
+/** @defgroup FMC_ColumnBits_Number 
+  * @{
+  */
+#define FMC_ColumnBits_Number_8b           ((uint32_t)0x00000000)
+#define FMC_ColumnBits_Number_9b           ((uint32_t)0x00000001)
+#define FMC_ColumnBits_Number_10b          ((uint32_t)0x00000002)
+#define FMC_ColumnBits_Number_11b          ((uint32_t)0x00000003)
+
+#define IS_FMC_COLUMNBITS_NUMBER(COLUMN) (((COLUMN) == FMC_ColumnBits_Number_8b)  || \
+                                          ((COLUMN) == FMC_ColumnBits_Number_9b)  || \
+                                          ((COLUMN) == FMC_ColumnBits_Number_10b) || \
+                                          ((COLUMN) == FMC_ColumnBits_Number_11b))
+
+/**
+  * @}
+  */
+  
+/** @defgroup FMC_RowBits_Number 
+  * @{
+  */
+#define FMC_RowBits_Number_11b             ((uint32_t)0x00000000)
+#define FMC_RowBits_Number_12b             ((uint32_t)0x00000004)
+#define FMC_RowBits_Number_13b             ((uint32_t)0x00000008)
+
+#define IS_FMC_ROWBITS_NUMBER(ROW) (((ROW) == FMC_RowBits_Number_11b) || \
+                                    ((ROW) == FMC_RowBits_Number_12b) || \
+                                    ((ROW) == FMC_RowBits_Number_13b))
+
+/**
+  * @}
+  */  
+
+/** @defgroup FMC_SDMemory_Data_Width 
+  * @{
+  */
+#define FMC_SDMemory_Width_8b                ((uint32_t)0x00000000)
+#define FMC_SDMemory_Width_16b               ((uint32_t)0x00000010)
+#define FMC_SDMemory_Width_32b               ((uint32_t)0x00000020)
+
+#define IS_FMC_SDMEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_SDMemory_Width_8b)  || \
+                                      ((WIDTH) == FMC_SDMemory_Width_16b) || \
+                                      ((WIDTH) == FMC_SDMemory_Width_32b))
+
+/**
+  * @}
+  */
+  
+/** @defgroup FMC_InternalBank_Number
+  * @{
+  */
+#define FMC_InternalBank_Number_2          ((uint32_t)0x00000000)
+#define FMC_InternalBank_Number_4          ((uint32_t)0x00000040)
+
+#define IS_FMC_INTERNALBANK_NUMBER(NUMBER) (((NUMBER) == FMC_InternalBank_Number_2) || \
+                                            ((NUMBER) == FMC_InternalBank_Number_4)) 
+
+/**
+  * @}
+  */  
+  
+  
+/** @defgroup FMC_CAS_Latency 
+  * @{
+  */
+#define FMC_CAS_Latency_1                  ((uint32_t)0x00000080)
+#define FMC_CAS_Latency_2                  ((uint32_t)0x00000100)
+#define FMC_CAS_Latency_3                  ((uint32_t)0x00000180)
+
+#define IS_FMC_CAS_LATENCY(LATENCY) (((LATENCY) == FMC_CAS_Latency_1) || \
+                                     ((LATENCY) == FMC_CAS_Latency_2) || \
+                                     ((LATENCY) == FMC_CAS_Latency_3))
+
+/**
+  * @}
+  */  
+
+/** @defgroup FMC_Write_Protection
+  * @{
+  */
+#define FMC_Write_Protection_Disable       ((uint32_t)0x00000000)
+#define FMC_Write_Protection_Enable        ((uint32_t)0x00000200)
+
+#define IS_FMC_WRITE_PROTECTION(WRITE) (((WRITE) == FMC_Write_Protection_Disable) || \
+                                        ((WRITE) == FMC_Write_Protection_Enable))
+
+/**
+  * @}
+  */  
+  
+
+/** @defgroup FMC_SDClock_Period
+  * @{
+  */
+#define FMC_SDClock_Disable                ((uint32_t)0x00000000)
+#define FMC_SDClock_Period_2               ((uint32_t)0x00000800)
+#define FMC_SDClock_Period_3               ((uint32_t)0x00000C00)
+
+#define IS_FMC_SDCLOCK_PERIOD(PERIOD) (((PERIOD) == FMC_SDClock_Disable) || \
+                                       ((PERIOD) == FMC_SDClock_Period_2) || \
+                                       ((PERIOD) == FMC_SDClock_Period_3))
+
+/**
+  * @}
+  */ 
+  
+/** @defgroup FMC_Read_Burst
+  * @{
+  */
+#define FMC_Read_Burst_Disable             ((uint32_t)0x00000000)
+#define FMC_Read_Burst_Enable              ((uint32_t)0x00001000)
+
+#define IS_FMC_READ_BURST(RBURST) (((RBURST) == FMC_Read_Burst_Disable) || \
+                                   ((RBURST) == FMC_Read_Burst_Enable))
+
+/**
+  * @}
+  */
+
+/** @defgroup FMC_ReadPipe_Delay
+  * @{
+  */
+#define FMC_ReadPipe_Delay_0               ((uint32_t)0x00000000)
+#define FMC_ReadPipe_Delay_1               ((uint32_t)0x00002000)
+#define FMC_ReadPipe_Delay_2               ((uint32_t)0x00004000)
+
+#define IS_FMC_READPIPE_DELAY(DELAY) (((DELAY) == FMC_ReadPipe_Delay_0) || \
+                                      ((DELAY) == FMC_ReadPipe_Delay_1) || \
+                                      ((DELAY) == FMC_ReadPipe_Delay_2))
+
+/**
+  * @}
+  */
+  
+/** @defgroup FMC_LoadToActive_Delay
+  * @{
+  */
+#define IS_FMC_LOADTOACTIVE_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))
+/**
+  * @}
+  */
+  
+/** @defgroup FMC_ExitSelfRefresh_Delay
+  * @{
+  */
+#define IS_FMC_EXITSELFREFRESH_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))
+/**
+  * @}
+  */ 
+     
+/** @defgroup FMC_SelfRefresh_Time
+  * @{
+  */  
+#define IS_FMC_SELFREFRESH_TIME(TIME) (((TIME) > 0) && ((TIME) <= 16))
+/**
+  * @}
+  */
+  
+/** @defgroup FMC_RowCycle_Delay
+  * @{
+  */  
+#define IS_FMC_ROWCYCLE_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))
+/**
+  * @}
+  */  
+  
+/** @defgroup FMC_Write_Recovery_Time
+  * @{
+  */  
+#define IS_FMC_WRITE_RECOVERY_TIME(TIME) (((TIME) > 0) && ((TIME) <= 16))
+/**
+  * @}
+  */         
+  
+/** @defgroup FMC_RP_Delay
+  * @{
+  */  
+#define IS_FMC_RP_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))
+/**
+  * @}
+  */ 
+  
+/** @defgroup FMC_RCD_Delay 
+  * @{
+  */  
+#define IS_FMC_RCD_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))
+
+/**
+  * @}
+  */  
+  
+/** @defgroup FMC_Command_Mode
+  * @{
+  */
+#define FMC_Command_Mode_normal            ((uint32_t)0x00000000)
+#define FMC_Command_Mode_CLK_Enabled       ((uint32_t)0x00000001)
+#define FMC_Command_Mode_PALL              ((uint32_t)0x00000002)
+#define FMC_Command_Mode_AutoRefresh       ((uint32_t)0x00000003)
+#define FMC_Command_Mode_LoadMode          ((uint32_t)0x00000004)
+#define FMC_Command_Mode_Selfrefresh       ((uint32_t)0x00000005)
+#define FMC_Command_Mode_PowerDown         ((uint32_t)0x00000006)
+
+#define IS_FMC_COMMAND_MODE(COMMAND) (((COMMAND) == FMC_Command_Mode_normal)      || \
+                                      ((COMMAND) == FMC_Command_Mode_CLK_Enabled) || \
+                                      ((COMMAND) == FMC_Command_Mode_PALL)        || \
+                                      ((COMMAND) == FMC_Command_Mode_AutoRefresh) || \
+                                      ((COMMAND) == FMC_Command_Mode_LoadMode)    || \
+                                      ((COMMAND) == FMC_Command_Mode_Selfrefresh) || \
+                                      ((COMMAND) == FMC_Command_Mode_PowerDown))
+
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Command_Target
+  * @{
+  */
+#define FMC_Command_Target_bank2           ((uint32_t)0x00000008)
+#define FMC_Command_Target_bank1           ((uint32_t)0x00000010)
+#define FMC_Command_Target_bank1_2         ((uint32_t)0x00000018)
+
+#define IS_FMC_COMMAND_TARGET(TARGET) (((TARGET) == FMC_Command_Target_bank1) || \
+                                       ((TARGET) == FMC_Command_Target_bank2) || \
+                                       ((TARGET) == FMC_Command_Target_bank1_2))
+
+/**
+  * @}
+  */   
+  
+/** @defgroup FMC_AutoRefresh_Number
+  * @{
+  */  
+#define IS_FMC_AUTOREFRESH_NUMBER(NUMBER) (((NUMBER) > 0) && ((NUMBER) <= 16))
+
+/**
+  * @}
+  */
+
+/** @defgroup FMC_ModeRegister_Definition
+  * @{
+  */
+#define IS_FMC_MODE_REGISTER(CONTENT) ((CONTENT) <= 8191)
+
+/**
+  * @}
+  */
+  
+
+/** @defgroup FMC_Mode_Status 
+  * @{
+  */
+#define FMC_NormalMode_Status                     ((uint32_t)0x00000000)
+#define FMC_SelfRefreshMode_Status                FMC_SDSR_MODES1_0
+#define FMC_PowerDownMode_Status                  FMC_SDSR_MODES1_1
+
+#define IS_FMC_MODE_STATUS(STATUS) (((STATUS) == FMC_NormalMode_Status)       || \
+                                    ((STATUS) == FMC_SelfRefreshMode_Status)  || \
+                                    ((STATUS) == FMC_PowerDownMode_Status))
+
+
+/**
+  * @}
+  */      
+
+/**
+  * @}
+  */  
+
+/** @defgroup FMC_Interrupt_sources 
+  * @{
+  */
+#define FMC_IT_RisingEdge                       ((uint32_t)0x00000008)
+#define FMC_IT_Level                            ((uint32_t)0x00000010)
+#define FMC_IT_FallingEdge                      ((uint32_t)0x00000020)
+#define FMC_IT_Refresh                          ((uint32_t)0x00004000)
+
+#define IS_FMC_IT(IT) ((((IT) & (uint32_t)0xFFFFBFC7) == 0x00000000) && ((IT) != 0x00000000))
+#define IS_FMC_GET_IT(IT) (((IT) == FMC_IT_RisingEdge)  || \
+                           ((IT) == FMC_IT_Level)       || \
+                           ((IT) == FMC_IT_FallingEdge) || \
+                           ((IT) == FMC_IT_Refresh)) 
+                           
+#define IS_FMC_IT_BANK(BANK) (((BANK) == FMC_Bank2_NAND)   || \
+                              ((BANK) == FMC_Bank3_NAND)   || \
+                              ((BANK) == FMC_Bank4_PCCARD) || \
+                              ((BANK) == FMC_Bank1_SDRAM)  || \
+                              ((BANK) == FMC_Bank2_SDRAM))                           
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Flags 
+  * @{
+  */
+#define FMC_FLAG_RisingEdge                     ((uint32_t)0x00000001)
+#define FMC_FLAG_Level                          ((uint32_t)0x00000002)
+#define FMC_FLAG_FallingEdge                    ((uint32_t)0x00000004)
+#define FMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
+#define FMC_FLAG_Refresh                        FMC_SDSR_RE
+#define FMC_FLAG_Busy                           FMC_SDSR_BUSY
+
+#define IS_FMC_GET_FLAG(FLAG) (((FLAG) == FMC_FLAG_RisingEdge)       || \
+                               ((FLAG) == FMC_FLAG_Level)            || \
+                               ((FLAG) == FMC_FLAG_FallingEdge)      || \
+                               ((FLAG) == FMC_FLAG_FEMPT)            || \
+                               ((FLAG) == FMC_FLAG_Refresh)          || \
+                               ((FLAG) == FMC_SDSR_BUSY))
+
+#define IS_FMC_GETFLAG_BANK(BANK) (((BANK) == FMC_Bank2_NAND)    || \
+                                   ((BANK) == FMC_Bank3_NAND)    || \
+                                   ((BANK) == FMC_Bank4_PCCARD)  || \
+                                   ((BANK) == FMC_Bank1_SDRAM)   || \
+                                   ((BANK) == FMC_Bank2_SDRAM)   || \
+                                   ((BANK) == (FMC_Bank1_SDRAM | FMC_Bank2_SDRAM)))
+                                   
+#define IS_FMC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))
+
+
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Refresh_count
+  * @{
+  */
+#define IS_FMC_REFRESH_COUNT(COUNT) ((COUNT) <= 8191)
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/* NOR/SRAM Controller functions **********************************************/
+void FMC_NORSRAMDeInit(uint32_t FMC_Bank);
+void FMC_NORSRAMInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct);
+void FMC_NORSRAMStructInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct);
+void FMC_NORSRAMCmd(uint32_t FMC_Bank, FunctionalState NewState);
+
+/* NAND Controller functions **************************************************/
+void     FMC_NANDDeInit(uint32_t FMC_Bank);
+void     FMC_NANDInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct);
+void     FMC_NANDStructInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct);
+void     FMC_NANDCmd(uint32_t FMC_Bank, FunctionalState NewState);
+void     FMC_NANDECCCmd(uint32_t FMC_Bank, FunctionalState NewState);
+uint32_t FMC_GetECC(uint32_t FMC_Bank);
+
+/* PCCARD Controller functions ************************************************/
+void FMC_PCCARDDeInit(void);
+void FMC_PCCARDInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct);
+void FMC_PCCARDStructInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct);
+void FMC_PCCARDCmd(FunctionalState NewState);
+
+/* SDRAM Controller functions ************************************************/
+void     FMC_SDRAMDeInit(uint32_t FMC_Bank);
+void     FMC_SDRAMInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct);
+void     FMC_SDRAMStructInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct);
+void     FMC_SDRAMCmdConfig(FMC_SDRAMCommandTypeDef* FMC_SDRAMCommandStruct);
+uint32_t FMC_GetModeStatus(uint32_t SDRAM_Bank);
+void     FMC_SetRefreshCount(uint32_t FMC_Count);
+void     FMC_SetAutoRefresh_Number(uint32_t FMC_Number);
+void     FMC_SDRAMWriteProtectionConfig(uint32_t SDRAM_Bank, FunctionalState NewState);
+
+/* Interrupts and flags management functions **********************************/
+void       FMC_ITConfig(uint32_t FMC_Bank, uint32_t FMC_IT, FunctionalState NewState);
+FlagStatus FMC_GetFlagStatus(uint32_t FMC_Bank, uint32_t FMC_FLAG);
+void       FMC_ClearFlag(uint32_t FMC_Bank, uint32_t FMC_FLAG);
+ITStatus   FMC_GetITStatus(uint32_t FMC_Bank, uint32_t FMC_IT);
+void       FMC_ClearITPendingBit(uint32_t FMC_Bank, uint32_t FMC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_FMC_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fsmc.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fsmc.h
new file mode 100644
index 0000000..fb81904
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fsmc.h
@@ -0,0 +1,675 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_fsmc.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the FSMC firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_FSMC_H
+#define __STM32F4xx_FSMC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup FSMC
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  Timing parameters For NOR/SRAM Banks  
+  */
+typedef struct
+{
+  uint32_t FSMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the address setup time. 
+                                             This parameter can be a value between 0 and 0xF.
+                                             @note This parameter is not used with synchronous NOR Flash memories. */
+
+  uint32_t FSMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the address hold time.
+                                             This parameter can be a value between 0 and 0xF. 
+                                             @note This parameter is not used with synchronous NOR Flash memories.*/
+
+  uint32_t FSMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the data setup time.
+                                             This parameter can be a value between 0 and 0xFF.
+                                             @note This parameter is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */
+
+  uint32_t FSMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the bus turnaround.
+                                             This parameter can be a value between 0 and 0xF.
+                                             @note This parameter is only used for multiplexed NOR Flash memories. */
+
+  uint32_t FSMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
+                                             This parameter can be a value between 1 and 0xF.
+                                             @note This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */
+
+  uint32_t FSMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue
+                                             to the memory before getting the first data.
+                                             The parameter value depends on the memory type as shown below:
+                                              - It must be set to 0 in case of a CRAM
+                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
+                                              - It may assume a value between 0 and 0xF in NOR Flash memories
+                                                with synchronous burst mode enable */
+
+  uint32_t FSMC_AccessMode;             /*!< Specifies the asynchronous access mode. 
+                                             This parameter can be a value of @ref FSMC_Access_Mode */
+}FSMC_NORSRAMTimingInitTypeDef;
+
+/** 
+  * @brief  FSMC NOR/SRAM Init structure definition
+  */
+typedef struct
+{
+  uint32_t FSMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.
+                                          This parameter can be a value of @ref FSMC_NORSRAM_Bank */
+
+  uint32_t FSMC_DataAddressMux;      /*!< Specifies whether the address and data values are
+                                          multiplexed on the data bus or not. 
+                                          This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing */
+
+  uint32_t FSMC_MemoryType;          /*!< Specifies the type of external memory attached to
+                                          the corresponding memory bank.
+                                          This parameter can be a value of @ref FSMC_Memory_Type */
+
+  uint32_t FSMC_MemoryDataWidth;     /*!< Specifies the external memory device width.
+                                          This parameter can be a value of @ref FSMC_Data_Width */
+
+  uint32_t FSMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,
+                                          valid only with synchronous burst Flash memories.
+                                          This parameter can be a value of @ref FSMC_Burst_Access_Mode */
+
+  uint32_t FSMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,
+                                          valid only with asynchronous Flash memories.
+                                          This parameter can be a value of @ref FSMC_AsynchronousWait */                                          
+
+  uint32_t FSMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing
+                                          the Flash memory in burst mode.
+                                          This parameter can be a value of @ref FSMC_Wait_Signal_Polarity */
+
+  uint32_t FSMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash
+                                          memory, valid only when accessing Flash memories in burst mode.
+                                          This parameter can be a value of @ref FSMC_Wrap_Mode */
+
+  uint32_t FSMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one
+                                          clock cycle before the wait state or during the wait state,
+                                          valid only when accessing memories in burst mode. 
+                                          This parameter can be a value of @ref FSMC_Wait_Timing */
+
+  uint32_t FSMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FSMC. 
+                                          This parameter can be a value of @ref FSMC_Write_Operation */
+
+  uint32_t FSMC_WaitSignal;          /*!< Enables or disables the wait state insertion via wait
+                                          signal, valid for Flash memory access in burst mode. 
+                                          This parameter can be a value of @ref FSMC_Wait_Signal */
+
+  uint32_t FSMC_ExtendedMode;        /*!< Enables or disables the extended mode.
+                                          This parameter can be a value of @ref FSMC_Extended_Mode */
+
+  uint32_t FSMC_WriteBurst;          /*!< Enables or disables the write burst operation.
+                                          This parameter can be a value of @ref FSMC_Write_Burst */ 
+
+  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  Extended Mode is not used*/  
+
+  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  Extended Mode is used*/      
+}FSMC_NORSRAMInitTypeDef;
+
+/** 
+  * @brief  Timing parameters For FSMC NAND and PCCARD Banks
+  */
+typedef struct
+{
+  uint32_t FSMC_SetupTime;      /*!< Defines the number of HCLK cycles to setup address before
+                                     the command assertion for NAND Flash read or write access
+                                     to common/Attribute or I/O memory space (depending on
+                                     the memory space timing to be configured).
+                                     This parameter can be a value between 0 and 0xFF.*/
+
+  uint32_t FSMC_WaitSetupTime;  /*!< Defines the minimum number of HCLK cycles to assert the
+                                     command for NAND Flash read or write access to
+                                     common/Attribute or I/O memory space (depending on the
+                                     memory space timing to be configured). 
+                                     This parameter can be a number between 0x00 and 0xFF */
+
+  uint32_t FSMC_HoldSetupTime;  /*!< Defines the number of HCLK clock cycles to hold address
+                                     (and data for write access) after the command de-assertion
+                                     for NAND Flash read or write access to common/Attribute
+                                     or I/O memory space (depending on the memory space timing
+                                     to be configured).
+                                     This parameter can be a number between 0x00 and 0xFF */
+
+  uint32_t FSMC_HiZSetupTime;   /*!< Defines the number of HCLK clock cycles during which the
+                                     data bus is kept in HiZ after the start of a NAND Flash
+                                     write access to common/Attribute or I/O memory space (depending
+                                     on the memory space timing to be configured).
+                                     This parameter can be a number between 0x00 and 0xFF */
+}FSMC_NAND_PCCARDTimingInitTypeDef;
+
+/** 
+  * @brief  FSMC NAND Init structure definition
+  */
+typedef struct
+{
+  uint32_t FSMC_Bank;              /*!< Specifies the NAND memory bank that will be used.
+                                      This parameter can be a value of @ref FSMC_NAND_Bank */
+
+  uint32_t FSMC_Waitfeature;      /*!< Enables or disables the Wait feature for the NAND Memory Bank.
+                                       This parameter can be any value of @ref FSMC_Wait_feature */
+
+  uint32_t FSMC_MemoryDataWidth;  /*!< Specifies the external memory device width.
+                                       This parameter can be any value of @ref FSMC_Data_Width */
+
+  uint32_t FSMC_ECC;              /*!< Enables or disables the ECC computation.
+                                       This parameter can be any value of @ref FSMC_ECC */
+
+  uint32_t FSMC_ECCPageSize;      /*!< Defines the page size for the extended ECC.
+                                       This parameter can be any value of @ref FSMC_ECC_Page_Size */
+
+  uint32_t FSMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the
+                                       delay between CLE low and RE low.
+                                       This parameter can be a value between 0 and 0xFF. */
+
+  uint32_t FSMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the
+                                       delay between ALE low and RE low.
+                                       This parameter can be a number between 0x0 and 0xFF */ 
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;   /*!< FSMC Common Space Timing */ 
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct; /*!< FSMC Attribute Space Timing */
+}FSMC_NANDInitTypeDef;
+
+/** 
+  * @brief  FSMC PCCARD Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t FSMC_Waitfeature;    /*!< Enables or disables the Wait feature for the Memory Bank.
+                                    This parameter can be any value of @ref FSMC_Wait_feature */
+
+  uint32_t FSMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the
+                                     delay between CLE low and RE low.
+                                     This parameter can be a value between 0 and 0xFF. */
+
+  uint32_t FSMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the
+                                     delay between ALE low and RE low.
+                                     This parameter can be a number between 0x0 and 0xFF */ 
+
+  
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct; /*!< FSMC Common Space Timing */
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;  /*!< FSMC Attribute Space Timing */ 
+  
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct; /*!< FSMC IO Space Timing */  
+}FSMC_PCCARDInitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup FSMC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup FSMC_NORSRAM_Bank 
+  * @{
+  */
+#define FSMC_Bank1_NORSRAM1                      ((uint32_t)0x00000000)
+#define FSMC_Bank1_NORSRAM2                      ((uint32_t)0x00000002)
+#define FSMC_Bank1_NORSRAM3                      ((uint32_t)0x00000004)
+#define FSMC_Bank1_NORSRAM4                      ((uint32_t)0x00000006)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_NAND_Bank 
+  * @{
+  */  
+#define FSMC_Bank2_NAND                          ((uint32_t)0x00000010)
+#define FSMC_Bank3_NAND                          ((uint32_t)0x00000100)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_PCCARD_Bank 
+  * @{
+  */    
+#define FSMC_Bank4_PCCARD                        ((uint32_t)0x00001000)
+/**
+  * @}
+  */
+
+#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
+                                    ((BANK) == FSMC_Bank1_NORSRAM2) || \
+                                    ((BANK) == FSMC_Bank1_NORSRAM3) || \
+                                    ((BANK) == FSMC_Bank1_NORSRAM4))
+
+#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
+                                 ((BANK) == FSMC_Bank3_NAND))
+
+#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
+                                    ((BANK) == FSMC_Bank3_NAND) || \
+                                    ((BANK) == FSMC_Bank4_PCCARD))
+
+#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
+                               ((BANK) == FSMC_Bank3_NAND) || \
+                               ((BANK) == FSMC_Bank4_PCCARD))
+
+/** @defgroup FSMC_NOR_SRAM_Controller 
+  * @{
+  */
+
+/** @defgroup FSMC_Data_Address_Bus_Multiplexing 
+  * @{
+  */
+
+#define FSMC_DataAddressMux_Disable                ((uint32_t)0x00000000)
+#define FSMC_DataAddressMux_Enable                 ((uint32_t)0x00000002)
+#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
+                          ((MUX) == FSMC_DataAddressMux_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Memory_Type 
+  * @{
+  */
+
+#define FSMC_MemoryType_SRAM                     ((uint32_t)0x00000000)
+#define FSMC_MemoryType_PSRAM                    ((uint32_t)0x00000004)
+#define FSMC_MemoryType_NOR                      ((uint32_t)0x00000008)
+#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
+                                ((MEMORY) == FSMC_MemoryType_PSRAM)|| \
+                                ((MEMORY) == FSMC_MemoryType_NOR))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Data_Width 
+  * @{
+  */
+
+#define FSMC_MemoryDataWidth_8b                  ((uint32_t)0x00000000)
+#define FSMC_MemoryDataWidth_16b                 ((uint32_t)0x00000010)
+#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
+                                     ((WIDTH) == FSMC_MemoryDataWidth_16b))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Burst_Access_Mode 
+  * @{
+  */
+
+#define FSMC_BurstAccessMode_Disable             ((uint32_t)0x00000000) 
+#define FSMC_BurstAccessMode_Enable              ((uint32_t)0x00000100)
+#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
+                                  ((STATE) == FSMC_BurstAccessMode_Enable))
+/**
+  * @}
+  */
+    
+/** @defgroup FSMC_AsynchronousWait 
+  * @{
+  */
+#define FSMC_AsynchronousWait_Disable            ((uint32_t)0x00000000)
+#define FSMC_AsynchronousWait_Enable             ((uint32_t)0x00008000)
+#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
+                                 ((STATE) == FSMC_AsynchronousWait_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Signal_Polarity 
+  * @{
+  */
+#define FSMC_WaitSignalPolarity_Low              ((uint32_t)0x00000000)
+#define FSMC_WaitSignalPolarity_High             ((uint32_t)0x00000200)
+#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
+                                         ((POLARITY) == FSMC_WaitSignalPolarity_High))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wrap_Mode 
+  * @{
+  */
+#define FSMC_WrapMode_Disable                    ((uint32_t)0x00000000)
+#define FSMC_WrapMode_Enable                     ((uint32_t)0x00000400) 
+#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
+                                 ((MODE) == FSMC_WrapMode_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Timing 
+  * @{
+  */
+#define FSMC_WaitSignalActive_BeforeWaitState    ((uint32_t)0x00000000)
+#define FSMC_WaitSignalActive_DuringWaitState    ((uint32_t)0x00000800) 
+#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
+                                            ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Write_Operation 
+  * @{
+  */
+#define FSMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
+#define FSMC_WriteOperation_Enable                      ((uint32_t)0x00001000)
+#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
+                                            ((OPERATION) == FSMC_WriteOperation_Enable))                         
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Signal 
+  * @{
+  */
+#define FSMC_WaitSignal_Disable                  ((uint32_t)0x00000000)
+#define FSMC_WaitSignal_Enable                   ((uint32_t)0x00002000) 
+#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
+                                      ((SIGNAL) == FSMC_WaitSignal_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Extended_Mode 
+  * @{
+  */
+#define FSMC_ExtendedMode_Disable                ((uint32_t)0x00000000)
+#define FSMC_ExtendedMode_Enable                 ((uint32_t)0x00004000)
+
+#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
+                                     ((MODE) == FSMC_ExtendedMode_Enable)) 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Write_Burst 
+  * @{
+  */
+
+#define FSMC_WriteBurst_Disable                  ((uint32_t)0x00000000)
+#define FSMC_WriteBurst_Enable                   ((uint32_t)0x00080000) 
+#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
+                                    ((BURST) == FSMC_WriteBurst_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Address_Setup_Time 
+  * @{
+  */
+#define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Address_Hold_Time 
+  * @{
+  */
+#define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Data_Setup_Time 
+  * @{
+  */
+#define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Bus_Turn_around_Duration 
+  * @{
+  */
+#define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_CLK_Division 
+  * @{
+  */
+#define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Data_Latency 
+  * @{
+  */
+#define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Access_Mode 
+  * @{
+  */
+#define FSMC_AccessMode_A                        ((uint32_t)0x00000000)
+#define FSMC_AccessMode_B                        ((uint32_t)0x10000000) 
+#define FSMC_AccessMode_C                        ((uint32_t)0x20000000)
+#define FSMC_AccessMode_D                        ((uint32_t)0x30000000)
+#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
+                                   ((MODE) == FSMC_AccessMode_B) || \
+                                   ((MODE) == FSMC_AccessMode_C) || \
+                                   ((MODE) == FSMC_AccessMode_D))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+  
+/** @defgroup FSMC_NAND_PCCARD_Controller 
+  * @{
+  */
+
+/** @defgroup FSMC_Wait_feature 
+  * @{
+  */
+#define FSMC_Waitfeature_Disable                 ((uint32_t)0x00000000)
+#define FSMC_Waitfeature_Enable                  ((uint32_t)0x00000002)
+#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
+                                       ((FEATURE) == FSMC_Waitfeature_Enable))
+/**
+  * @}
+  */
+
+
+/** @defgroup FSMC_ECC 
+  * @{
+  */
+#define FSMC_ECC_Disable                         ((uint32_t)0x00000000)
+#define FSMC_ECC_Enable                          ((uint32_t)0x00000040)
+#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
+                                  ((STATE) == FSMC_ECC_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_ECC_Page_Size 
+  * @{
+  */
+#define FSMC_ECCPageSize_256Bytes                ((uint32_t)0x00000000)
+#define FSMC_ECCPageSize_512Bytes                ((uint32_t)0x00020000)
+#define FSMC_ECCPageSize_1024Bytes               ((uint32_t)0x00040000)
+#define FSMC_ECCPageSize_2048Bytes               ((uint32_t)0x00060000)
+#define FSMC_ECCPageSize_4096Bytes               ((uint32_t)0x00080000)
+#define FSMC_ECCPageSize_8192Bytes               ((uint32_t)0x000A0000)
+#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_512Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_1024Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_2048Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_4096Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_8192Bytes))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_TCLR_Setup_Time 
+  * @{
+  */
+#define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_TAR_Setup_Time 
+  * @{
+  */
+#define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Setup_Time 
+  * @{
+  */
+#define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Setup_Time 
+  * @{
+  */
+#define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Hold_Setup_Time 
+  * @{
+  */
+#define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_HiZ_Setup_Time 
+  * @{
+  */
+#define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Interrupt_sources 
+  * @{
+  */
+#define FSMC_IT_RisingEdge                       ((uint32_t)0x00000008)
+#define FSMC_IT_Level                            ((uint32_t)0x00000010)
+#define FSMC_IT_FallingEdge                      ((uint32_t)0x00000020)
+#define IS_FSMC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFC7) == 0x00000000) && ((IT) != 0x00000000))
+#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) || \
+                            ((IT) == FSMC_IT_Level) || \
+                            ((IT) == FSMC_IT_FallingEdge)) 
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Flags 
+  * @{
+  */
+#define FSMC_FLAG_RisingEdge                     ((uint32_t)0x00000001)
+#define FSMC_FLAG_Level                          ((uint32_t)0x00000002)
+#define FSMC_FLAG_FallingEdge                    ((uint32_t)0x00000004)
+#define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
+#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) || \
+                                ((FLAG) == FSMC_FLAG_Level) || \
+                                ((FLAG) == FSMC_FLAG_FallingEdge) || \
+                                ((FLAG) == FSMC_FLAG_FEMPT))
+
+#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/* NOR/SRAM Controller functions **********************************************/
+void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank);
+void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
+void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
+void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);
+
+/* NAND Controller functions **************************************************/
+void FSMC_NANDDeInit(uint32_t FSMC_Bank);
+void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
+void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
+void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState);
+void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState);
+uint32_t FSMC_GetECC(uint32_t FSMC_Bank);
+
+/* PCCARD Controller functions ************************************************/
+void FSMC_PCCARDDeInit(void);
+void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
+void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
+void FSMC_PCCARDCmd(FunctionalState NewState);
+
+/* Interrupts and flags management functions **********************************/
+void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState);
+FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
+void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
+ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT);
+void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_FSMC_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h
new file mode 100644
index 0000000..e187f16
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h
@@ -0,0 +1,502 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_gpio.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the GPIO firmware
+  *          library.  
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_GPIO_H
+#define __STM32F4xx_GPIO_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup GPIO
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+
+#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
+                                    ((PERIPH) == GPIOB) || \
+                                    ((PERIPH) == GPIOC) || \
+                                    ((PERIPH) == GPIOD) || \
+                                    ((PERIPH) == GPIOE) || \
+                                    ((PERIPH) == GPIOF) || \
+                                    ((PERIPH) == GPIOG) || \
+                                    ((PERIPH) == GPIOH) || \
+                                    ((PERIPH) == GPIOI) || \
+                                    ((PERIPH) == GPIOJ) || \
+                                    ((PERIPH) == GPIOK))
+
+/** 
+  * @brief  GPIO Configuration Mode enumeration 
+  */   
+typedef enum
+{ 
+  GPIO_Mode_IN   = 0x00, /*!< GPIO Input Mode */
+  GPIO_Mode_OUT  = 0x01, /*!< GPIO Output Mode */
+  GPIO_Mode_AF   = 0x02, /*!< GPIO Alternate function Mode */
+  GPIO_Mode_AN   = 0x03  /*!< GPIO Analog Mode */
+}GPIOMode_TypeDef;
+#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)  || ((MODE) == GPIO_Mode_OUT) || \
+                            ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))
+
+/** 
+  * @brief  GPIO Output type enumeration 
+  */  
+typedef enum
+{ 
+  GPIO_OType_PP = 0x00,
+  GPIO_OType_OD = 0x01
+}GPIOOType_TypeDef;
+#define IS_GPIO_OTYPE(OTYPE) (((OTYPE) == GPIO_OType_PP) || ((OTYPE) == GPIO_OType_OD))
+
+
+/** 
+  * @brief  GPIO Output Maximum frequency enumeration 
+  */  
+typedef enum
+{ 
+  GPIO_Low_Speed     = 0x00, /*!< Low speed    */
+  GPIO_Medium_Speed  = 0x01, /*!< Medium speed */
+  GPIO_Fast_Speed    = 0x02, /*!< Fast speed   */
+  GPIO_High_Speed    = 0x03  /*!< High speed   */
+}GPIOSpeed_TypeDef;
+
+/* Add legacy definition */
+#define  GPIO_Speed_2MHz    GPIO_Low_Speed    
+#define  GPIO_Speed_25MHz   GPIO_Medium_Speed 
+#define  GPIO_Speed_50MHz   GPIO_Fast_Speed 
+#define  GPIO_Speed_100MHz  GPIO_High_Speed  
+  
+#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Low_Speed) || ((SPEED) == GPIO_Medium_Speed) || \
+                              ((SPEED) == GPIO_Fast_Speed)||  ((SPEED) == GPIO_High_Speed)) 
+
+/** 
+  * @brief  GPIO Configuration PullUp PullDown enumeration 
+  */ 
+typedef enum
+{ 
+  GPIO_PuPd_NOPULL = 0x00,
+  GPIO_PuPd_UP     = 0x01,
+  GPIO_PuPd_DOWN   = 0x02
+}GPIOPuPd_TypeDef;
+#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) || \
+                            ((PUPD) == GPIO_PuPd_DOWN))
+
+/** 
+  * @brief  GPIO Bit SET and Bit RESET enumeration 
+  */ 
+typedef enum
+{ 
+  Bit_RESET = 0,
+  Bit_SET
+}BitAction;
+#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
+
+
+/** 
+  * @brief   GPIO Init structure definition  
+  */ 
+typedef struct
+{
+  uint32_t GPIO_Pin;              /*!< Specifies the GPIO pins to be configured.
+                                       This parameter can be any value of @ref GPIO_pins_define */
+
+  GPIOMode_TypeDef GPIO_Mode;     /*!< Specifies the operating mode for the selected pins.
+                                       This parameter can be a value of @ref GPIOMode_TypeDef */
+
+  GPIOSpeed_TypeDef GPIO_Speed;   /*!< Specifies the speed for the selected pins.
+                                       This parameter can be a value of @ref GPIOSpeed_TypeDef */
+
+  GPIOOType_TypeDef GPIO_OType;   /*!< Specifies the operating output type for the selected pins.
+                                       This parameter can be a value of @ref GPIOOType_TypeDef */
+
+  GPIOPuPd_TypeDef GPIO_PuPd;     /*!< Specifies the operating Pull-up/Pull down for the selected pins.
+                                       This parameter can be a value of @ref GPIOPuPd_TypeDef */
+}GPIO_InitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup GPIO_Exported_Constants
+  * @{
+  */ 
+
+/** @defgroup GPIO_pins_define 
+  * @{
+  */ 
+#define GPIO_Pin_0                 ((uint16_t)0x0001)  /* Pin 0 selected */
+#define GPIO_Pin_1                 ((uint16_t)0x0002)  /* Pin 1 selected */
+#define GPIO_Pin_2                 ((uint16_t)0x0004)  /* Pin 2 selected */
+#define GPIO_Pin_3                 ((uint16_t)0x0008)  /* Pin 3 selected */
+#define GPIO_Pin_4                 ((uint16_t)0x0010)  /* Pin 4 selected */
+#define GPIO_Pin_5                 ((uint16_t)0x0020)  /* Pin 5 selected */
+#define GPIO_Pin_6                 ((uint16_t)0x0040)  /* Pin 6 selected */
+#define GPIO_Pin_7                 ((uint16_t)0x0080)  /* Pin 7 selected */
+#define GPIO_Pin_8                 ((uint16_t)0x0100)  /* Pin 8 selected */
+#define GPIO_Pin_9                 ((uint16_t)0x0200)  /* Pin 9 selected */
+#define GPIO_Pin_10                ((uint16_t)0x0400)  /* Pin 10 selected */
+#define GPIO_Pin_11                ((uint16_t)0x0800)  /* Pin 11 selected */
+#define GPIO_Pin_12                ((uint16_t)0x1000)  /* Pin 12 selected */
+#define GPIO_Pin_13                ((uint16_t)0x2000)  /* Pin 13 selected */
+#define GPIO_Pin_14                ((uint16_t)0x4000)  /* Pin 14 selected */
+#define GPIO_Pin_15                ((uint16_t)0x8000)  /* Pin 15 selected */
+#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /* All pins selected */
+
+#define GPIO_PIN_MASK              ((uint32_t)0x0000FFFF) /* PIN mask for assert test */
+#define IS_GPIO_PIN(PIN)           (((PIN) & GPIO_PIN_MASK ) != (uint32_t)0x00)
+#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
+                              ((PIN) == GPIO_Pin_1) || \
+                              ((PIN) == GPIO_Pin_2) || \
+                              ((PIN) == GPIO_Pin_3) || \
+                              ((PIN) == GPIO_Pin_4) || \
+                              ((PIN) == GPIO_Pin_5) || \
+                              ((PIN) == GPIO_Pin_6) || \
+                              ((PIN) == GPIO_Pin_7) || \
+                              ((PIN) == GPIO_Pin_8) || \
+                              ((PIN) == GPIO_Pin_9) || \
+                              ((PIN) == GPIO_Pin_10) || \
+                              ((PIN) == GPIO_Pin_11) || \
+                              ((PIN) == GPIO_Pin_12) || \
+                              ((PIN) == GPIO_Pin_13) || \
+                              ((PIN) == GPIO_Pin_14) || \
+                              ((PIN) == GPIO_Pin_15))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup GPIO_Pin_sources 
+  * @{
+  */ 
+#define GPIO_PinSource0            ((uint8_t)0x00)
+#define GPIO_PinSource1            ((uint8_t)0x01)
+#define GPIO_PinSource2            ((uint8_t)0x02)
+#define GPIO_PinSource3            ((uint8_t)0x03)
+#define GPIO_PinSource4            ((uint8_t)0x04)
+#define GPIO_PinSource5            ((uint8_t)0x05)
+#define GPIO_PinSource6            ((uint8_t)0x06)
+#define GPIO_PinSource7            ((uint8_t)0x07)
+#define GPIO_PinSource8            ((uint8_t)0x08)
+#define GPIO_PinSource9            ((uint8_t)0x09)
+#define GPIO_PinSource10           ((uint8_t)0x0A)
+#define GPIO_PinSource11           ((uint8_t)0x0B)
+#define GPIO_PinSource12           ((uint8_t)0x0C)
+#define GPIO_PinSource13           ((uint8_t)0x0D)
+#define GPIO_PinSource14           ((uint8_t)0x0E)
+#define GPIO_PinSource15           ((uint8_t)0x0F)
+
+#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
+                                       ((PINSOURCE) == GPIO_PinSource1) || \
+                                       ((PINSOURCE) == GPIO_PinSource2) || \
+                                       ((PINSOURCE) == GPIO_PinSource3) || \
+                                       ((PINSOURCE) == GPIO_PinSource4) || \
+                                       ((PINSOURCE) == GPIO_PinSource5) || \
+                                       ((PINSOURCE) == GPIO_PinSource6) || \
+                                       ((PINSOURCE) == GPIO_PinSource7) || \
+                                       ((PINSOURCE) == GPIO_PinSource8) || \
+                                       ((PINSOURCE) == GPIO_PinSource9) || \
+                                       ((PINSOURCE) == GPIO_PinSource10) || \
+                                       ((PINSOURCE) == GPIO_PinSource11) || \
+                                       ((PINSOURCE) == GPIO_PinSource12) || \
+                                       ((PINSOURCE) == GPIO_PinSource13) || \
+                                       ((PINSOURCE) == GPIO_PinSource14) || \
+                                       ((PINSOURCE) == GPIO_PinSource15))
+/**
+  * @}
+  */ 
+
+/** @defgroup GPIO_Alternat_function_selection_define 
+  * @{
+  */ 
+/** 
+  * @brief   AF 0 selection  
+  */ 
+#define GPIO_AF_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping */
+#define GPIO_AF_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping */
+#define GPIO_AF_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
+#define GPIO_AF_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping */
+#define GPIO_AF_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping */
+
+/** 
+  * @brief   AF 1 selection  
+  */ 
+#define GPIO_AF_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
+#define GPIO_AF_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
+
+/** 
+  * @brief   AF 2 selection  
+  */ 
+#define GPIO_AF_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
+#define GPIO_AF_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
+#define GPIO_AF_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
+
+/** 
+  * @brief   AF 3 selection  
+  */ 
+#define GPIO_AF_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping */
+#define GPIO_AF_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping */
+#define GPIO_AF_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
+#define GPIO_AF_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
+
+/** 
+  * @brief   AF 4 selection  
+  */ 
+#define GPIO_AF_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
+#define GPIO_AF_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
+#define GPIO_AF_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
+
+/** 
+  * @brief   AF 5 selection  
+  */ 
+#define GPIO_AF_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping */
+#define GPIO_AF_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping */
+#define GPIO_AF5_SPI3         ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping (Only for STM32F411xE Devices) */
+#define GPIO_AF_SPI4          ((uint8_t)0x05)  /* SPI4/I2S4 Alternate Function mapping */
+#define GPIO_AF_SPI5          ((uint8_t)0x05)  /* SPI5 Alternate Function mapping      */
+#define GPIO_AF_SPI6          ((uint8_t)0x05)  /* SPI6 Alternate Function mapping      */
+
+/** 
+  * @brief   AF 6 selection  
+  */ 
+#define GPIO_AF_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping */
+#define GPIO_AF6_SPI2         ((uint8_t)0x06)  /* SPI2 Alternate Function mapping (Only for STM32F411xE Devices) */
+#define GPIO_AF6_SPI4         ((uint8_t)0x06)  /* SPI4 Alternate Function mapping (Only for STM32F411xE Devices) */
+#define GPIO_AF6_SPI5         ((uint8_t)0x06)  /* SPI5 Alternate Function mapping (Only for STM32F411xE Devices) */
+#define GPIO_AF_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping      */
+
+/** 
+  * @brief   AF 7 selection  
+  */ 
+#define GPIO_AF_USART1         ((uint8_t)0x07)  /* USART1 Alternate Function mapping  */
+#define GPIO_AF_USART2         ((uint8_t)0x07)  /* USART2 Alternate Function mapping  */
+#define GPIO_AF_USART3         ((uint8_t)0x07)  /* USART3 Alternate Function mapping  */
+#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3ext Alternate Function mapping */
+
+/** 
+  * @brief   AF 7 selection Legacy 
+  */ 
+#define GPIO_AF_I2S3ext   GPIO_AF7_SPI3
+
+/** 
+  * @brief   AF 8 selection  
+  */ 
+#define GPIO_AF_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
+#define GPIO_AF_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
+#define GPIO_AF_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
+#define GPIO_AF_UART7         ((uint8_t)0x08)  /* UART7 Alternate Function mapping  */
+#define GPIO_AF_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
+
+/** 
+  * @brief   AF 9 selection 
+  */ 
+#define GPIO_AF_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
+#define GPIO_AF_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
+#define GPIO_AF_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
+#define GPIO_AF_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
+#define GPIO_AF_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
+
+#define GPIO_AF9_I2C2         ((uint8_t)0x09)  /* I2C2 Alternate Function mapping (Only for STM32F401xx/STM32F411xE Devices) */
+#define GPIO_AF9_I2C3         ((uint8_t)0x09)  /* I2C3 Alternate Function mapping (Only for STM32F401xx/STM32F411xE Devices) */
+
+/** 
+  * @brief   AF 10 selection  
+  */ 
+#define GPIO_AF_OTG_FS         ((uint8_t)0xA)  /* OTG_FS Alternate Function mapping */
+#define GPIO_AF_OTG_HS         ((uint8_t)0xA)  /* OTG_HS Alternate Function mapping */
+
+/** 
+  * @brief   AF 11 selection  
+  */ 
+#define GPIO_AF_ETH             ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
+
+/** 
+  * @brief   AF 12 selection  
+  */ 
+#if defined (STM32F40_41xxx)
+#define GPIO_AF_FSMC             ((uint8_t)0xC)  /* FSMC Alternate Function mapping                     */
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define GPIO_AF_FMC              ((uint8_t)0xC)  /* FMC Alternate Function mapping                      */
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+#define GPIO_AF_OTG_HS_FS        ((uint8_t)0xC)  /* OTG HS configured in FS, Alternate Function mapping */
+#define GPIO_AF_SDIO             ((uint8_t)0xC)  /* SDIO Alternate Function mapping                     */
+
+/** 
+  * @brief   AF 13 selection  
+  */ 
+#define GPIO_AF_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
+
+/** 
+  * @brief   AF 14 selection  
+  */
+
+#define GPIO_AF_LTDC          ((uint8_t)0x0E)  /* LCD-TFT Alternate Function mapping */
+
+/** 
+  * @brief   AF 15 selection  
+  */ 
+#define GPIO_AF_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
+
+#if defined (STM32F40_41xxx)
+#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
+                          ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    || \
+                          ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     || \
+                          ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      || \
+                          ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      || \
+                          ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      || \
+                          ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      || \
+                          ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      || \
+                          ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     || \
+                          ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     || \
+                          ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    || \
+                          ((AF) == GPIO_AF_USART3)    || ((AF) == GPIO_AF_UART4)     || \
+                          ((AF) == GPIO_AF_UART5)     || ((AF) == GPIO_AF_USART6)    || \
+                          ((AF) == GPIO_AF_CAN1)      || ((AF) == GPIO_AF_CAN2)      || \
+                          ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    || \
+                          ((AF) == GPIO_AF_ETH)       || ((AF) == GPIO_AF_OTG_HS_FS) || \
+                          ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_DCMI)      || \
+                          ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_FSMC))
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F401xx)
+#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
+                          ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    || \
+                          ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     || \
+                          ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      || \
+                          ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      || \
+                          ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      || \
+                          ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      || \
+                          ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      || \
+                          ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     || \
+                          ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     || \
+                          ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    || \
+                          ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_USART6)    || \
+                          ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    || \
+                          ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_SPI4))
+#endif /* STM32F401xx */
+
+#if defined (STM32F411xE)
+#define IS_GPIO_AF(AF)   (((AF) < 16) && ((AF) != 11) && ((AF) != 13) && ((AF) != 14))
+#endif /* STM32F411xE */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
+                          ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    || \
+                          ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     || \
+                          ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      || \
+                          ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      || \
+                          ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      || \
+                          ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      || \
+                          ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      || \
+                          ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     || \
+                          ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     || \
+                          ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    || \
+                          ((AF) == GPIO_AF_USART3)    || ((AF) == GPIO_AF_UART4)     || \
+                          ((AF) == GPIO_AF_UART5)     || ((AF) == GPIO_AF_USART6)    || \
+                          ((AF) == GPIO_AF_CAN1)      || ((AF) == GPIO_AF_CAN2)      || \
+                          ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    || \
+                          ((AF) == GPIO_AF_ETH)       || ((AF) == GPIO_AF_OTG_HS_FS) || \
+                          ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_DCMI)      || \
+                          ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_SPI4)      || \
+                          ((AF) == GPIO_AF_SPI5)      || ((AF) == GPIO_AF_SPI6)      || \
+                          ((AF) == GPIO_AF_UART7)     || ((AF) == GPIO_AF_UART8)     || \
+                          ((AF) == GPIO_AF_FMC)       ||  ((AF) == GPIO_AF_SAI1)     || \
+                          ((AF) == GPIO_AF_LTDC))
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+                          
+/**
+  * @}
+  */ 
+
+/** @defgroup GPIO_Legacy 
+  * @{
+  */
+    
+#define GPIO_Mode_AIN           GPIO_Mode_AN
+
+#define GPIO_AF_OTG1_FS         GPIO_AF_OTG_FS
+#define GPIO_AF_OTG2_HS         GPIO_AF_OTG_HS
+#define GPIO_AF_OTG2_FS         GPIO_AF_OTG_HS_FS
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+
+/*  Function used to set the GPIO configuration to the default reset state ****/
+void GPIO_DeInit(GPIO_TypeDef* GPIOx);
+
+/* Initialization and Configuration functions *********************************/
+void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
+void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
+void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+
+/* GPIO Read and Write functions **********************************************/
+uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
+uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
+void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
+void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
+void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+
+/* GPIO Alternate functions configuration function ****************************/
+void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_GPIO_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_hash.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_hash.h
new file mode 100644
index 0000000..d952293
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_hash.h
@@ -0,0 +1,257 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_hash.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the HASH 
+  *          firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_HASH_H
+#define __STM32F4xx_HASH_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup HASH
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief   HASH Init structure definition
+  */ 
+typedef struct
+{
+  uint32_t HASH_AlgoSelection; /*!< SHA-1, SHA-224, SHA-256 or MD5. This parameter
+                                    can be a value of @ref HASH_Algo_Selection */
+  uint32_t HASH_AlgoMode;      /*!< HASH or HMAC. This parameter can be a value 
+                                    of @ref HASH_processor_Algorithm_Mode */
+  uint32_t HASH_DataType;      /*!< 32-bit data, 16-bit data, 8-bit data or 
+                                    bit string. This parameter can be a value of
+                                    @ref HASH_Data_Type */
+  uint32_t HASH_HMACKeyType;   /*!< HMAC Short key or HMAC Long Key. This parameter
+                                    can be a value of @ref HASH_HMAC_Long_key_only_for_HMAC_mode */
+}HASH_InitTypeDef;
+
+/** 
+  * @brief  HASH message digest result structure definition  
+  */ 
+typedef struct
+{
+  uint32_t Data[8];      /*!< Message digest result : 8x 32bit wors for SHA-256,
+                                                      7x 32bit wors for SHA-224,
+                                                      5x 32bit words for SHA-1 or
+                                                      4x 32bit words for MD5  */
+} HASH_MsgDigest; 
+
+/** 
+  * @brief  HASH context swapping structure definition  
+  */ 
+typedef struct
+{
+  uint32_t HASH_IMR; 
+  uint32_t HASH_STR;      
+  uint32_t HASH_CR;     
+  uint32_t HASH_CSR[54];       
+}HASH_Context;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup HASH_Exported_Constants
+  * @{
+  */ 
+
+/** @defgroup HASH_Algo_Selection 
+  * @{
+  */ 
+#define HASH_AlgoSelection_SHA1      ((uint32_t)0x0000) /*!< HASH function is SHA1   */
+#define HASH_AlgoSelection_SHA224    HASH_CR_ALGO_1     /*!< HASH function is SHA224 */
+#define HASH_AlgoSelection_SHA256    HASH_CR_ALGO       /*!< HASH function is SHA256 */
+#define HASH_AlgoSelection_MD5       HASH_CR_ALGO_0     /*!< HASH function is MD5    */
+
+#define IS_HASH_ALGOSELECTION(ALGOSELECTION) (((ALGOSELECTION) == HASH_AlgoSelection_SHA1) || \
+                                              ((ALGOSELECTION) == HASH_AlgoSelection_SHA224) || \
+                                              ((ALGOSELECTION) == HASH_AlgoSelection_SHA256) || \
+                                              ((ALGOSELECTION) == HASH_AlgoSelection_MD5))
+/**
+  * @}
+  */
+
+/** @defgroup HASH_processor_Algorithm_Mode 
+  * @{
+  */ 
+#define HASH_AlgoMode_HASH         ((uint32_t)0x00000000) /*!< Algorithm is HASH */ 
+#define HASH_AlgoMode_HMAC         HASH_CR_MODE           /*!< Algorithm is HMAC */
+
+#define IS_HASH_ALGOMODE(ALGOMODE) (((ALGOMODE) == HASH_AlgoMode_HASH) || \
+                                    ((ALGOMODE) == HASH_AlgoMode_HMAC))
+/**
+  * @}
+  */
+
+/** @defgroup HASH_Data_Type  
+  * @{
+  */  
+#define HASH_DataType_32b          ((uint32_t)0x0000) /*!< 32-bit data. No swapping                     */
+#define HASH_DataType_16b          HASH_CR_DATATYPE_0 /*!< 16-bit data. Each half word is swapped       */
+#define HASH_DataType_8b           HASH_CR_DATATYPE_1 /*!< 8-bit data. All bytes are swapped            */
+#define HASH_DataType_1b           HASH_CR_DATATYPE   /*!< 1-bit data. In the word all bits are swapped */
+
+#define IS_HASH_DATATYPE(DATATYPE) (((DATATYPE) == HASH_DataType_32b)|| \
+                                    ((DATATYPE) == HASH_DataType_16b)|| \
+                                    ((DATATYPE) == HASH_DataType_8b) || \
+                                    ((DATATYPE) == HASH_DataType_1b))
+/**
+  * @}
+  */
+
+/** @defgroup HASH_HMAC_Long_key_only_for_HMAC_mode  
+  * @{
+  */ 
+#define HASH_HMACKeyType_ShortKey      ((uint32_t)0x00000000) /*!< HMAC Key is <= 64 bytes */
+#define HASH_HMACKeyType_LongKey       HASH_CR_LKEY           /*!< HMAC Key is > 64 bytes  */
+
+#define IS_HASH_HMAC_KEYTYPE(KEYTYPE) (((KEYTYPE) == HASH_HMACKeyType_ShortKey) || \
+                                       ((KEYTYPE) == HASH_HMACKeyType_LongKey))
+/**
+  * @}
+  */
+
+/** @defgroup Number_of_valid_bits_in_last_word_of_the_message   
+  * @{
+  */  
+#define IS_HASH_VALIDBITSNUMBER(VALIDBITS) ((VALIDBITS) <= 0x1F)
+
+/**
+  * @}
+  */
+
+/** @defgroup HASH_interrupts_definition   
+  * @{
+  */  
+#define HASH_IT_DINI               HASH_IMR_DINIM  /*!< A new block can be entered into the input buffer (DIN) */
+#define HASH_IT_DCI                HASH_IMR_DCIM   /*!< Digest calculation complete                            */
+
+#define IS_HASH_IT(IT) ((((IT) & (uint32_t)0xFFFFFFFC) == 0x00000000) && ((IT) != 0x00000000))
+#define IS_HASH_GET_IT(IT) (((IT) == HASH_IT_DINI) || ((IT) == HASH_IT_DCI))
+				   
+/**
+  * @}
+  */
+
+/** @defgroup HASH_flags_definition   
+  * @{
+  */  
+#define HASH_FLAG_DINIS            HASH_SR_DINIS  /*!< 16 locations are free in the DIN : A new block can be entered into the input buffer */
+#define HASH_FLAG_DCIS             HASH_SR_DCIS   /*!< Digest calculation complete                                                         */
+#define HASH_FLAG_DMAS             HASH_SR_DMAS   /*!< DMA interface is enabled (DMAE=1) or a transfer is ongoing                          */
+#define HASH_FLAG_BUSY             HASH_SR_BUSY   /*!< The hash core is Busy : processing a block of data                                  */
+#define HASH_FLAG_DINNE            HASH_CR_DINNE  /*!< DIN not empty : The input buffer contains at least one word of data                 */
+
+#define IS_HASH_GET_FLAG(FLAG) (((FLAG) == HASH_FLAG_DINIS) || \
+                                ((FLAG) == HASH_FLAG_DCIS)  || \
+                                ((FLAG) == HASH_FLAG_DMAS)  || \
+                                ((FLAG) == HASH_FLAG_BUSY)  || \
+                                ((FLAG) == HASH_FLAG_DINNE)) 
+
+#define IS_HASH_CLEAR_FLAG(FLAG)(((FLAG) == HASH_FLAG_DINIS) || \
+                                 ((FLAG) == HASH_FLAG_DCIS))                                 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+  
+/*  Function used to set the HASH configuration to the default reset state ****/
+void HASH_DeInit(void);
+
+/* HASH Configuration function ************************************************/
+void HASH_Init(HASH_InitTypeDef* HASH_InitStruct);
+void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct);
+void HASH_Reset(void);
+
+/* HASH Message Digest generation functions ***********************************/
+void HASH_DataIn(uint32_t Data);
+uint8_t HASH_GetInFIFOWordsNbr(void);
+void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber);
+void HASH_StartDigest(void);
+void HASH_AutoStartDigest(FunctionalState NewState);
+void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest);
+
+/* HASH Context swapping functions ********************************************/
+void HASH_SaveContext(HASH_Context* HASH_ContextSave);
+void HASH_RestoreContext(HASH_Context* HASH_ContextRestore);
+
+/* HASH DMA interface function ************************************************/
+void HASH_DMACmd(FunctionalState NewState);
+
+/* HASH Interrupts and flags management functions *****************************/
+void HASH_ITConfig(uint32_t HASH_IT, FunctionalState NewState);
+FlagStatus HASH_GetFlagStatus(uint32_t HASH_FLAG);
+void HASH_ClearFlag(uint32_t HASH_FLAG);
+ITStatus HASH_GetITStatus(uint32_t HASH_IT);
+void HASH_ClearITPendingBit(uint32_t HASH_IT);
+
+/* High Level SHA1 functions **************************************************/
+ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20]);
+ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen,
+                      uint8_t *Input, uint32_t Ilen,
+                      uint8_t Output[20]);
+
+/* High Level MD5 functions ***************************************************/
+ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16]);
+ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen,
+                     uint8_t *Input, uint32_t Ilen,
+                     uint8_t Output[16]);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_HASH_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_i2c.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_i2c.h
new file mode 100644
index 0000000..16c83b4
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_i2c.h
@@ -0,0 +1,711 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_i2c.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the I2C firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_I2C_H
+#define __STM32F4xx_I2C_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup I2C
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  I2C Init structure definition  
+  */
+
+typedef struct
+{
+  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.
+                                         This parameter must be set to a value lower than 400kHz */
+
+  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.
+                                         This parameter can be a value of @ref I2C_mode */
+
+  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.
+                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */
+
+  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.
+                                         This parameter can be a 7-bit or 10-bit address. */
+
+  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.
+                                         This parameter can be a value of @ref I2C_acknowledgement */
+
+  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.
+                                         This parameter can be a value of @ref I2C_acknowledged_address */
+}I2C_InitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+
+/** @defgroup I2C_Exported_Constants
+  * @{
+  */
+
+#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) || \
+                                   ((PERIPH) == I2C2) || \
+                                   ((PERIPH) == I2C3))
+
+/** @defgroup I2C_Digital_Filter
+  * @{
+  */
+
+#define IS_I2C_DIGITAL_FILTER(FILTER)   ((FILTER) <= 0x0000000F)
+/**
+  * @}
+  */
+
+
+/** @defgroup I2C_mode 
+  * @{
+  */
+
+#define I2C_Mode_I2C                    ((uint16_t)0x0000)
+#define I2C_Mode_SMBusDevice            ((uint16_t)0x0002)  
+#define I2C_Mode_SMBusHost              ((uint16_t)0x000A)
+#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
+                           ((MODE) == I2C_Mode_SMBusDevice) || \
+                           ((MODE) == I2C_Mode_SMBusHost))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_duty_cycle_in_fast_mode 
+  * @{
+  */
+
+#define I2C_DutyCycle_16_9              ((uint16_t)0x4000) /*!< I2C fast mode Tlow/Thigh = 16/9 */
+#define I2C_DutyCycle_2                 ((uint16_t)0xBFFF) /*!< I2C fast mode Tlow/Thigh = 2 */
+#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
+                                  ((CYCLE) == I2C_DutyCycle_2))
+/**
+  * @}
+  */ 
+
+/** @defgroup I2C_acknowledgement
+  * @{
+  */
+
+#define I2C_Ack_Enable                  ((uint16_t)0x0400)
+#define I2C_Ack_Disable                 ((uint16_t)0x0000)
+#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
+                                 ((STATE) == I2C_Ack_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_transfer_direction 
+  * @{
+  */
+
+#define  I2C_Direction_Transmitter      ((uint8_t)0x00)
+#define  I2C_Direction_Receiver         ((uint8_t)0x01)
+#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
+                                     ((DIRECTION) == I2C_Direction_Receiver))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_acknowledged_address 
+  * @{
+  */
+
+#define I2C_AcknowledgedAddress_7bit    ((uint16_t)0x4000)
+#define I2C_AcknowledgedAddress_10bit   ((uint16_t)0xC000)
+#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
+                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
+/**
+  * @}
+  */ 
+
+/** @defgroup I2C_registers 
+  * @{
+  */
+
+#define I2C_Register_CR1                ((uint8_t)0x00)
+#define I2C_Register_CR2                ((uint8_t)0x04)
+#define I2C_Register_OAR1               ((uint8_t)0x08)
+#define I2C_Register_OAR2               ((uint8_t)0x0C)
+#define I2C_Register_DR                 ((uint8_t)0x10)
+#define I2C_Register_SR1                ((uint8_t)0x14)
+#define I2C_Register_SR2                ((uint8_t)0x18)
+#define I2C_Register_CCR                ((uint8_t)0x1C)
+#define I2C_Register_TRISE              ((uint8_t)0x20)
+#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
+                                   ((REGISTER) == I2C_Register_CR2) || \
+                                   ((REGISTER) == I2C_Register_OAR1) || \
+                                   ((REGISTER) == I2C_Register_OAR2) || \
+                                   ((REGISTER) == I2C_Register_DR) || \
+                                   ((REGISTER) == I2C_Register_SR1) || \
+                                   ((REGISTER) == I2C_Register_SR2) || \
+                                   ((REGISTER) == I2C_Register_CCR) || \
+                                   ((REGISTER) == I2C_Register_TRISE))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_NACK_position 
+  * @{
+  */
+
+#define I2C_NACKPosition_Next           ((uint16_t)0x0800)
+#define I2C_NACKPosition_Current        ((uint16_t)0xF7FF)
+#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) || \
+                                         ((POSITION) == I2C_NACKPosition_Current))
+/**
+  * @}
+  */ 
+
+/** @defgroup I2C_SMBus_alert_pin_level 
+  * @{
+  */
+
+#define I2C_SMBusAlert_Low              ((uint16_t)0x2000)
+#define I2C_SMBusAlert_High             ((uint16_t)0xDFFF)
+#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
+                                   ((ALERT) == I2C_SMBusAlert_High))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_PEC_position 
+  * @{
+  */
+
+#define I2C_PECPosition_Next            ((uint16_t)0x0800)
+#define I2C_PECPosition_Current         ((uint16_t)0xF7FF)
+#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
+                                       ((POSITION) == I2C_PECPosition_Current))
+/**
+  * @}
+  */ 
+
+/** @defgroup I2C_interrupts_definition 
+  * @{
+  */
+
+#define I2C_IT_BUF                      ((uint16_t)0x0400)
+#define I2C_IT_EVT                      ((uint16_t)0x0200)
+#define I2C_IT_ERR                      ((uint16_t)0x0100)
+#define IS_I2C_CONFIG_IT(IT) ((((IT) & (uint16_t)0xF8FF) == 0x00) && ((IT) != 0x00))
+/**
+  * @}
+  */ 
+
+/** @defgroup I2C_interrupts_definition 
+  * @{
+  */
+
+#define I2C_IT_SMBALERT                 ((uint32_t)0x01008000)
+#define I2C_IT_TIMEOUT                  ((uint32_t)0x01004000)
+#define I2C_IT_PECERR                   ((uint32_t)0x01001000)
+#define I2C_IT_OVR                      ((uint32_t)0x01000800)
+#define I2C_IT_AF                       ((uint32_t)0x01000400)
+#define I2C_IT_ARLO                     ((uint32_t)0x01000200)
+#define I2C_IT_BERR                     ((uint32_t)0x01000100)
+#define I2C_IT_TXE                      ((uint32_t)0x06000080)
+#define I2C_IT_RXNE                     ((uint32_t)0x06000040)
+#define I2C_IT_STOPF                    ((uint32_t)0x02000010)
+#define I2C_IT_ADD10                    ((uint32_t)0x02000008)
+#define I2C_IT_BTF                      ((uint32_t)0x02000004)
+#define I2C_IT_ADDR                     ((uint32_t)0x02000002)
+#define I2C_IT_SB                       ((uint32_t)0x02000001)
+
+#define IS_I2C_CLEAR_IT(IT) ((((IT) & (uint16_t)0x20FF) == 0x00) && ((IT) != (uint16_t)0x00))
+
+#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
+                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
+                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
+                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \
+                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
+                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
+                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_flags_definition 
+  * @{
+  */
+
+/** 
+  * @brief  SR2 register flags  
+  */
+
+#define I2C_FLAG_DUALF                  ((uint32_t)0x00800000)
+#define I2C_FLAG_SMBHOST                ((uint32_t)0x00400000)
+#define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00200000)
+#define I2C_FLAG_GENCALL                ((uint32_t)0x00100000)
+#define I2C_FLAG_TRA                    ((uint32_t)0x00040000)
+#define I2C_FLAG_BUSY                   ((uint32_t)0x00020000)
+#define I2C_FLAG_MSL                    ((uint32_t)0x00010000)
+
+/** 
+  * @brief  SR1 register flags  
+  */
+
+#define I2C_FLAG_SMBALERT               ((uint32_t)0x10008000)
+#define I2C_FLAG_TIMEOUT                ((uint32_t)0x10004000)
+#define I2C_FLAG_PECERR                 ((uint32_t)0x10001000)
+#define I2C_FLAG_OVR                    ((uint32_t)0x10000800)
+#define I2C_FLAG_AF                     ((uint32_t)0x10000400)
+#define I2C_FLAG_ARLO                   ((uint32_t)0x10000200)
+#define I2C_FLAG_BERR                   ((uint32_t)0x10000100)
+#define I2C_FLAG_TXE                    ((uint32_t)0x10000080)
+#define I2C_FLAG_RXNE                   ((uint32_t)0x10000040)
+#define I2C_FLAG_STOPF                  ((uint32_t)0x10000010)
+#define I2C_FLAG_ADD10                  ((uint32_t)0x10000008)
+#define I2C_FLAG_BTF                    ((uint32_t)0x10000004)
+#define I2C_FLAG_ADDR                   ((uint32_t)0x10000002)
+#define I2C_FLAG_SB                     ((uint32_t)0x10000001)
+
+#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0x20FF) == 0x00) && ((FLAG) != (uint16_t)0x00))
+
+#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
+                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
+                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
+                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \
+                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \
+                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \
+                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \
+                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \
+                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
+                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
+                               ((FLAG) == I2C_FLAG_SB))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Events 
+  * @{
+  */
+
+/**
+ ===============================================================================
+               I2C Master Events (Events grouped in order of communication)
+ ===============================================================================
+ */
+
+/** 
+  * @brief  Communication start
+  * 
+  * After sending the START condition (I2C_GenerateSTART() function) the master 
+  * has to wait for this event. It means that the Start condition has been correctly 
+  * released on the I2C bus (the bus is free, no other devices is communicating).
+  * 
+  */
+/* --EV5 */
+#define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */
+
+/** 
+  * @brief  Address Acknowledge
+  * 
+  * After checking on EV5 (start condition correctly released on the bus), the 
+  * master sends the address of the slave(s) with which it will communicate 
+  * (I2C_Send7bitAddress() function, it also determines the direction of the communication: 
+  * Master transmitter or Receiver). Then the master has to wait that a slave acknowledges 
+  * his address. If an acknowledge is sent on the bus, one of the following events will 
+  * be set:
+  * 
+  *  1) In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED 
+  *     event is set.
+  *  
+  *  2) In case of Master Transmitter (7-bit addressing): the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED 
+  *     is set
+  *  
+  *  3) In case of 10-Bit addressing mode, the master (just after generating the START 
+  *  and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData() 
+  *  function). Then master should wait on EV9. It means that the 10-bit addressing 
+  *  header has been correctly sent on the bus. Then master should send the second part of 
+  *  the 10-bit address (LSB) using the function I2C_Send7bitAddress(). Then master 
+  *  should wait for event EV6. 
+  *     
+  */
+
+/* --EV6 */
+#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
+#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
+/* --EV9 */
+#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */
+
+/** 
+  * @brief Communication events
+  * 
+  * If a communication is established (START condition generated and slave address 
+  * acknowledged) then the master has to check on one of the following events for 
+  * communication procedures:
+  *  
+  * 1) Master Receiver mode: The master has to wait on the event EV7 then to read 
+  *    the data received from the slave (I2C_ReceiveData() function).
+  * 
+  * 2) Master Transmitter mode: The master has to send data (I2C_SendData() 
+  *    function) then to wait on event EV8 or EV8_2.
+  *    These two events are similar: 
+  *     - EV8 means that the data has been written in the data register and is 
+  *       being shifted out.
+  *     - EV8_2 means that the data has been physically shifted out and output 
+  *       on the bus.
+  *     In most cases, using EV8 is sufficient for the application.
+  *     Using EV8_2 leads to a slower communication but ensure more reliable test.
+  *     EV8_2 is also more suitable than EV8 for testing on the last data transmission 
+  *     (before Stop condition generation).
+  *     
+  *  @note In case the  user software does not guarantee that this event EV7 is 
+  *        managed before the current byte end of transfer, then user may check on EV7 
+  *        and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)).
+  *        In this case the communication may be slower.
+  * 
+  */
+
+/* Master RECEIVER mode -----------------------------*/ 
+/* --EV7 */
+#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */
+
+/* Master TRANSMITTER mode --------------------------*/
+/* --EV8 */
+#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
+/* --EV8_2 */
+#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
+
+
+/**
+ ===============================================================================
+               I2C Slave Events (Events grouped in order of communication)
+ ===============================================================================
+ */
+
+
+/** 
+  * @brief  Communication start events
+  * 
+  * Wait on one of these events at the start of the communication. It means that 
+  * the I2C peripheral detected a Start condition on the bus (generated by master 
+  * device) followed by the peripheral address. The peripheral generates an ACK 
+  * condition on the bus (if the acknowledge feature is enabled through function 
+  * I2C_AcknowledgeConfig()) and the events listed above are set :
+  *  
+  * 1) In normal case (only one address managed by the slave), when the address 
+  *   sent by the master matches the own address of the peripheral (configured by 
+  *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set 
+  *   (where XXX could be TRANSMITTER or RECEIVER).
+  *    
+  * 2) In case the address sent by the master matches the second address of the 
+  *   peripheral (configured by the function I2C_OwnAddress2Config() and enabled 
+  *   by the function I2C_DualAddressCmd()) the events I2C_EVENT_SLAVE_XXX_SECONDADDRESS_MATCHED 
+  *   (where XXX could be TRANSMITTER or RECEIVER) are set.
+  *   
+  * 3) In case the address sent by the master is General Call (address 0x00) and 
+  *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd()) 
+  *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.   
+  * 
+  */
+
+/* --EV1  (all the events below are variants of EV1) */   
+/* 1) Case of One Single Address managed by the slave */
+#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */
+#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
+
+/* 2) Case of Dual address managed by the slave */
+#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */
+#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
+
+/* 3) Case of General Call enabled for the slave */
+#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */
+
+/** 
+  * @brief  Communication events
+  * 
+  * Wait on one of these events when EV1 has already been checked and: 
+  * 
+  * - Slave RECEIVER mode:
+  *     - EV2: When the application is expecting a data byte to be received. 
+  *     - EV4: When the application is expecting the end of the communication: master 
+  *       sends a stop condition and data transmission is stopped.
+  *    
+  * - Slave Transmitter mode:
+  *    - EV3: When a byte has been transmitted by the slave and the application is expecting 
+  *      the end of the byte transmission. The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and
+  *      I2C_EVENT_SLAVE_BYTE_TRANSMITTING are similar. The second one can optionally be 
+  *      used when the user software doesn't guarantee the EV3 is managed before the
+  *      current byte end of transfer.
+  *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission 
+  *      shall end (before sending the STOP condition). In this case slave has to stop sending 
+  *      data bytes and expect a Stop condition on the bus.
+  *      
+  *  @note In case the  user software does not guarantee that the event EV2 is 
+  *        managed before the current byte end of transfer, then user may check on EV2 
+  *        and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).
+  *        In this case the communication may be slower.
+  *
+  */
+
+/* Slave RECEIVER mode --------------------------*/ 
+/* --EV2 */
+#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */
+/* --EV4  */
+#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */
+
+/* Slave TRANSMITTER mode -----------------------*/
+/* --EV3 */
+#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
+#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTING                 ((uint32_t)0x00060080)  /* TRA, BUSY and TXE flags */
+/* --EV3_2 */
+#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */
+
+/*
+ ===============================================================================
+                          End of Events Description
+ ===============================================================================
+ */
+
+#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
+                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \
+                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
+                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \
+                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
+                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \
+                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_own_address1 
+  * @{
+  */
+
+#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)
+/**
+  * @}
+  */
+
+/** @defgroup I2C_clock_speed 
+  * @{
+  */
+
+#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/*  Function used to set the I2C configuration to the default reset state *****/
+void I2C_DeInit(I2C_TypeDef* I2Cx);
+
+/* Initialization and Configuration functions *********************************/
+void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
+void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
+void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter);
+void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
+void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address);
+void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle);
+void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);
+void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert);
+void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+
+/* Data transfers functions ***************************************************/ 
+void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
+uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
+
+/* PEC management functions ***************************************************/ 
+void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition);
+void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
+uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);
+
+/* DMA transfers management functions *****************************************/
+void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+
+/* Interrupts, events and flags management functions **************************/
+uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
+void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);
+
+/* 
+ ===============================================================================
+                          I2C State Monitoring Functions
+ ===============================================================================
+  This I2C driver provides three different ways for I2C state monitoring
+  depending on the application requirements and constraints:
+         
+   
+     1. Basic state monitoring (Using I2C_CheckEvent() function)
+     -----------------------------------------------------------
+        It compares the status registers (SR1 and SR2) content to a given event
+        (can be the combination of one or more flags).
+        It returns SUCCESS if the current status includes the given flags 
+        and returns ERROR if one or more flags are missing in the current status.
+
+          - When to use
+             - This function is suitable for most applications as well as for startup 
+               activity since the events are fully described in the product reference 
+               manual (RM0090).
+             - It is also suitable for users who need to define their own events.
+
+          - Limitations
+             - If an error occurs (ie. error flags are set besides to the monitored 
+               flags), the I2C_CheckEvent() function may return SUCCESS despite 
+               the communication hold or corrupted real state. 
+               In this case, it is advised to use error interrupts to monitor 
+               the error events and handle them in the interrupt IRQ handler.
+         
+     Note 
+         For error management, it is advised to use the following functions:
+           - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
+           - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
+             Where x is the peripheral instance (I2C1, I2C2 ...)
+           - I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
+             I2Cx_ER_IRQHandler() function in order to determine which error occurred.
+           - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
+             and/or I2C_GenerateStop() in order to clear the error flag and source 
+             and return to correct  communication status.
+             
+ 
+     2. Advanced state monitoring (Using the function I2C_GetLastEvent())
+     -------------------------------------------------------------------- 
+        Using the function I2C_GetLastEvent() which returns the image of both status 
+        registers in a single word (uint32_t) (Status Register 2 value is shifted left 
+        by 16 bits and concatenated to Status Register 1).
+
+          - When to use
+             - This function is suitable for the same applications above but it 
+               allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
+               function.
+             - The returned value could be compared to events already defined in 
+               this file or to custom values defined by user.
+               This function is suitable when multiple flags are monitored at the 
+               same time.
+             - At the opposite of I2C_CheckEvent() function, this function allows 
+               user to choose when an event is accepted (when all events flags are 
+               set and no other flags are set or just when the needed flags are set 
+               like I2C_CheckEvent() function.
+
+          - Limitations
+             - User may need to define his own events.
+             - Same remark concerning the error management is applicable for this 
+               function if user decides to check only regular communication flags 
+               (and ignores error flags).
+      
+ 
+     3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
+     -----------------------------------------------------------------------
+     
+      Using the function I2C_GetFlagStatus() which simply returns the status of 
+      one single flag (ie. I2C_FLAG_RXNE ...). 
+
+          - When to use
+             - This function could be used for specific applications or in debug 
+               phase.
+             - It is suitable when only one flag checking is needed (most I2C 
+               events are monitored through multiple flags).
+          - Limitations: 
+             - When calling this function, the Status register is accessed. 
+               Some flags are cleared when the status register is accessed. 
+               So checking the status of one Flag, may clear other ones.
+             - Function may need to be called twice or more in order to monitor 
+               one single event.           
+ */
+
+/*
+ ===============================================================================
+                          1. Basic state monitoring
+ ===============================================================================
+ */
+ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
+/*
+ ===============================================================================
+                          2. Advanced state monitoring
+ ===============================================================================
+ */
+uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
+/*
+ ===============================================================================
+                          3. Flag-based state monitoring
+ ===============================================================================
+ */
+FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
+
+
+void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
+ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
+void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_I2C_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_iwdg.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_iwdg.h
new file mode 100644
index 0000000..2650bd8
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_iwdg.h
@@ -0,0 +1,131 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_iwdg.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the IWDG 
+  *          firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_IWDG_H
+#define __STM32F4xx_IWDG_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup IWDG
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup IWDG_Exported_Constants
+  * @{
+  */
+  
+/** @defgroup IWDG_WriteAccess
+  * @{
+  */
+#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
+#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
+#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
+                                      ((ACCESS) == IWDG_WriteAccess_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_prescaler 
+  * @{
+  */
+#define IWDG_Prescaler_4            ((uint8_t)0x00)
+#define IWDG_Prescaler_8            ((uint8_t)0x01)
+#define IWDG_Prescaler_16           ((uint8_t)0x02)
+#define IWDG_Prescaler_32           ((uint8_t)0x03)
+#define IWDG_Prescaler_64           ((uint8_t)0x04)
+#define IWDG_Prescaler_128          ((uint8_t)0x05)
+#define IWDG_Prescaler_256          ((uint8_t)0x06)
+#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
+                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
+                                      ((PRESCALER) == IWDG_Prescaler_16) || \
+                                      ((PRESCALER) == IWDG_Prescaler_32) || \
+                                      ((PRESCALER) == IWDG_Prescaler_64) || \
+                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
+                                      ((PRESCALER) == IWDG_Prescaler_256))
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Flag 
+  * @{
+  */
+#define IWDG_FLAG_PVU               ((uint16_t)0x0001)
+#define IWDG_FLAG_RVU               ((uint16_t)0x0002)
+#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))
+#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+
+/* Prescaler and Counter configuration functions ******************************/
+void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
+void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
+void IWDG_SetReload(uint16_t Reload);
+void IWDG_ReloadCounter(void);
+
+/* IWDG activation function ***************************************************/
+void IWDG_Enable(void);
+
+/* Flag management function ***************************************************/
+FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_IWDG_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_ltdc.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_ltdc.h
new file mode 100644
index 0000000..1c67a77
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_ltdc.h
@@ -0,0 +1,531 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_ltdc.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the LTDC firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_LTDC_H
+#define __STM32F4xx_LTDC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup LTDC
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+ 
+/** 
+  * @brief  LTDC Init structure definition  
+  */
+
+typedef struct
+{
+  uint32_t LTDC_HSPolarity;                 /*!< configures the horizontal synchronization polarity.
+                                                 This parameter can be one value of @ref LTDC_HSPolarity */
+
+  uint32_t LTDC_VSPolarity;                 /*!< configures the vertical synchronization polarity.
+                                                 This parameter can be one value of @ref LTDC_VSPolarity */
+
+  uint32_t LTDC_DEPolarity;                 /*!< configures the data enable polarity. This parameter can
+                                                 be one of value of @ref LTDC_DEPolarity */
+
+  uint32_t LTDC_PCPolarity;                 /*!< configures the pixel clock polarity. This parameter can
+                                                 be one of value of @ref LTDC_PCPolarity */
+
+  uint32_t LTDC_HorizontalSync;             /*!< configures the number of Horizontal synchronization 
+                                                 width. This parameter must range from 0x000 to 0xFFF. */
+
+  uint32_t LTDC_VerticalSync;               /*!< configures the number of Vertical synchronization 
+                                                 heigh. This parameter must range from 0x000 to 0x7FF. */
+
+  uint32_t LTDC_AccumulatedHBP;             /*!< configures the accumulated horizontal back porch width.
+                                                 This parameter must range from LTDC_HorizontalSync to 0xFFF. */
+
+  uint32_t LTDC_AccumulatedVBP;             /*!< configures the accumulated vertical back porch heigh.
+                                                 This parameter must range from LTDC_VerticalSync to 0x7FF. */
+            
+  uint32_t LTDC_AccumulatedActiveW;         /*!< configures the accumulated active width. This parameter 
+                                                 must range from LTDC_AccumulatedHBP to 0xFFF. */
+
+  uint32_t LTDC_AccumulatedActiveH;         /*!< configures the accumulated active heigh. This parameter 
+                                                 must range from LTDC_AccumulatedVBP to 0x7FF. */
+
+  uint32_t LTDC_TotalWidth;                 /*!< configures the total width. This parameter 
+                                                 must range from LTDC_AccumulatedActiveW to 0xFFF. */
+
+  uint32_t LTDC_TotalHeigh;                 /*!< configures the total heigh. This parameter 
+                                                 must range from LTDC_AccumulatedActiveH to 0x7FF. */
+            
+  uint32_t LTDC_BackgroundRedValue;         /*!< configures the background red value.
+                                                 This parameter must range from 0x00 to 0xFF. */
+
+  uint32_t LTDC_BackgroundGreenValue;       /*!< configures the background green value.
+                                                 This parameter must range from 0x00 to 0xFF. */ 
+
+   uint32_t LTDC_BackgroundBlueValue;       /*!< configures the background blue value.
+                                                 This parameter must range from 0x00 to 0xFF. */
+} LTDC_InitTypeDef;
+
+/** 
+  * @brief  LTDC Layer structure definition  
+  */
+
+typedef struct
+{
+  uint32_t LTDC_HorizontalStart;            /*!< Configures the Window Horizontal Start Position.
+                                                 This parameter must range from 0x000 to 0xFFF. */
+            
+  uint32_t LTDC_HorizontalStop;             /*!< Configures the Window Horizontal Stop Position.
+                                                 This parameter must range from 0x0000 to 0xFFFF. */
+  
+  uint32_t LTDC_VerticalStart;              /*!< Configures the Window vertical Start Position.
+                                                 This parameter must range from 0x000 to 0xFFF. */
+
+  uint32_t LTDC_VerticalStop;               /*!< Configures the Window vaertical Stop Position.
+                                                 This parameter must range from 0x0000 to 0xFFFF. */
+  
+  uint32_t LTDC_PixelFormat;                /*!< Specifies the pixel format. This parameter can be 
+                                                 one of value of @ref LTDC_Pixelformat */
+
+  uint32_t LTDC_ConstantAlpha;              /*!< Specifies the constant alpha used for blending.
+                                                 This parameter must range from 0x00 to 0xFF. */
+
+  uint32_t LTDC_DefaultColorBlue;           /*!< Configures the default blue value.
+                                                 This parameter must range from 0x00 to 0xFF. */
+
+  uint32_t LTDC_DefaultColorGreen;          /*!< Configures the default green value.
+                                                 This parameter must range from 0x00 to 0xFF. */
+            
+  uint32_t LTDC_DefaultColorRed;            /*!< Configures the default red value.
+                                                 This parameter must range from 0x00 to 0xFF. */
+
+  uint32_t LTDC_DefaultColorAlpha;          /*!< Configures the default alpha value.
+                                                 This parameter must range from 0x00 to 0xFF. */
+
+  uint32_t LTDC_BlendingFactor_1;           /*!< Select the blending factor 1. This parameter 
+                                                 can be one of value of @ref LTDC_BlendingFactor1 */
+
+  uint32_t LTDC_BlendingFactor_2;           /*!< Select the blending factor 2. This parameter 
+                                                 can be one of value of @ref LTDC_BlendingFactor2 */
+            
+  uint32_t LTDC_CFBStartAdress;             /*!< Configures the color frame buffer address */
+
+  uint32_t LTDC_CFBLineLength;              /*!< Configures the color frame buffer line length. 
+                                                 This parameter must range from 0x0000 to 0x1FFF. */
+
+  uint32_t LTDC_CFBPitch;                   /*!< Configures the color frame buffer pitch in bytes.
+                                                 This parameter must range from 0x0000 to 0x1FFF. */
+                                                 
+  uint32_t LTDC_CFBLineNumber;              /*!< Specifies the number of line in frame buffer. 
+                                                 This parameter must range from 0x000 to 0x7FF. */
+} LTDC_Layer_InitTypeDef;
+
+/** 
+  * @brief  LTDC Position structure definition  
+  */
+
+typedef struct
+{
+  uint32_t LTDC_POSX;                         /*!<  Current X Position */
+  uint32_t LTDC_POSY;                         /*!<  Current Y Position */
+} LTDC_PosTypeDef;
+
+typedef struct
+{
+  uint32_t LTDC_BlueWidth;                        /*!< Blue width */
+  uint32_t LTDC_GreenWidth;                       /*!< Green width */
+  uint32_t LTDC_RedWidth;                         /*!< Red width */
+} LTDC_RGBTypeDef;
+
+typedef struct
+{
+  uint32_t LTDC_ColorKeyBlue;               /*!< Configures the color key blue value. 
+                                                 This parameter must range from 0x00 to 0xFF. */
+
+  uint32_t LTDC_ColorKeyGreen;              /*!< Configures the color key green value. 
+                                                 This parameter must range from 0x00 to 0xFF. */
+            
+  uint32_t LTDC_ColorKeyRed;                /*!< Configures the color key red value. 
+                                                 This parameter must range from 0x00 to 0xFF. */
+} LTDC_ColorKeying_InitTypeDef;
+
+typedef struct
+{
+  uint32_t LTDC_CLUTAdress;                 /*!< Configures the CLUT address.
+                                                 This parameter must range from 0x00 to 0xFF. */
+
+  uint32_t LTDC_BlueValue;                  /*!< Configures the blue value. 
+                                                 This parameter must range from 0x00 to 0xFF. */
+                                                 
+  uint32_t LTDC_GreenValue;                 /*!< Configures the green value. 
+                                                 This parameter must range from 0x00 to 0xFF. */
+
+  uint32_t LTDC_RedValue;                   /*!< Configures the red value.
+                                                 This parameter must range from 0x00 to 0xFF. */
+} LTDC_CLUT_InitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup LTDC_Exported_Constants
+  * @}
+  */
+  
+/** @defgroup LTDC_SYNC 
+  * @{
+  */
+
+#define LTDC_HorizontalSYNC               ((uint32_t)0x00000FFF)
+#define LTDC_VerticalSYNC                 ((uint32_t)0x000007FF)
+
+#define IS_LTDC_HSYNC(HSYNC) ((HSYNC) <= LTDC_HorizontalSYNC)
+#define IS_LTDC_VSYNC(VSYNC) ((VSYNC) <= LTDC_VerticalSYNC)
+#define IS_LTDC_AHBP(AHBP)  ((AHBP) <= LTDC_HorizontalSYNC)
+#define IS_LTDC_AVBP(AVBP) ((AVBP) <= LTDC_VerticalSYNC)
+#define IS_LTDC_AAW(AAW)   ((AAW) <= LTDC_HorizontalSYNC)
+#define IS_LTDC_AAH(AAH) ((AAH) <= LTDC_VerticalSYNC)
+#define IS_LTDC_TOTALW(TOTALW) ((TOTALW) <= LTDC_HorizontalSYNC)
+#define IS_LTDC_TOTALH(TOTALH) ((TOTALH) <= LTDC_VerticalSYNC)
+
+/**
+  * @}
+  */
+  
+/** @defgroup LTDC_HSPolarity 
+  * @{
+  */
+#define LTDC_HSPolarity_AL                ((uint32_t)0x00000000)                /*!< Horizontal Synchronization is active low. */
+#define LTDC_HSPolarity_AH                LTDC_GCR_HSPOL                        /*!< Horizontal Synchronization is active high. */
+
+#define IS_LTDC_HSPOL(HSPOL) (((HSPOL) == LTDC_HSPolarity_AL) || \
+                              ((HSPOL) == LTDC_HSPolarity_AH))  
+
+/**
+  * @}
+  */
+  
+/** @defgroup LTDC_VSPolarity 
+  * @{
+  */
+#define LTDC_VSPolarity_AL                ((uint32_t)0x00000000)                /*!< Vertical Synchronization is active low. */
+#define LTDC_VSPolarity_AH                LTDC_GCR_VSPOL                        /*!< Vertical Synchronization is active high. */
+
+#define IS_LTDC_VSPOL(VSPOL) (((VSPOL) == LTDC_VSPolarity_AL) || \
+                              ((VSPOL) == LTDC_VSPolarity_AH))  
+
+/**
+  * @}
+  */
+  
+/** @defgroup LTDC_DEPolarity 
+  * @{
+  */
+#define LTDC_DEPolarity_AL                ((uint32_t)0x00000000)                /*!< Data Enable, is active low. */
+#define LTDC_DEPolarity_AH                LTDC_GCR_DEPOL                        /*!< Data Enable, is active high. */
+
+#define IS_LTDC_DEPOL(DEPOL) (((DEPOL) ==  LTDC_VSPolarity_AL) || \
+                              ((DEPOL) ==  LTDC_DEPolarity_AH))
+
+/**
+  * @}
+  */
+
+/** @defgroup LTDC_PCPolarity 
+  * @{
+  */
+#define LTDC_PCPolarity_IPC               ((uint32_t)0x00000000)                /*!< input pixel clock. */
+#define LTDC_PCPolarity_IIPC              LTDC_GCR_PCPOL                        /*!< inverted input pixel clock. */
+
+#define IS_LTDC_PCPOL(PCPOL) (((PCPOL) ==  LTDC_PCPolarity_IPC) || \
+                              ((PCPOL) ==  LTDC_PCPolarity_IIPC))
+
+/**
+  * @}
+  */
+
+/** @defgroup LTDC_Reload 
+  * @{
+  */
+#define LTDC_IMReload                     LTDC_SRCR_IMR                         /*!< Immediately Reload. */
+#define LTDC_VBReload                     LTDC_SRCR_VBR                         /*!< Vertical Blanking Reload. */
+
+#define IS_LTDC_RELOAD(RELOAD) (((RELOAD) == LTDC_IMReload) || \
+                                ((RELOAD) == LTDC_VBReload))
+
+/**
+  * @}
+  */
+  
+/** @defgroup LTDC_Back_Color
+  * @{
+  */ 
+
+#define LTDC_Back_Color                   ((uint32_t)0x000000FF)
+
+#define IS_LTDC_BackBlueValue(BBLUE)    ((BBLUE) <= LTDC_Back_Color)
+#define IS_LTDC_BackGreenValue(BGREEN)  ((BGREEN) <= LTDC_Back_Color)
+#define IS_LTDC_BackRedValue(BRED)      ((BRED) <= LTDC_Back_Color) 
+
+/**
+  * @}
+  */
+      
+/** @defgroup LTDC_Position 
+  * @{
+  */
+
+#define LTDC_POS_CY                       LTDC_CPSR_CYPOS
+#define LTDC_POS_CX                       LTDC_CPSR_CXPOS
+
+#define IS_LTDC_GET_POS(POS) (((POS) <= LTDC_POS_CY))
+
+
+/**
+  * @}
+  */
+      
+/** @defgroup LTDC_LIPosition 
+  * @{
+  */
+
+#define IS_LTDC_LIPOS(LIPOS) ((LIPOS) <= 0x7FF)
+
+/**
+  * @}
+  */
+      
+/** @defgroup LTDC_CurrentStatus 
+  * @{
+  */
+
+#define LTDC_CD_VDES                     LTDC_CDSR_VDES
+#define LTDC_CD_HDES                     LTDC_CDSR_HDES
+#define LTDC_CD_VSYNC                    LTDC_CDSR_VSYNCS
+#define LTDC_CD_HSYNC                    LTDC_CDSR_HSYNCS
+
+
+#define IS_LTDC_GET_CD(CD) (((CD) == LTDC_CD_VDES) || ((CD) == LTDC_CD_HDES) || \
+                              ((CD) == LTDC_CD_VSYNC) || ((CD) == LTDC_CD_HSYNC))
+
+
+/**
+  * @}
+  */  
+
+/** @defgroup LTDC_Interrupts 
+  * @{
+  */                           
+
+#define LTDC_IT_LI                      LTDC_IER_LIE
+#define LTDC_IT_FU                      LTDC_IER_FUIE
+#define LTDC_IT_TERR                    LTDC_IER_TERRIE
+#define LTDC_IT_RR                      LTDC_IER_RRIE
+
+#define IS_LTDC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFF0) == 0x00) && ((IT) != 0x00))
+
+/**
+  * @}
+  */
+      
+/** @defgroup LTDC_Flag 
+  * @{
+  */
+
+#define LTDC_FLAG_LI                     LTDC_ISR_LIF
+#define LTDC_FLAG_FU                     LTDC_ISR_FUIF
+#define LTDC_FLAG_TERR                   LTDC_ISR_TERRIF
+#define LTDC_FLAG_RR                     LTDC_ISR_RRIF
+
+
+#define IS_LTDC_FLAG(FLAG) (((FLAG) == LTDC_FLAG_LI) || ((FLAG) == LTDC_FLAG_FU) || \
+                               ((FLAG) == LTDC_FLAG_TERR) || ((FLAG) == LTDC_FLAG_RR))
+
+/**
+  * @}
+  */
+      
+/** @defgroup LTDC_Pixelformat 
+  * @{
+  */
+#define LTDC_Pixelformat_ARGB8888                  ((uint32_t)0x00000000)
+#define LTDC_Pixelformat_RGB888                    ((uint32_t)0x00000001)
+#define LTDC_Pixelformat_RGB565                    ((uint32_t)0x00000002)
+#define LTDC_Pixelformat_ARGB1555                  ((uint32_t)0x00000003)
+#define LTDC_Pixelformat_ARGB4444                  ((uint32_t)0x00000004)
+#define LTDC_Pixelformat_L8                        ((uint32_t)0x00000005)
+#define LTDC_Pixelformat_AL44                      ((uint32_t)0x00000006)
+#define LTDC_Pixelformat_AL88                      ((uint32_t)0x00000007)
+
+#define IS_LTDC_Pixelformat(Pixelformat) (((Pixelformat) == LTDC_Pixelformat_ARGB8888) || ((Pixelformat) == LTDC_Pixelformat_RGB888)   || \
+                        ((Pixelformat) == LTDC_Pixelformat_RGB565)   || ((Pixelformat) == LTDC_Pixelformat_ARGB1555) || \
+                        ((Pixelformat) == LTDC_Pixelformat_ARGB4444) || ((Pixelformat) == LTDC_Pixelformat_L8)       || \
+                        ((Pixelformat) == LTDC_Pixelformat_AL44)     || ((Pixelformat) == LTDC_Pixelformat_AL88))
+
+/**
+  * @}
+  */
+      
+/** @defgroup LTDC_BlendingFactor1 
+  * @{
+  */
+
+#define LTDC_BlendingFactor1_CA                       ((uint32_t)0x00000400)
+#define LTDC_BlendingFactor1_PAxCA                    ((uint32_t)0x00000600)
+
+#define IS_LTDC_BlendingFactor1(BlendingFactor1) (((BlendingFactor1) == LTDC_BlendingFactor1_CA) || ((BlendingFactor1) == LTDC_BlendingFactor1_PAxCA))
+
+/**
+  * @}
+  */
+      
+/** @defgroup LTDC_BlendingFactor2
+  * @{
+  */
+
+#define LTDC_BlendingFactor2_CA                       ((uint32_t)0x00000005)
+#define LTDC_BlendingFactor2_PAxCA                    ((uint32_t)0x00000007)
+
+#define IS_LTDC_BlendingFactor2(BlendingFactor2) (((BlendingFactor2) == LTDC_BlendingFactor2_CA) || ((BlendingFactor2) == LTDC_BlendingFactor2_PAxCA))
+
+
+/**
+  * @}
+  */
+      
+     
+/** @defgroup LTDC_LAYER_Config
+  * @{
+  */
+
+#define LTDC_STOPPosition                 ((uint32_t)0x0000FFFF)
+#define LTDC_STARTPosition                ((uint32_t)0x00000FFF)
+
+#define LTDC_DefaultColorConfig           ((uint32_t)0x000000FF)
+#define LTDC_ColorFrameBuffer             ((uint32_t)0x00001FFF)
+#define LTDC_LineNumber                   ((uint32_t)0x000007FF)
+
+#define IS_LTDC_HCONFIGST(HCONFIGST) ((HCONFIGST) <= LTDC_STARTPosition)
+#define IS_LTDC_HCONFIGSP(HCONFIGSP) ((HCONFIGSP) <= LTDC_STOPPosition)
+#define IS_LTDC_VCONFIGST(VCONFIGST)  ((VCONFIGST) <= LTDC_STARTPosition)
+#define IS_LTDC_VCONFIGSP(VCONFIGSP) ((VCONFIGSP) <= LTDC_STOPPosition)
+
+#define IS_LTDC_DEFAULTCOLOR(DEFAULTCOLOR) ((DEFAULTCOLOR) <= LTDC_DefaultColorConfig)
+
+#define IS_LTDC_CFBP(CFBP) ((CFBP) <= LTDC_ColorFrameBuffer)
+#define IS_LTDC_CFBLL(CFBLL) ((CFBLL) <= LTDC_ColorFrameBuffer)
+
+#define IS_LTDC_CFBLNBR(CFBLNBR) ((CFBLNBR) <= LTDC_LineNumber)
+
+
+
+/**
+  * @}
+  */
+          
+/** @defgroup LTDC_colorkeying_Config
+  * @{
+  */
+
+#define LTDC_colorkeyingConfig            ((uint32_t)0x000000FF)
+
+#define IS_LTDC_CKEYING(CKEYING) ((CKEYING) <= LTDC_colorkeyingConfig)
+
+
+/**
+  * @}
+  */
+          
+/** @defgroup LTDC_CLUT_Config
+  * @{
+  */
+
+#define LTDC_CLUTWR                       ((uint32_t)0x000000FF)
+
+#define IS_LTDC_CLUTWR(CLUTWR)  ((CLUTWR) <= LTDC_CLUTWR)
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions ------------------------------------------------------- */
+
+/*  Function used to set the LTDC configuration to the default reset state *****/
+void LTDC_DeInit(void);
+
+/* Initialization and Configuration functions *********************************/
+void LTDC_Init(LTDC_InitTypeDef* LTDC_InitStruct);
+void LTDC_StructInit(LTDC_InitTypeDef* LTDC_InitStruct);
+void LTDC_Cmd(FunctionalState NewState);
+void LTDC_DitherCmd(FunctionalState NewState);
+LTDC_RGBTypeDef LTDC_GetRGBWidth(void);
+void LTDC_RGBStructInit(LTDC_RGBTypeDef* LTDC_RGB_InitStruct);
+void LTDC_LIPConfig(uint32_t LTDC_LIPositionConfig);
+void LTDC_ReloadConfig(uint32_t LTDC_Reload);
+void LTDC_LayerInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_Layer_InitTypeDef* LTDC_Layer_InitStruct);
+void LTDC_LayerStructInit(LTDC_Layer_InitTypeDef * LTDC_Layer_InitStruct);
+void LTDC_LayerCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState);
+LTDC_PosTypeDef LTDC_GetPosStatus(void);
+void LTDC_PosStructInit(LTDC_PosTypeDef* LTDC_Pos_InitStruct);
+FlagStatus LTDC_GetCDStatus(uint32_t LTDC_CD);
+void LTDC_ColorKeyingConfig(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct, FunctionalState NewState);
+void LTDC_ColorKeyingStructInit(LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct);
+void LTDC_CLUTCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState);
+void LTDC_CLUTInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct);
+void LTDC_CLUTStructInit(LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct);
+void LTDC_LayerPosition(LTDC_Layer_TypeDef* LTDC_Layerx, uint16_t OffsetX, uint16_t OffsetY);
+void LTDC_LayerAlpha(LTDC_Layer_TypeDef* LTDC_Layerx, uint8_t ConstantAlpha);
+void LTDC_LayerAddress(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Address);
+void LTDC_LayerSize(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Width, uint32_t Height);
+void LTDC_LayerPixelFormat(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t PixelFormat);
+
+/* Interrupts and flags management functions **********************************/
+void LTDC_ITConfig(uint32_t LTDC_IT, FunctionalState NewState);
+FlagStatus LTDC_GetFlagStatus(uint32_t LTDC_FLAG);
+void LTDC_ClearFlag(uint32_t LTDC_FLAG);
+ITStatus LTDC_GetITStatus(uint32_t LTDC_IT);
+void LTDC_ClearITPendingBit(uint32_t LTDC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_LTDC_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_pwr.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_pwr.h
new file mode 100644
index 0000000..636b1e0
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_pwr.h
@@ -0,0 +1,212 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_pwr.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the PWR firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */ 
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_PWR_H
+#define __STM32F4xx_PWR_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup PWR
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup PWR_Exported_Constants
+  * @{
+  */ 
+
+/** @defgroup PWR_PVD_detection_level 
+  * @{
+  */ 
+#define PWR_PVDLevel_0                  PWR_CR_PLS_LEV0
+#define PWR_PVDLevel_1                  PWR_CR_PLS_LEV1
+#define PWR_PVDLevel_2                  PWR_CR_PLS_LEV2
+#define PWR_PVDLevel_3                  PWR_CR_PLS_LEV3
+#define PWR_PVDLevel_4                  PWR_CR_PLS_LEV4
+#define PWR_PVDLevel_5                  PWR_CR_PLS_LEV5
+#define PWR_PVDLevel_6                  PWR_CR_PLS_LEV6
+#define PWR_PVDLevel_7                  PWR_CR_PLS_LEV7
+
+#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)|| \
+                                 ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)|| \
+                                 ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)|| \
+                                 ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7))
+/**
+  * @}
+  */
+
+  
+/** @defgroup PWR_Regulator_state_in_STOP_mode 
+  * @{
+  */
+#define PWR_MainRegulator_ON                        ((uint32_t)0x00000000)
+#define PWR_LowPowerRegulator_ON                    PWR_CR_LPDS
+
+/* --- PWR_Legacy ---*/
+#define PWR_Regulator_ON                            PWR_MainRegulator_ON
+#define PWR_Regulator_LowPower                      PWR_LowPowerRegulator_ON
+
+#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MainRegulator_ON) || \
+                                     ((REGULATOR) == PWR_LowPowerRegulator_ON))
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Regulator_state_in_UnderDrive_mode 
+  * @{
+  */
+#define PWR_MainRegulator_UnderDrive_ON               PWR_CR_MRUDS
+#define PWR_LowPowerRegulator_UnderDrive_ON           ((uint32_t)(PWR_CR_LPDS | PWR_CR_LPUDS))
+
+#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MainRegulator_UnderDrive_ON) || \
+                                                ((REGULATOR) == PWR_LowPowerRegulator_UnderDrive_ON))
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_STOP_mode_entry 
+  * @{
+  */
+#define PWR_STOPEntry_WFI               ((uint8_t)0x01)
+#define PWR_STOPEntry_WFE               ((uint8_t)0x02)
+#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Regulator_Voltage_Scale 
+  * @{
+  */
+#define PWR_Regulator_Voltage_Scale1    ((uint32_t)0x0000C000)
+#define PWR_Regulator_Voltage_Scale2    ((uint32_t)0x00008000)
+#define PWR_Regulator_Voltage_Scale3    ((uint32_t)0x00004000)
+#define IS_PWR_REGULATOR_VOLTAGE(VOLTAGE) (((VOLTAGE) == PWR_Regulator_Voltage_Scale1) || \
+                                           ((VOLTAGE) == PWR_Regulator_Voltage_Scale2) || \
+                                           ((VOLTAGE) == PWR_Regulator_Voltage_Scale3))
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Flag 
+  * @{
+  */
+#define PWR_FLAG_WU                     PWR_CSR_WUF
+#define PWR_FLAG_SB                     PWR_CSR_SBF
+#define PWR_FLAG_PVDO                   PWR_CSR_PVDO
+#define PWR_FLAG_BRR                    PWR_CSR_BRR
+#define PWR_FLAG_VOSRDY                 PWR_CSR_VOSRDY
+#define PWR_FLAG_ODRDY                  PWR_CSR_ODRDY
+#define PWR_FLAG_ODSWRDY                PWR_CSR_ODSWRDY
+#define PWR_FLAG_UDRDY                  PWR_CSR_UDSWRDY
+
+/* --- FLAG Legacy ---*/
+#define PWR_FLAG_REGRDY                  PWR_FLAG_VOSRDY               
+
+#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
+                               ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_BRR) || \
+                               ((FLAG) == PWR_FLAG_VOSRDY) || ((FLAG) == PWR_FLAG_ODRDY) || \
+                               ((FLAG) == PWR_FLAG_ODSWRDY) || ((FLAG) == PWR_FLAG_UDRDY))
+
+
+#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
+                                 ((FLAG) == PWR_FLAG_UDRDY))
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/* Function used to set the PWR configuration to the default reset state ******/ 
+void PWR_DeInit(void);
+
+/* Backup Domain Access function **********************************************/ 
+void PWR_BackupAccessCmd(FunctionalState NewState);
+
+/* PVD configuration functions ************************************************/ 
+void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);
+void PWR_PVDCmd(FunctionalState NewState);
+
+/* WakeUp pins configuration functions ****************************************/ 
+void PWR_WakeUpPinCmd(FunctionalState NewState);
+
+/* Main and Backup Regulators configuration functions *************************/ 
+void PWR_BackupRegulatorCmd(FunctionalState NewState);
+void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage);
+void PWR_OverDriveCmd(FunctionalState NewState);
+void PWR_OverDriveSWCmd(FunctionalState NewState);
+void PWR_UnderDriveCmd(FunctionalState NewState);
+void PWR_MainRegulatorLowVoltageCmd(FunctionalState NewState);
+void PWR_LowRegulatorLowVoltageCmd(FunctionalState NewState);
+
+/* FLASH Power Down configuration functions ***********************************/ 
+void PWR_FlashPowerDownCmd(FunctionalState NewState);
+
+/* Low Power modes configuration functions ************************************/ 
+void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
+void PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
+void PWR_EnterSTANDBYMode(void);
+
+/* Flags management functions *************************************************/ 
+FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
+void PWR_ClearFlag(uint32_t PWR_FLAG);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_PWR_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h
new file mode 100644
index 0000000..b550caf
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h
@@ -0,0 +1,630 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_rcc.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the RCC firmware library.  
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_RCC_H
+#define __STM32F4xx_RCC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup RCC
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+typedef struct
+{
+  uint32_t SYSCLK_Frequency; /*!<  SYSCLK clock frequency expressed in Hz */
+  uint32_t HCLK_Frequency;   /*!<  HCLK clock frequency expressed in Hz   */
+  uint32_t PCLK1_Frequency;  /*!<  PCLK1 clock frequency expressed in Hz  */
+  uint32_t PCLK2_Frequency;  /*!<  PCLK2 clock frequency expressed in Hz  */
+}RCC_ClocksTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup RCC_Exported_Constants
+  * @{
+  */
+  
+/** @defgroup RCC_HSE_configuration 
+  * @{
+  */
+#define RCC_HSE_OFF                      ((uint8_t)0x00)
+#define RCC_HSE_ON                       ((uint8_t)0x01)
+#define RCC_HSE_Bypass                   ((uint8_t)0x05)
+#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
+                         ((HSE) == RCC_HSE_Bypass))
+/**
+  * @}
+  */ 
+
+/** @defgroup RCC_LSE_Dual_Mode_Selection
+  * @{
+  */
+#define RCC_LSE_LOWPOWER_MODE           ((uint8_t)0x00)
+#define RCC_LSE_HIGHDRIVE_MODE          ((uint8_t)0x01)
+#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) || \
+                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
+/**
+  * @}
+  */
+
+/** @defgroup RCC_PLL_Clock_Source 
+  * @{
+  */
+#define RCC_PLLSource_HSI                ((uint32_t)0x00000000)
+#define RCC_PLLSource_HSE                ((uint32_t)0x00400000)
+#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI) || \
+                                   ((SOURCE) == RCC_PLLSource_HSE))
+#define IS_RCC_PLLM_VALUE(VALUE) ((VALUE) <= 63)
+#define IS_RCC_PLLN_VALUE(VALUE) ((192 <= (VALUE)) && ((VALUE) <= 432))
+#define IS_RCC_PLLP_VALUE(VALUE) (((VALUE) == 2) || ((VALUE) == 4) || ((VALUE) == 6) || ((VALUE) == 8))
+#define IS_RCC_PLLQ_VALUE(VALUE) ((4 <= (VALUE)) && ((VALUE) <= 15))
+ 
+#define IS_RCC_PLLI2SN_VALUE(VALUE) ((192 <= (VALUE)) && ((VALUE) <= 432))
+#define IS_RCC_PLLI2SR_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 7))  
+#define IS_RCC_PLLI2SM_VALUE(VALUE) ((VALUE) <= 63)  
+
+#define IS_RCC_PLLI2SQ_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 15))
+#define IS_RCC_PLLSAIN_VALUE(VALUE) ((192 <= (VALUE)) && ((VALUE) <= 432))
+#define IS_RCC_PLLSAIQ_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 15))
+#define IS_RCC_PLLSAIR_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 7))  
+
+#define IS_RCC_PLLSAI_DIVQ_VALUE(VALUE) ((1 <= (VALUE)) && ((VALUE) <= 32))
+#define IS_RCC_PLLI2S_DIVQ_VALUE(VALUE) ((1 <= (VALUE)) && ((VALUE) <= 32))
+
+#define RCC_PLLSAIDivR_Div2                ((uint32_t)0x00000000)
+#define RCC_PLLSAIDivR_Div4                ((uint32_t)0x00010000)
+#define RCC_PLLSAIDivR_Div8                ((uint32_t)0x00020000)
+#define RCC_PLLSAIDivR_Div16               ((uint32_t)0x00030000)
+#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDivR_Div2) ||\
+                                        ((VALUE) == RCC_PLLSAIDivR_Div4)  ||\
+                                        ((VALUE) == RCC_PLLSAIDivR_Div8)  ||\
+                                        ((VALUE) == RCC_PLLSAIDivR_Div16))
+ 
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_System_Clock_Source 
+  * @{
+  */
+#define RCC_SYSCLKSource_HSI             ((uint32_t)0x00000000)
+#define RCC_SYSCLKSource_HSE             ((uint32_t)0x00000001)
+#define RCC_SYSCLKSource_PLLCLK          ((uint32_t)0x00000002)
+#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
+                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
+                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_AHB_Clock_Source
+  * @{
+  */
+#define RCC_SYSCLK_Div1                  ((uint32_t)0x00000000)
+#define RCC_SYSCLK_Div2                  ((uint32_t)0x00000080)
+#define RCC_SYSCLK_Div4                  ((uint32_t)0x00000090)
+#define RCC_SYSCLK_Div8                  ((uint32_t)0x000000A0)
+#define RCC_SYSCLK_Div16                 ((uint32_t)0x000000B0)
+#define RCC_SYSCLK_Div64                 ((uint32_t)0x000000C0)
+#define RCC_SYSCLK_Div128                ((uint32_t)0x000000D0)
+#define RCC_SYSCLK_Div256                ((uint32_t)0x000000E0)
+#define RCC_SYSCLK_Div512                ((uint32_t)0x000000F0)
+#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
+                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
+                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
+                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
+                           ((HCLK) == RCC_SYSCLK_Div512))
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_APB1_APB2_Clock_Source
+  * @{
+  */
+#define RCC_HCLK_Div1                    ((uint32_t)0x00000000)
+#define RCC_HCLK_Div2                    ((uint32_t)0x00001000)
+#define RCC_HCLK_Div4                    ((uint32_t)0x00001400)
+#define RCC_HCLK_Div8                    ((uint32_t)0x00001800)
+#define RCC_HCLK_Div16                   ((uint32_t)0x00001C00)
+#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
+                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
+                           ((PCLK) == RCC_HCLK_Div16))
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_Interrupt_Source 
+  * @{
+  */
+#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
+#define RCC_IT_LSERDY                    ((uint8_t)0x02)
+#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
+#define RCC_IT_HSERDY                    ((uint8_t)0x08)
+#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
+#define RCC_IT_PLLI2SRDY                 ((uint8_t)0x20) 
+#define RCC_IT_PLLSAIRDY                 ((uint8_t)0x40)
+#define RCC_IT_CSS                       ((uint8_t)0x80)
+
+#define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))
+#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
+                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
+                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) || \
+                           ((IT) == RCC_IT_PLLSAIRDY) || ((IT) == RCC_IT_PLLI2SRDY))
+#define IS_RCC_CLEAR_IT(IT)((IT) != 0x00)
+
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_LSE_Configuration 
+  * @{
+  */
+#define RCC_LSE_OFF                      ((uint8_t)0x00)
+#define RCC_LSE_ON                       ((uint8_t)0x01)
+#define RCC_LSE_Bypass                   ((uint8_t)0x04)
+#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
+                         ((LSE) == RCC_LSE_Bypass))
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_RTC_Clock_Source
+  * @{
+  */
+#define RCC_RTCCLKSource_LSE             ((uint32_t)0x00000100)
+#define RCC_RTCCLKSource_LSI             ((uint32_t)0x00000200)
+#define RCC_RTCCLKSource_HSE_Div2        ((uint32_t)0x00020300)
+#define RCC_RTCCLKSource_HSE_Div3        ((uint32_t)0x00030300)
+#define RCC_RTCCLKSource_HSE_Div4        ((uint32_t)0x00040300)
+#define RCC_RTCCLKSource_HSE_Div5        ((uint32_t)0x00050300)
+#define RCC_RTCCLKSource_HSE_Div6        ((uint32_t)0x00060300)
+#define RCC_RTCCLKSource_HSE_Div7        ((uint32_t)0x00070300)
+#define RCC_RTCCLKSource_HSE_Div8        ((uint32_t)0x00080300)
+#define RCC_RTCCLKSource_HSE_Div9        ((uint32_t)0x00090300)
+#define RCC_RTCCLKSource_HSE_Div10       ((uint32_t)0x000A0300)
+#define RCC_RTCCLKSource_HSE_Div11       ((uint32_t)0x000B0300)
+#define RCC_RTCCLKSource_HSE_Div12       ((uint32_t)0x000C0300)
+#define RCC_RTCCLKSource_HSE_Div13       ((uint32_t)0x000D0300)
+#define RCC_RTCCLKSource_HSE_Div14       ((uint32_t)0x000E0300)
+#define RCC_RTCCLKSource_HSE_Div15       ((uint32_t)0x000F0300)
+#define RCC_RTCCLKSource_HSE_Div16       ((uint32_t)0x00100300)
+#define RCC_RTCCLKSource_HSE_Div17       ((uint32_t)0x00110300)
+#define RCC_RTCCLKSource_HSE_Div18       ((uint32_t)0x00120300)
+#define RCC_RTCCLKSource_HSE_Div19       ((uint32_t)0x00130300)
+#define RCC_RTCCLKSource_HSE_Div20       ((uint32_t)0x00140300)
+#define RCC_RTCCLKSource_HSE_Div21       ((uint32_t)0x00150300)
+#define RCC_RTCCLKSource_HSE_Div22       ((uint32_t)0x00160300)
+#define RCC_RTCCLKSource_HSE_Div23       ((uint32_t)0x00170300)
+#define RCC_RTCCLKSource_HSE_Div24       ((uint32_t)0x00180300)
+#define RCC_RTCCLKSource_HSE_Div25       ((uint32_t)0x00190300)
+#define RCC_RTCCLKSource_HSE_Div26       ((uint32_t)0x001A0300)
+#define RCC_RTCCLKSource_HSE_Div27       ((uint32_t)0x001B0300)
+#define RCC_RTCCLKSource_HSE_Div28       ((uint32_t)0x001C0300)
+#define RCC_RTCCLKSource_HSE_Div29       ((uint32_t)0x001D0300)
+#define RCC_RTCCLKSource_HSE_Div30       ((uint32_t)0x001E0300)
+#define RCC_RTCCLKSource_HSE_Div31       ((uint32_t)0x001F0300)
+#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div2) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div3) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div4) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div5) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div6) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div7) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div8) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div9) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div10) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div11) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div12) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div13) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div14) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div15) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div16) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div17) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div18) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div19) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div20) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div21) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div22) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div23) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div24) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div25) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div26) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div27) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div28) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div29) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div30) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div31))
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_I2S_Clock_Source
+  * @{
+  */
+#define RCC_I2S2CLKSource_PLLI2S             ((uint8_t)0x00)
+#define RCC_I2S2CLKSource_Ext                ((uint8_t)0x01)
+
+#define IS_RCC_I2SCLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S2CLKSource_PLLI2S) || ((SOURCE) == RCC_I2S2CLKSource_Ext))                                
+/**
+  * @}
+  */ 
+
+/** @defgroup RCC_SAI_BlockA_Clock_Source
+  * @{
+  */
+#define RCC_SAIACLKSource_PLLSAI             ((uint32_t)0x00000000)
+#define RCC_SAIACLKSource_PLLI2S             ((uint32_t)0x00100000)
+#define RCC_SAIACLKSource_Ext                ((uint32_t)0x00200000)
+
+#define IS_RCC_SAIACLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIACLKSource_PLLI2S) ||\
+                                       ((SOURCE) == RCC_SAIACLKSource_PLLSAI) ||\
+                                       ((SOURCE) == RCC_SAIACLKSource_Ext))
+/**
+  * @}
+  */ 
+
+/** @defgroup RCC_SAI_BlockB_Clock_Source
+  * @{
+  */
+#define RCC_SAIBCLKSource_PLLSAI             ((uint32_t)0x00000000)
+#define RCC_SAIBCLKSource_PLLI2S             ((uint32_t)0x00400000)
+#define RCC_SAIBCLKSource_Ext                ((uint32_t)0x00800000)
+
+#define IS_RCC_SAIBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIBCLKSource_PLLI2S) ||\
+                                       ((SOURCE) == RCC_SAIBCLKSource_PLLSAI) ||\
+                                       ((SOURCE) == RCC_SAIBCLKSource_Ext))
+/**
+  * @}
+  */ 
+
+/** @defgroup RCC_TIM_PRescaler_Selection
+  * @{
+  */
+#define RCC_TIMPrescDesactivated             ((uint8_t)0x00)
+#define RCC_TIMPrescActivated                ((uint8_t)0x01)
+
+#define IS_RCC_TIMCLK_PRESCALER(VALUE) (((VALUE) == RCC_TIMPrescDesactivated) || ((VALUE) == RCC_TIMPrescActivated))
+/**
+  * @}
+  */
+  
+/** @defgroup RCC_AHB1_Peripherals 
+  * @{
+  */ 
+#define RCC_AHB1Periph_GPIOA             ((uint32_t)0x00000001)
+#define RCC_AHB1Periph_GPIOB             ((uint32_t)0x00000002)
+#define RCC_AHB1Periph_GPIOC             ((uint32_t)0x00000004)
+#define RCC_AHB1Periph_GPIOD             ((uint32_t)0x00000008)
+#define RCC_AHB1Periph_GPIOE             ((uint32_t)0x00000010)
+#define RCC_AHB1Periph_GPIOF             ((uint32_t)0x00000020)
+#define RCC_AHB1Periph_GPIOG             ((uint32_t)0x00000040)
+#define RCC_AHB1Periph_GPIOH             ((uint32_t)0x00000080)
+#define RCC_AHB1Periph_GPIOI             ((uint32_t)0x00000100) 
+#define RCC_AHB1Periph_GPIOJ             ((uint32_t)0x00000200)
+#define RCC_AHB1Periph_GPIOK             ((uint32_t)0x00000400)
+#define RCC_AHB1Periph_CRC               ((uint32_t)0x00001000)
+#define RCC_AHB1Periph_FLITF             ((uint32_t)0x00008000)
+#define RCC_AHB1Periph_SRAM1             ((uint32_t)0x00010000)
+#define RCC_AHB1Periph_SRAM2             ((uint32_t)0x00020000)
+#define RCC_AHB1Periph_BKPSRAM           ((uint32_t)0x00040000)
+#define RCC_AHB1Periph_SRAM3             ((uint32_t)0x00080000)
+#define RCC_AHB1Periph_CCMDATARAMEN      ((uint32_t)0x00100000)
+#define RCC_AHB1Periph_DMA1              ((uint32_t)0x00200000)
+#define RCC_AHB1Periph_DMA2              ((uint32_t)0x00400000)
+#define RCC_AHB1Periph_DMA2D             ((uint32_t)0x00800000)
+#define RCC_AHB1Periph_ETH_MAC           ((uint32_t)0x02000000)
+#define RCC_AHB1Periph_ETH_MAC_Tx        ((uint32_t)0x04000000)
+#define RCC_AHB1Periph_ETH_MAC_Rx        ((uint32_t)0x08000000)
+#define RCC_AHB1Periph_ETH_MAC_PTP       ((uint32_t)0x10000000)
+#define RCC_AHB1Periph_OTG_HS            ((uint32_t)0x20000000)
+#define RCC_AHB1Periph_OTG_HS_ULPI       ((uint32_t)0x40000000)
+
+#define IS_RCC_AHB1_CLOCK_PERIPH(PERIPH) ((((PERIPH) & 0x810BE800) == 0x00) && ((PERIPH) != 0x00))
+#define IS_RCC_AHB1_RESET_PERIPH(PERIPH) ((((PERIPH) & 0xDD1FE800) == 0x00) && ((PERIPH) != 0x00))
+#define IS_RCC_AHB1_LPMODE_PERIPH(PERIPH) ((((PERIPH) & 0x81106800) == 0x00) && ((PERIPH) != 0x00))
+
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_AHB2_Peripherals 
+  * @{
+  */  
+#define RCC_AHB2Periph_DCMI              ((uint32_t)0x00000001)
+#define RCC_AHB2Periph_CRYP              ((uint32_t)0x00000010)
+#define RCC_AHB2Periph_HASH              ((uint32_t)0x00000020)
+#define RCC_AHB2Periph_RNG               ((uint32_t)0x00000040)
+#define RCC_AHB2Periph_OTG_FS            ((uint32_t)0x00000080)
+#define IS_RCC_AHB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFF0E) == 0x00) && ((PERIPH) != 0x00))
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_AHB3_Peripherals 
+  * @{
+  */ 
+#if defined (STM32F40_41xxx)
+#define RCC_AHB3Periph_FSMC                ((uint32_t)0x00000001)
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx) 
+#define RCC_AHB3Periph_FMC                ((uint32_t)0x00000001)
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+#define IS_RCC_AHB3_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFFE) == 0x00) && ((PERIPH) != 0x00))
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_APB1_Peripherals 
+  * @{
+  */ 
+#define RCC_APB1Periph_TIM2              ((uint32_t)0x00000001)
+#define RCC_APB1Periph_TIM3              ((uint32_t)0x00000002)
+#define RCC_APB1Periph_TIM4              ((uint32_t)0x00000004)
+#define RCC_APB1Periph_TIM5              ((uint32_t)0x00000008)
+#define RCC_APB1Periph_TIM6              ((uint32_t)0x00000010)
+#define RCC_APB1Periph_TIM7              ((uint32_t)0x00000020)
+#define RCC_APB1Periph_TIM12             ((uint32_t)0x00000040)
+#define RCC_APB1Periph_TIM13             ((uint32_t)0x00000080)
+#define RCC_APB1Periph_TIM14             ((uint32_t)0x00000100)
+#define RCC_APB1Periph_WWDG              ((uint32_t)0x00000800)
+#define RCC_APB1Periph_SPI2              ((uint32_t)0x00004000)
+#define RCC_APB1Periph_SPI3              ((uint32_t)0x00008000)
+#define RCC_APB1Periph_USART2            ((uint32_t)0x00020000)
+#define RCC_APB1Periph_USART3            ((uint32_t)0x00040000)
+#define RCC_APB1Periph_UART4             ((uint32_t)0x00080000)
+#define RCC_APB1Periph_UART5             ((uint32_t)0x00100000)
+#define RCC_APB1Periph_I2C1              ((uint32_t)0x00200000)
+#define RCC_APB1Periph_I2C2              ((uint32_t)0x00400000)
+#define RCC_APB1Periph_I2C3              ((uint32_t)0x00800000)
+#define RCC_APB1Periph_CAN1              ((uint32_t)0x02000000)
+#define RCC_APB1Periph_CAN2              ((uint32_t)0x04000000)
+#define RCC_APB1Periph_PWR               ((uint32_t)0x10000000)
+#define RCC_APB1Periph_DAC               ((uint32_t)0x20000000)
+#define RCC_APB1Periph_UART7             ((uint32_t)0x40000000)
+#define RCC_APB1Periph_UART8             ((uint32_t)0x80000000)
+#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x09013600) == 0x00) && ((PERIPH) != 0x00))
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_APB2_Peripherals 
+  * @{
+  */ 
+#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000001)
+#define RCC_APB2Periph_TIM8              ((uint32_t)0x00000002)
+#define RCC_APB2Periph_USART1            ((uint32_t)0x00000010)
+#define RCC_APB2Periph_USART6            ((uint32_t)0x00000020)
+#define RCC_APB2Periph_ADC               ((uint32_t)0x00000100)
+#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000100)
+#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000200)
+#define RCC_APB2Periph_ADC3              ((uint32_t)0x00000400)
+#define RCC_APB2Periph_SDIO              ((uint32_t)0x00000800)
+#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)
+#define RCC_APB2Periph_SPI4              ((uint32_t)0x00002000)
+#define RCC_APB2Periph_SYSCFG            ((uint32_t)0x00004000)
+#define RCC_APB2Periph_TIM9              ((uint32_t)0x00010000)
+#define RCC_APB2Periph_TIM10             ((uint32_t)0x00020000)
+#define RCC_APB2Periph_TIM11             ((uint32_t)0x00040000)
+#define RCC_APB2Periph_SPI5              ((uint32_t)0x00100000)
+#define RCC_APB2Periph_SPI6              ((uint32_t)0x00200000)
+#define RCC_APB2Periph_SAI1              ((uint32_t)0x00400000)
+#define RCC_APB2Periph_LTDC              ((uint32_t)0x04000000)
+
+#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFB8880CC) == 0x00) && ((PERIPH) != 0x00))
+#define IS_RCC_APB2_RESET_PERIPH(PERIPH) ((((PERIPH) & 0xFB8886CC) == 0x00) && ((PERIPH) != 0x00))
+
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_MCO1_Clock_Source_Prescaler
+  * @{
+  */
+#define RCC_MCO1Source_HSI               ((uint32_t)0x00000000)
+#define RCC_MCO1Source_LSE               ((uint32_t)0x00200000)
+#define RCC_MCO1Source_HSE               ((uint32_t)0x00400000)
+#define RCC_MCO1Source_PLLCLK            ((uint32_t)0x00600000)
+#define RCC_MCO1Div_1                    ((uint32_t)0x00000000)
+#define RCC_MCO1Div_2                    ((uint32_t)0x04000000)
+#define RCC_MCO1Div_3                    ((uint32_t)0x05000000)
+#define RCC_MCO1Div_4                    ((uint32_t)0x06000000)
+#define RCC_MCO1Div_5                    ((uint32_t)0x07000000)
+#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1Source_HSI) || ((SOURCE) == RCC_MCO1Source_LSE) || \
+                                   ((SOURCE) == RCC_MCO1Source_HSE) || ((SOURCE) == RCC_MCO1Source_PLLCLK))
+                                   
+#define IS_RCC_MCO1DIV(DIV) (((DIV) == RCC_MCO1Div_1) || ((DIV) == RCC_MCO1Div_2) || \
+                             ((DIV) == RCC_MCO1Div_3) || ((DIV) == RCC_MCO1Div_4) || \
+                             ((DIV) == RCC_MCO1Div_5)) 
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_MCO2_Clock_Source_Prescaler
+  * @{
+  */
+#define RCC_MCO2Source_SYSCLK            ((uint32_t)0x00000000)
+#define RCC_MCO2Source_PLLI2SCLK         ((uint32_t)0x40000000)
+#define RCC_MCO2Source_HSE               ((uint32_t)0x80000000)
+#define RCC_MCO2Source_PLLCLK            ((uint32_t)0xC0000000)
+#define RCC_MCO2Div_1                    ((uint32_t)0x00000000)
+#define RCC_MCO2Div_2                    ((uint32_t)0x20000000)
+#define RCC_MCO2Div_3                    ((uint32_t)0x28000000)
+#define RCC_MCO2Div_4                    ((uint32_t)0x30000000)
+#define RCC_MCO2Div_5                    ((uint32_t)0x38000000)
+#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2Source_SYSCLK) || ((SOURCE) == RCC_MCO2Source_PLLI2SCLK)|| \
+                                   ((SOURCE) == RCC_MCO2Source_HSE) || ((SOURCE) == RCC_MCO2Source_PLLCLK))
+                                   
+#define IS_RCC_MCO2DIV(DIV) (((DIV) == RCC_MCO2Div_1) || ((DIV) == RCC_MCO2Div_2) || \
+                             ((DIV) == RCC_MCO2Div_3) || ((DIV) == RCC_MCO2Div_4) || \
+                             ((DIV) == RCC_MCO2Div_5))                             
+/**
+  * @}
+  */ 
+  
+/** @defgroup RCC_Flag 
+  * @{
+  */
+#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
+#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
+#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
+#define RCC_FLAG_PLLI2SRDY               ((uint8_t)0x3B)
+#define RCC_FLAG_PLLSAIRDY               ((uint8_t)0x3D)
+#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
+#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
+#define RCC_FLAG_BORRST                  ((uint8_t)0x79)
+#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
+#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
+#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
+#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
+#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
+#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
+
+#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY)   || ((FLAG) == RCC_FLAG_HSERDY) || \
+                           ((FLAG) == RCC_FLAG_PLLRDY)   || ((FLAG) == RCC_FLAG_LSERDY) || \
+                           ((FLAG) == RCC_FLAG_LSIRDY)   || ((FLAG) == RCC_FLAG_BORRST) || \
+                           ((FLAG) == RCC_FLAG_PINRST)   || ((FLAG) == RCC_FLAG_PORRST) || \
+                           ((FLAG) == RCC_FLAG_SFTRST)   || ((FLAG) == RCC_FLAG_IWDGRST)|| \
+                           ((FLAG) == RCC_FLAG_WWDGRST)  || ((FLAG) == RCC_FLAG_LPWRRST)|| \
+                           ((FLAG) == RCC_FLAG_PLLI2SRDY)|| ((FLAG) == RCC_FLAG_PLLSAIRDY))
+
+#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/* Function used to set the RCC clock configuration to the default reset state */
+void RCC_DeInit(void);
+
+/* Internal/external clocks, PLL, CSS and MCO configuration functions *********/
+void        RCC_HSEConfig(uint8_t RCC_HSE);
+ErrorStatus RCC_WaitForHSEStartUp(void);
+void        RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
+void        RCC_HSICmd(FunctionalState NewState);
+void        RCC_LSEConfig(uint8_t RCC_LSE);
+void        RCC_LSICmd(FunctionalState NewState);
+void        RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ);
+void        RCC_PLLCmd(FunctionalState NewState);
+
+#if defined (STM32F40_41xxx) || defined (STM32F401xx)
+void        RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR);
+#elif defined (STM32F411xE)
+void        RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR, uint32_t PLLI2SM);
+#elif defined (STM32F427_437xx) || defined (STM32F429_439xx)
+void        RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SQ, uint32_t PLLI2SR);
+#else
+#endif /* STM32F40_41xxx || STM32F401xx */
+
+void        RCC_PLLI2SCmd(FunctionalState NewState);
+void        RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR);
+void        RCC_PLLSAICmd(FunctionalState NewState);
+void        RCC_ClockSecuritySystemCmd(FunctionalState NewState);
+void        RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div);
+void        RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div);
+
+/* System, AHB and APB busses clocks configuration functions ******************/
+void        RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
+uint8_t     RCC_GetSYSCLKSource(void);
+void        RCC_HCLKConfig(uint32_t RCC_SYSCLK);
+void        RCC_PCLK1Config(uint32_t RCC_HCLK);
+void        RCC_PCLK2Config(uint32_t RCC_HCLK);
+void        RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
+
+/* Peripheral clocks configuration functions **********************************/
+void        RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
+void        RCC_RTCCLKCmd(FunctionalState NewState);
+void        RCC_BackupResetCmd(FunctionalState NewState);
+void        RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource); 
+void        RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ);
+void        RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ);
+void        RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource);
+void        RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource);
+void        RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR);
+void        RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler);
+
+void        RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
+void        RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState);
+void        RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState);
+void        RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
+void        RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
+
+void        RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
+void        RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState);
+void        RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState);
+void        RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
+void        RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
+
+void        RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
+void        RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState);
+void        RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState);
+void        RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
+void        RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
+
+void        RCC_LSEModeConfig(uint8_t Mode);
+
+/* Interrupts and flags management functions **********************************/
+void        RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
+FlagStatus  RCC_GetFlagStatus(uint8_t RCC_FLAG);
+void        RCC_ClearFlag(void);
+ITStatus    RCC_GetITStatus(uint8_t RCC_IT);
+void        RCC_ClearITPendingBit(uint8_t RCC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_RCC_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rng.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rng.h
new file mode 100644
index 0000000..b97f832
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rng.h
@@ -0,0 +1,120 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_rng.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the Random 
+  *          Number Generator(RNG) firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_RNG_H
+#define __STM32F4xx_RNG_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup RNG
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/ 
+
+/** @defgroup RNG_Exported_Constants
+  * @{
+  */
+  
+/** @defgroup RNG_flags_definition  
+  * @{
+  */ 
+#define RNG_FLAG_DRDY               ((uint8_t)0x0001) /*!< Data ready */
+#define RNG_FLAG_CECS               ((uint8_t)0x0002) /*!< Clock error current status */
+#define RNG_FLAG_SECS               ((uint8_t)0x0004) /*!< Seed error current status */
+
+#define IS_RNG_GET_FLAG(RNG_FLAG) (((RNG_FLAG) == RNG_FLAG_DRDY) || \
+                                   ((RNG_FLAG) == RNG_FLAG_CECS) || \
+                                   ((RNG_FLAG) == RNG_FLAG_SECS))
+#define IS_RNG_CLEAR_FLAG(RNG_FLAG) (((RNG_FLAG) == RNG_FLAG_CECS) || \
+                                    ((RNG_FLAG) == RNG_FLAG_SECS))
+/**
+  * @}
+  */ 
+
+/** @defgroup RNG_interrupts_definition   
+  * @{
+  */  
+#define RNG_IT_CEI                  ((uint8_t)0x20) /*!< Clock error interrupt */
+#define RNG_IT_SEI                  ((uint8_t)0x40) /*!< Seed error interrupt */
+
+#define IS_RNG_IT(IT) ((((IT) & (uint8_t)0x9F) == 0x00) && ((IT) != 0x00))
+#define IS_RNG_GET_IT(RNG_IT) (((RNG_IT) == RNG_IT_CEI) || ((RNG_IT) == RNG_IT_SEI))
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/*  Function used to set the RNG configuration to the default reset state *****/ 
+void RNG_DeInit(void);
+
+/* Configuration function *****************************************************/
+void RNG_Cmd(FunctionalState NewState);
+
+/* Get 32 bit Random number function ******************************************/
+uint32_t RNG_GetRandomNumber(void);
+
+/* Interrupts and flags management functions **********************************/
+void RNG_ITConfig(FunctionalState NewState);
+FlagStatus RNG_GetFlagStatus(uint8_t RNG_FLAG);
+void RNG_ClearFlag(uint8_t RNG_FLAG);
+ITStatus RNG_GetITStatus(uint8_t RNG_IT);
+void RNG_ClearITPendingBit(uint8_t RNG_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_RNG_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rtc.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rtc.h
new file mode 100644
index 0000000..a8a94a9
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rtc.h
@@ -0,0 +1,881 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_rtc.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the RTC firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ****************************************************************************** 
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_RTC_H
+#define __STM32F4xx_RTC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup RTC
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  RTC Init structures definition  
+  */ 
+typedef struct
+{
+  uint32_t RTC_HourFormat;   /*!< Specifies the RTC Hour Format.
+                             This parameter can be a value of @ref RTC_Hour_Formats */
+  
+  uint32_t RTC_AsynchPrediv; /*!< Specifies the RTC Asynchronous Predivider value.
+                             This parameter must be set to a value lower than 0x7F */
+  
+  uint32_t RTC_SynchPrediv;  /*!< Specifies the RTC Synchronous Predivider value.
+                             This parameter must be set to a value lower than 0x7FFF */
+}RTC_InitTypeDef;
+
+/** 
+  * @brief  RTC Time structure definition  
+  */
+typedef struct
+{
+  uint8_t RTC_Hours;    /*!< Specifies the RTC Time Hour.
+                        This parameter must be set to a value in the 0-12 range
+                        if the RTC_HourFormat_12 is selected or 0-23 range if
+                        the RTC_HourFormat_24 is selected. */
+
+  uint8_t RTC_Minutes;  /*!< Specifies the RTC Time Minutes.
+                        This parameter must be set to a value in the 0-59 range. */
+  
+  uint8_t RTC_Seconds;  /*!< Specifies the RTC Time Seconds.
+                        This parameter must be set to a value in the 0-59 range. */
+
+  uint8_t RTC_H12;      /*!< Specifies the RTC AM/PM Time.
+                        This parameter can be a value of @ref RTC_AM_PM_Definitions */
+}RTC_TimeTypeDef; 
+
+/** 
+  * @brief  RTC Date structure definition  
+  */
+typedef struct
+{
+  uint8_t RTC_WeekDay; /*!< Specifies the RTC Date WeekDay.
+                        This parameter can be a value of @ref RTC_WeekDay_Definitions */
+  
+  uint8_t RTC_Month;   /*!< Specifies the RTC Date Month (in BCD format).
+                        This parameter can be a value of @ref RTC_Month_Date_Definitions */
+
+  uint8_t RTC_Date;     /*!< Specifies the RTC Date.
+                        This parameter must be set to a value in the 1-31 range. */
+  
+  uint8_t RTC_Year;     /*!< Specifies the RTC Date Year.
+                        This parameter must be set to a value in the 0-99 range. */
+}RTC_DateTypeDef;
+
+/** 
+  * @brief  RTC Alarm structure definition  
+  */
+typedef struct
+{
+  RTC_TimeTypeDef RTC_AlarmTime;     /*!< Specifies the RTC Alarm Time members. */
+
+  uint32_t RTC_AlarmMask;            /*!< Specifies the RTC Alarm Masks.
+                                     This parameter can be a value of @ref RTC_AlarmMask_Definitions */
+
+  uint32_t RTC_AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
+                                     This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
+  
+  uint8_t RTC_AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
+                                     If the Alarm Date is selected, this parameter
+                                     must be set to a value in the 1-31 range.
+                                     If the Alarm WeekDay is selected, this 
+                                     parameter can be a value of @ref RTC_WeekDay_Definitions */
+}RTC_AlarmTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup RTC_Exported_Constants
+  * @{
+  */ 
+
+
+/** @defgroup RTC_Hour_Formats 
+  * @{
+  */ 
+#define RTC_HourFormat_24              ((uint32_t)0x00000000)
+#define RTC_HourFormat_12              ((uint32_t)0x00000040)
+#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) || \
+                                        ((FORMAT) == RTC_HourFormat_24))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Asynchronous_Predivider 
+  * @{
+  */ 
+#define IS_RTC_ASYNCH_PREDIV(PREDIV)   ((PREDIV) <= 0x7F)
+ 
+/**
+  * @}
+  */ 
+
+
+/** @defgroup RTC_Synchronous_Predivider 
+  * @{
+  */ 
+#define IS_RTC_SYNCH_PREDIV(PREDIV)    ((PREDIV) <= 0x7FFF)
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Time_Definitions 
+  * @{
+  */ 
+#define IS_RTC_HOUR12(HOUR)            (((HOUR) > 0) && ((HOUR) <= 12))
+#define IS_RTC_HOUR24(HOUR)            ((HOUR) <= 23)
+#define IS_RTC_MINUTES(MINUTES)        ((MINUTES) <= 59)
+#define IS_RTC_SECONDS(SECONDS)        ((SECONDS) <= 59)
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_AM_PM_Definitions 
+  * @{
+  */ 
+#define RTC_H12_AM                     ((uint8_t)0x00)
+#define RTC_H12_PM                     ((uint8_t)0x40)
+#define IS_RTC_H12(PM) (((PM) == RTC_H12_AM) || ((PM) == RTC_H12_PM))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Year_Date_Definitions 
+  * @{
+  */ 
+#define IS_RTC_YEAR(YEAR)              ((YEAR) <= 99)
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Month_Date_Definitions 
+  * @{
+  */ 
+
+/* Coded in BCD format */
+#define RTC_Month_January              ((uint8_t)0x01)
+#define RTC_Month_February             ((uint8_t)0x02)
+#define RTC_Month_March                ((uint8_t)0x03)
+#define RTC_Month_April                ((uint8_t)0x04)
+#define RTC_Month_May                  ((uint8_t)0x05)
+#define RTC_Month_June                 ((uint8_t)0x06)
+#define RTC_Month_July                 ((uint8_t)0x07)
+#define RTC_Month_August               ((uint8_t)0x08)
+#define RTC_Month_September            ((uint8_t)0x09)
+#define RTC_Month_October              ((uint8_t)0x10)
+#define RTC_Month_November             ((uint8_t)0x11)
+#define RTC_Month_December             ((uint8_t)0x12)
+#define IS_RTC_MONTH(MONTH)            (((MONTH) >= 1) && ((MONTH) <= 12))
+#define IS_RTC_DATE(DATE)              (((DATE) >= 1) && ((DATE) <= 31))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_WeekDay_Definitions 
+  * @{
+  */ 
+  
+#define RTC_Weekday_Monday             ((uint8_t)0x01)
+#define RTC_Weekday_Tuesday            ((uint8_t)0x02)
+#define RTC_Weekday_Wednesday          ((uint8_t)0x03)
+#define RTC_Weekday_Thursday           ((uint8_t)0x04)
+#define RTC_Weekday_Friday             ((uint8_t)0x05)
+#define RTC_Weekday_Saturday           ((uint8_t)0x06)
+#define RTC_Weekday_Sunday             ((uint8_t)0x07)
+#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
+                                 ((WEEKDAY) == RTC_Weekday_Tuesday) || \
+                                 ((WEEKDAY) == RTC_Weekday_Wednesday) || \
+                                 ((WEEKDAY) == RTC_Weekday_Thursday) || \
+                                 ((WEEKDAY) == RTC_Weekday_Friday) || \
+                                 ((WEEKDAY) == RTC_Weekday_Saturday) || \
+                                 ((WEEKDAY) == RTC_Weekday_Sunday))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup RTC_Alarm_Definitions
+  * @{
+  */ 
+#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(DATE) (((DATE) > 0) && ((DATE) <= 31))
+#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
+                                                    ((WEEKDAY) == RTC_Weekday_Tuesday) || \
+                                                    ((WEEKDAY) == RTC_Weekday_Wednesday) || \
+                                                    ((WEEKDAY) == RTC_Weekday_Thursday) || \
+                                                    ((WEEKDAY) == RTC_Weekday_Friday) || \
+                                                    ((WEEKDAY) == RTC_Weekday_Saturday) || \
+                                                    ((WEEKDAY) == RTC_Weekday_Sunday))
+
+/**
+  * @}
+  */ 
+
+
+/** @defgroup RTC_AlarmDateWeekDay_Definitions 
+  * @{
+  */ 
+#define RTC_AlarmDateWeekDaySel_Date      ((uint32_t)0x00000000)
+#define RTC_AlarmDateWeekDaySel_WeekDay   ((uint32_t)0x40000000)
+
+#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) || \
+                                            ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))
+
+/**
+  * @}
+  */ 
+
+
+/** @defgroup RTC_AlarmMask_Definitions 
+  * @{
+  */ 
+#define RTC_AlarmMask_None                ((uint32_t)0x00000000)
+#define RTC_AlarmMask_DateWeekDay         ((uint32_t)0x80000000)
+#define RTC_AlarmMask_Hours               ((uint32_t)0x00800000)
+#define RTC_AlarmMask_Minutes             ((uint32_t)0x00008000)
+#define RTC_AlarmMask_Seconds             ((uint32_t)0x00000080)
+#define RTC_AlarmMask_All                 ((uint32_t)0x80808080)
+#define IS_ALARM_MASK(MASK)  (((MASK) & 0x7F7F7F7F) == (uint32_t)RESET)
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Alarms_Definitions 
+  * @{
+  */ 
+#define RTC_Alarm_A                       ((uint32_t)0x00000100)
+#define RTC_Alarm_B                       ((uint32_t)0x00000200)
+#define IS_RTC_ALARM(ALARM)     (((ALARM) == RTC_Alarm_A) || ((ALARM) == RTC_Alarm_B))
+#define IS_RTC_CMD_ALARM(ALARM) (((ALARM) & (RTC_Alarm_A | RTC_Alarm_B)) != (uint32_t)RESET)
+
+/**
+  * @}
+  */ 
+
+  /** @defgroup RTC_Alarm_Sub_Seconds_Masks_Definitions
+  * @{
+  */ 
+#define RTC_AlarmSubSecondMask_All         ((uint32_t)0x00000000) /*!< All Alarm SS fields are masked. 
+                                                                       There is no comparison on sub seconds 
+                                                                       for Alarm */
+#define RTC_AlarmSubSecondMask_SS14_1      ((uint32_t)0x01000000) /*!< SS[14:1] are don't care in Alarm 
+                                                                       comparison. Only SS[0] is compared. */
+#define RTC_AlarmSubSecondMask_SS14_2      ((uint32_t)0x02000000) /*!< SS[14:2] are don't care in Alarm 
+                                                                       comparison. Only SS[1:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_3      ((uint32_t)0x03000000) /*!< SS[14:3] are don't care in Alarm 
+                                                                       comparison. Only SS[2:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_4      ((uint32_t)0x04000000) /*!< SS[14:4] are don't care in Alarm 
+                                                                       comparison. Only SS[3:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_5      ((uint32_t)0x05000000) /*!< SS[14:5] are don't care in Alarm 
+                                                                       comparison. Only SS[4:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_6      ((uint32_t)0x06000000) /*!< SS[14:6] are don't care in Alarm 
+                                                                       comparison. Only SS[5:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_7      ((uint32_t)0x07000000) /*!< SS[14:7] are don't care in Alarm 
+                                                                       comparison. Only SS[6:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_8      ((uint32_t)0x08000000) /*!< SS[14:8] are don't care in Alarm 
+                                                                       comparison. Only SS[7:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_9      ((uint32_t)0x09000000) /*!< SS[14:9] are don't care in Alarm 
+                                                                       comparison. Only SS[8:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_10     ((uint32_t)0x0A000000) /*!< SS[14:10] are don't care in Alarm 
+                                                                       comparison. Only SS[9:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_11     ((uint32_t)0x0B000000) /*!< SS[14:11] are don't care in Alarm 
+                                                                       comparison. Only SS[10:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_12     ((uint32_t)0x0C000000) /*!< SS[14:12] are don't care in Alarm 
+                                                                       comparison.Only SS[11:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14_13     ((uint32_t)0x0D000000) /*!< SS[14:13] are don't care in Alarm 
+                                                                       comparison. Only SS[12:0] are compared */
+#define RTC_AlarmSubSecondMask_SS14        ((uint32_t)0x0E000000) /*!< SS[14] is don't care in Alarm 
+                                                                       comparison.Only SS[13:0] are compared */
+#define RTC_AlarmSubSecondMask_None        ((uint32_t)0x0F000000) /*!< SS[14:0] are compared and must match 
+                                                                       to activate alarm. */
+#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_1) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_2) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_3) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_4) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_5) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_6) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_7) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_8) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_9) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_10) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_11) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_12) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_13) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_SS14) || \
+                                              ((MASK) == RTC_AlarmSubSecondMask_None))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Alarm_Sub_Seconds_Value
+  * @{
+  */ 
+
+#define IS_RTC_ALARM_SUB_SECOND_VALUE(VALUE) ((VALUE) <= 0x00007FFF)
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Wakeup_Timer_Definitions 
+  * @{
+  */ 
+#define RTC_WakeUpClock_RTCCLK_Div16        ((uint32_t)0x00000000)
+#define RTC_WakeUpClock_RTCCLK_Div8         ((uint32_t)0x00000001)
+#define RTC_WakeUpClock_RTCCLK_Div4         ((uint32_t)0x00000002)
+#define RTC_WakeUpClock_RTCCLK_Div2         ((uint32_t)0x00000003)
+#define RTC_WakeUpClock_CK_SPRE_16bits      ((uint32_t)0x00000004)
+#define RTC_WakeUpClock_CK_SPRE_17bits      ((uint32_t)0x00000006)
+#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WakeUpClock_RTCCLK_Div16) || \
+                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div8) || \
+                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div4) || \
+                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div2) || \
+                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_16bits) || \
+                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_17bits))
+#define IS_RTC_WAKEUP_COUNTER(COUNTER)  ((COUNTER) <= 0xFFFF)
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Time_Stamp_Edges_definitions 
+  * @{
+  */ 
+#define RTC_TimeStampEdge_Rising          ((uint32_t)0x00000000)
+#define RTC_TimeStampEdge_Falling         ((uint32_t)0x00000008)
+#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) || \
+                                     ((EDGE) == RTC_TimeStampEdge_Falling))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Output_selection_Definitions 
+  * @{
+  */ 
+#define RTC_Output_Disable             ((uint32_t)0x00000000)
+#define RTC_Output_AlarmA              ((uint32_t)0x00200000)
+#define RTC_Output_AlarmB              ((uint32_t)0x00400000)
+#define RTC_Output_WakeUp              ((uint32_t)0x00600000)
+ 
+#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) || \
+                               ((OUTPUT) == RTC_Output_AlarmA) || \
+                               ((OUTPUT) == RTC_Output_AlarmB) || \
+                               ((OUTPUT) == RTC_Output_WakeUp))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Output_Polarity_Definitions 
+  * @{
+  */ 
+#define RTC_OutputPolarity_High           ((uint32_t)0x00000000)
+#define RTC_OutputPolarity_Low            ((uint32_t)0x00100000)
+#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) || \
+                                ((POL) == RTC_OutputPolarity_Low))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup RTC_Digital_Calibration_Definitions 
+  * @{
+  */ 
+#define RTC_CalibSign_Positive            ((uint32_t)0x00000000) 
+#define RTC_CalibSign_Negative            ((uint32_t)0x00000080)
+#define IS_RTC_CALIB_SIGN(SIGN) (((SIGN) == RTC_CalibSign_Positive) || \
+                                 ((SIGN) == RTC_CalibSign_Negative))
+#define IS_RTC_CALIB_VALUE(VALUE) ((VALUE) < 0x20)
+
+/**
+  * @}
+  */ 
+
+ /** @defgroup RTC_Calib_Output_selection_Definitions 
+  * @{
+  */ 
+#define RTC_CalibOutput_512Hz            ((uint32_t)0x00000000) 
+#define RTC_CalibOutput_1Hz              ((uint32_t)0x00080000)
+#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) || \
+                                      ((OUTPUT) == RTC_CalibOutput_1Hz))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Smooth_calib_period_Definitions 
+  * @{
+  */ 
+#define RTC_SmoothCalibPeriod_32sec   ((uint32_t)0x00000000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation
+                                                             period is 32s,  else 2exp20 RTCCLK seconds */
+#define RTC_SmoothCalibPeriod_16sec   ((uint32_t)0x00002000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
+                                                             period is 16s, else 2exp19 RTCCLK seconds */
+#define RTC_SmoothCalibPeriod_8sec    ((uint32_t)0x00004000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
+                                                             period is 8s, else 2exp18 RTCCLK seconds */
+#define IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) || \
+                                             ((PERIOD) == RTC_SmoothCalibPeriod_16sec) || \
+                                             ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
+                                          
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Smooth_calib_Plus_pulses_Definitions 
+  * @{
+  */ 
+#define RTC_SmoothCalibPlusPulses_Set    ((uint32_t)0x00008000) /*!<  The number of RTCCLK pulses added  
+                                                                during a X -second window = Y - CALM[8:0]. 
+                                                                 with Y = 512, 256, 128 when X = 32, 16, 8 */
+#define RTC_SmoothCalibPlusPulses_Reset  ((uint32_t)0x00000000) /*!<  The number of RTCCLK pulses subbstited
+                                                                 during a 32-second window =   CALM[8:0]. */
+#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) || \
+                                         ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Smooth_calib_Minus_pulses_Definitions 
+  * @{
+  */ 
+#define  IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= 0x000001FF)
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_DayLightSaving_Definitions 
+  * @{
+  */ 
+#define RTC_DayLightSaving_SUB1H   ((uint32_t)0x00020000)
+#define RTC_DayLightSaving_ADD1H   ((uint32_t)0x00010000)
+#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DayLightSaving_SUB1H) || \
+                                      ((SAVE) == RTC_DayLightSaving_ADD1H))
+
+#define RTC_StoreOperation_Reset        ((uint32_t)0x00000000)
+#define RTC_StoreOperation_Set          ((uint32_t)0x00040000)
+#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) || \
+                                           ((OPERATION) == RTC_StoreOperation_Set))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Tamper_Trigger_Definitions 
+  * @{
+  */ 
+#define RTC_TamperTrigger_RisingEdge            ((uint32_t)0x00000000)
+#define RTC_TamperTrigger_FallingEdge           ((uint32_t)0x00000001)
+#define RTC_TamperTrigger_LowLevel              ((uint32_t)0x00000000)
+#define RTC_TamperTrigger_HighLevel             ((uint32_t)0x00000001)
+#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) || \
+                                        ((TRIGGER) == RTC_TamperTrigger_FallingEdge) || \
+                                        ((TRIGGER) == RTC_TamperTrigger_LowLevel) || \
+                                        ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Tamper_Filter_Definitions 
+  * @{
+  */ 
+#define RTC_TamperFilter_Disable   ((uint32_t)0x00000000) /*!< Tamper filter is disabled */
+
+#define RTC_TamperFilter_2Sample   ((uint32_t)0x00000800) /*!< Tamper is activated after 2 
+                                                          consecutive samples at the active level */
+#define RTC_TamperFilter_4Sample   ((uint32_t)0x00001000) /*!< Tamper is activated after 4 
+                                                          consecutive samples at the active level */
+#define RTC_TamperFilter_8Sample   ((uint32_t)0x00001800) /*!< Tamper is activated after 8 
+                                                          consecutive samples at the active leve. */
+#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) || \
+                                      ((FILTER) == RTC_TamperFilter_2Sample) || \
+                                      ((FILTER) == RTC_TamperFilter_4Sample) || \
+                                      ((FILTER) == RTC_TamperFilter_8Sample))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Tamper_Sampling_Frequencies_Definitions 
+  * @{
+  */ 
+#define RTC_TamperSamplingFreq_RTCCLK_Div32768  ((uint32_t)0x00000000) /*!< Each of the tamper inputs are sampled
+                                                                           with a frequency =  RTCCLK / 32768 */
+#define RTC_TamperSamplingFreq_RTCCLK_Div16384  ((uint32_t)0x000000100) /*!< Each of the tamper inputs are sampled
+                                                                            with a frequency =  RTCCLK / 16384 */
+#define RTC_TamperSamplingFreq_RTCCLK_Div8192   ((uint32_t)0x00000200) /*!< Each of the tamper inputs are sampled
+                                                                           with a frequency =  RTCCLK / 8192  */
+#define RTC_TamperSamplingFreq_RTCCLK_Div4096   ((uint32_t)0x00000300) /*!< Each of the tamper inputs are sampled
+                                                                           with a frequency =  RTCCLK / 4096  */
+#define RTC_TamperSamplingFreq_RTCCLK_Div2048   ((uint32_t)0x00000400) /*!< Each of the tamper inputs are sampled
+                                                                           with a frequency =  RTCCLK / 2048  */
+#define RTC_TamperSamplingFreq_RTCCLK_Div1024   ((uint32_t)0x00000500) /*!< Each of the tamper inputs are sampled
+                                                                           with a frequency =  RTCCLK / 1024  */
+#define RTC_TamperSamplingFreq_RTCCLK_Div512    ((uint32_t)0x00000600) /*!< Each of the tamper inputs are sampled
+                                                                           with a frequency =  RTCCLK / 512   */
+#define RTC_TamperSamplingFreq_RTCCLK_Div256    ((uint32_t)0x00000700) /*!< Each of the tamper inputs are sampled
+                                                                           with a frequency =  RTCCLK / 256   */
+#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) || \
+                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) || \
+                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) || \
+                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) || \
+                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) || \
+                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) || \
+                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) || \
+                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))
+
+/**
+  * @}
+  */
+
+  /** @defgroup RTC_Tamper_Pin_Precharge_Duration_Definitions 
+  * @{
+  */ 
+#define RTC_TamperPrechargeDuration_1RTCCLK ((uint32_t)0x00000000)  /*!< Tamper pins are pre-charged before 
+                                                                         sampling during 1 RTCCLK cycle */
+#define RTC_TamperPrechargeDuration_2RTCCLK ((uint32_t)0x00002000)  /*!< Tamper pins are pre-charged before 
+                                                                         sampling during 2 RTCCLK cycles */
+#define RTC_TamperPrechargeDuration_4RTCCLK ((uint32_t)0x00004000)  /*!< Tamper pins are pre-charged before 
+                                                                         sampling during 4 RTCCLK cycles */
+#define RTC_TamperPrechargeDuration_8RTCCLK ((uint32_t)0x00006000)  /*!< Tamper pins are pre-charged before 
+                                                                         sampling during 8 RTCCLK cycles */
+
+#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) || \
+                                                    ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) || \
+                                                    ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) || \
+                                                    ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Tamper_Pins_Definitions 
+  * @{
+  */ 
+#define RTC_Tamper_1                    RTC_TAFCR_TAMP1E
+#define IS_RTC_TAMPER(TAMPER) (((TAMPER) == RTC_Tamper_1))
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Tamper_Pin_Selection 
+  * @{
+  */ 
+#define RTC_TamperPin_PC13                 ((uint32_t)0x00000000)
+#define RTC_TamperPin_PI8                  ((uint32_t)0x00010000)
+#define IS_RTC_TAMPER_PIN(PIN) (((PIN) == RTC_TamperPin_PC13) || \
+                                ((PIN) == RTC_TamperPin_PI8))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_TimeStamp_Pin_Selection 
+  * @{
+  */ 
+#define RTC_TimeStampPin_PC13              ((uint32_t)0x00000000)
+#define RTC_TimeStampPin_PI8               ((uint32_t)0x00020000)
+#define IS_RTC_TIMESTAMP_PIN(PIN) (((PIN) == RTC_TimeStampPin_PC13) || \
+                                   ((PIN) == RTC_TimeStampPin_PI8))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Output_Type_ALARM_OUT 
+  * @{
+  */ 
+#define RTC_OutputType_OpenDrain           ((uint32_t)0x00000000)
+#define RTC_OutputType_PushPull            ((uint32_t)0x00040000)
+#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) || \
+                                  ((TYPE) == RTC_OutputType_PushPull))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Add_1_Second_Parameter_Definitions
+  * @{
+  */ 
+#define RTC_ShiftAdd1S_Reset      ((uint32_t)0x00000000)
+#define RTC_ShiftAdd1S_Set        ((uint32_t)0x80000000)
+#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) || \
+                                 ((SEL) == RTC_ShiftAdd1S_Set))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Substract_Fraction_Of_Second_Value
+  * @{
+  */ 
+#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= 0x00007FFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Backup_Registers_Definitions 
+  * @{
+  */
+
+#define RTC_BKP_DR0                       ((uint32_t)0x00000000)
+#define RTC_BKP_DR1                       ((uint32_t)0x00000001)
+#define RTC_BKP_DR2                       ((uint32_t)0x00000002)
+#define RTC_BKP_DR3                       ((uint32_t)0x00000003)
+#define RTC_BKP_DR4                       ((uint32_t)0x00000004)
+#define RTC_BKP_DR5                       ((uint32_t)0x00000005)
+#define RTC_BKP_DR6                       ((uint32_t)0x00000006)
+#define RTC_BKP_DR7                       ((uint32_t)0x00000007)
+#define RTC_BKP_DR8                       ((uint32_t)0x00000008)
+#define RTC_BKP_DR9                       ((uint32_t)0x00000009)
+#define RTC_BKP_DR10                      ((uint32_t)0x0000000A)
+#define RTC_BKP_DR11                      ((uint32_t)0x0000000B)
+#define RTC_BKP_DR12                      ((uint32_t)0x0000000C)
+#define RTC_BKP_DR13                      ((uint32_t)0x0000000D)
+#define RTC_BKP_DR14                      ((uint32_t)0x0000000E)
+#define RTC_BKP_DR15                      ((uint32_t)0x0000000F)
+#define RTC_BKP_DR16                      ((uint32_t)0x00000010)
+#define RTC_BKP_DR17                      ((uint32_t)0x00000011)
+#define RTC_BKP_DR18                      ((uint32_t)0x00000012)
+#define RTC_BKP_DR19                      ((uint32_t)0x00000013)
+#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0) || \
+                                           ((BKP) == RTC_BKP_DR1) || \
+                                           ((BKP) == RTC_BKP_DR2) || \
+                                           ((BKP) == RTC_BKP_DR3) || \
+                                           ((BKP) == RTC_BKP_DR4) || \
+                                           ((BKP) == RTC_BKP_DR5) || \
+                                           ((BKP) == RTC_BKP_DR6) || \
+                                           ((BKP) == RTC_BKP_DR7) || \
+                                           ((BKP) == RTC_BKP_DR8) || \
+                                           ((BKP) == RTC_BKP_DR9) || \
+                                           ((BKP) == RTC_BKP_DR10) || \
+                                           ((BKP) == RTC_BKP_DR11) || \
+                                           ((BKP) == RTC_BKP_DR12) || \
+                                           ((BKP) == RTC_BKP_DR13) || \
+                                           ((BKP) == RTC_BKP_DR14) || \
+                                           ((BKP) == RTC_BKP_DR15) || \
+                                           ((BKP) == RTC_BKP_DR16) || \
+                                           ((BKP) == RTC_BKP_DR17) || \
+                                           ((BKP) == RTC_BKP_DR18) || \
+                                           ((BKP) == RTC_BKP_DR19))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Input_parameter_format_definitions 
+  * @{
+  */ 
+#define RTC_Format_BIN                    ((uint32_t)0x000000000)
+#define RTC_Format_BCD                    ((uint32_t)0x000000001)
+#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_Format_BIN) || ((FORMAT) == RTC_Format_BCD))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Flags_Definitions 
+  * @{
+  */ 
+#define RTC_FLAG_RECALPF                  ((uint32_t)0x00010000)
+#define RTC_FLAG_TAMP1F                   ((uint32_t)0x00002000)
+#define RTC_FLAG_TSOVF                    ((uint32_t)0x00001000)
+#define RTC_FLAG_TSF                      ((uint32_t)0x00000800)
+#define RTC_FLAG_WUTF                     ((uint32_t)0x00000400)
+#define RTC_FLAG_ALRBF                    ((uint32_t)0x00000200)
+#define RTC_FLAG_ALRAF                    ((uint32_t)0x00000100)
+#define RTC_FLAG_INITF                    ((uint32_t)0x00000040)
+#define RTC_FLAG_RSF                      ((uint32_t)0x00000020)
+#define RTC_FLAG_INITS                    ((uint32_t)0x00000010)
+#define RTC_FLAG_SHPF                     ((uint32_t)0x00000008)
+#define RTC_FLAG_WUTWF                    ((uint32_t)0x00000004)
+#define RTC_FLAG_ALRBWF                   ((uint32_t)0x00000002)
+#define RTC_FLAG_ALRAWF                   ((uint32_t)0x00000001)
+#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF) || ((FLAG) == RTC_FLAG_TSF) || \
+                               ((FLAG) == RTC_FLAG_WUTF) || ((FLAG) == RTC_FLAG_ALRBF) || \
+                               ((FLAG) == RTC_FLAG_ALRAF) || ((FLAG) == RTC_FLAG_INITF) || \
+                               ((FLAG) == RTC_FLAG_RSF) || ((FLAG) == RTC_FLAG_WUTWF) || \
+                               ((FLAG) == RTC_FLAG_ALRBWF) || ((FLAG) == RTC_FLAG_ALRAWF) || \
+                               ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_RECALPF) || \
+                                ((FLAG) == RTC_FLAG_SHPF))
+#define IS_RTC_CLEAR_FLAG(FLAG) (((FLAG) != (uint32_t)RESET) && (((FLAG) & 0xFFFF00DF) == (uint32_t)RESET))
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Interrupts_Definitions 
+  * @{
+  */ 
+#define RTC_IT_TS                         ((uint32_t)0x00008000)
+#define RTC_IT_WUT                        ((uint32_t)0x00004000)
+#define RTC_IT_ALRB                       ((uint32_t)0x00002000)
+#define RTC_IT_ALRA                       ((uint32_t)0x00001000)
+#define RTC_IT_TAMP                       ((uint32_t)0x00000004) /* Used only to Enable the Tamper Interrupt */
+#define RTC_IT_TAMP1                      ((uint32_t)0x00020000)
+
+#define IS_RTC_CONFIG_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFF0FFB) == (uint32_t)RESET))
+#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS) || ((IT) == RTC_IT_WUT) || \
+                           ((IT) == RTC_IT_ALRB) || ((IT) == RTC_IT_ALRA) || \
+                           ((IT) == RTC_IT_TAMP1))
+#define IS_RTC_CLEAR_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFD0FFF) == (uint32_t)RESET))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup RTC_Legacy 
+  * @{
+  */ 
+#define RTC_DigitalCalibConfig  RTC_CoarseCalibConfig
+#define RTC_DigitalCalibCmd     RTC_CoarseCalibCmd
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/*  Function used to set the RTC configuration to the default reset state *****/
+ErrorStatus RTC_DeInit(void);
+
+/* Initialization and Configuration functions *********************************/
+ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct);
+void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct);
+void RTC_WriteProtectionCmd(FunctionalState NewState);
+ErrorStatus RTC_EnterInitMode(void);
+void RTC_ExitInitMode(void);
+ErrorStatus RTC_WaitForSynchro(void);
+ErrorStatus RTC_RefClockCmd(FunctionalState NewState);
+void RTC_BypassShadowCmd(FunctionalState NewState);
+
+/* Time and Date configuration functions **************************************/
+ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
+void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct);
+void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
+uint32_t RTC_GetSubSecond(void);
+ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
+void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct);
+void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
+
+/* Alarms (Alarm A and Alarm B) configuration functions  **********************/
+void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
+void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct);
+void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
+ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState);
+void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask);
+uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm);
+
+/* WakeUp Timer configuration functions ***************************************/
+void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock);
+void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter);
+uint32_t RTC_GetWakeUpCounter(void);
+ErrorStatus RTC_WakeUpCmd(FunctionalState NewState);
+
+/* Daylight Saving configuration functions ************************************/
+void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation);
+uint32_t RTC_GetStoreOperation(void);
+
+/* Output pin Configuration function ******************************************/
+void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity);
+
+/* Digital Calibration configuration functions *********************************/
+ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value);
+ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState);
+void RTC_CalibOutputCmd(FunctionalState NewState);
+void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput);
+ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod, 
+                                  uint32_t RTC_SmoothCalibPlusPulses,
+                                  uint32_t RTC_SmouthCalibMinusPulsesValue);
+
+/* TimeStamp configuration functions ******************************************/
+void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState);
+void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct,
+                                      RTC_DateTypeDef* RTC_StampDateStruct);
+uint32_t RTC_GetTimeStampSubSecond(void);
+
+/* Tampers configuration functions ********************************************/
+void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger);
+void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState);
+void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter);
+void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq);
+void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration);
+void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState);
+void RTC_TamperPullUpCmd(FunctionalState NewState);
+
+/* Backup Data Registers configuration functions ******************************/
+void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data);
+uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR);
+
+/* RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration
+   functions ******************************************************************/
+void RTC_TamperPinSelection(uint32_t RTC_TamperPin);
+void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin);
+void RTC_OutputTypeConfig(uint32_t RTC_OutputType);
+
+/* RTC_Shift_control_synchonisation_functions *********************************/
+ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS);
+
+/* Interrupts and flags management functions **********************************/
+void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState);
+FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG);
+void RTC_ClearFlag(uint32_t RTC_FLAG);
+ITStatus RTC_GetITStatus(uint32_t RTC_IT);
+void RTC_ClearITPendingBit(uint32_t RTC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_RTC_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sai.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sai.h
new file mode 100644
index 0000000..a6eb217
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sai.h
@@ -0,0 +1,611 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_sai.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the SAI 
+  *          firmware library.  
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */ 
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_SAI_H
+#define __STM32F4xx_SAI_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup SAI
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  SAI Block Init structure definition  
+  */
+
+typedef struct
+{
+  uint32_t SAI_AudioMode;           /*!< Specifies the SAI Block Audio Mode.
+                                         This parameter can be a value of @ref SAI_Block_Mode */
+
+  uint32_t SAI_Protocol;             /*!< Specifies the SAI Block Protocol.
+                                         This parameter can be a value of @ref SAI_Block_Protocol */
+
+  uint32_t SAI_DataSize;            /*!< Specifies the SAI Block data size.
+                                         This parameter can be a value of @ref SAI_Block_Data_Size 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
+
+  uint32_t SAI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
+                                         This parameter can be a value of @ref SAI_Block_MSB_LSB_transmission 
+                                         @note this value has no meaning when AC'97 or SPDIF protocols are selected.*/
+
+  uint32_t SAI_ClockStrobing;       /*!< Specifies the SAI Block clock strobing edge sensitivity.
+                                         This parameter can be a value of @ref SAI_Block_Clock_Strobing */
+
+  uint32_t SAI_Synchro;             /*!< Specifies SAI Block synchronization
+                                         This parameter can be a value of @ref SAI_Block_Synchronization */
+ 
+  uint32_t SAI_OUTDRIV;             /*!< Specifies when SAI Block outputs are driven.
+                                         This parameter can be a value of @ref SAI_Block_Output_Drive
+                                         @note this value has to be set before enabling the audio block  
+                                               but after the audio block configuration. */
+
+  uint32_t SAI_NoDivider;            /*!< Specifies whether Master Clock will be divided or not.
+                                         This parameter can be a value of @ref SAI_Block_NoDivider */
+
+  uint32_t SAI_MasterDivider;       /*!< Specifies SAI Block Master Clock Divider. 
+                                         @note the Master Clock Frequency is calculated accordingly to the  
+                                               following formula : MCLK_x = SAI_CK_x/(MCKDIV[3:0]*2)*/
+                                               
+  uint32_t SAI_FIFOThreshold;      /*!< Specifies SAI Block FIFO Threshold.
+                                         This parameter can be a value of @ref SAI_Block_Fifo_Threshold */                                                                                             
+}SAI_InitTypeDef;
+
+/** 
+  * @brief  SAI Block Frame Init structure definition  
+  */
+
+typedef struct
+{
+
+  uint32_t SAI_FrameLength;         /*!< Specifies the Frame Length, the number of SCK clocks 
+                                         for each audio frame.
+                                         This parameter must be a number between 8 and 256.
+                                         @note If master Clock MCLK_x pin is declared as an output, the frame length
+                                               should be Aligned to a number equal to power of 2 in order to keep 
+                                              in an audio frame, an integer number of MCLK pulses by bit Clock.                                                 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
+                                   
+  uint32_t SAI_ActiveFrameLength;   /*!< Specifies the Frame synchronization active level length.
+                                         This Parameter specifies the length in number of bit clock (SCK + 1)  
+                                         of the active level of FS signal in audio frame.
+                                         This parameter must be a number between 1 and 128. 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
+
+  uint32_t SAI_FSDefinition;        /*!< Specifies the Frame Synchronization definition.
+                                         This parameter can be a value of @ref SAI_Block_FS_Definition 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
+
+  uint32_t SAI_FSPolarity;          /*!< Specifies the Frame Synchronization Polarity.
+                                         This parameter can be a value of @ref SAI_Block_FS_Polarity 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
+
+  uint32_t SAI_FSOffset;            /*!< Specifies the Frame Synchronization Offset.
+                                         This parameter can be a value of @ref SAI_Block_FS_Offset 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
+
+}SAI_FrameInitTypeDef;
+
+/**
+  * @brief   SAI Block Slot Init Structure definition
+  */    
+
+typedef struct
+{
+  uint32_t SAI_FirstBitOffset;      /*!< Specifies the position of first data transfer bit in the slot.
+                                         This parameter must be a number between 0 and 24. 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
+
+  uint32_t SAI_SlotSize;            /*!< Specifies the Slot Size.
+                                         This parameter can be a value of @ref SAI_Block_Slot_Size 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
+
+  uint32_t SAI_SlotNumber;          /*!< Specifies the number of slot in the audio frame.
+                                         This parameter must be a number between 1 and 16. 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
+
+  uint32_t SAI_SlotActive;          /*!< Specifies the slots in audio frame that will be activated.
+                                         This parameter can be a value of @ ref SAI_Block_Slot_Active 
+                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/ 
+}SAI_SlotInitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup SAI_Exported_Constants
+  * @{
+  */
+
+#define IS_SAI_PERIPH(PERIPH) ((PERIPH) == SAI1)
+
+#define IS_SAI_BLOCK_PERIPH(PERIPH) (((PERIPH) == SAI1_Block_A) || \
+                                     ((PERIPH) == SAI1_Block_B))
+
+
+/** @defgroup SAI_Block_Mode 
+  * @{
+  */
+#define SAI_Mode_MasterTx               ((uint32_t)0x00000000)
+#define SAI_Mode_MasterRx               ((uint32_t)0x00000001)  
+#define SAI_Mode_SlaveTx                ((uint32_t)0x00000002)
+#define SAI_Mode_SlaveRx                ((uint32_t)0x00000003)
+#define IS_SAI_BLOCK_MODE(MODE) (((MODE) == SAI_Mode_MasterTx) || \
+                                 ((MODE) == SAI_Mode_MasterRx) || \
+                                 ((MODE) == SAI_Mode_SlaveTx)  || \
+                                 ((MODE) == SAI_Mode_SlaveRx))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Protocol 
+  * @{
+  */
+
+#define SAI_Free_Protocol                 ((uint32_t)0x00000000)
+#define SAI_SPDIF_Protocol                ((uint32_t)SAI_xCR1_PRTCFG_0)
+#define SAI_AC97_Protocol                 ((uint32_t)SAI_xCR1_PRTCFG_1)
+#define IS_SAI_BLOCK_PROTOCOL(PROTOCOL) (((PROTOCOL) == SAI_Free_Protocol)  || \
+                                         ((PROTOCOL) == SAI_SPDIF_Protocol) || \
+                                         ((PROTOCOL) == SAI_AC97_Protocol))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Data_Size 
+  * @{
+  */
+
+#define SAI_DataSize_8b                   ((uint32_t)0x00000040)
+#define SAI_DataSize_10b                  ((uint32_t)0x00000060)
+#define SAI_DataSize_16b                  ((uint32_t)0x00000080)
+#define SAI_DataSize_20b                  ((uint32_t)0x000000A0)
+#define SAI_DataSize_24b                  ((uint32_t)0x000000C0)
+#define SAI_DataSize_32b                  ((uint32_t)0x000000E0)
+#define IS_SAI_BLOCK_DATASIZE(DATASIZE) (((DATASIZE) == SAI_DataSize_8b)  || \
+                                         ((DATASIZE) == SAI_DataSize_10b) || \
+                                         ((DATASIZE) == SAI_DataSize_16b) || \
+                                         ((DATASIZE) == SAI_DataSize_20b) || \
+                                         ((DATASIZE) == SAI_DataSize_24b) || \
+                                         ((DATASIZE) == SAI_DataSize_32b))
+/**
+  * @}
+  */ 
+
+/** @defgroup SAI_Block_MSB_LSB_transmission 
+  * @{
+  */
+
+#define SAI_FirstBit_MSB                  ((uint32_t)0x00000000)
+#define SAI_FirstBit_LSB                  ((uint32_t)SAI_xCR1_LSBFIRST)
+#define IS_SAI_BLOCK_FIRST_BIT(BIT) (((BIT) == SAI_FirstBit_MSB) || \
+                                     ((BIT) == SAI_FirstBit_LSB))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Clock_Strobing 
+  * @{
+  */
+
+#define SAI_ClockStrobing_FallingEdge     ((uint32_t)0x00000000)
+#define SAI_ClockStrobing_RisingEdge      ((uint32_t)SAI_xCR1_CKSTR)
+#define IS_SAI_BLOCK_CLOCK_STROBING(CLOCK) (((CLOCK) == SAI_ClockStrobing_FallingEdge) || \
+                                            ((CLOCK) == SAI_ClockStrobing_RisingEdge))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Synchronization 
+  * @{
+  */
+
+#define SAI_Asynchronous                   ((uint32_t)0x00000000)
+#define SAI_Synchronous                    ((uint32_t)SAI_xCR1_SYNCEN_0)
+#define IS_SAI_BLOCK_SYNCHRO(SYNCHRO) (((SYNCHRO) == SAI_Synchronous) || \
+                                       ((SYNCHRO) == SAI_Asynchronous))
+/**
+  * @}
+  */ 
+
+/** @defgroup SAI_Block_Output_Drive 
+  * @{
+  */
+
+#define SAI_OutputDrive_Disabled          ((uint32_t)0x00000000)
+#define SAI_OutputDrive_Enabled           ((uint32_t)SAI_xCR1_OUTDRIV)
+#define IS_SAI_BLOCK_OUTPUT_DRIVE(DRIVE) (((DRIVE) == SAI_OutputDrive_Disabled) || \
+                                          ((DRIVE) == SAI_OutputDrive_Enabled))
+/**
+  * @}
+  */ 
+
+
+
+/** @defgroup SAI_Block_NoDivider 
+  * @{
+  */
+
+#define SAI_MasterDivider_Enabled         ((uint32_t)0x00000000)
+#define SAI_MasterDivider_Disabled        ((uint32_t)SAI_xCR1_NODIV)
+#define IS_SAI_BLOCK_NODIVIDER(NODIVIDER) (((NODIVIDER) == SAI_MasterDivider_Enabled) || \
+                                           ((NODIVIDER) == SAI_MasterDivider_Disabled))
+/**
+  * @}
+  */
+  
+
+/** @defgroup SAI_Block_Master_Divider 
+  * @{
+  */
+#define IS_SAI_BLOCK_MASTER_DIVIDER(DIVIDER) ((DIVIDER) <= 15)
+
+/**
+  * @}
+  */
+  
+/** @defgroup SAI_Block_Frame_Length 
+  * @{
+  */
+#define IS_SAI_BLOCK_FRAME_LENGTH(LENGTH) ((8 <= (LENGTH)) && ((LENGTH) <= 256))
+
+/**
+  * @}
+  */
+    
+/** @defgroup SAI_Block_Active_FrameLength 
+  * @{
+  */
+#define IS_SAI_BLOCK_ACTIVE_FRAME(LENGTH) ((1 <= (LENGTH)) && ((LENGTH) <= 128))
+
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_FS_Definition 
+  * @{
+  */
+
+#define SAI_FS_StartFrame                 ((uint32_t)0x00000000)
+#define I2S_FS_ChannelIdentification      ((uint32_t)SAI_xFRCR_FSDEF)
+#define IS_SAI_BLOCK_FS_DEFINITION(DEFINITION) (((DEFINITION) == SAI_FS_StartFrame) || \
+                                                ((DEFINITION) == I2S_FS_ChannelIdentification))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_FS_Polarity 
+  * @{
+  */
+
+#define SAI_FS_ActiveLow                  ((uint32_t)0x00000000)
+#define SAI_FS_ActiveHigh                 ((uint32_t)SAI_xFRCR_FSPO)
+#define IS_SAI_BLOCK_FS_POLARITY(POLARITY) (((POLARITY) == SAI_FS_ActiveLow) || \
+                                            ((POLARITY) == SAI_FS_ActiveHigh))
+/**
+  * @}
+  */
+            
+/** @defgroup SAI_Block_FS_Offset 
+  * @{
+  */
+  
+#define SAI_FS_FirstBit                   ((uint32_t)0x00000000)
+#define SAI_FS_BeforeFirstBit             ((uint32_t)SAI_xFRCR_FSOFF)
+#define IS_SAI_BLOCK_FS_OFFSET(OFFSET) (((OFFSET) == SAI_FS_FirstBit) || \
+                                        ((OFFSET) == SAI_FS_BeforeFirstBit))
+/**
+  * @}
+  */
+  
+/** @defgroup SAI_Block_Slot_FirstBit_Offset
+  * @{
+  */
+#define IS_SAI_BLOCK_FIRSTBIT_OFFSET(OFFSET) ((OFFSET) <= 24)
+
+/**
+  * @}
+  */
+
+  /** @defgroup SAI_Block_Slot_Size
+  * @{
+  */
+#define SAI_SlotSize_DataSize             ((uint32_t)0x00000000)  
+#define SAI_SlotSize_16b                  ((uint32_t)SAI_xSLOTR_SLOTSZ_0)
+#define SAI_SlotSize_32b                  ((uint32_t)SAI_xSLOTR_SLOTSZ_1)
+#define IS_SAI_BLOCK_SLOT_SIZE(SIZE) (((SIZE) == SAI_SlotSize_DataSize) || \
+                                      ((SIZE) == SAI_SlotSize_16b)      || \
+                                      ((SIZE) == SAI_SlotSize_32b))
+
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Slot_Number
+  * @{
+  */
+#define IS_SAI_BLOCK_SLOT_NUMBER(NUMBER) ((1 <= (NUMBER)) && ((NUMBER) <= 16))
+
+/**
+  * @}
+  */
+  
+/** @defgroup SAI_Block_Slot_Active
+  * @{
+  */
+#define SAI_Slot_NotActive           ((uint32_t)0x00000000)  
+#define SAI_SlotActive_0             ((uint32_t)0x00010000)  
+#define SAI_SlotActive_1             ((uint32_t)0x00020000)
+#define SAI_SlotActive_2             ((uint32_t)0x00040000)
+#define SAI_SlotActive_3             ((uint32_t)0x00080000)
+#define SAI_SlotActive_4             ((uint32_t)0x00100000)
+#define SAI_SlotActive_5             ((uint32_t)0x00200000)
+#define SAI_SlotActive_6             ((uint32_t)0x00400000)
+#define SAI_SlotActive_7             ((uint32_t)0x00800000)
+#define SAI_SlotActive_8             ((uint32_t)0x01000000)
+#define SAI_SlotActive_9             ((uint32_t)0x02000000)
+#define SAI_SlotActive_10            ((uint32_t)0x04000000)
+#define SAI_SlotActive_11            ((uint32_t)0x08000000)
+#define SAI_SlotActive_12            ((uint32_t)0x10000000)
+#define SAI_SlotActive_13            ((uint32_t)0x20000000)
+#define SAI_SlotActive_14            ((uint32_t)0x40000000)
+#define SAI_SlotActive_15            ((uint32_t)0x80000000)
+#define SAI_SlotActive_ALL           ((uint32_t)0xFFFF0000)
+
+#define IS_SAI_SLOT_ACTIVE(ACTIVE) ((ACTIVE) != 0)
+
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Mono_Streo_Mode
+  * @{
+  */
+
+#define SAI_MonoMode                      ((uint32_t)SAI_xCR1_MONO)
+#define SAI_StreoMode                     ((uint32_t)0x00000000)
+#define IS_SAI_BLOCK_MONO_STREO_MODE(MODE) (((MODE) == SAI_MonoMode) ||\
+                                            ((MODE) == SAI_StreoMode))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_TRIState_Management
+  * @{
+  */
+
+#define SAI_Output_NotReleased              ((uint32_t)0x00000000)
+#define SAI_Output_Released                 ((uint32_t)SAI_xCR2_TRIS)
+#define IS_SAI_BLOCK_TRISTATE_MANAGEMENT(STATE) (((STATE) == SAI_Output_NotReleased) ||\
+                                                 ((STATE) == SAI_Output_Released))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Fifo_Threshold 
+  * @{
+  */
+
+#define SAI_Threshold_FIFOEmpty           ((uint32_t)0x00000000)
+#define SAI_FIFOThreshold_1QuarterFull    ((uint32_t)0x00000001)
+#define SAI_FIFOThreshold_HalfFull        ((uint32_t)0x00000002) 
+#define SAI_FIFOThreshold_3QuartersFull   ((uint32_t)0x00000003)
+#define SAI_FIFOThreshold_Full            ((uint32_t)0x00000004)
+#define IS_SAI_BLOCK_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == SAI_Threshold_FIFOEmpty)         || \
+                                                ((THRESHOLD) == SAI_FIFOThreshold_1QuarterFull)  || \
+                                                ((THRESHOLD) == SAI_FIFOThreshold_HalfFull)      || \
+                                                ((THRESHOLD) == SAI_FIFOThreshold_3QuartersFull) || \
+                                                ((THRESHOLD) == SAI_FIFOThreshold_Full))
+/**
+  * @}
+  */
+  
+/** @defgroup SAI_Block_Companding_Mode
+  * @{
+  */
+  
+#define SAI_NoCompanding                  ((uint32_t)0x00000000)
+#define SAI_ULaw_1CPL_Companding          ((uint32_t)0x00008000)
+#define SAI_ALaw_1CPL_Companding          ((uint32_t)0x0000C000)
+#define SAI_ULaw_2CPL_Companding          ((uint32_t)0x0000A000)
+#define SAI_ALaw_2CPL_Companding          ((uint32_t)0x0000E000)
+#define IS_SAI_BLOCK_COMPANDING_MODE(MODE)    (((MODE) == SAI_NoCompanding)        || \
+                                              ((MODE) == SAI_ULaw_1CPL_Companding) || \
+                                              ((MODE) == SAI_ALaw_1CPL_Companding) || \
+                                              ((MODE) == SAI_ULaw_2CPL_Companding) || \
+                                              ((MODE) == SAI_ALaw_2CPL_Companding))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Mute_Value
+  * @{
+  */
+  
+#define SAI_ZeroValue                     ((uint32_t)0x00000000)
+#define SAI_LastSentValue                 ((uint32_t)SAI_xCR2_MUTEVAL)
+#define IS_SAI_BLOCK_MUTE_VALUE(VALUE)    (((VALUE) == SAI_ZeroValue)     || \
+                                           ((VALUE) == SAI_LastSentValue))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Mute_Frame_Counter
+  * @{
+  */
+  
+#define IS_SAI_BLOCK_MUTE_COUNTER(COUNTER) ((COUNTER) <= 63)
+
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Interrupts_Definition 
+  * @{
+  */
+
+#define SAI_IT_OVRUDR                     ((uint32_t)SAI_xIMR_OVRUDRIE)
+#define SAI_IT_MUTEDET                    ((uint32_t)SAI_xIMR_MUTEDETIE)
+#define SAI_IT_WCKCFG                     ((uint32_t)SAI_xIMR_WCKCFGIE)
+#define SAI_IT_FREQ                       ((uint32_t)SAI_xIMR_FREQIE)
+#define SAI_IT_CNRDY                      ((uint32_t)SAI_xIMR_CNRDYIE)
+#define SAI_IT_AFSDET                     ((uint32_t)SAI_xIMR_AFSDETIE)
+#define SAI_IT_LFSDET                     ((uint32_t)SAI_xIMR_LFSDETIE)
+
+#define IS_SAI_BLOCK_CONFIG_IT(IT) (((IT) == SAI_IT_OVRUDR)  || \
+                                    ((IT) == SAI_IT_MUTEDET) || \
+                                    ((IT) == SAI_IT_WCKCFG)  || \
+                                    ((IT) == SAI_IT_FREQ)    || \
+                                    ((IT) == SAI_IT_CNRDY)   || \
+                                    ((IT) == SAI_IT_AFSDET)  || \
+                                    ((IT) == SAI_IT_LFSDET))
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Block_Flags_Definition 
+  * @{
+  */
+
+#define SAI_FLAG_OVRUDR                   ((uint32_t)SAI_xSR_OVRUDR)
+#define SAI_FLAG_MUTEDET                  ((uint32_t)SAI_xSR_MUTEDET)
+#define SAI_FLAG_WCKCFG                   ((uint32_t)SAI_xSR_WCKCFG)
+#define SAI_FLAG_FREQ                     ((uint32_t)SAI_xSR_FREQ)
+#define SAI_FLAG_CNRDY                    ((uint32_t)SAI_xSR_CNRDY)
+#define SAI_FLAG_AFSDET                   ((uint32_t)SAI_xSR_AFSDET)
+#define SAI_FLAG_LFSDET                   ((uint32_t)SAI_xSR_LFSDET)
+
+#define IS_SAI_BLOCK_GET_FLAG(FLAG) (((FLAG) == SAI_FLAG_OVRUDR)  || \
+                                    ((FLAG) == SAI_FLAG_MUTEDET) || \
+                                    ((FLAG) == SAI_FLAG_WCKCFG)  || \
+                                    ((FLAG) == SAI_FLAG_FREQ)    || \
+                                    ((FLAG) == SAI_FLAG_CNRDY)   || \
+                                    ((FLAG) == SAI_FLAG_AFSDET)  || \
+                                    ((FLAG) == SAI_FLAG_LFSDET))
+                                   
+#define IS_SAI_BLOCK_CLEAR_FLAG(FLAG) (((FLAG) == SAI_FLAG_OVRUDR)  || \
+                                       ((FLAG) == SAI_FLAG_MUTEDET) || \
+                                       ((FLAG) == SAI_FLAG_WCKCFG)  || \
+                                       ((FLAG) == SAI_FLAG_FREQ)    || \
+                                       ((FLAG) == SAI_FLAG_CNRDY)   || \
+                                       ((FLAG) == SAI_FLAG_AFSDET)  || \
+                                       ((FLAG) == SAI_FLAG_LFSDET))
+/**
+  * @}
+  */
+  
+/** @defgroup SAI_Block_Fifo_Status_Level 
+  * @{
+  */
+#define SAI_FIFOStatus_Empty              ((uint32_t)0x00000000)
+#define SAI_FIFOStatus_Less1QuarterFull   ((uint32_t)0x00010000)
+#define SAI_FIFOStatus_1QuarterFull       ((uint32_t)0x00020000)
+#define SAI_FIFOStatus_HalfFull           ((uint32_t)0x00030000) 
+#define SAI_FIFOStatus_3QuartersFull      ((uint32_t)0x00040000)
+#define SAI_FIFOStatus_Full               ((uint32_t)0x00050000)
+
+#define IS_SAI_BLOCK_FIFO_STATUS(STATUS) (((STATUS) == SAI_FIFOStatus_Less1QuarterFull ) || \
+                                          ((STATUS) == SAI_FIFOStatus_HalfFull)          || \
+                                          ((STATUS) == SAI_FIFOStatus_1QuarterFull)      || \
+                                          ((STATUS) == SAI_FIFOStatus_3QuartersFull)     || \
+                                          ((STATUS) == SAI_FIFOStatus_Full)              || \
+                                          ((STATUS) == SAI_FIFOStatus_Empty)) 
+/**
+  * @}
+  */
+
+  
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/*  Function used to set the SAI configuration to the default reset state *****/ 
+void SAI_DeInit(SAI_TypeDef* SAIx);
+
+/* Initialization and Configuration functions *********************************/
+void SAI_Init(SAI_Block_TypeDef* SAI_Block_x, SAI_InitTypeDef* SAI_InitStruct);
+void SAI_FrameInit(SAI_Block_TypeDef* SAI_Block_x, SAI_FrameInitTypeDef* SAI_FrameInitStruct);
+void SAI_SlotInit(SAI_Block_TypeDef* SAI_Block_x, SAI_SlotInitTypeDef* SAI_SlotInitStruct);
+void SAI_StructInit(SAI_InitTypeDef* SAI_InitStruct);
+void SAI_FrameStructInit(SAI_FrameInitTypeDef* SAI_FrameInitStruct);
+void SAI_SlotStructInit(SAI_SlotInitTypeDef* SAI_SlotInitStruct);
+
+void SAI_Cmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState);
+void SAI_MonoModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_Mono_StreoMode);
+void SAI_TRIStateConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_TRIState);
+void SAI_CompandingModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_CompandingMode);
+void SAI_MuteModeCmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState);
+void SAI_MuteValueConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteValue);
+void SAI_MuteFrameCounterConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteCounter);
+void SAI_FlushFIFO(SAI_Block_TypeDef* SAI_Block_x);
+
+/* Data transfers functions ***************************************************/ 
+void SAI_SendData(SAI_Block_TypeDef* SAI_Block_x, uint32_t Data);
+uint32_t SAI_ReceiveData(SAI_Block_TypeDef* SAI_Block_x);
+
+/* DMA transfers management functions *****************************************/
+void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState);
+
+/* Interrupts and flags management functions **********************************/
+void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState);
+FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);
+void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);
+ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);
+void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);
+FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x);
+uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_SAI_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sdio.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sdio.h
new file mode 100644
index 0000000..c3edbc2
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sdio.h
@@ -0,0 +1,536 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_sdio.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the SDIO firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_SDIO_H
+#define __STM32F4xx_SDIO_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup SDIO
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+typedef struct
+{
+  uint32_t SDIO_ClockEdge;            /*!< Specifies the clock transition on which the bit capture is made.
+                                           This parameter can be a value of @ref SDIO_Clock_Edge */
+
+  uint32_t SDIO_ClockBypass;          /*!< Specifies whether the SDIO Clock divider bypass is
+                                           enabled or disabled.
+                                           This parameter can be a value of @ref SDIO_Clock_Bypass */
+
+  uint32_t SDIO_ClockPowerSave;       /*!< Specifies whether SDIO Clock output is enabled or
+                                           disabled when the bus is idle.
+                                           This parameter can be a value of @ref SDIO_Clock_Power_Save */
+
+  uint32_t SDIO_BusWide;              /*!< Specifies the SDIO bus width.
+                                           This parameter can be a value of @ref SDIO_Bus_Wide */
+
+  uint32_t SDIO_HardwareFlowControl;  /*!< Specifies whether the SDIO hardware flow control is enabled or disabled.
+                                           This parameter can be a value of @ref SDIO_Hardware_Flow_Control */
+
+  uint8_t SDIO_ClockDiv;              /*!< Specifies the clock frequency of the SDIO controller.
+                                           This parameter can be a value between 0x00 and 0xFF. */
+                                           
+} SDIO_InitTypeDef;
+
+typedef struct
+{
+  uint32_t SDIO_Argument;  /*!< Specifies the SDIO command argument which is sent
+                                to a card as part of a command message. If a command
+                                contains an argument, it must be loaded into this register
+                                before writing the command to the command register */
+
+  uint32_t SDIO_CmdIndex;  /*!< Specifies the SDIO command index. It must be lower than 0x40. */
+
+  uint32_t SDIO_Response;  /*!< Specifies the SDIO response type.
+                                This parameter can be a value of @ref SDIO_Response_Type */
+
+  uint32_t SDIO_Wait;      /*!< Specifies whether SDIO wait for interrupt request is enabled or disabled.
+                                This parameter can be a value of @ref SDIO_Wait_Interrupt_State */
+
+  uint32_t SDIO_CPSM;      /*!< Specifies whether SDIO Command path state machine (CPSM)
+                                is enabled or disabled.
+                                This parameter can be a value of @ref SDIO_CPSM_State */
+} SDIO_CmdInitTypeDef;
+
+typedef struct
+{
+  uint32_t SDIO_DataTimeOut;    /*!< Specifies the data timeout period in card bus clock periods. */
+
+  uint32_t SDIO_DataLength;     /*!< Specifies the number of data bytes to be transferred. */
+ 
+  uint32_t SDIO_DataBlockSize;  /*!< Specifies the data block size for block transfer.
+                                     This parameter can be a value of @ref SDIO_Data_Block_Size */
+ 
+  uint32_t SDIO_TransferDir;    /*!< Specifies the data transfer direction, whether the transfer
+                                     is a read or write.
+                                     This parameter can be a value of @ref SDIO_Transfer_Direction */
+ 
+  uint32_t SDIO_TransferMode;   /*!< Specifies whether data transfer is in stream or block mode.
+                                     This parameter can be a value of @ref SDIO_Transfer_Type */
+ 
+  uint32_t SDIO_DPSM;           /*!< Specifies whether SDIO Data path state machine (DPSM)
+                                     is enabled or disabled.
+                                     This parameter can be a value of @ref SDIO_DPSM_State */
+} SDIO_DataInitTypeDef;
+
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup SDIO_Exported_Constants
+  * @{
+  */
+
+/** @defgroup SDIO_Clock_Edge 
+  * @{
+  */
+
+#define SDIO_ClockEdge_Rising               ((uint32_t)0x00000000)
+#define SDIO_ClockEdge_Falling              ((uint32_t)0x00002000)
+#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \
+                                  ((EDGE) == SDIO_ClockEdge_Falling))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Clock_Bypass 
+  * @{
+  */
+
+#define SDIO_ClockBypass_Disable             ((uint32_t)0x00000000)
+#define SDIO_ClockBypass_Enable              ((uint32_t)0x00000400)    
+#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \
+                                     ((BYPASS) == SDIO_ClockBypass_Enable))
+/**
+  * @}
+  */ 
+
+/** @defgroup SDIO_Clock_Power_Save 
+  * @{
+  */
+
+#define SDIO_ClockPowerSave_Disable         ((uint32_t)0x00000000)
+#define SDIO_ClockPowerSave_Enable          ((uint32_t)0x00000200) 
+#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \
+                                        ((SAVE) == SDIO_ClockPowerSave_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Bus_Wide 
+  * @{
+  */
+
+#define SDIO_BusWide_1b                     ((uint32_t)0x00000000)
+#define SDIO_BusWide_4b                     ((uint32_t)0x00000800)
+#define SDIO_BusWide_8b                     ((uint32_t)0x00001000)
+#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \
+                                ((WIDE) == SDIO_BusWide_8b))
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Hardware_Flow_Control 
+  * @{
+  */
+
+#define SDIO_HardwareFlowControl_Disable    ((uint32_t)0x00000000)
+#define SDIO_HardwareFlowControl_Enable     ((uint32_t)0x00004000)
+#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \
+                                                ((CONTROL) == SDIO_HardwareFlowControl_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Power_State 
+  * @{
+  */
+
+#define SDIO_PowerState_OFF                 ((uint32_t)0x00000000)
+#define SDIO_PowerState_ON                  ((uint32_t)0x00000003)
+#define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup SDIO_Interrupt_sources
+  * @{
+  */
+
+#define SDIO_IT_CCRCFAIL                    ((uint32_t)0x00000001)
+#define SDIO_IT_DCRCFAIL                    ((uint32_t)0x00000002)
+#define SDIO_IT_CTIMEOUT                    ((uint32_t)0x00000004)
+#define SDIO_IT_DTIMEOUT                    ((uint32_t)0x00000008)
+#define SDIO_IT_TXUNDERR                    ((uint32_t)0x00000010)
+#define SDIO_IT_RXOVERR                     ((uint32_t)0x00000020)
+#define SDIO_IT_CMDREND                     ((uint32_t)0x00000040)
+#define SDIO_IT_CMDSENT                     ((uint32_t)0x00000080)
+#define SDIO_IT_DATAEND                     ((uint32_t)0x00000100)
+#define SDIO_IT_STBITERR                    ((uint32_t)0x00000200)
+#define SDIO_IT_DBCKEND                     ((uint32_t)0x00000400)
+#define SDIO_IT_CMDACT                      ((uint32_t)0x00000800)
+#define SDIO_IT_TXACT                       ((uint32_t)0x00001000)
+#define SDIO_IT_RXACT                       ((uint32_t)0x00002000)
+#define SDIO_IT_TXFIFOHE                    ((uint32_t)0x00004000)
+#define SDIO_IT_RXFIFOHF                    ((uint32_t)0x00008000)
+#define SDIO_IT_TXFIFOF                     ((uint32_t)0x00010000)
+#define SDIO_IT_RXFIFOF                     ((uint32_t)0x00020000)
+#define SDIO_IT_TXFIFOE                     ((uint32_t)0x00040000)
+#define SDIO_IT_RXFIFOE                     ((uint32_t)0x00080000)
+#define SDIO_IT_TXDAVL                      ((uint32_t)0x00100000)
+#define SDIO_IT_RXDAVL                      ((uint32_t)0x00200000)
+#define SDIO_IT_SDIOIT                      ((uint32_t)0x00400000)
+#define SDIO_IT_CEATAEND                    ((uint32_t)0x00800000)
+#define IS_SDIO_IT(IT) ((((IT) & (uint32_t)0xFF000000) == 0x00) && ((IT) != (uint32_t)0x00))
+/**
+  * @}
+  */ 
+
+/** @defgroup SDIO_Command_Index
+  * @{
+  */
+
+#define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) < 0x40)
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Response_Type
+  * @{
+  */
+
+#define SDIO_Response_No                    ((uint32_t)0x00000000)
+#define SDIO_Response_Short                 ((uint32_t)0x00000040)
+#define SDIO_Response_Long                  ((uint32_t)0x000000C0)
+#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \
+                                    ((RESPONSE) == SDIO_Response_Short) || \
+                                    ((RESPONSE) == SDIO_Response_Long))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Wait_Interrupt_State
+  * @{
+  */
+
+#define SDIO_Wait_No                        ((uint32_t)0x00000000) /*!< SDIO No Wait, TimeOut is enabled */
+#define SDIO_Wait_IT                        ((uint32_t)0x00000100) /*!< SDIO Wait Interrupt Request */
+#define SDIO_Wait_Pend                      ((uint32_t)0x00000200) /*!< SDIO Wait End of transfer */
+#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \
+                            ((WAIT) == SDIO_Wait_Pend))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_CPSM_State
+  * @{
+  */
+
+#define SDIO_CPSM_Disable                    ((uint32_t)0x00000000)
+#define SDIO_CPSM_Enable                     ((uint32_t)0x00000400)
+#define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))
+/**
+  * @}
+  */ 
+
+/** @defgroup SDIO_Response_Registers
+  * @{
+  */
+
+#define SDIO_RESP1                          ((uint32_t)0x00000000)
+#define SDIO_RESP2                          ((uint32_t)0x00000004)
+#define SDIO_RESP3                          ((uint32_t)0x00000008)
+#define SDIO_RESP4                          ((uint32_t)0x0000000C)
+#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \
+                            ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Data_Length 
+  * @{
+  */
+
+#define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Data_Block_Size 
+  * @{
+  */
+
+#define SDIO_DataBlockSize_1b               ((uint32_t)0x00000000)
+#define SDIO_DataBlockSize_2b               ((uint32_t)0x00000010)
+#define SDIO_DataBlockSize_4b               ((uint32_t)0x00000020)
+#define SDIO_DataBlockSize_8b               ((uint32_t)0x00000030)
+#define SDIO_DataBlockSize_16b              ((uint32_t)0x00000040)
+#define SDIO_DataBlockSize_32b              ((uint32_t)0x00000050)
+#define SDIO_DataBlockSize_64b              ((uint32_t)0x00000060)
+#define SDIO_DataBlockSize_128b             ((uint32_t)0x00000070)
+#define SDIO_DataBlockSize_256b             ((uint32_t)0x00000080)
+#define SDIO_DataBlockSize_512b             ((uint32_t)0x00000090)
+#define SDIO_DataBlockSize_1024b            ((uint32_t)0x000000A0)
+#define SDIO_DataBlockSize_2048b            ((uint32_t)0x000000B0)
+#define SDIO_DataBlockSize_4096b            ((uint32_t)0x000000C0)
+#define SDIO_DataBlockSize_8192b            ((uint32_t)0x000000D0)
+#define SDIO_DataBlockSize_16384b           ((uint32_t)0x000000E0)
+#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_2b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_4b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_8b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_16b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_32b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_64b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_128b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_256b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_512b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_1024b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_2048b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_4096b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_8192b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_16384b)) 
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Transfer_Direction 
+  * @{
+  */
+
+#define SDIO_TransferDir_ToCard             ((uint32_t)0x00000000)
+#define SDIO_TransferDir_ToSDIO             ((uint32_t)0x00000002)
+#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \
+                                   ((DIR) == SDIO_TransferDir_ToSDIO))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Transfer_Type 
+  * @{
+  */
+
+#define SDIO_TransferMode_Block             ((uint32_t)0x00000000)
+#define SDIO_TransferMode_Stream            ((uint32_t)0x00000004)
+#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \
+                                     ((MODE) == SDIO_TransferMode_Block))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_DPSM_State 
+  * @{
+  */
+
+#define SDIO_DPSM_Disable                    ((uint32_t)0x00000000)
+#define SDIO_DPSM_Enable                     ((uint32_t)0x00000001)
+#define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Flags 
+  * @{
+  */
+
+#define SDIO_FLAG_CCRCFAIL                  ((uint32_t)0x00000001)
+#define SDIO_FLAG_DCRCFAIL                  ((uint32_t)0x00000002)
+#define SDIO_FLAG_CTIMEOUT                  ((uint32_t)0x00000004)
+#define SDIO_FLAG_DTIMEOUT                  ((uint32_t)0x00000008)
+#define SDIO_FLAG_TXUNDERR                  ((uint32_t)0x00000010)
+#define SDIO_FLAG_RXOVERR                   ((uint32_t)0x00000020)
+#define SDIO_FLAG_CMDREND                   ((uint32_t)0x00000040)
+#define SDIO_FLAG_CMDSENT                   ((uint32_t)0x00000080)
+#define SDIO_FLAG_DATAEND                   ((uint32_t)0x00000100)
+#define SDIO_FLAG_STBITERR                  ((uint32_t)0x00000200)
+#define SDIO_FLAG_DBCKEND                   ((uint32_t)0x00000400)
+#define SDIO_FLAG_CMDACT                    ((uint32_t)0x00000800)
+#define SDIO_FLAG_TXACT                     ((uint32_t)0x00001000)
+#define SDIO_FLAG_RXACT                     ((uint32_t)0x00002000)
+#define SDIO_FLAG_TXFIFOHE                  ((uint32_t)0x00004000)
+#define SDIO_FLAG_RXFIFOHF                  ((uint32_t)0x00008000)
+#define SDIO_FLAG_TXFIFOF                   ((uint32_t)0x00010000)
+#define SDIO_FLAG_RXFIFOF                   ((uint32_t)0x00020000)
+#define SDIO_FLAG_TXFIFOE                   ((uint32_t)0x00040000)
+#define SDIO_FLAG_RXFIFOE                   ((uint32_t)0x00080000)
+#define SDIO_FLAG_TXDAVL                    ((uint32_t)0x00100000)
+#define SDIO_FLAG_RXDAVL                    ((uint32_t)0x00200000)
+#define SDIO_FLAG_SDIOIT                    ((uint32_t)0x00400000)
+#define SDIO_FLAG_CEATAEND                  ((uint32_t)0x00800000)
+#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \
+                            ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \
+                            ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \
+                            ((FLAG)  == SDIO_FLAG_DTIMEOUT) || \
+                            ((FLAG)  == SDIO_FLAG_TXUNDERR) || \
+                            ((FLAG)  == SDIO_FLAG_RXOVERR) || \
+                            ((FLAG)  == SDIO_FLAG_CMDREND) || \
+                            ((FLAG)  == SDIO_FLAG_CMDSENT) || \
+                            ((FLAG)  == SDIO_FLAG_DATAEND) || \
+                            ((FLAG)  == SDIO_FLAG_STBITERR) || \
+                            ((FLAG)  == SDIO_FLAG_DBCKEND) || \
+                            ((FLAG)  == SDIO_FLAG_CMDACT) || \
+                            ((FLAG)  == SDIO_FLAG_TXACT) || \
+                            ((FLAG)  == SDIO_FLAG_RXACT) || \
+                            ((FLAG)  == SDIO_FLAG_TXFIFOHE) || \
+                            ((FLAG)  == SDIO_FLAG_RXFIFOHF) || \
+                            ((FLAG)  == SDIO_FLAG_TXFIFOF) || \
+                            ((FLAG)  == SDIO_FLAG_RXFIFOF) || \
+                            ((FLAG)  == SDIO_FLAG_TXFIFOE) || \
+                            ((FLAG)  == SDIO_FLAG_RXFIFOE) || \
+                            ((FLAG)  == SDIO_FLAG_TXDAVL) || \
+                            ((FLAG)  == SDIO_FLAG_RXDAVL) || \
+                            ((FLAG)  == SDIO_FLAG_SDIOIT) || \
+                            ((FLAG)  == SDIO_FLAG_CEATAEND))
+
+#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFF3FF800) == 0x00) && ((FLAG) != (uint32_t)0x00))
+
+#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \
+                            ((IT)  == SDIO_IT_DCRCFAIL) || \
+                            ((IT)  == SDIO_IT_CTIMEOUT) || \
+                            ((IT)  == SDIO_IT_DTIMEOUT) || \
+                            ((IT)  == SDIO_IT_TXUNDERR) || \
+                            ((IT)  == SDIO_IT_RXOVERR) || \
+                            ((IT)  == SDIO_IT_CMDREND) || \
+                            ((IT)  == SDIO_IT_CMDSENT) || \
+                            ((IT)  == SDIO_IT_DATAEND) || \
+                            ((IT)  == SDIO_IT_STBITERR) || \
+                            ((IT)  == SDIO_IT_DBCKEND) || \
+                            ((IT)  == SDIO_IT_CMDACT) || \
+                            ((IT)  == SDIO_IT_TXACT) || \
+                            ((IT)  == SDIO_IT_RXACT) || \
+                            ((IT)  == SDIO_IT_TXFIFOHE) || \
+                            ((IT)  == SDIO_IT_RXFIFOHF) || \
+                            ((IT)  == SDIO_IT_TXFIFOF) || \
+                            ((IT)  == SDIO_IT_RXFIFOF) || \
+                            ((IT)  == SDIO_IT_TXFIFOE) || \
+                            ((IT)  == SDIO_IT_RXFIFOE) || \
+                            ((IT)  == SDIO_IT_TXDAVL) || \
+                            ((IT)  == SDIO_IT_RXDAVL) || \
+                            ((IT)  == SDIO_IT_SDIOIT) || \
+                            ((IT)  == SDIO_IT_CEATAEND))
+
+#define IS_SDIO_CLEAR_IT(IT) ((((IT) & (uint32_t)0xFF3FF800) == 0x00) && ((IT) != (uint32_t)0x00))
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Read_Wait_Mode 
+  * @{
+  */
+
+#define SDIO_ReadWaitMode_DATA2             ((uint32_t)0x00000000)
+#define SDIO_ReadWaitMode_CLK               ((uint32_t)0x00000001)
+#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \
+                                     ((MODE) == SDIO_ReadWaitMode_DATA2))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+/*  Function used to set the SDIO configuration to the default reset state ****/
+void SDIO_DeInit(void);
+
+/* Initialization and Configuration functions *********************************/
+void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);
+void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
+void SDIO_ClockCmd(FunctionalState NewState);
+void SDIO_SetPowerState(uint32_t SDIO_PowerState);
+uint32_t SDIO_GetPowerState(void);
+
+/* Command path state machine (CPSM) management functions *********************/
+void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);
+void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);
+uint8_t SDIO_GetCommandResponse(void);
+uint32_t SDIO_GetResponse(uint32_t SDIO_RESP);
+
+/* Data path state machine (DPSM) management functions ************************/
+void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
+void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
+uint32_t SDIO_GetDataCounter(void);
+uint32_t SDIO_ReadData(void);
+void SDIO_WriteData(uint32_t Data);
+uint32_t SDIO_GetFIFOCount(void);
+
+/* SDIO IO Cards mode management functions ************************************/
+void SDIO_StartSDIOReadWait(FunctionalState NewState);
+void SDIO_StopSDIOReadWait(FunctionalState NewState);
+void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode);
+void SDIO_SetSDIOOperation(FunctionalState NewState);
+void SDIO_SendSDIOSuspendCmd(FunctionalState NewState);
+
+/* CE-ATA mode management functions *******************************************/
+void SDIO_CommandCompletionCmd(FunctionalState NewState);
+void SDIO_CEATAITCmd(FunctionalState NewState);
+void SDIO_SendCEATACmd(FunctionalState NewState);
+
+/* DMA transfers management functions *****************************************/
+void SDIO_DMACmd(FunctionalState NewState);
+
+/* Interrupts and flags management functions **********************************/
+void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState);
+FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG);
+void SDIO_ClearFlag(uint32_t SDIO_FLAG);
+ITStatus SDIO_GetITStatus(uint32_t SDIO_IT);
+void SDIO_ClearITPendingBit(uint32_t SDIO_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_SDIO_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_spi.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_spi.h
new file mode 100644
index 0000000..12b2f7f
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_spi.h
@@ -0,0 +1,549 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_spi.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the SPI 
+  *          firmware library. 
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_SPI_H
+#define __STM32F4xx_SPI_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup SPI
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  SPI Init structure definition  
+  */
+
+typedef struct
+{
+  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.
+                                         This parameter can be a value of @ref SPI_data_direction */
+
+  uint16_t SPI_Mode;                /*!< Specifies the SPI operating mode.
+                                         This parameter can be a value of @ref SPI_mode */
+
+  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.
+                                         This parameter can be a value of @ref SPI_data_size */
+
+  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.
+                                         This parameter can be a value of @ref SPI_Clock_Polarity */
+
+  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.
+                                         This parameter can be a value of @ref SPI_Clock_Phase */
+
+  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by
+                                         hardware (NSS pin) or by software using the SSI bit.
+                                         This parameter can be a value of @ref SPI_Slave_Select_management */
+ 
+  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
+                                         used to configure the transmit and receive SCK clock.
+                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler
+                                         @note The communication clock is derived from the master
+                                               clock. The slave clock does not need to be set. */
+
+  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
+                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */
+
+  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */
+}SPI_InitTypeDef;
+
+/** 
+  * @brief  I2S Init structure definition  
+  */
+
+typedef struct
+{
+
+  uint16_t I2S_Mode;         /*!< Specifies the I2S operating mode.
+                                  This parameter can be a value of @ref I2S_Mode */
+
+  uint16_t I2S_Standard;     /*!< Specifies the standard used for the I2S communication.
+                                  This parameter can be a value of @ref I2S_Standard */
+
+  uint16_t I2S_DataFormat;   /*!< Specifies the data format for the I2S communication.
+                                  This parameter can be a value of @ref I2S_Data_Format */
+
+  uint16_t I2S_MCLKOutput;   /*!< Specifies whether the I2S MCLK output is enabled or not.
+                                  This parameter can be a value of @ref I2S_MCLK_Output */
+
+  uint32_t I2S_AudioFreq;    /*!< Specifies the frequency selected for the I2S communication.
+                                  This parameter can be a value of @ref I2S_Audio_Frequency */
+
+  uint16_t I2S_CPOL;         /*!< Specifies the idle state of the I2S clock.
+                                  This parameter can be a value of @ref I2S_Clock_Polarity */
+}I2S_InitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup SPI_Exported_Constants
+  * @{
+  */
+
+#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
+                                   ((PERIPH) == SPI2) || \
+                                   ((PERIPH) == SPI3) || \
+                                   ((PERIPH) == SPI4) || \
+                                   ((PERIPH) == SPI5) || \
+                                   ((PERIPH) == SPI6))
+
+#define IS_SPI_ALL_PERIPH_EXT(PERIPH) (((PERIPH) == SPI1)    || \
+                                       ((PERIPH) == SPI2)    || \
+                                       ((PERIPH) == SPI3)    || \
+                                       ((PERIPH) == SPI4)    || \
+                                       ((PERIPH) == SPI5)    || \
+                                       ((PERIPH) == SPI6)    || \
+                                       ((PERIPH) == I2S2ext) || \
+                                       ((PERIPH) == I2S3ext))
+
+#define IS_SPI_23_PERIPH(PERIPH)  (((PERIPH) == SPI2) || \
+                                   ((PERIPH) == SPI3))
+
+#define IS_SPI_23_PERIPH_EXT(PERIPH)  (((PERIPH) == SPI2)    || \
+                                       ((PERIPH) == SPI3)    || \
+                                       ((PERIPH) == I2S2ext) || \
+                                       ((PERIPH) == I2S3ext))
+
+#define IS_I2S_EXT_PERIPH(PERIPH)  (((PERIPH) == I2S2ext) || \
+                                    ((PERIPH) == I2S3ext))
+
+
+/** @defgroup SPI_data_direction 
+  * @{
+  */
+  
+#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
+#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
+#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
+#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
+#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
+                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
+                                     ((MODE) == SPI_Direction_1Line_Rx) || \
+                                     ((MODE) == SPI_Direction_1Line_Tx))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_mode 
+  * @{
+  */
+
+#define SPI_Mode_Master                 ((uint16_t)0x0104)
+#define SPI_Mode_Slave                  ((uint16_t)0x0000)
+#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
+                           ((MODE) == SPI_Mode_Slave))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_data_size 
+  * @{
+  */
+
+#define SPI_DataSize_16b                ((uint16_t)0x0800)
+#define SPI_DataSize_8b                 ((uint16_t)0x0000)
+#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
+                                   ((DATASIZE) == SPI_DataSize_8b))
+/**
+  * @}
+  */ 
+
+/** @defgroup SPI_Clock_Polarity 
+  * @{
+  */
+
+#define SPI_CPOL_Low                    ((uint16_t)0x0000)
+#define SPI_CPOL_High                   ((uint16_t)0x0002)
+#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
+                           ((CPOL) == SPI_CPOL_High))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Clock_Phase 
+  * @{
+  */
+
+#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
+#define SPI_CPHA_2Edge                  ((uint16_t)0x0001)
+#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
+                           ((CPHA) == SPI_CPHA_2Edge))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Slave_Select_management 
+  * @{
+  */
+
+#define SPI_NSS_Soft                    ((uint16_t)0x0200)
+#define SPI_NSS_Hard                    ((uint16_t)0x0000)
+#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
+                         ((NSS) == SPI_NSS_Hard))
+/**
+  * @}
+  */ 
+
+/** @defgroup SPI_BaudRate_Prescaler 
+  * @{
+  */
+
+#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
+#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
+#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
+#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
+#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
+#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
+#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
+#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
+#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
+/**
+  * @}
+  */ 
+
+/** @defgroup SPI_MSB_LSB_transmission 
+  * @{
+  */
+
+#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
+#define SPI_FirstBit_LSB                ((uint16_t)0x0080)
+#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
+                               ((BIT) == SPI_FirstBit_LSB))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_Mode 
+  * @{
+  */
+
+#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
+#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
+#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
+#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
+#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
+                           ((MODE) == I2S_Mode_SlaveRx) || \
+                           ((MODE) == I2S_Mode_MasterTx)|| \
+                           ((MODE) == I2S_Mode_MasterRx))
+/**
+  * @}
+  */
+  
+
+/** @defgroup SPI_I2S_Standard 
+  * @{
+  */
+
+#define I2S_Standard_Phillips           ((uint16_t)0x0000)
+#define I2S_Standard_MSB                ((uint16_t)0x0010)
+#define I2S_Standard_LSB                ((uint16_t)0x0020)
+#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
+#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
+#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
+                                   ((STANDARD) == I2S_Standard_MSB) || \
+                                   ((STANDARD) == I2S_Standard_LSB) || \
+                                   ((STANDARD) == I2S_Standard_PCMShort) || \
+                                   ((STANDARD) == I2S_Standard_PCMLong))
+/**
+  * @}
+  */
+  
+/** @defgroup SPI_I2S_Data_Format 
+  * @{
+  */
+
+#define I2S_DataFormat_16b              ((uint16_t)0x0000)
+#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
+#define I2S_DataFormat_24b              ((uint16_t)0x0003)
+#define I2S_DataFormat_32b              ((uint16_t)0x0005)
+#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
+                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
+                                    ((FORMAT) == I2S_DataFormat_24b) || \
+                                    ((FORMAT) == I2S_DataFormat_32b))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_MCLK_Output 
+  * @{
+  */
+
+#define I2S_MCLKOutput_Enable           ((uint16_t)0x0200)
+#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
+#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
+                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_Audio_Frequency 
+  * @{
+  */
+
+#define I2S_AudioFreq_192k               ((uint32_t)192000)
+#define I2S_AudioFreq_96k                ((uint32_t)96000)
+#define I2S_AudioFreq_48k                ((uint32_t)48000)
+#define I2S_AudioFreq_44k                ((uint32_t)44100)
+#define I2S_AudioFreq_32k                ((uint32_t)32000)
+#define I2S_AudioFreq_22k                ((uint32_t)22050)
+#define I2S_AudioFreq_16k                ((uint32_t)16000)
+#define I2S_AudioFreq_11k                ((uint32_t)11025)
+#define I2S_AudioFreq_8k                 ((uint32_t)8000)
+#define I2S_AudioFreq_Default            ((uint32_t)2)
+
+#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \
+                                 ((FREQ) <= I2S_AudioFreq_192k)) || \
+                                 ((FREQ) == I2S_AudioFreq_Default))
+/**
+  * @}
+  */
+            
+/** @defgroup SPI_I2S_Clock_Polarity 
+  * @{
+  */
+
+#define I2S_CPOL_Low                    ((uint16_t)0x0000)
+#define I2S_CPOL_High                   ((uint16_t)0x0008)
+#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
+                           ((CPOL) == I2S_CPOL_High))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_DMA_transfer_requests 
+  * @{
+  */
+
+#define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
+#define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
+#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_NSS_internal_software_management 
+  * @{
+  */
+
+#define SPI_NSSInternalSoft_Set         ((uint16_t)0x0100)
+#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
+#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
+                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_CRC_Transmit_Receive 
+  * @{
+  */
+
+#define SPI_CRC_Tx                      ((uint8_t)0x00)
+#define SPI_CRC_Rx                      ((uint8_t)0x01)
+#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_direction_transmit_receive 
+  * @{
+  */
+
+#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
+#define SPI_Direction_Tx                ((uint16_t)0x4000)
+#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
+                                     ((DIRECTION) == SPI_Direction_Tx))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_interrupts_definition 
+  * @{
+  */
+
+#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
+#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
+#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
+#define I2S_IT_UDR                      ((uint8_t)0x53)
+#define SPI_I2S_IT_TIFRFE               ((uint8_t)0x58)
+
+#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
+                                  ((IT) == SPI_I2S_IT_RXNE) || \
+                                  ((IT) == SPI_I2S_IT_ERR))
+
+#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
+#define SPI_IT_MODF                     ((uint8_t)0x55)
+#define SPI_IT_CRCERR                   ((uint8_t)0x54)
+
+#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_IT_CRCERR))
+
+#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE)|| ((IT) == SPI_I2S_IT_TXE) || \
+                               ((IT) == SPI_IT_CRCERR)  || ((IT) == SPI_IT_MODF) || \
+                               ((IT) == SPI_I2S_IT_OVR) || ((IT) == I2S_IT_UDR) ||\
+                               ((IT) == SPI_I2S_IT_TIFRFE))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_flags_definition 
+  * @{
+  */
+
+#define SPI_I2S_FLAG_RXNE               ((uint16_t)0x0001)
+#define SPI_I2S_FLAG_TXE                ((uint16_t)0x0002)
+#define I2S_FLAG_CHSIDE                 ((uint16_t)0x0004)
+#define I2S_FLAG_UDR                    ((uint16_t)0x0008)
+#define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
+#define SPI_FLAG_MODF                   ((uint16_t)0x0020)
+#define SPI_I2S_FLAG_OVR                ((uint16_t)0x0040)
+#define SPI_I2S_FLAG_BSY                ((uint16_t)0x0080)
+#define SPI_I2S_FLAG_TIFRFE             ((uint16_t)0x0100)
+
+#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
+#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
+                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
+                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
+                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)|| \
+                                   ((FLAG) == SPI_I2S_FLAG_TIFRFE))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_CRC_polynomial 
+  * @{
+  */
+
+#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_Legacy 
+  * @{
+  */
+
+#define SPI_DMAReq_Tx                SPI_I2S_DMAReq_Tx
+#define SPI_DMAReq_Rx                SPI_I2S_DMAReq_Rx
+#define SPI_IT_TXE                   SPI_I2S_IT_TXE
+#define SPI_IT_RXNE                  SPI_I2S_IT_RXNE
+#define SPI_IT_ERR                   SPI_I2S_IT_ERR
+#define SPI_IT_OVR                   SPI_I2S_IT_OVR
+#define SPI_FLAG_RXNE                SPI_I2S_FLAG_RXNE
+#define SPI_FLAG_TXE                 SPI_I2S_FLAG_TXE
+#define SPI_FLAG_OVR                 SPI_I2S_FLAG_OVR
+#define SPI_FLAG_BSY                 SPI_I2S_FLAG_BSY
+#define SPI_DeInit                   SPI_I2S_DeInit
+#define SPI_ITConfig                 SPI_I2S_ITConfig
+#define SPI_DMACmd                   SPI_I2S_DMACmd
+#define SPI_SendData                 SPI_I2S_SendData
+#define SPI_ReceiveData              SPI_I2S_ReceiveData
+#define SPI_GetFlagStatus            SPI_I2S_GetFlagStatus
+#define SPI_ClearFlag                SPI_I2S_ClearFlag
+#define SPI_GetITStatus              SPI_I2S_GetITStatus
+#define SPI_ClearITPendingBit        SPI_I2S_ClearITPendingBit
+/**
+  * @}
+  */
+  
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/*  Function used to set the SPI configuration to the default reset state *****/ 
+void SPI_I2S_DeInit(SPI_TypeDef* SPIx);
+
+/* Initialization and Configuration functions *********************************/
+void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
+void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
+void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
+void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
+void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
+void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
+void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
+void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
+void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
+void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
+void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
+
+void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct);
+
+/* Data transfers functions ***************************************************/ 
+void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
+uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
+
+/* Hardware CRC Calculation functions *****************************************/
+void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
+void SPI_TransmitCRC(SPI_TypeDef* SPIx);
+uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
+uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
+
+/* DMA transfers management functions *****************************************/
+void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
+
+/* Interrupts and flags management functions **********************************/
+void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
+FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
+void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
+ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
+void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_SPI_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_syscfg.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_syscfg.h
new file mode 100644
index 0000000..181c9d9
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_syscfg.h
@@ -0,0 +1,210 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_syscfg.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the SYSCFG firmware
+  *          library. 
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_SYSCFG_H
+#define __STM32F4xx_SYSCFG_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup SYSCFG
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+  
+/** @defgroup SYSCFG_Exported_Constants 
+  * @{
+  */ 
+
+/** @defgroup SYSCFG_EXTI_Port_Sources 
+  * @{
+  */ 
+#define EXTI_PortSourceGPIOA       ((uint8_t)0x00)
+#define EXTI_PortSourceGPIOB       ((uint8_t)0x01)
+#define EXTI_PortSourceGPIOC       ((uint8_t)0x02)
+#define EXTI_PortSourceGPIOD       ((uint8_t)0x03)
+#define EXTI_PortSourceGPIOE       ((uint8_t)0x04)
+#define EXTI_PortSourceGPIOF       ((uint8_t)0x05)
+#define EXTI_PortSourceGPIOG       ((uint8_t)0x06)
+#define EXTI_PortSourceGPIOH       ((uint8_t)0x07)
+#define EXTI_PortSourceGPIOI       ((uint8_t)0x08)
+#define EXTI_PortSourceGPIOJ       ((uint8_t)0x09)
+#define EXTI_PortSourceGPIOK       ((uint8_t)0x0A)
+
+#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOB) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOC) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOD) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOE) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOF) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOG) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOH) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOI) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOJ) || \
+                                         ((PORTSOURCE) == EXTI_PortSourceGPIOK))
+                                         
+/**
+  * @}
+  */ 
+
+
+/** @defgroup SYSCFG_EXTI_Pin_Sources 
+  * @{
+  */ 
+#define EXTI_PinSource0            ((uint8_t)0x00)
+#define EXTI_PinSource1            ((uint8_t)0x01)
+#define EXTI_PinSource2            ((uint8_t)0x02)
+#define EXTI_PinSource3            ((uint8_t)0x03)
+#define EXTI_PinSource4            ((uint8_t)0x04)
+#define EXTI_PinSource5            ((uint8_t)0x05)
+#define EXTI_PinSource6            ((uint8_t)0x06)
+#define EXTI_PinSource7            ((uint8_t)0x07)
+#define EXTI_PinSource8            ((uint8_t)0x08)
+#define EXTI_PinSource9            ((uint8_t)0x09)
+#define EXTI_PinSource10           ((uint8_t)0x0A)
+#define EXTI_PinSource11           ((uint8_t)0x0B)
+#define EXTI_PinSource12           ((uint8_t)0x0C)
+#define EXTI_PinSource13           ((uint8_t)0x0D)
+#define EXTI_PinSource14           ((uint8_t)0x0E)
+#define EXTI_PinSource15           ((uint8_t)0x0F)
+#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0)  || \
+                                       ((PINSOURCE) == EXTI_PinSource1)  || \
+                                       ((PINSOURCE) == EXTI_PinSource2)  || \
+                                       ((PINSOURCE) == EXTI_PinSource3)  || \
+                                       ((PINSOURCE) == EXTI_PinSource4)  || \
+                                       ((PINSOURCE) == EXTI_PinSource5)  || \
+                                       ((PINSOURCE) == EXTI_PinSource6)  || \
+                                       ((PINSOURCE) == EXTI_PinSource7)  || \
+                                       ((PINSOURCE) == EXTI_PinSource8)  || \
+                                       ((PINSOURCE) == EXTI_PinSource9)  || \
+                                       ((PINSOURCE) == EXTI_PinSource10) || \
+                                       ((PINSOURCE) == EXTI_PinSource11) || \
+                                       ((PINSOURCE) == EXTI_PinSource12) || \
+                                       ((PINSOURCE) == EXTI_PinSource13) || \
+                                       ((PINSOURCE) == EXTI_PinSource14) || \
+                                       ((PINSOURCE) == EXTI_PinSource15))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup SYSCFG_Memory_Remap_Config 
+  * @{
+  */ 
+#define SYSCFG_MemoryRemap_Flash       ((uint8_t)0x00)
+#define SYSCFG_MemoryRemap_SystemFlash ((uint8_t)0x01)
+#define SYSCFG_MemoryRemap_SRAM        ((uint8_t)0x03)
+#define SYSCFG_MemoryRemap_SDRAM       ((uint8_t)0x04)
+
+#if defined (STM32F40_41xxx)
+#define SYSCFG_MemoryRemap_FSMC        ((uint8_t)0x02) 
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define SYSCFG_MemoryRemap_FMC         ((uint8_t)0x02) 
+#endif /* STM32F427_437xx ||  STM32F429_439xx */  
+
+#if defined (STM32F40_41xxx) 
+#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
+                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
+                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM)        || \
+                                               ((REMAP) == SYSCFG_MemoryRemap_FSMC))
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F401xx) || defined (STM32F411xE)
+#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
+                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
+                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM))
+#endif /* STM32F401xx || STM32F411xE */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
+                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
+                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM)        || \
+                                               ((REMAP) == SYSCFG_MemoryRemap_SDRAM)       || \
+                                               ((REMAP) == SYSCFG_MemoryRemap_FMC))
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+                                                                                              
+/**
+  * @}
+  */ 
+
+
+/** @defgroup SYSCFG_ETHERNET_Media_Interface 
+  * @{
+  */ 
+#define SYSCFG_ETH_MediaInterface_MII    ((uint32_t)0x00000000)
+#define SYSCFG_ETH_MediaInterface_RMII   ((uint32_t)0x00000001)
+
+#define IS_SYSCFG_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == SYSCFG_ETH_MediaInterface_MII) || \
+                                                 ((INTERFACE) == SYSCFG_ETH_MediaInterface_RMII))
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+ 
+void SYSCFG_DeInit(void);
+void       SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap);
+void       SYSCFG_MemorySwappingBank(FunctionalState NewState);
+void       SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex);
+void       SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface); 
+void       SYSCFG_CompensationCellCmd(FunctionalState NewState); 
+FlagStatus SYSCFG_GetCompensationCellStatus(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_SYSCFG_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h
new file mode 100644
index 0000000..adc8140
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h
@@ -0,0 +1,1150 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_tim.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the TIM firmware 
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_TIM_H
+#define __STM32F4xx_TIM_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup TIM
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+
+/** 
+  * @brief  TIM Time Base Init structure definition  
+  * @note   This structure is used with all TIMx except for TIM6 and TIM7.  
+  */
+
+typedef struct
+{
+  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
+                                       This parameter can be a number between 0x0000 and 0xFFFF */
+
+  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.
+                                       This parameter can be a value of @ref TIM_Counter_Mode */
+
+  uint32_t TIM_Period;            /*!< Specifies the period value to be loaded into the active
+                                       Auto-Reload Register at the next update event.
+                                       This parameter must be a number between 0x0000 and 0xFFFF.  */ 
+
+  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.
+                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
+
+  uint8_t TIM_RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
+                                       reaches zero, an update event is generated and counting restarts
+                                       from the RCR value (N).
+                                       This means in PWM mode that (N+1) corresponds to:
+                                          - the number of PWM periods in edge-aligned mode
+                                          - the number of half PWM period in center-aligned mode
+                                       This parameter must be a number between 0x00 and 0xFF. 
+                                       @note This parameter is valid only for TIM1 and TIM8. */
+} TIM_TimeBaseInitTypeDef; 
+
+/** 
+  * @brief  TIM Output Compare Init structure definition  
+  */
+
+typedef struct
+{
+  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.
+                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
+
+  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_State */
+
+  uint16_t TIM_OutputNState;  /*!< Specifies the TIM complementary Output Compare state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_N_State
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+
+  uint32_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
+                                   This parameter can be a number between 0x0000 and 0xFFFF */
+
+  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.
+                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
+
+  uint16_t TIM_OCNPolarity;   /*!< Specifies the complementary output polarity.
+                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+
+  uint16_t TIM_OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+
+  uint16_t TIM_OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+} TIM_OCInitTypeDef;
+
+/** 
+  * @brief  TIM Input Capture Init structure definition  
+  */
+
+typedef struct
+{
+
+  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.
+                                  This parameter can be a value of @ref TIM_Channel */
+
+  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.
+                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
+
+  uint16_t TIM_ICSelection;  /*!< Specifies the input.
+                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
+
+  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
+                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
+
+  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.
+                                  This parameter can be a number between 0x0 and 0xF */
+} TIM_ICInitTypeDef;
+
+/** 
+  * @brief  BDTR structure definition 
+  * @note   This structure is used only with TIM1 and TIM8.    
+  */
+
+typedef struct
+{
+
+  uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.
+                                      This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state */
+
+  uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.
+                                      This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state */
+
+  uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.
+                                      This parameter can be a value of @ref TIM_Lock_level */ 
+
+  uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the
+                                      switching-on of the outputs.
+                                      This parameter can be a number between 0x00 and 0xFF  */
+
+  uint16_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not. 
+                                      This parameter can be a value of @ref TIM_Break_Input_enable_disable */
+
+  uint16_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.
+                                      This parameter can be a value of @ref TIM_Break_Polarity */
+
+  uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not. 
+                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
+} TIM_BDTRInitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup TIM_Exported_constants 
+  * @{
+  */
+
+#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                   ((PERIPH) == TIM2) || \
+                                   ((PERIPH) == TIM3) || \
+                                   ((PERIPH) == TIM4) || \
+                                   ((PERIPH) == TIM5) || \
+                                   ((PERIPH) == TIM6) || \
+                                   ((PERIPH) == TIM7) || \
+                                   ((PERIPH) == TIM8) || \
+                                   ((PERIPH) == TIM9) || \
+                                   ((PERIPH) == TIM10) || \
+                                   ((PERIPH) == TIM11) || \
+                                   ((PERIPH) == TIM12) || \
+                                   (((PERIPH) == TIM13) || \
+                                   ((PERIPH) == TIM14)))
+/* LIST1: TIM1, TIM2, TIM3, TIM4, TIM5, TIM8, TIM9, TIM10, TIM11, TIM12, TIM13 and TIM14 */                                         
+#define IS_TIM_LIST1_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                     ((PERIPH) == TIM2) || \
+                                     ((PERIPH) == TIM3) || \
+                                     ((PERIPH) == TIM4) || \
+                                     ((PERIPH) == TIM5) || \
+                                     ((PERIPH) == TIM8) || \
+                                     ((PERIPH) == TIM9) || \
+                                     ((PERIPH) == TIM10) || \
+                                     ((PERIPH) == TIM11) || \
+                                     ((PERIPH) == TIM12) || \
+                                     ((PERIPH) == TIM13) || \
+                                     ((PERIPH) == TIM14))
+                                     
+/* LIST2: TIM1, TIM2, TIM3, TIM4, TIM5, TIM8, TIM9 and TIM12 */
+#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                     ((PERIPH) == TIM2) || \
+                                     ((PERIPH) == TIM3) || \
+                                     ((PERIPH) == TIM4) || \
+                                     ((PERIPH) == TIM5) || \
+                                     ((PERIPH) == TIM8) || \
+                                     ((PERIPH) == TIM9) || \
+                                     ((PERIPH) == TIM12))
+/* LIST3: TIM1, TIM2, TIM3, TIM4, TIM5 and TIM8 */
+#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                     ((PERIPH) == TIM2) || \
+                                     ((PERIPH) == TIM3) || \
+                                     ((PERIPH) == TIM4) || \
+                                     ((PERIPH) == TIM5) || \
+                                     ((PERIPH) == TIM8))
+/* LIST4: TIM1 and TIM8 */
+#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                     ((PERIPH) == TIM8))
+/* LIST5: TIM1, TIM2, TIM3, TIM4, TIM5, TIM6, TIM7 and TIM8 */
+#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                     ((PERIPH) == TIM2) || \
+                                     ((PERIPH) == TIM3) || \
+                                     ((PERIPH) == TIM4) || \
+                                     ((PERIPH) == TIM5) || \
+                                     ((PERIPH) == TIM6) || \
+                                     ((PERIPH) == TIM7) || \
+                                     ((PERIPH) == TIM8))
+/* LIST6: TIM2, TIM5 and TIM11 */                               
+#define IS_TIM_LIST6_PERIPH(TIMx)(((TIMx) == TIM2) || \
+                                 ((TIMx) == TIM5) || \
+                                 ((TIMx) == TIM11))
+
+/** @defgroup TIM_Output_Compare_and_PWM_modes 
+  * @{
+  */
+
+#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
+#define TIM_OCMode_Active                  ((uint16_t)0x0010)
+#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
+#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
+#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
+#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
+#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
+                              ((MODE) == TIM_OCMode_Active) || \
+                              ((MODE) == TIM_OCMode_Inactive) || \
+                              ((MODE) == TIM_OCMode_Toggle)|| \
+                              ((MODE) == TIM_OCMode_PWM1) || \
+                              ((MODE) == TIM_OCMode_PWM2))
+#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
+                          ((MODE) == TIM_OCMode_Active) || \
+                          ((MODE) == TIM_OCMode_Inactive) || \
+                          ((MODE) == TIM_OCMode_Toggle)|| \
+                          ((MODE) == TIM_OCMode_PWM1) || \
+                          ((MODE) == TIM_OCMode_PWM2) ||	\
+                          ((MODE) == TIM_ForcedAction_Active) || \
+                          ((MODE) == TIM_ForcedAction_InActive))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_One_Pulse_Mode 
+  * @{
+  */
+
+#define TIM_OPMode_Single                  ((uint16_t)0x0008)
+#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
+#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
+                               ((MODE) == TIM_OPMode_Repetitive))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Channel 
+  * @{
+  */
+
+#define TIM_Channel_1                      ((uint16_t)0x0000)
+#define TIM_Channel_2                      ((uint16_t)0x0004)
+#define TIM_Channel_3                      ((uint16_t)0x0008)
+#define TIM_Channel_4                      ((uint16_t)0x000C)
+                                 
+#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
+                                 ((CHANNEL) == TIM_Channel_2) || \
+                                 ((CHANNEL) == TIM_Channel_3) || \
+                                 ((CHANNEL) == TIM_Channel_4))
+                                 
+#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
+                                      ((CHANNEL) == TIM_Channel_2))
+#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
+                                               ((CHANNEL) == TIM_Channel_2) || \
+                                               ((CHANNEL) == TIM_Channel_3))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Clock_Division_CKD 
+  * @{
+  */
+
+#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
+#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
+#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
+#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
+                             ((DIV) == TIM_CKD_DIV2) || \
+                             ((DIV) == TIM_CKD_DIV4))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Counter_Mode 
+  * @{
+  */
+
+#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
+#define TIM_CounterMode_Down               ((uint16_t)0x0010)
+#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
+#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
+#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
+#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
+                                   ((MODE) == TIM_CounterMode_Down) || \
+                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
+                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
+                                   ((MODE) == TIM_CounterMode_CenterAligned3))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Output_Compare_Polarity 
+  * @{
+  */
+
+#define TIM_OCPolarity_High                ((uint16_t)0x0000)
+#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
+#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
+                                      ((POLARITY) == TIM_OCPolarity_Low))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_N_Polarity 
+  * @{
+  */
+  
+#define TIM_OCNPolarity_High               ((uint16_t)0x0000)
+#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)
+#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
+                                       ((POLARITY) == TIM_OCNPolarity_Low))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_State 
+  * @{
+  */
+
+#define TIM_OutputState_Disable            ((uint16_t)0x0000)
+#define TIM_OutputState_Enable             ((uint16_t)0x0001)
+#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
+                                    ((STATE) == TIM_OutputState_Enable))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Output_Compare_N_State
+  * @{
+  */
+
+#define TIM_OutputNState_Disable           ((uint16_t)0x0000)
+#define TIM_OutputNState_Enable            ((uint16_t)0x0004)
+#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
+                                     ((STATE) == TIM_OutputNState_Enable))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Capture_Compare_State
+  * @{
+  */
+
+#define TIM_CCx_Enable                      ((uint16_t)0x0001)
+#define TIM_CCx_Disable                     ((uint16_t)0x0000)
+#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
+                         ((CCX) == TIM_CCx_Disable))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Capture_Compare_N_State
+  * @{
+  */
+
+#define TIM_CCxN_Enable                     ((uint16_t)0x0004)
+#define TIM_CCxN_Disable                    ((uint16_t)0x0000)
+#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
+                           ((CCXN) == TIM_CCxN_Disable))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Break_Input_enable_disable 
+  * @{
+  */
+
+#define TIM_Break_Enable                   ((uint16_t)0x1000)
+#define TIM_Break_Disable                  ((uint16_t)0x0000)
+#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
+                                   ((STATE) == TIM_Break_Disable))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Break_Polarity 
+  * @{
+  */
+
+#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)
+#define TIM_BreakPolarity_High             ((uint16_t)0x2000)
+#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
+                                         ((POLARITY) == TIM_BreakPolarity_High))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_AOE_Bit_Set_Reset 
+  * @{
+  */
+
+#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)
+#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)
+#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
+                                              ((STATE) == TIM_AutomaticOutput_Disable))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Lock_level
+  * @{
+  */
+
+#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)
+#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)
+#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)
+#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)
+#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
+                                  ((LEVEL) == TIM_LOCKLevel_1) || \
+                                  ((LEVEL) == TIM_LOCKLevel_2) || \
+                                  ((LEVEL) == TIM_LOCKLevel_3))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_OSSI_Off_State_Selection_for_Idle_mode_state 
+  * @{
+  */
+
+#define TIM_OSSIState_Enable               ((uint16_t)0x0400)
+#define TIM_OSSIState_Disable              ((uint16_t)0x0000)
+#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
+                                  ((STATE) == TIM_OSSIState_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_OSSR_Off_State_Selection_for_Run_mode_state
+  * @{
+  */
+
+#define TIM_OSSRState_Enable               ((uint16_t)0x0800)
+#define TIM_OSSRState_Disable              ((uint16_t)0x0000)
+#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
+                                  ((STATE) == TIM_OSSRState_Disable))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Output_Compare_Idle_State 
+  * @{
+  */
+
+#define TIM_OCIdleState_Set                ((uint16_t)0x0100)
+#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)
+#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
+                                    ((STATE) == TIM_OCIdleState_Reset))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Output_Compare_N_Idle_State 
+  * @{
+  */
+
+#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)
+#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)
+#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
+                                     ((STATE) == TIM_OCNIdleState_Reset))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Input_Capture_Polarity 
+  * @{
+  */
+
+#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
+#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
+#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)
+#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
+                                      ((POLARITY) == TIM_ICPolarity_Falling)|| \
+                                      ((POLARITY) == TIM_ICPolarity_BothEdge))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Input_Capture_Selection 
+  * @{
+  */
+
+#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be 
+                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
+#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
+                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
+#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
+#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
+                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
+                                        ((SELECTION) == TIM_ICSelection_TRC))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Input_Capture_Prescaler 
+  * @{
+  */
+
+#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */
+#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */
+#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */
+#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */
+#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
+                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
+                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
+                                        ((PRESCALER) == TIM_ICPSC_DIV8))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_interrupt_sources 
+  * @{
+  */
+
+#define TIM_IT_Update                      ((uint16_t)0x0001)
+#define TIM_IT_CC1                         ((uint16_t)0x0002)
+#define TIM_IT_CC2                         ((uint16_t)0x0004)
+#define TIM_IT_CC3                         ((uint16_t)0x0008)
+#define TIM_IT_CC4                         ((uint16_t)0x0010)
+#define TIM_IT_COM                         ((uint16_t)0x0020)
+#define TIM_IT_Trigger                     ((uint16_t)0x0040)
+#define TIM_IT_Break                       ((uint16_t)0x0080)
+#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFF00) == 0x0000) && ((IT) != 0x0000))
+
+#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
+                           ((IT) == TIM_IT_CC1) || \
+                           ((IT) == TIM_IT_CC2) || \
+                           ((IT) == TIM_IT_CC3) || \
+                           ((IT) == TIM_IT_CC4) || \
+                           ((IT) == TIM_IT_COM) || \
+                           ((IT) == TIM_IT_Trigger) || \
+                           ((IT) == TIM_IT_Break))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_DMA_Base_address 
+  * @{
+  */
+
+#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
+#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
+#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
+#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
+#define TIM_DMABase_SR                     ((uint16_t)0x0004)
+#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
+#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
+#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
+#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
+#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
+#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
+#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
+#define TIM_DMABase_RCR                    ((uint16_t)0x000C)
+#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
+#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
+#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
+#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
+#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)
+#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
+#define TIM_DMABase_OR                     ((uint16_t)0x0013)
+#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
+                               ((BASE) == TIM_DMABase_CR2) || \
+                               ((BASE) == TIM_DMABase_SMCR) || \
+                               ((BASE) == TIM_DMABase_DIER) || \
+                               ((BASE) == TIM_DMABase_SR) || \
+                               ((BASE) == TIM_DMABase_EGR) || \
+                               ((BASE) == TIM_DMABase_CCMR1) || \
+                               ((BASE) == TIM_DMABase_CCMR2) || \
+                               ((BASE) == TIM_DMABase_CCER) || \
+                               ((BASE) == TIM_DMABase_CNT) || \
+                               ((BASE) == TIM_DMABase_PSC) || \
+                               ((BASE) == TIM_DMABase_ARR) || \
+                               ((BASE) == TIM_DMABase_RCR) || \
+                               ((BASE) == TIM_DMABase_CCR1) || \
+                               ((BASE) == TIM_DMABase_CCR2) || \
+                               ((BASE) == TIM_DMABase_CCR3) || \
+                               ((BASE) == TIM_DMABase_CCR4) || \
+                               ((BASE) == TIM_DMABase_BDTR) || \
+                               ((BASE) == TIM_DMABase_DCR) || \
+                               ((BASE) == TIM_DMABase_OR))                     
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_DMA_Burst_Length 
+  * @{
+  */
+
+#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)
+#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)
+#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)
+#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)
+#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)
+#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)
+#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)
+#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)
+#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)
+#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)
+#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)
+#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)
+#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)
+#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)
+#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)
+#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)
+#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)
+#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)
+#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \
+                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_DMA_sources 
+  * @{
+  */
+
+#define TIM_DMA_Update                     ((uint16_t)0x0100)
+#define TIM_DMA_CC1                        ((uint16_t)0x0200)
+#define TIM_DMA_CC2                        ((uint16_t)0x0400)
+#define TIM_DMA_CC3                        ((uint16_t)0x0800)
+#define TIM_DMA_CC4                        ((uint16_t)0x1000)
+#define TIM_DMA_COM                        ((uint16_t)0x2000)
+#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
+#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_External_Trigger_Prescaler 
+  * @{
+  */
+
+#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
+#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
+#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
+#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
+#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
+                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
+                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
+                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Internal_Trigger_Selection 
+  * @{
+  */
+
+#define TIM_TS_ITR0                        ((uint16_t)0x0000)
+#define TIM_TS_ITR1                        ((uint16_t)0x0010)
+#define TIM_TS_ITR2                        ((uint16_t)0x0020)
+#define TIM_TS_ITR3                        ((uint16_t)0x0030)
+#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
+#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
+#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
+#define TIM_TS_ETRF                        ((uint16_t)0x0070)
+#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
+                                             ((SELECTION) == TIM_TS_ITR1) || \
+                                             ((SELECTION) == TIM_TS_ITR2) || \
+                                             ((SELECTION) == TIM_TS_ITR3) || \
+                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
+                                             ((SELECTION) == TIM_TS_TI1FP1) || \
+                                             ((SELECTION) == TIM_TS_TI2FP2) || \
+                                             ((SELECTION) == TIM_TS_ETRF))
+#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
+                                                      ((SELECTION) == TIM_TS_ITR1) || \
+                                                      ((SELECTION) == TIM_TS_ITR2) || \
+                                                      ((SELECTION) == TIM_TS_ITR3))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_TIx_External_Clock_Source 
+  * @{
+  */
+
+#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
+#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
+#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
+
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_External_Trigger_Polarity 
+  * @{
+  */ 
+#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
+#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
+#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
+                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Prescaler_Reload_Mode 
+  * @{
+  */
+
+#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
+#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
+#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
+                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Forced_Action 
+  * @{
+  */
+
+#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
+#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
+#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
+                                      ((ACTION) == TIM_ForcedAction_InActive))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Encoder_Mode 
+  * @{
+  */
+
+#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
+#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
+#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
+#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
+                                   ((MODE) == TIM_EncoderMode_TI2) || \
+                                   ((MODE) == TIM_EncoderMode_TI12))
+/**
+  * @}
+  */ 
+
+
+/** @defgroup TIM_Event_Source 
+  * @{
+  */
+
+#define TIM_EventSource_Update             ((uint16_t)0x0001)
+#define TIM_EventSource_CC1                ((uint16_t)0x0002)
+#define TIM_EventSource_CC2                ((uint16_t)0x0004)
+#define TIM_EventSource_CC3                ((uint16_t)0x0008)
+#define TIM_EventSource_CC4                ((uint16_t)0x0010)
+#define TIM_EventSource_COM                ((uint16_t)0x0020)
+#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
+#define TIM_EventSource_Break              ((uint16_t)0x0080)
+#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))                                          
+  
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Update_Source 
+  * @{
+  */
+
+#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow
+                                                                   or the setting of UG bit, or an update generation
+                                                                   through the slave mode controller. */
+#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */
+#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
+                                      ((SOURCE) == TIM_UpdateSource_Regular))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Output_Compare_Preload_State 
+  * @{
+  */
+
+#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
+#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
+#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
+                                       ((STATE) == TIM_OCPreload_Disable))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Output_Compare_Fast_State 
+  * @{
+  */
+
+#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
+#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
+#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
+                                    ((STATE) == TIM_OCFast_Disable))
+                                     
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Output_Compare_Clear_State 
+  * @{
+  */
+
+#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
+#define TIM_OCClear_Disable                ((uint16_t)0x0000)
+#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
+                                     ((STATE) == TIM_OCClear_Disable))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Trigger_Output_Source 
+  * @{
+  */
+
+#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
+#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
+#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
+#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
+#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
+#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
+#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
+#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
+#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
+                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
+                                    ((SOURCE) == TIM_TRGOSource_Update) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Slave_Mode 
+  * @{
+  */
+
+#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
+#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
+#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
+#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
+#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
+                                 ((MODE) == TIM_SlaveMode_Gated) || \
+                                 ((MODE) == TIM_SlaveMode_Trigger) || \
+                                 ((MODE) == TIM_SlaveMode_External1))
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Master_Slave_Mode 
+  * @{
+  */
+
+#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
+#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
+#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
+                                 ((STATE) == TIM_MasterSlaveMode_Disable))
+/**
+  * @}
+  */ 
+/** @defgroup TIM_Remap 
+  * @{
+  */
+
+#define TIM2_TIM8_TRGO                     ((uint16_t)0x0000)
+#define TIM2_ETH_PTP                       ((uint16_t)0x0400)
+#define TIM2_USBFS_SOF                     ((uint16_t)0x0800)
+#define TIM2_USBHS_SOF                     ((uint16_t)0x0C00)
+
+#define TIM5_GPIO                          ((uint16_t)0x0000)
+#define TIM5_LSI                           ((uint16_t)0x0040)
+#define TIM5_LSE                           ((uint16_t)0x0080)
+#define TIM5_RTC                           ((uint16_t)0x00C0)
+
+#define TIM11_GPIO                         ((uint16_t)0x0000)
+#define TIM11_HSE                          ((uint16_t)0x0002)
+
+#define IS_TIM_REMAP(TIM_REMAP)	 (((TIM_REMAP) == TIM2_TIM8_TRGO)||\
+                                  ((TIM_REMAP) == TIM2_ETH_PTP)||\
+                                  ((TIM_REMAP) == TIM2_USBFS_SOF)||\
+                                  ((TIM_REMAP) == TIM2_USBHS_SOF)||\
+                                  ((TIM_REMAP) == TIM5_GPIO)||\
+                                  ((TIM_REMAP) == TIM5_LSI)||\
+                                  ((TIM_REMAP) == TIM5_LSE)||\
+                                  ((TIM_REMAP) == TIM5_RTC)||\
+                                  ((TIM_REMAP) == TIM11_GPIO)||\
+                                  ((TIM_REMAP) == TIM11_HSE))
+
+/**
+  * @}
+  */ 
+/** @defgroup TIM_Flags 
+  * @{
+  */
+
+#define TIM_FLAG_Update                    ((uint16_t)0x0001)
+#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
+#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
+#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
+#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
+#define TIM_FLAG_COM                       ((uint16_t)0x0020)
+#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
+#define TIM_FLAG_Break                     ((uint16_t)0x0080)
+#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
+#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
+#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
+#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
+#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
+                               ((FLAG) == TIM_FLAG_CC1) || \
+                               ((FLAG) == TIM_FLAG_CC2) || \
+                               ((FLAG) == TIM_FLAG_CC3) || \
+                               ((FLAG) == TIM_FLAG_CC4) || \
+                               ((FLAG) == TIM_FLAG_COM) || \
+                               ((FLAG) == TIM_FLAG_Trigger) || \
+                               ((FLAG) == TIM_FLAG_Break) || \
+                               ((FLAG) == TIM_FLAG_CC1OF) || \
+                               ((FLAG) == TIM_FLAG_CC2OF) || \
+                               ((FLAG) == TIM_FLAG_CC3OF) || \
+                               ((FLAG) == TIM_FLAG_CC4OF))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Input_Capture_Filer_Value 
+  * @{
+  */
+
+#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_External_Trigger_Filter 
+  * @{
+  */
+
+#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)
+/**
+  * @}
+  */ 
+
+/** @defgroup TIM_Legacy 
+  * @{
+  */
+
+#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer
+#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers
+#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers
+#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers
+#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers
+#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers
+#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers
+#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers
+#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers
+#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers
+#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers
+#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers
+#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers
+#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers
+#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers
+#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers
+#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers
+#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/ 
+
+/* TimeBase management ********************************************************/
+void TIM_DeInit(TIM_TypeDef* TIMx);
+void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
+void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
+void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
+void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
+void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter);
+void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload);
+uint32_t TIM_GetCounter(TIM_TypeDef* TIMx);
+uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
+void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
+void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
+void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
+void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
+
+/* Output Compare management **************************************************/
+void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
+void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1);
+void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2);
+void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3);
+void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4);
+void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
+void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
+void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
+void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
+void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);
+
+/* Input Capture management ***************************************************/
+void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
+void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
+void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
+uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx);
+uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx);
+uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx);
+uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx);
+void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+
+/* Advanced-control timers (TIM1 and TIM8) specific features ******************/
+void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
+void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
+void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
+
+/* Interrupts, DMA and flags management ***************************************/
+void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
+void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
+FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
+void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
+ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
+void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
+void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
+void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
+void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
+
+/* Clocks management **********************************************************/
+void TIM_InternalClockConfig(TIM_TypeDef* TIMx);
+void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
+void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
+                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
+void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                             uint16_t ExtTRGFilter);
+void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
+                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
+
+/* Synchronization management *************************************************/
+void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
+void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
+void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
+void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
+void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                   uint16_t ExtTRGFilter);
+
+/* Specific interface management **********************************************/   
+void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
+                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
+void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
+
+/* Specific remapping management **********************************************/
+void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F4xx_TIM_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_usart.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_usart.h
new file mode 100644
index 0000000..9fb3bf7
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_usart.h
@@ -0,0 +1,431 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_usart.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the USART 
+  *          firmware library.    
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_USART_H
+#define __STM32F4xx_USART_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup USART
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/ 
+
+/** 
+  * @brief  USART Init Structure definition  
+  */ 
+  
+typedef struct
+{
+  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.
+                                           The baud rate is computed using the following formula:
+                                            - IntegerDivider = ((PCLKx) / (8 * (OVR8+1) * (USART_InitStruct->USART_BaudRate)))
+                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 8 * (OVR8+1)) + 0.5 
+                                           Where OVR8 is the "oversampling by 8 mode" configuration bit in the CR1 register. */
+
+  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
+                                           This parameter can be a value of @ref USART_Word_Length */
+
+  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
+                                           This parameter can be a value of @ref USART_Stop_Bits */
+
+  uint16_t USART_Parity;              /*!< Specifies the parity mode.
+                                           This parameter can be a value of @ref USART_Parity
+                                           @note When parity is enabled, the computed parity is inserted
+                                                 at the MSB position of the transmitted data (9th bit when
+                                                 the word length is set to 9 data bits; 8th bit when the
+                                                 word length is set to 8 data bits). */
+ 
+  uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.
+                                           This parameter can be a value of @ref USART_Mode */
+
+  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled
+                                           or disabled.
+                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */
+} USART_InitTypeDef;
+
+/** 
+  * @brief  USART Clock Init Structure definition  
+  */ 
+  
+typedef struct
+{
+
+  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
+                               This parameter can be a value of @ref USART_Clock */
+
+  uint16_t USART_CPOL;    /*!< Specifies the steady state of the serial clock.
+                               This parameter can be a value of @ref USART_Clock_Polarity */
+
+  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
+                               This parameter can be a value of @ref USART_Clock_Phase */
+
+  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted
+                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.
+                               This parameter can be a value of @ref USART_Last_Bit */
+} USART_ClockInitTypeDef;
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup USART_Exported_Constants
+  * @{
+  */ 
+  
+#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
+                                     ((PERIPH) == USART2) || \
+                                     ((PERIPH) == USART3) || \
+                                     ((PERIPH) == UART4)  || \
+                                     ((PERIPH) == UART5)  || \
+                                     ((PERIPH) == USART6) || \
+                                     ((PERIPH) == UART7)  || \
+                                     ((PERIPH) == UART8))
+
+#define IS_USART_1236_PERIPH(PERIPH) (((PERIPH) == USART1) || \
+                                      ((PERIPH) == USART2) || \
+                                      ((PERIPH) == USART3) || \
+                                      ((PERIPH) == USART6))
+
+/** @defgroup USART_Word_Length 
+  * @{
+  */ 
+  
+#define USART_WordLength_8b                  ((uint16_t)0x0000)
+#define USART_WordLength_9b                  ((uint16_t)0x1000)
+                                    
+#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
+                                      ((LENGTH) == USART_WordLength_9b))
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Stop_Bits 
+  * @{
+  */ 
+  
+#define USART_StopBits_1                     ((uint16_t)0x0000)
+#define USART_StopBits_0_5                   ((uint16_t)0x1000)
+#define USART_StopBits_2                     ((uint16_t)0x2000)
+#define USART_StopBits_1_5                   ((uint16_t)0x3000)
+#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
+                                     ((STOPBITS) == USART_StopBits_0_5) || \
+                                     ((STOPBITS) == USART_StopBits_2) || \
+                                     ((STOPBITS) == USART_StopBits_1_5))
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Parity 
+  * @{
+  */ 
+  
+#define USART_Parity_No                      ((uint16_t)0x0000)
+#define USART_Parity_Even                    ((uint16_t)0x0400)
+#define USART_Parity_Odd                     ((uint16_t)0x0600) 
+#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
+                                 ((PARITY) == USART_Parity_Even) || \
+                                 ((PARITY) == USART_Parity_Odd))
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Mode 
+  * @{
+  */ 
+  
+#define USART_Mode_Rx                        ((uint16_t)0x0004)
+#define USART_Mode_Tx                        ((uint16_t)0x0008)
+#define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Hardware_Flow_Control 
+  * @{
+  */ 
+#define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
+#define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
+#define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
+#define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
+#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
+                              (((CONTROL) == USART_HardwareFlowControl_None) || \
+                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
+                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
+                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Clock 
+  * @{
+  */ 
+#define USART_Clock_Disable                  ((uint16_t)0x0000)
+#define USART_Clock_Enable                   ((uint16_t)0x0800)
+#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
+                               ((CLOCK) == USART_Clock_Enable))
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Clock_Polarity 
+  * @{
+  */
+  
+#define USART_CPOL_Low                       ((uint16_t)0x0000)
+#define USART_CPOL_High                      ((uint16_t)0x0400)
+#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Clock_Phase
+  * @{
+  */
+
+#define USART_CPHA_1Edge                     ((uint16_t)0x0000)
+#define USART_CPHA_2Edge                     ((uint16_t)0x0200)
+#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Last_Bit
+  * @{
+  */
+
+#define USART_LastBit_Disable                ((uint16_t)0x0000)
+#define USART_LastBit_Enable                 ((uint16_t)0x0100)
+#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
+                                   ((LASTBIT) == USART_LastBit_Enable))
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Interrupt_definition 
+  * @{
+  */
+  
+#define USART_IT_PE                          ((uint16_t)0x0028)
+#define USART_IT_TXE                         ((uint16_t)0x0727)
+#define USART_IT_TC                          ((uint16_t)0x0626)
+#define USART_IT_RXNE                        ((uint16_t)0x0525)
+#define USART_IT_ORE_RX                      ((uint16_t)0x0325) /* In case interrupt is generated if the RXNEIE bit is set */
+#define USART_IT_IDLE                        ((uint16_t)0x0424)
+#define USART_IT_LBD                         ((uint16_t)0x0846)
+#define USART_IT_CTS                         ((uint16_t)0x096A)
+#define USART_IT_ERR                         ((uint16_t)0x0060)
+#define USART_IT_ORE_ER                      ((uint16_t)0x0360) /* In case interrupt is generated if the EIE bit is set */
+#define USART_IT_NE                          ((uint16_t)0x0260)
+#define USART_IT_FE                          ((uint16_t)0x0160)
+
+/** @defgroup USART_Legacy 
+  * @{
+  */
+#define USART_IT_ORE                          USART_IT_ORE_ER               
+/**
+  * @}
+  */
+
+#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
+                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
+                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
+                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
+#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
+                             ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
+                             ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
+                             ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
+                             ((IT) == USART_IT_ORE_RX) || ((IT) == USART_IT_ORE_ER) || \
+                             ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
+#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
+                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
+/**
+  * @}
+  */
+
+/** @defgroup USART_DMA_Requests 
+  * @{
+  */
+
+#define USART_DMAReq_Tx                      ((uint16_t)0x0080)
+#define USART_DMAReq_Rx                      ((uint16_t)0x0040)
+#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFF3F) == 0x00) && ((DMAREQ) != (uint16_t)0x00))
+
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_WakeUp_methods
+  * @{
+  */
+
+#define USART_WakeUp_IdleLine                ((uint16_t)0x0000)
+#define USART_WakeUp_AddressMark             ((uint16_t)0x0800)
+#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
+                                 ((WAKEUP) == USART_WakeUp_AddressMark))
+/**
+  * @}
+  */
+
+/** @defgroup USART_LIN_Break_Detection_Length 
+  * @{
+  */
+  
+#define USART_LINBreakDetectLength_10b      ((uint16_t)0x0000)
+#define USART_LINBreakDetectLength_11b      ((uint16_t)0x0020)
+#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
+                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
+                                ((LENGTH) == USART_LINBreakDetectLength_11b))
+/**
+  * @}
+  */
+
+/** @defgroup USART_IrDA_Low_Power 
+  * @{
+  */
+
+#define USART_IrDAMode_LowPower              ((uint16_t)0x0004)
+#define USART_IrDAMode_Normal                ((uint16_t)0x0000)
+#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
+                                  ((MODE) == USART_IrDAMode_Normal))
+/**
+  * @}
+  */ 
+
+/** @defgroup USART_Flags 
+  * @{
+  */
+
+#define USART_FLAG_CTS                       ((uint16_t)0x0200)
+#define USART_FLAG_LBD                       ((uint16_t)0x0100)
+#define USART_FLAG_TXE                       ((uint16_t)0x0080)
+#define USART_FLAG_TC                        ((uint16_t)0x0040)
+#define USART_FLAG_RXNE                      ((uint16_t)0x0020)
+#define USART_FLAG_IDLE                      ((uint16_t)0x0010)
+#define USART_FLAG_ORE                       ((uint16_t)0x0008)
+#define USART_FLAG_NE                        ((uint16_t)0x0004)
+#define USART_FLAG_FE                        ((uint16_t)0x0002)
+#define USART_FLAG_PE                        ((uint16_t)0x0001)
+#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
+                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
+                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
+                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
+                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
+                              
+#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFC9F) == 0x00) && ((FLAG) != (uint16_t)0x00))
+
+#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 7500001))
+#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)
+#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/  
+
+/*  Function used to set the USART configuration to the default reset state ***/ 
+void USART_DeInit(USART_TypeDef* USARTx);
+
+/* Initialization and Configuration functions *********************************/
+void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
+void USART_StructInit(USART_InitTypeDef* USART_InitStruct);
+void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
+void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
+void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);
+void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+
+/* Data transfers functions ***************************************************/ 
+void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
+uint16_t USART_ReceiveData(USART_TypeDef* USARTx);
+
+/* Multi-Processor Communication functions ************************************/
+void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
+void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp);
+void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+
+/* LIN mode functions *********************************************************/
+void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength);
+void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_SendBreak(USART_TypeDef* USARTx);
+
+/* Half-duplex mode function **************************************************/
+void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+
+/* Smartcard mode functions ***************************************************/
+void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);
+
+/* IrDA mode functions ********************************************************/
+void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode);
+void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
+
+/* DMA transfers management functions *****************************************/
+void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
+
+/* Interrupts and flags management functions **********************************/
+void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
+FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
+void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
+ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
+void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_USART_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_wwdg.h b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_wwdg.h
new file mode 100644
index 0000000..552f973
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_wwdg.h
@@ -0,0 +1,111 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_wwdg.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains all the functions prototypes for the WWDG firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_WWDG_H
+#define __STM32F4xx_WWDG_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup WWDG
+  * @{
+  */ 
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup WWDG_Exported_Constants
+  * @{
+  */ 
+  
+/** @defgroup WWDG_Prescaler 
+  * @{
+  */
+  
+#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
+#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
+#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
+#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
+#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
+                                      ((PRESCALER) == WWDG_Prescaler_2) || \
+                                      ((PRESCALER) == WWDG_Prescaler_4) || \
+                                      ((PRESCALER) == WWDG_Prescaler_8))
+#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
+#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+  
+/*  Function used to set the WWDG configuration to the default reset state ****/  
+void WWDG_DeInit(void);
+
+/* Prescaler, Refresh window and Counter configuration functions **************/
+void WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
+void WWDG_SetWindowValue(uint8_t WindowValue);
+void WWDG_EnableIT(void);
+void WWDG_SetCounter(uint8_t Counter);
+
+/* WWDG activation function ***************************************************/
+void WWDG_Enable(uint8_t Counter);
+
+/* Interrupts and flags management functions **********************************/
+FlagStatus WWDG_GetFlagStatus(void);
+void WWDG_ClearFlag(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_WWDG_H */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/misc.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/misc.c
new file mode 100644
index 0000000..af6e3ff
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/misc.c
@@ -0,0 +1,250 @@
+/**
+  ******************************************************************************
+  * @file    misc.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides all the miscellaneous firmware functions (add-on
+  *          to CMSIS functions).
+  *          
+  *  @verbatim   
+  *                               
+  *          ===================================================================      
+  *                        How to configure Interrupts using driver 
+  *          ===================================================================      
+  * 
+  *            This section provide functions allowing to configure the NVIC interrupts (IRQ).
+  *            The Cortex-M4 exceptions are managed by CMSIS functions.
+  *
+  *            1. Configure the NVIC Priority Grouping using NVIC_PriorityGroupConfig()
+  *                function according to the following table.
+ 
+  *  The table below gives the allowed values of the pre-emption priority and subpriority according
+  *  to the Priority Grouping configuration performed by NVIC_PriorityGroupConfig function
+  *    ==========================================================================================================================
+  *      NVIC_PriorityGroup   | NVIC_IRQChannelPreemptionPriority | NVIC_IRQChannelSubPriority  |       Description
+  *    ==========================================================================================================================
+  *     NVIC_PriorityGroup_0  |                0                  |            0-15             | 0 bits for pre-emption priority
+  *                           |                                   |                             | 4 bits for subpriority
+  *    --------------------------------------------------------------------------------------------------------------------------
+  *     NVIC_PriorityGroup_1  |                0-1                |            0-7              | 1 bits for pre-emption priority
+  *                           |                                   |                             | 3 bits for subpriority
+  *    --------------------------------------------------------------------------------------------------------------------------    
+  *     NVIC_PriorityGroup_2  |                0-3                |            0-3              | 2 bits for pre-emption priority
+  *                           |                                   |                             | 2 bits for subpriority
+  *    --------------------------------------------------------------------------------------------------------------------------    
+  *     NVIC_PriorityGroup_3  |                0-7                |            0-1              | 3 bits for pre-emption priority
+  *                           |                                   |                             | 1 bits for subpriority
+  *    --------------------------------------------------------------------------------------------------------------------------    
+  *     NVIC_PriorityGroup_4  |                0-15               |            0                | 4 bits for pre-emption priority
+  *                           |                                   |                             | 0 bits for subpriority                       
+  *    ==========================================================================================================================     
+  *
+  *            2. Enable and Configure the priority of the selected IRQ Channels using NVIC_Init()  
+  *
+  * @note  When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
+  *        The pending IRQ priority will be managed only by the subpriority.
+  *
+  * @note  IRQ priority order (sorted by highest to lowest priority):
+  *         - Lowest pre-emption priority
+  *         - Lowest subpriority
+  *         - Lowest hardware priority (IRQ number)
+  *
+  *  @endverbatim
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "misc.h"
+#include "stm32f4xx_conf.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup MISC 
+  * @brief MISC driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define AIRCR_VECTKEY_MASK    ((uint32_t)0x05FA0000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup MISC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Configures the priority grouping: pre-emption priority and subpriority.
+  * @param  NVIC_PriorityGroup: specifies the priority grouping bits length. 
+  *   This parameter can be one of the following values:
+  *     @arg NVIC_PriorityGroup_0: 0 bits for pre-emption priority
+  *                                4 bits for subpriority
+  *     @arg NVIC_PriorityGroup_1: 1 bits for pre-emption priority
+  *                                3 bits for subpriority
+  *     @arg NVIC_PriorityGroup_2: 2 bits for pre-emption priority
+  *                                2 bits for subpriority
+  *     @arg NVIC_PriorityGroup_3: 3 bits for pre-emption priority
+  *                                1 bits for subpriority
+  *     @arg NVIC_PriorityGroup_4: 4 bits for pre-emption priority
+  *                                0 bits for subpriority
+  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
+  *         The pending IRQ priority will be managed only by the subpriority. 
+  * @retval None
+  */
+void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
+  
+  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
+  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
+}
+
+/**
+  * @brief  Initializes the NVIC peripheral according to the specified
+  *         parameters in the NVIC_InitStruct.
+  * @note   To configure interrupts priority correctly, the NVIC_PriorityGroupConfig()
+  *         function should be called before. 
+  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
+  *         the configuration information for the specified NVIC peripheral.
+  * @retval None
+  */
+void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
+{
+  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
+  
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
+  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
+  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
+    
+  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
+  {
+    /* Compute the Corresponding IRQ Priority --------------------------------*/    
+    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
+    tmppre = (0x4 - tmppriority);
+    tmpsub = tmpsub >> tmppriority;
+
+    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
+    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
+        
+    tmppriority = tmppriority << 0x04;
+        
+    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
+    
+    /* Enable the Selected IRQ Channels --------------------------------------*/
+    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
+      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
+  }
+  else
+  {
+    /* Disable the Selected IRQ Channels -------------------------------------*/
+    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
+      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
+  }
+}
+
+/**
+  * @brief  Sets the vector table location and Offset.
+  * @param  NVIC_VectTab: specifies if the vector table is in RAM or FLASH memory.
+  *   This parameter can be one of the following values:
+  *     @arg NVIC_VectTab_RAM: Vector Table in internal SRAM.
+  *     @arg NVIC_VectTab_FLASH: Vector Table in internal FLASH.
+  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x200.
+  * @retval None
+  */
+void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
+{ 
+  /* Check the parameters */
+  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
+  assert_param(IS_NVIC_OFFSET(Offset));  
+   
+  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
+}
+
+/**
+  * @brief  Selects the condition for the system to enter low power mode.
+  * @param  LowPowerMode: Specifies the new mode for the system to enter low power mode.
+  *   This parameter can be one of the following values:
+  *     @arg NVIC_LP_SEVONPEND: Low Power SEV on Pend.
+  *     @arg NVIC_LP_SLEEPDEEP: Low Power DEEPSLEEP request.
+  *     @arg NVIC_LP_SLEEPONEXIT: Low Power Sleep on Exit.
+  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_LP(LowPowerMode));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));  
+  
+  if (NewState != DISABLE)
+  {
+    SCB->SCR |= LowPowerMode;
+  }
+  else
+  {
+    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
+  }
+}
+
+/**
+  * @brief  Configures the SysTick clock source.
+  * @param  SysTick_CLKSource: specifies the SysTick clock source.
+  *   This parameter can be one of the following values:
+  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
+  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
+  * @retval None
+  */
+void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
+  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
+  {
+    SysTick->CTRL |= SysTick_CLKSource_HCLK;
+  }
+  else
+  {
+    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_adc.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_adc.c
new file mode 100644
index 0000000..187ff33
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_adc.c
@@ -0,0 +1,1745 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_adc.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
+  *           + Initialization and Configuration (in addition to ADC multi mode 
+  *             selection)
+  *           + Analog Watchdog configuration
+  *           + Temperature Sensor & Vrefint (Voltage Reference internal) & VBAT
+  *             management 
+  *           + Regular Channels Configuration
+  *           + Regular Channels DMA Configuration
+  *           + Injected channels Configuration
+  *           + Interrupts and flags management
+  *         
+  @verbatim
+ ===============================================================================
+                     ##### How to use this driver #####
+ ===============================================================================
+    [..]
+    (#) Enable the ADC interface clock using 
+        RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADCx, ENABLE); 
+       
+    (#) ADC pins configuration
+         (++) Enable the clock for the ADC GPIOs using the following function:
+             RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
+         (++) Configure these ADC pins in analog mode using GPIO_Init();  
+  
+     (#) Configure the ADC Prescaler, conversion resolution and data 
+         alignment using the ADC_Init() function.
+     (#) Activate the ADC peripheral using ADC_Cmd() function.
+  
+     *** Regular channels group configuration ***
+     ============================================
+     [..]    
+       (+) To configure the ADC regular channels group features, use 
+           ADC_Init() and ADC_RegularChannelConfig() functions.
+       (+) To activate the continuous mode, use the ADC_continuousModeCmd()
+           function.
+       (+) To configurate and activate the Discontinuous mode, use the 
+           ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.
+       (+) To read the ADC converted values, use the ADC_GetConversionValue()
+           function.
+  
+     *** Multi mode ADCs Regular channels configuration ***
+     ======================================================
+     [..]
+       (+) Refer to "Regular channels group configuration" description to
+           configure the ADC1, ADC2 and ADC3 regular channels.        
+       (+) Select the Multi mode ADC regular channels features (dual or 
+           triple mode) using ADC_CommonInit() function and configure 
+           the DMA mode using ADC_MultiModeDMARequestAfterLastTransferCmd() 
+           functions.        
+       (+) Read the ADCs converted values using the 
+           ADC_GetMultiModeConversionValue() function.
+  
+     *** DMA for Regular channels group features configuration ***
+     ============================================================= 
+     [..]
+       (+) To enable the DMA mode for regular channels group, use the 
+           ADC_DMACmd() function.
+       (+) To enable the generation of DMA requests continuously at the end
+           of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
+           function.
+  
+     *** Injected channels group configuration ***
+     =============================================    
+     [..]
+       (+) To configure the ADC Injected channels group features, use 
+           ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
+           functions.
+       (+) To activate the continuous mode, use the ADC_continuousModeCmd()
+           function.
+       (+) To activate the Injected Discontinuous mode, use the 
+           ADC_InjectedDiscModeCmd() function.  
+       (+) To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
+           function.        
+       (+) To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
+           function.
+  
+    @endverbatim
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_adc.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup ADC 
+  * @brief ADC driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/ 
+
+/* ADC DISCNUM mask */
+#define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
+
+/* ADC AWDCH mask */
+#define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0)   
+
+/* ADC Analog watchdog enable mode mask */
+#define CR1_AWDMode_RESET         ((uint32_t)0xFF3FFDFF)   
+
+/* CR1 register Mask */
+#define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF)
+
+/* ADC EXTEN mask */
+#define CR2_EXTEN_RESET           ((uint32_t)0xCFFFFFFF)  
+
+/* ADC JEXTEN mask */
+#define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)  
+
+/* ADC JEXTSEL mask */
+#define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)  
+
+/* CR2 register Mask */
+#define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
+
+/* ADC SQx mask */
+#define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
+#define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
+#define SQR1_SQ_SET               ((uint32_t)0x0000001F)  
+
+/* ADC L Mask */
+#define SQR1_L_RESET              ((uint32_t)0xFF0FFFFF) 
+
+/* ADC JSQx mask */
+#define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
+
+/* ADC JL mask */
+#define JSQR_JL_SET               ((uint32_t)0x00300000) 
+#define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
+
+/* ADC SMPx mask */
+#define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
+#define SMPR2_SMP_SET             ((uint32_t)0x00000007) 
+
+/* ADC JDRx registers offset */
+#define JDR_OFFSET                ((uint8_t)0x28) 
+
+/* ADC CDR register base address */
+#define CDR_ADDRESS               ((uint32_t)0x40012308)   
+
+/* ADC CCR register Mask */
+#define CR_CLEAR_MASK             ((uint32_t)0xFFFC30E0)  
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup ADC_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup ADC_Group1 Initialization and Configuration functions
+ *  @brief    Initialization and Configuration functions 
+ *
+@verbatim    
+ ===============================================================================
+              ##### Initialization and Configuration functions #####
+ ===============================================================================
+    [..]  This section provides functions allowing to:
+      (+) Initialize and configure the ADC Prescaler
+      (+) ADC Conversion Resolution (12bit..6bit)
+      (+) Scan Conversion Mode (multichannel or one channel) for regular group
+      (+) ADC Continuous Conversion Mode (Continuous or Single conversion) for 
+          regular group
+      (+) External trigger Edge and source of regular group, 
+      (+) Converted data alignment (left or right)
+      (+) The number of ADC conversions that will be done using the sequencer for 
+          regular channel group
+      (+) Multi ADC mode selection
+      (+) Direct memory access mode selection for multi ADC mode  
+      (+) Delay between 2 sampling phases (used in dual or triple interleaved modes)
+      (+) Enable or disable the ADC peripheral   
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes all ADCs peripherals registers to their default reset 
+  *         values.
+  * @param  None
+  * @retval None
+  */
+void ADC_DeInit(void)
+{
+  /* Enable all ADCs reset state */
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
+  
+  /* Release all ADCs from reset state */
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
+}
+
+/**
+  * @brief  Initializes the ADCx peripheral according to the specified parameters 
+  *         in the ADC_InitStruct.
+  * @note   This function is used to configure the global features of the ADC ( 
+  *         Resolution and Data Alignment), however, the rest of the configuration
+  *         parameters are specific to the regular channels group (scan mode 
+  *         activation, continuous mode activation, External trigger source and 
+  *         edge, number of conversion in the regular channels group sequencer).  
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
+  *         the configuration information for the specified ADC peripheral.
+  * @retval None
+  */
+void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
+{
+  uint32_t tmpreg1 = 0;
+  uint8_t tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
+  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
+  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
+  assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
+  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
+  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
+  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
+  
+  /*---------------------------- ADCx CR1 Configuration -----------------*/
+  /* Get the ADCx CR1 value */
+  tmpreg1 = ADCx->CR1;
+  
+  /* Clear RES and SCAN bits */
+  tmpreg1 &= CR1_CLEAR_MASK;
+  
+  /* Configure ADCx: scan conversion mode and resolution */
+  /* Set SCAN bit according to ADC_ScanConvMode value */
+  /* Set RES bit according to ADC_Resolution value */ 
+  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
+                                   ADC_InitStruct->ADC_Resolution);
+  /* Write to ADCx CR1 */
+  ADCx->CR1 = tmpreg1;
+  /*---------------------------- ADCx CR2 Configuration -----------------*/
+  /* Get the ADCx CR2 value */
+  tmpreg1 = ADCx->CR2;
+  
+  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
+  tmpreg1 &= CR2_CLEAR_MASK;
+  
+  /* Configure ADCx: external trigger event and edge, data alignment and 
+     continuous conversion mode */
+  /* Set ALIGN bit according to ADC_DataAlign value */
+  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
+  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
+  /* Set CONT bit according to ADC_ContinuousConvMode value */
+  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
+                        ADC_InitStruct->ADC_ExternalTrigConv | 
+                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
+                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
+                        
+  /* Write to ADCx CR2 */
+  ADCx->CR2 = tmpreg1;
+  /*---------------------------- ADCx SQR1 Configuration -----------------*/
+  /* Get the ADCx SQR1 value */
+  tmpreg1 = ADCx->SQR1;
+  
+  /* Clear L bits */
+  tmpreg1 &= SQR1_L_RESET;
+  
+  /* Configure ADCx: regular channel sequence length */
+  /* Set L bits according to ADC_NbrOfConversion value */
+  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
+  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
+  
+  /* Write to ADCx SQR1 */
+  ADCx->SQR1 = tmpreg1;
+}
+
+/**
+  * @brief  Fills each ADC_InitStruct member with its default value.
+  * @note   This function is used to initialize the global features of the ADC ( 
+  *         Resolution and Data Alignment), however, the rest of the configuration
+  *         parameters are specific to the regular channels group (scan mode 
+  *         activation, continuous mode activation, External trigger source and 
+  *         edge, number of conversion in the regular channels group sequencer).  
+  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
+  *         be initialized.
+  * @retval None
+  */
+void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
+{
+  /* Initialize the ADC_Mode member */
+  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
+
+  /* initialize the ADC_ScanConvMode member */
+  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
+
+  /* Initialize the ADC_ContinuousConvMode member */
+  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
+
+  /* Initialize the ADC_ExternalTrigConvEdge member */
+  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
+
+  /* Initialize the ADC_ExternalTrigConv member */
+  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
+
+  /* Initialize the ADC_DataAlign member */
+  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
+
+  /* Initialize the ADC_NbrOfConversion member */
+  ADC_InitStruct->ADC_NbrOfConversion = 1;
+}
+
+/**
+  * @brief  Initializes the ADCs peripherals according to the specified parameters 
+  *         in the ADC_CommonInitStruct.
+  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
+  *         that contains the configuration information for  All ADCs peripherals.
+  * @retval None
+  */
+void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
+{
+  uint32_t tmpreg1 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
+  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
+  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
+  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
+  /*---------------------------- ADC CCR Configuration -----------------*/
+  /* Get the ADC CCR value */
+  tmpreg1 = ADC->CCR;
+  
+  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
+  tmpreg1 &= CR_CLEAR_MASK;
+  
+  /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
+     and DMA access mode for multimode */
+  /* Set MULTI bits according to ADC_Mode value */
+  /* Set ADCPRE bits according to ADC_Prescaler value */
+  /* Set DMA bits according to ADC_DMAAccessMode value */
+  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
+  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
+                        ADC_CommonInitStruct->ADC_Prescaler | 
+                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
+                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
+                        
+  /* Write to ADC CCR */
+  ADC->CCR = tmpreg1;
+}
+
+/**
+  * @brief  Fills each ADC_CommonInitStruct member with its default value.
+  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
+  *         which will be initialized.
+  * @retval None
+  */
+void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
+{
+  /* Initialize the ADC_Mode member */
+  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
+
+  /* initialize the ADC_Prescaler member */
+  ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
+
+  /* Initialize the ADC_DMAAccessMode member */
+  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
+
+  /* Initialize the ADC_TwoSamplingDelay member */
+  ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
+}
+
+/**
+  * @brief  Enables or disables the specified ADC peripheral.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the ADCx peripheral. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the ADON bit to wake up the ADC from power down mode */
+    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
+  }
+  else
+  {
+    /* Disable the selected ADC peripheral */
+    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Group2 Analog Watchdog configuration functions
+ *  @brief    Analog Watchdog configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+             ##### Analog Watchdog configuration functions #####
+ ===============================================================================  
+    [..] This section provides functions allowing to configure the Analog Watchdog
+         (AWD) feature in the ADC.
+  
+    [..] A typical configuration Analog Watchdog is done following these steps :
+      (#) the ADC guarded channel(s) is (are) selected using the 
+          ADC_AnalogWatchdogSingleChannelConfig() function.
+      (#) The Analog watchdog lower and higher threshold are configured using the  
+          ADC_AnalogWatchdogThresholdsConfig() function.
+      (#) The Analog watchdog is enabled and configured to enable the check, on one
+          or more channels, using the  ADC_AnalogWatchdogCmd() function.
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Enables or disables the analog watchdog on single/all regular or 
+  *         injected channels
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
+  *         This parameter can be one of the following values:
+  *            @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
+  *            @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
+  *            @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
+  *            @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular channel
+  *            @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected channel
+  *            @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
+  *            @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
+  * @retval None	  
+  */
+void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
+  
+  /* Get the old register value */
+  tmpreg = ADCx->CR1;
+  
+  /* Clear AWDEN, JAWDEN and AWDSGL bits */
+  tmpreg &= CR1_AWDMode_RESET;
+  
+  /* Set the analog watchdog enable mode */
+  tmpreg |= ADC_AnalogWatchdog;
+  
+  /* Store the new register value */
+  ADCx->CR1 = tmpreg;
+}
+
+/**
+  * @brief  Configures the high and low thresholds of the analog watchdog.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  HighThreshold: the ADC analog watchdog High threshold value.
+  *          This parameter must be a 12-bit value.
+  * @param  LowThreshold:  the ADC analog watchdog Low threshold value.
+  *          This parameter must be a 12-bit value.
+  * @retval None
+  */
+void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
+                                        uint16_t LowThreshold)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_THRESHOLD(HighThreshold));
+  assert_param(IS_ADC_THRESHOLD(LowThreshold));
+  
+  /* Set the ADCx high threshold */
+  ADCx->HTR = HighThreshold;
+  
+  /* Set the ADCx low threshold */
+  ADCx->LTR = LowThreshold;
+}
+
+/**
+  * @brief  Configures the analog watchdog guarded single channel
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_Channel_0: ADC Channel0 selected
+  *            @arg ADC_Channel_1: ADC Channel1 selected
+  *            @arg ADC_Channel_2: ADC Channel2 selected
+  *            @arg ADC_Channel_3: ADC Channel3 selected
+  *            @arg ADC_Channel_4: ADC Channel4 selected
+  *            @arg ADC_Channel_5: ADC Channel5 selected
+  *            @arg ADC_Channel_6: ADC Channel6 selected
+  *            @arg ADC_Channel_7: ADC Channel7 selected
+  *            @arg ADC_Channel_8: ADC Channel8 selected
+  *            @arg ADC_Channel_9: ADC Channel9 selected
+  *            @arg ADC_Channel_10: ADC Channel10 selected
+  *            @arg ADC_Channel_11: ADC Channel11 selected
+  *            @arg ADC_Channel_12: ADC Channel12 selected
+  *            @arg ADC_Channel_13: ADC Channel13 selected
+  *            @arg ADC_Channel_14: ADC Channel14 selected
+  *            @arg ADC_Channel_15: ADC Channel15 selected
+  *            @arg ADC_Channel_16: ADC Channel16 selected
+  *            @arg ADC_Channel_17: ADC Channel17 selected
+  *            @arg ADC_Channel_18: ADC Channel18 selected
+  * @retval None
+  */
+void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  
+  /* Get the old register value */
+  tmpreg = ADCx->CR1;
+  
+  /* Clear the Analog watchdog channel select bits */
+  tmpreg &= CR1_AWDCH_RESET;
+  
+  /* Set the Analog watchdog channel */
+  tmpreg |= ADC_Channel;
+  
+  /* Store the new register value */
+  ADCx->CR1 = tmpreg;
+}
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Group3 Temperature Sensor, Vrefint (Voltage Reference internal) 
+ *            and VBAT (Voltage BATtery) management functions
+ *  @brief   Temperature Sensor, Vrefint and VBAT management functions 
+ *
+@verbatim   
+ ===============================================================================
+      ##### Temperature Sensor, Vrefint and VBAT management functions #####
+ ===============================================================================  
+    [..] This section provides functions allowing to enable/ disable the internal 
+         connections between the ADC and the Temperature Sensor, the Vrefint and 
+         the Vbat sources.
+     
+    [..] A typical configuration to get the Temperature sensor and Vrefint channels 
+         voltages is done following these steps :
+      (#) Enable the internal connection of Temperature sensor and Vrefint sources 
+          with the ADC channels using ADC_TempSensorVrefintCmd() function. 
+      (#) Select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
+          ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions 
+      (#) Get the voltage values, using ADC_GetConversionValue() or  
+          ADC_GetInjectedConversionValue().
+
+    [..] A typical configuration to get the VBAT channel voltage is done following 
+         these steps :
+      (#) Enable the internal connection of VBAT source with the ADC channel using 
+          ADC_VBATCmd() function. 
+      (#) Select the ADC_Channel_Vbat using ADC_RegularChannelConfig() or  
+          ADC_InjectedChannelConfig() functions 
+      (#) Get the voltage value, using ADC_GetConversionValue() or  
+          ADC_GetInjectedConversionValue().
+ 
+@endverbatim
+  * @{
+  */
+  
+  
+/**
+  * @brief  Enables or disables the temperature sensor and Vrefint channels.
+  * @param  NewState: new state of the temperature sensor and Vrefint channels.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the temperature sensor and Vrefint channel*/
+    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
+  }
+  else
+  {
+    /* Disable the temperature sensor and Vrefint channel*/
+    ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
+  }
+}
+
+/**
+  * @brief  Enables or disables the VBAT (Voltage Battery) channel.
+  * 
+  * @note   the Battery voltage measured is equal to VBAT/2 on STM32F40xx and 
+  *         STM32F41xx devices and equal to VBAT/4 on STM32F42xx and STM32F43xx devices 
+  *              
+  * @param  NewState: new state of the VBAT channel.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_VBATCmd(FunctionalState NewState)                             
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the VBAT channel*/
+    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
+  }
+  else
+  {
+    /* Disable the VBAT channel*/
+    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Group4 Regular Channels Configuration functions
+ *  @brief   Regular Channels Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+             ##### Regular Channels Configuration functions #####
+ ===============================================================================  
+
+    [..] This section provides functions allowing to manage the ADC's regular channels,
+         it is composed of 2 sub sections : 
+  
+      (#) Configuration and management functions for regular channels: This subsection 
+          provides functions allowing to configure the ADC regular channels :    
+         (++) Configure the rank in the regular group sequencer for each channel
+         (++) Configure the sampling time for each channel
+         (++) select the conversion Trigger for regular channels
+         (++) select the desired EOC event behavior configuration
+         (++) Activate the continuous Mode  (*)
+         (++) Activate the Discontinuous Mode 
+         -@@- Please Note that the following features for regular channels 
+             are configurated using the ADC_Init() function : 
+           (+@@) scan mode activation 
+           (+@@) continuous mode activation (**) 
+           (+@@) External trigger source  
+           (+@@) External trigger edge 
+           (+@@) number of conversion in the regular channels group sequencer.
+     
+         -@@- (*) and (**) are performing the same configuration
+     
+      (#) Get the conversion data: This subsection provides an important function in 
+          the ADC peripheral since it returns the converted data of the current 
+          regular channel. When the Conversion value is read, the EOC Flag is 
+          automatically cleared.
+     
+          -@- For multi ADC mode, the last ADC1, ADC2 and ADC3 regular conversions 
+              results data (in the selected multi mode) can be returned in the same 
+              time using ADC_GetMultiModeConversionValue() function. 
+         
+@endverbatim
+  * @{
+  */
+/**
+  * @brief  Configures for the selected ADC regular channel its corresponding
+  *         rank in the sequencer and its sample time.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_Channel: the ADC channel to configure. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_Channel_0: ADC Channel0 selected
+  *            @arg ADC_Channel_1: ADC Channel1 selected
+  *            @arg ADC_Channel_2: ADC Channel2 selected
+  *            @arg ADC_Channel_3: ADC Channel3 selected
+  *            @arg ADC_Channel_4: ADC Channel4 selected
+  *            @arg ADC_Channel_5: ADC Channel5 selected
+  *            @arg ADC_Channel_6: ADC Channel6 selected
+  *            @arg ADC_Channel_7: ADC Channel7 selected
+  *            @arg ADC_Channel_8: ADC Channel8 selected
+  *            @arg ADC_Channel_9: ADC Channel9 selected
+  *            @arg ADC_Channel_10: ADC Channel10 selected
+  *            @arg ADC_Channel_11: ADC Channel11 selected
+  *            @arg ADC_Channel_12: ADC Channel12 selected
+  *            @arg ADC_Channel_13: ADC Channel13 selected
+  *            @arg ADC_Channel_14: ADC Channel14 selected
+  *            @arg ADC_Channel_15: ADC Channel15 selected
+  *            @arg ADC_Channel_16: ADC Channel16 selected
+  *            @arg ADC_Channel_17: ADC Channel17 selected
+  *            @arg ADC_Channel_18: ADC Channel18 selected                       
+  * @param  Rank: The rank in the regular group sequencer.
+  *          This parameter must be between 1 to 16.
+  * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
+  *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
+  *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
+  *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
+  *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
+  *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
+  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
+  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
+  * @retval None
+  */
+void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
+{
+  uint32_t tmpreg1 = 0, tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  assert_param(IS_ADC_REGULAR_RANK(Rank));
+  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
+  
+  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
+  if (ADC_Channel > ADC_Channel_9)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SMPR1;
+    
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
+    
+    /* Clear the old sample time */
+    tmpreg1 &= ~tmpreg2;
+    
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
+    
+    /* Set the new sample time */
+    tmpreg1 |= tmpreg2;
+    
+    /* Store the new register value */
+    ADCx->SMPR1 = tmpreg1;
+  }
+  else /* ADC_Channel include in ADC_Channel_[0..9] */
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SMPR2;
+    
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
+    
+    /* Clear the old sample time */
+    tmpreg1 &= ~tmpreg2;
+    
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
+    
+    /* Set the new sample time */
+    tmpreg1 |= tmpreg2;
+    
+    /* Store the new register value */
+    ADCx->SMPR2 = tmpreg1;
+  }
+  /* For Rank 1 to 6 */
+  if (Rank < 7)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SQR3;
+    
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
+    
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &= ~tmpreg2;
+    
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
+    
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    
+    /* Store the new register value */
+    ADCx->SQR3 = tmpreg1;
+  }
+  /* For Rank 7 to 12 */
+  else if (Rank < 13)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SQR2;
+    
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
+    
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &= ~tmpreg2;
+    
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
+    
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    
+    /* Store the new register value */
+    ADCx->SQR2 = tmpreg1;
+  }
+  /* For Rank 13 to 16 */
+  else
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SQR1;
+    
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
+    
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &= ~tmpreg2;
+    
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
+    
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    
+    /* Store the new register value */
+    ADCx->SQR1 = tmpreg1;
+  }
+}
+
+/**
+  * @brief  Enables the selected ADC software start conversion of the regular channels.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval None
+  */
+void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  
+  /* Enable the selected ADC conversion for regular group */
+  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
+}
+
+/**
+  * @brief  Gets the selected ADC Software start regular conversion Status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC software start conversion (SET or RESET).
+  */
+FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  
+  /* Check the status of SWSTART bit */
+  if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
+  {
+    /* SWSTART bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SWSTART bit is reset */
+    bitstatus = RESET;
+  }
+  
+  /* Return the SWSTART bit status */
+  return  bitstatus;
+}
+
+
+/**
+  * @brief  Enables or disables the EOC on each regular channel conversion
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC EOC flag rising
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC EOC rising on each regular channel conversion */
+    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
+  }
+  else
+  {
+    /* Disable the selected ADC EOC rising on each regular channel conversion */
+    ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
+  }
+}
+
+/**
+  * @brief  Enables or disables the ADC continuous conversion mode 
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC continuous conversion mode
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC continuous conversion mode */
+    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
+  }
+  else
+  {
+    /* Disable the selected ADC continuous conversion mode */
+    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
+  }
+}
+
+/**
+  * @brief  Configures the discontinuous mode for the selected ADC regular group 
+  *         channel.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  Number: specifies the discontinuous mode regular channel count value.
+  *          This number must be between 1 and 8.
+  * @retval None
+  */
+void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
+{
+  uint32_t tmpreg1 = 0;
+  uint32_t tmpreg2 = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
+  
+  /* Get the old register value */
+  tmpreg1 = ADCx->CR1;
+  
+  /* Clear the old discontinuous mode channel count */
+  tmpreg1 &= CR1_DISCNUM_RESET;
+  
+  /* Set the discontinuous mode channel count */
+  tmpreg2 = Number - 1;
+  tmpreg1 |= tmpreg2 << 13;
+  
+  /* Store the new register value */
+  ADCx->CR1 = tmpreg1;
+}
+
+/**
+  * @brief  Enables or disables the discontinuous mode on regular group channel 
+  *         for the specified ADC
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC discontinuous mode on 
+  *         regular group channel.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC regular discontinuous mode */
+    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
+  }
+  else
+  {
+    /* Disable the selected ADC regular discontinuous mode */
+    ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
+  }
+}
+
+/**
+  * @brief  Returns the last ADCx conversion result data for regular channel.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The Data conversion value.
+  */
+uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  
+  /* Return the selected ADC conversion value */
+  return (uint16_t) ADCx->DR;
+}
+
+/**
+  * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
+  *         data in the selected multi mode.
+  * @param  None  
+  * @retval The Data conversion value.
+  * @note   In dual mode, the value returned by this function is as following
+  *           Data[15:0] : these bits contain the regular data of ADC1.
+  *           Data[31:16]: these bits contain the regular data of ADC2.
+  * @note   In triple mode, the value returned by this function is as following
+  *           Data[15:0] : these bits contain alternatively the regular data of ADC1, ADC3 and ADC2.
+  *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
+  */
+uint32_t ADC_GetMultiModeConversionValue(void)
+{
+  /* Return the multi mode conversion value */
+  return (*(__IO uint32_t *) CDR_ADDRESS);
+}
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Group5 Regular Channels DMA Configuration functions
+ *  @brief   Regular Channels DMA Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+            ##### Regular Channels DMA Configuration functions #####
+ ===============================================================================  
+    [..] This section provides functions allowing to configure the DMA for ADC 
+         regular channels.
+         Since converted regular channel values are stored into a unique data 
+         register, it is useful to use DMA for conversion of more than one regular 
+         channel. This avoids the loss of the data already stored in the ADC 
+         Data register.   
+         When the DMA mode is enabled (using the ADC_DMACmd() function), after each
+         conversion of a regular channel, a DMA request is generated.
+    [..] Depending on the "DMA disable selection for Independent ADC mode" 
+         configuration (using the ADC_DMARequestAfterLastTransferCmd() function), 
+         at the end of the last DMA transfer, two possibilities are allowed:
+      (+) No new DMA request is issued to the DMA controller (feature DISABLED) 
+      (+) Requests can continue to be generated (feature ENABLED).  
+    [..] Depending on the "DMA disable selection for multi ADC mode" configuration 
+         (using the void ADC_MultiModeDMARequestAfterLastTransferCmd() function), 
+         at the end of the last DMA transfer, two possibilities are allowed:
+        (+) No new DMA request is issued to the DMA controller (feature DISABLED) 
+        (+) Requests can continue to be generated (feature ENABLED).
+
+@endverbatim
+  * @{
+  */
+  
+ /**
+  * @brief  Enables or disables the specified ADC DMA request.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC DMA transfer.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC DMA request */
+    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
+  }
+  else
+  {
+    /* Disable the selected ADC DMA request */
+    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
+  }
+}
+
+/**
+  * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC DMA request after last transfer.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC DMA request after last transfer */
+    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
+  }
+  else
+  {
+    /* Disable the selected ADC DMA request after last transfer */
+    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
+  }
+}
+
+/**
+  * @brief  Enables or disables the ADC DMA request after last transfer in multi ADC mode       
+  * @param  NewState: new state of the selected ADC DMA request after last transfer.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @note   if Enabled, DMA requests are issued as long as data are converted and 
+  *         DMA mode for multi ADC mode (selected using ADC_CommonInit() function 
+  *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
+  *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
+  * @retval None
+  */
+void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC DMA request after last transfer */
+    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
+  }
+  else
+  {
+    /* Disable the selected ADC DMA request after last transfer */
+    ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Group6 Injected channels Configuration functions
+ *  @brief   Injected channels Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Injected channels Configuration functions #####
+ ===============================================================================  
+
+    [..] This section provide functions allowing to configure the ADC Injected channels,
+         it is composed of 2 sub sections : 
+    
+      (#) Configuration functions for Injected channels: This subsection provides 
+          functions allowing to configure the ADC injected channels :    
+        (++) Configure the rank in the injected group sequencer for each channel
+        (++) Configure the sampling time for each channel    
+        (++) Activate the Auto injected Mode  
+        (++) Activate the Discontinuous Mode 
+        (++) scan mode activation  
+        (++) External/software trigger source   
+        (++) External trigger edge 
+        (++) injected channels sequencer.
+    
+      (#) Get the Specified Injected channel conversion data: This subsection 
+          provides an important function in the ADC peripheral since it returns the 
+          converted data of the specific injected channel.
+
+@endverbatim
+  * @{
+  */ 
+/**
+  * @brief  Configures for the selected ADC injected channel its corresponding
+  *         rank in the sequencer and its sample time.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_Channel: the ADC channel to configure. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_Channel_0: ADC Channel0 selected
+  *            @arg ADC_Channel_1: ADC Channel1 selected
+  *            @arg ADC_Channel_2: ADC Channel2 selected
+  *            @arg ADC_Channel_3: ADC Channel3 selected
+  *            @arg ADC_Channel_4: ADC Channel4 selected
+  *            @arg ADC_Channel_5: ADC Channel5 selected
+  *            @arg ADC_Channel_6: ADC Channel6 selected
+  *            @arg ADC_Channel_7: ADC Channel7 selected
+  *            @arg ADC_Channel_8: ADC Channel8 selected
+  *            @arg ADC_Channel_9: ADC Channel9 selected
+  *            @arg ADC_Channel_10: ADC Channel10 selected
+  *            @arg ADC_Channel_11: ADC Channel11 selected
+  *            @arg ADC_Channel_12: ADC Channel12 selected
+  *            @arg ADC_Channel_13: ADC Channel13 selected
+  *            @arg ADC_Channel_14: ADC Channel14 selected
+  *            @arg ADC_Channel_15: ADC Channel15 selected
+  *            @arg ADC_Channel_16: ADC Channel16 selected
+  *            @arg ADC_Channel_17: ADC Channel17 selected
+  *            @arg ADC_Channel_18: ADC Channel18 selected                       
+  * @param  Rank: The rank in the injected group sequencer. 
+  *          This parameter must be between 1 to 4.
+  * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
+  *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
+  *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
+  *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
+  *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
+  *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
+  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
+  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
+  * @retval None
+  */
+void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
+{
+  uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  assert_param(IS_ADC_INJECTED_RANK(Rank));
+  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
+  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
+  if (ADC_Channel > ADC_Channel_9)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SMPR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
+    /* Clear the old sample time */
+    tmpreg1 &= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
+    /* Set the new sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx->SMPR1 = tmpreg1;
+  }
+  else /* ADC_Channel include in ADC_Channel_[0..9] */
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SMPR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
+    /* Clear the old sample time */
+    tmpreg1 &= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
+    /* Set the new sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx->SMPR2 = tmpreg1;
+  }
+  /* Rank configuration */
+  /* Get the old register value */
+  tmpreg1 = ADCx->JSQR;
+  /* Get JL value: Number = JL+1 */
+  tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
+  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
+  tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
+  /* Clear the old JSQx bits for the selected rank */
+  tmpreg1 &= ~tmpreg2;
+  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
+  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
+  /* Set the JSQx bits for the selected rank */
+  tmpreg1 |= tmpreg2;
+  /* Store the new register value */
+  ADCx->JSQR = tmpreg1;
+}
+
+/**
+  * @brief  Configures the sequencer length for injected channels
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  Length: The sequencer length. 
+  *          This parameter must be a number between 1 to 4.
+  * @retval None
+  */
+void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
+{
+  uint32_t tmpreg1 = 0;
+  uint32_t tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_LENGTH(Length));
+  
+  /* Get the old register value */
+  tmpreg1 = ADCx->JSQR;
+  
+  /* Clear the old injected sequence length JL bits */
+  tmpreg1 &= JSQR_JL_RESET;
+  
+  /* Set the injected sequence length JL bits */
+  tmpreg2 = Length - 1; 
+  tmpreg1 |= tmpreg2 << 20;
+  
+  /* Store the new register value */
+  ADCx->JSQR = tmpreg1;
+}
+
+/**
+  * @brief  Set the injected channels conversion value offset
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
+  *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
+  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
+  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
+  * @param  Offset: the offset value for the selected ADC injected channel
+  *          This parameter must be a 12bit value.
+  * @retval None
+  */
+void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
+{
+    __IO uint32_t tmp = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
+  assert_param(IS_ADC_OFFSET(Offset));
+  
+  tmp = (uint32_t)ADCx;
+  tmp += ADC_InjectedChannel;
+  
+  /* Set the selected injected channel data offset */
+ *(__IO uint32_t *) tmp = (uint32_t)Offset;
+}
+
+ /**
+  * @brief  Configures the ADCx external trigger for injected channels conversion.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.
+  *          This parameter can be one of the following values:                    
+  *            @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected 
+  *            @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected 
+  *            @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected 
+  *            @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected 
+  *            @arg ADC_ExternalTrigInjecConv_T3_CC2: Timer3 capture compare2 selected 
+  *            @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected 
+  *            @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected                       
+  *            @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
+  *            @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected                        
+  *            @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
+  *            @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected                        
+  *            @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected                        
+  *            @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected
+  *            @arg ADC_ExternalTrigInjecConv_T8_CC3: Timer8 capture compare3 selected                        
+  *            @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected 
+  *            @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
+  * @retval None
+  */
+void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
+  
+  /* Get the old register value */
+  tmpreg = ADCx->CR2;
+  
+  /* Clear the old external event selection for injected group */
+  tmpreg &= CR2_JEXTSEL_RESET;
+  
+  /* Set the external event selection for injected group */
+  tmpreg |= ADC_ExternalTrigInjecConv;
+  
+  /* Store the new register value */
+  ADCx->CR2 = tmpreg;
+}
+
+/**
+  * @brief  Configures the ADCx external trigger edge for injected channels conversion.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger edge
+  *         to start injected conversion. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_ExternalTrigInjecConvEdge_None: external trigger disabled for 
+  *                                                     injected conversion
+  *            @arg ADC_ExternalTrigInjecConvEdge_Rising: detection on rising edge
+  *            @arg ADC_ExternalTrigInjecConvEdge_Falling: detection on falling edge
+  *            @arg ADC_ExternalTrigInjecConvEdge_RisingFalling: detection on both rising 
+  *                                                               and falling edge
+  * @retval None
+  */
+void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
+  /* Get the old register value */
+  tmpreg = ADCx->CR2;
+  /* Clear the old external trigger edge for injected group */
+  tmpreg &= CR2_JEXTEN_RESET;
+  /* Set the new external trigger edge for injected group */
+  tmpreg |= ADC_ExternalTrigInjecConvEdge;
+  /* Store the new register value */
+  ADCx->CR2 = tmpreg;
+}
+
+/**
+  * @brief  Enables the selected ADC software start conversion of the injected channels.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval None
+  */
+void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Enable the selected ADC conversion for injected group */
+  ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
+}
+
+/**
+  * @brief  Gets the selected ADC Software start injected conversion Status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC software start injected conversion (SET or RESET).
+  */
+FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  
+  /* Check the status of JSWSTART bit */
+  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
+  {
+    /* JSWSTART bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* JSWSTART bit is reset */
+    bitstatus = RESET;
+  }
+  /* Return the JSWSTART bit status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Enables or disables the selected ADC automatic injected group 
+  *         conversion after regular one.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC auto injected conversion
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC automatic injected group conversion */
+    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
+  }
+  else
+  {
+    /* Disable the selected ADC automatic injected group conversion */
+    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
+  }
+}
+
+/**
+  * @brief  Enables or disables the discontinuous mode for injected group 
+  *         channel for the specified ADC
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC discontinuous mode on injected
+  *         group channel.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC injected discontinuous mode */
+    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
+  }
+  else
+  {
+    /* Disable the selected ADC injected discontinuous mode */
+    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
+  }
+}
+
+/**
+  * @brief  Returns the ADC injected channel conversion result
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_InjectedChannel: the converted ADC injected channel.
+  *          This parameter can be one of the following values:
+  *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
+  *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
+  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
+  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
+  * @retval The Data conversion value.
+  */
+uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
+{
+  __IO uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
+
+  tmp = (uint32_t)ADCx;
+  tmp += ADC_InjectedChannel + JDR_OFFSET;
+  
+  /* Returns the selected injected channel conversion data value */
+  return (uint16_t) (*(__IO uint32_t*)  tmp); 
+}
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Group7 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+            ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+    [..] This section provides functions allowing to configure the ADC Interrupts 
+         and to get the status and clear flags and Interrupts pending bits.
+  
+    [..] Each ADC provides 4 Interrupts sources and 6 Flags which can be divided
+        into 3 groups:
+  
+  *** Flags and Interrupts for ADC regular channels ***
+  =====================================================
+    [..]
+      (+) Flags :
+        (##) ADC_FLAG_OVR : Overrun detection when regular converted data are lost
+
+        (##) ADC_FLAG_EOC : Regular channel end of conversion ==> to indicate 
+             (depending on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() )
+             the end of:
+             (+++) a regular CHANNEL conversion 
+             (+++) sequence of regular GROUP conversions .
+
+        (##) ADC_FLAG_STRT: Regular channel start ==> to indicate when regular 
+             CHANNEL conversion starts.
+    [..]
+      (+) Interrupts :
+        (##) ADC_IT_OVR : specifies the interrupt source for Overrun detection 
+             event.  
+        (##) ADC_IT_EOC : specifies the interrupt source for Regular channel end
+             of conversion event.
+  
+  
+  *** Flags and Interrupts for ADC Injected channels ***
+  ======================================================
+    [..]
+      (+) Flags :
+        (##) ADC_FLAG_JEOC : Injected channel end of conversion ==> to indicate 
+             at the end of injected GROUP conversion  
+              
+        (##) ADC_FLAG_JSTRT: Injected channel start ==> to indicate hardware when 
+             injected GROUP conversion starts.
+    [..]
+      (+) Interrupts :
+        (##) ADC_IT_JEOC : specifies the interrupt source for Injected channel 
+             end of conversion event.     
+
+  *** General Flags and Interrupts for the ADC ***
+  ================================================ 
+    [..]
+      (+)Flags :
+        (##) ADC_FLAG_AWD: Analog watchdog ==> to indicate if the converted voltage 
+             crosses the programmed thresholds values.
+    [..]          
+      (+) Interrupts :
+        (##) ADC_IT_AWD : specifies the interrupt source for Analog watchdog event. 
+
+  
+    [..] The user should identify which mode will be used in his application to 
+         manage the ADC controller events: Polling mode or Interrupt mode.
+  
+    [..] In the Polling Mode it is advised to use the following functions:
+      (+) ADC_GetFlagStatus() : to check if flags events occur. 
+      (+) ADC_ClearFlag()     : to clear the flags events.
+      
+    [..] In the Interrupt Mode it is advised to use the following functions:
+      (+) ADC_ITConfig()          : to enable or disable the interrupt source.
+      (+) ADC_GetITStatus()       : to check if Interrupt occurs.
+      (+) ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
+                                   (corresponding Flag). 
+@endverbatim
+  * @{
+  */ 
+/**
+  * @brief  Enables or disables the specified ADC interrupts.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_IT_EOC: End of conversion interrupt mask
+  *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
+  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
+  *            @arg ADC_IT_OVR: Overrun interrupt enable                       
+  * @param  NewState: new state of the specified ADC interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
+{
+  uint32_t itmask = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_ADC_IT(ADC_IT)); 
+
+  /* Get the ADC IT index */
+  itmask = (uint8_t)ADC_IT;
+  itmask = (uint32_t)0x01 << itmask;    
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC interrupts */
+    ADCx->CR1 |= itmask;
+  }
+  else
+  {
+    /* Disable the selected ADC interrupts */
+    ADCx->CR1 &= (~(uint32_t)itmask);
+  }
+}
+
+/**
+  * @brief  Checks whether the specified ADC flag is set or not.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_FLAG: specifies the flag to check. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_FLAG_AWD: Analog watchdog flag
+  *            @arg ADC_FLAG_EOC: End of conversion flag
+  *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
+  *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
+  *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
+  *            @arg ADC_FLAG_OVR: Overrun flag                                                 
+  * @retval The new state of ADC_FLAG (SET or RESET).
+  */
+FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
+
+  /* Check the status of the specified ADC flag */
+  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
+  {
+    /* ADC_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* ADC_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the ADC_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the ADCx's pending flags.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_FLAG: specifies the flag to clear. 
+  *          This parameter can be any combination of the following values:
+  *            @arg ADC_FLAG_AWD: Analog watchdog flag
+  *            @arg ADC_FLAG_EOC: End of conversion flag
+  *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
+  *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
+  *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
+  *            @arg ADC_FLAG_OVR: Overrun flag                          
+  * @retval None
+  */
+void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
+
+  /* Clear the selected ADC flags */
+  ADCx->SR = ~(uint32_t)ADC_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified ADC interrupt has occurred or not.
+  * @param  ADCx:   where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_IT: specifies the ADC interrupt source to check. 
+  *          This parameter can be one of the following values:
+  *            @arg ADC_IT_EOC: End of conversion interrupt mask
+  *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
+  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
+  *            @arg ADC_IT_OVR: Overrun interrupt mask                        
+  * @retval The new state of ADC_IT (SET or RESET).
+  */
+ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t itmask = 0, enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_IT(ADC_IT));
+
+  /* Get the ADC IT index */
+  itmask = ADC_IT >> 8;
+
+  /* Get the ADC_IT enable bit status */
+  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
+
+  /* Check the status of the specified ADC interrupt */
+  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
+  {
+    /* ADC_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* ADC_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the ADC_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the ADCx's interrupt pending bits.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
+  *          This parameter can be one of the following values:
+  *            @arg ADC_IT_EOC: End of conversion interrupt mask
+  *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
+  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
+  *            @arg ADC_IT_OVR: Overrun interrupt mask                         
+  * @retval None
+  */
+void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
+{
+  uint8_t itmask = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_IT(ADC_IT)); 
+  /* Get the ADC IT index */
+  itmask = (uint8_t)(ADC_IT >> 8);
+  /* Clear the selected ADC interrupt pending bits */
+  ADCx->SR = ~(uint32_t)itmask;
+}                    
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_can.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_can.c
new file mode 100644
index 0000000..a68223e
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_can.c
@@ -0,0 +1,1700 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_can.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Controller area network (CAN) peripheral:
+  *           + Initialization and Configuration 
+  *           + CAN Frames Transmission
+  *           + CAN Frames Reception
+  *           + Operation modes switch
+  *           + Error management
+  *           + Interrupts and flags
+  *
+@verbatim
+ ===============================================================================
+                        ##### How to use this driver #####
+ ===============================================================================
+    [..]
+      (#) Enable the CAN controller interface clock using 
+          RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); for CAN1 
+          and RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE); for CAN2
+      -@- In case you are using CAN2 only, you have to enable the CAN1 clock.
+       
+      (#) CAN pins configuration
+        (++) Enable the clock for the CAN GPIOs using the following function:
+             RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
+        (++) Connect the involved CAN pins to AF9 using the following function 
+             GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
+        (++) Configure these CAN pins in alternate function mode by calling
+             the function  GPIO_Init();
+      
+      (#) Initialise and configure the CAN using CAN_Init() and 
+          CAN_FilterInit() functions.   
+                 
+      (#) Transmit the desired CAN frame using CAN_Transmit() function.
+           
+      (#) Check the transmission of a CAN frame using CAN_TransmitStatus()
+          function.
+                 
+      (#) Cancel the transmission of a CAN frame using CAN_CancelTransmit()
+          function.  
+              
+      (#) Receive a CAN frame using CAN_Recieve() function.
+           
+      (#) Release the receive FIFOs using CAN_FIFORelease() function.
+                 
+      (#) Return the number of pending received frames using 
+          CAN_MessagePending() function.            
+                     
+      (#) To control CAN events you can use one of the following two methods:
+        (++) Check on CAN flags using the CAN_GetFlagStatus() function.  
+        (++) Use CAN interrupts through the function CAN_ITConfig() at 
+             initialization phase and CAN_GetITStatus() function into 
+             interrupt routines to check if the event has occurred or not.
+             After checking on a flag you should clear it using CAN_ClearFlag()
+             function. And after checking on an interrupt event you should 
+             clear it using CAN_ClearITPendingBit() function.            
+
+@endverbatim
+           
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_can.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CAN 
+  * @brief CAN driver modules
+  * @{
+  */ 
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* CAN Master Control Register bits */
+#define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
+
+/* CAN Mailbox Transmit Request */
+#define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
+
+/* CAN Filter Master Register bits */
+#define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
+
+/* Time out for INAK bit */
+#define INAK_TIMEOUT      ((uint32_t)0x0000FFFF)
+/* Time out for SLAK bit */
+#define SLAK_TIMEOUT      ((uint32_t)0x0000FFFF)
+
+/* Flags in TSR register */
+#define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
+/* Flags in RF1R register */
+#define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
+/* Flags in RF0R register */
+#define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
+/* Flags in MSR register */
+#define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
+/* Flags in ESR register */
+#define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
+
+/* Mailboxes definition */
+#define CAN_TXMAILBOX_0   ((uint8_t)0x00)
+#define CAN_TXMAILBOX_1   ((uint8_t)0x01)
+#define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
+
+#define CAN_MODE_MASK     ((uint32_t) 0x00000003)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
+
+/** @defgroup CAN_Private_Functions
+  * @{
+  */
+
+/** @defgroup CAN_Group1 Initialization and Configuration functions
+ *  @brief    Initialization and Configuration functions 
+ *
+@verbatim    
+ ===============================================================================
+              ##### Initialization and Configuration functions #####
+ ===============================================================================  
+    [..] This section provides functions allowing to 
+      (+) Initialize the CAN peripherals : Prescaler, operating mode, the maximum 
+          number of time quanta to perform resynchronization, the number of time 
+          quanta in Bit Segment 1 and 2 and many other modes. 
+          Refer to  @ref CAN_InitTypeDef  for more details.
+      (+) Configures the CAN reception filter.                                      
+      (+) Select the start bank filter for slave CAN.
+      (+) Enables or disables the Debug Freeze mode for CAN
+      (+)Enables or disables the CAN Time Trigger Operation communication mode
+   
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Deinitializes the CAN peripheral registers to their default reset values.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @retval None.
+  */
+void CAN_DeInit(CAN_TypeDef* CANx)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+ 
+  if (CANx == CAN1)
+  {
+    /* Enable CAN1 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
+    /* Release CAN1 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
+  }
+  else
+  {  
+    /* Enable CAN2 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
+    /* Release CAN2 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
+  }
+}
+
+/**
+  * @brief  Initializes the CAN peripheral according to the specified
+  *         parameters in the CAN_InitStruct.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
+  *         the configuration information for the CAN peripheral.
+  * @retval Constant indicates initialization succeed which will be 
+  *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
+  */
+uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
+{
+  uint8_t InitStatus = CAN_InitStatus_Failed;
+  uint32_t wait_ack = 0x00000000;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
+  assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
+  assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
+  assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
+  assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
+  assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
+
+  /* Exit from sleep mode */
+  CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
+
+  /* Request initialisation */
+  CANx->MCR |= CAN_MCR_INRQ ;
+
+  /* Wait the acknowledge */
+  while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
+  {
+    wait_ack++;
+  }
+
+  /* Check acknowledge */
+  if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
+  {
+    InitStatus = CAN_InitStatus_Failed;
+  }
+  else 
+  {
+    /* Set the time triggered communication mode */
+    if (CAN_InitStruct->CAN_TTCM == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_TTCM;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
+    }
+
+    /* Set the automatic bus-off management */
+    if (CAN_InitStruct->CAN_ABOM == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_ABOM;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
+    }
+
+    /* Set the automatic wake-up mode */
+    if (CAN_InitStruct->CAN_AWUM == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_AWUM;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
+    }
+
+    /* Set the no automatic retransmission */
+    if (CAN_InitStruct->CAN_NART == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_NART;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
+    }
+
+    /* Set the receive FIFO locked mode */
+    if (CAN_InitStruct->CAN_RFLM == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_RFLM;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
+    }
+
+    /* Set the transmit FIFO priority */
+    if (CAN_InitStruct->CAN_TXFP == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_TXFP;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
+    }
+
+    /* Set the bit timing register */
+    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
+                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
+                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
+                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
+               ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
+
+    /* Request leave initialisation */
+    CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
+
+   /* Wait the acknowledge */
+   wait_ack = 0;
+
+   while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
+   {
+     wait_ack++;
+   }
+
+    /* ...and check acknowledged */
+    if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
+    {
+      InitStatus = CAN_InitStatus_Failed;
+    }
+    else
+    {
+      InitStatus = CAN_InitStatus_Success ;
+    }
+  }
+
+  /* At this step, return the status of initialization */
+  return InitStatus;
+}
+
+/**
+  * @brief  Configures the CAN reception filter according to the specified
+  *         parameters in the CAN_FilterInitStruct.
+  * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
+  *         contains the configuration information.
+  * @retval None
+  */
+void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
+{
+  uint32_t filter_number_bit_pos = 0;
+  /* Check the parameters */
+  assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
+  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
+  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
+  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
+
+  filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
+
+  /* Initialisation mode for the filter */
+  CAN1->FMR |= FMR_FINIT;
+
+  /* Filter Deactivation */
+  CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
+
+  /* Filter Scale */
+  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
+  {
+    /* 16-bit scale for the filter */
+    CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
+
+    /* First 16-bit identifier and First 16-bit mask */
+    /* Or First 16-bit identifier and Second 16-bit identifier */
+    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
+       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
+        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
+
+    /* Second 16-bit identifier and Second 16-bit mask */
+    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
+    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
+       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
+        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
+  }
+
+  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
+  {
+    /* 32-bit scale for the filter */
+    CAN1->FS1R |= filter_number_bit_pos;
+    /* 32-bit identifier or First 32-bit identifier */
+    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
+       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
+        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
+    /* 32-bit mask or Second 32-bit identifier */
+    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
+       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
+        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
+  }
+
+  /* Filter Mode */
+  if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
+  {
+    /*Id/Mask mode for the filter*/
+    CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
+  }
+  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
+  {
+    /*Identifier list mode for the filter*/
+    CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
+  }
+
+  /* Filter FIFO assignment */
+  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
+  {
+    /* FIFO 0 assignation for the filter */
+    CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
+  }
+
+  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
+  {
+    /* FIFO 1 assignation for the filter */
+    CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
+  }
+  
+  /* Filter activation */
+  if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
+  {
+    CAN1->FA1R |= filter_number_bit_pos;
+  }
+
+  /* Leave the initialisation mode for the filter */
+  CAN1->FMR &= ~FMR_FINIT;
+}
+
+/**
+  * @brief  Fills each CAN_InitStruct member with its default value.
+  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
+  * @retval None
+  */
+void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
+{
+  /* Reset CAN init structure parameters values */
+  
+  /* Initialize the time triggered communication mode */
+  CAN_InitStruct->CAN_TTCM = DISABLE;
+  
+  /* Initialize the automatic bus-off management */
+  CAN_InitStruct->CAN_ABOM = DISABLE;
+  
+  /* Initialize the automatic wake-up mode */
+  CAN_InitStruct->CAN_AWUM = DISABLE;
+  
+  /* Initialize the no automatic retransmission */
+  CAN_InitStruct->CAN_NART = DISABLE;
+  
+  /* Initialize the receive FIFO locked mode */
+  CAN_InitStruct->CAN_RFLM = DISABLE;
+  
+  /* Initialize the transmit FIFO priority */
+  CAN_InitStruct->CAN_TXFP = DISABLE;
+  
+  /* Initialize the CAN_Mode member */
+  CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
+  
+  /* Initialize the CAN_SJW member */
+  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
+  
+  /* Initialize the CAN_BS1 member */
+  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
+  
+  /* Initialize the CAN_BS2 member */
+  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
+  
+  /* Initialize the CAN_Prescaler member */
+  CAN_InitStruct->CAN_Prescaler = 1;
+}
+
+/**
+  * @brief  Select the start bank filter for slave CAN.
+  * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
+  * @retval None
+  */
+void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
+  
+  /* Enter Initialisation mode for the filter */
+  CAN1->FMR |= FMR_FINIT;
+  
+  /* Select the start slave bank */
+  CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
+  CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
+  
+  /* Leave Initialisation mode for the filter */
+  CAN1->FMR &= ~FMR_FINIT;
+}
+
+/**
+  * @brief  Enables or disables the DBG Freeze for CAN.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  NewState: new state of the CAN peripheral. 
+  *          This parameter can be: ENABLE (CAN reception/transmission is frozen
+  *          during debug. Reception FIFOs can still be accessed/controlled normally) 
+  *          or DISABLE (CAN is working during debug).
+  * @retval None
+  */
+void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable Debug Freeze  */
+    CANx->MCR |= MCR_DBF;
+  }
+  else
+  {
+    /* Disable Debug Freeze */
+    CANx->MCR &= ~MCR_DBF;
+  }
+}
+
+
+/**
+  * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
+  * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
+  *         sent over the CAN bus.  
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
+  *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
+  *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
+  *         in data byte 7. 
+  * @retval None
+  */
+void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the TTCM mode */
+    CANx->MCR |= CAN_MCR_TTCM;
+
+    /* Set TGT bits */
+    CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
+    CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
+    CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
+  }
+  else
+  {
+    /* Disable the TTCM mode */
+    CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
+
+    /* Reset TGT bits */
+    CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
+    CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
+    CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
+  }
+}
+/**
+  * @}
+  */
+
+
+/** @defgroup CAN_Group2 CAN Frames Transmission functions
+ *  @brief    CAN Frames Transmission functions 
+ *
+@verbatim    
+ ===============================================================================
+                ##### CAN Frames Transmission functions #####
+ ===============================================================================  
+    [..] This section provides functions allowing to 
+      (+) Initiate and transmit a CAN frame message (if there is an empty mailbox).
+      (+) Check the transmission status of a CAN Frame
+      (+) Cancel a transmit request
+   
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Initiates and transmits a CAN frame message.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
+  * @retval The number of the mailbox that is used for transmission or
+  *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
+  */
+uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
+{
+  uint8_t transmit_mailbox = 0;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
+  assert_param(IS_CAN_RTR(TxMessage->RTR));
+  assert_param(IS_CAN_DLC(TxMessage->DLC));
+
+  /* Select one empty transmit mailbox */
+  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
+  {
+    transmit_mailbox = 0;
+  }
+  else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
+  {
+    transmit_mailbox = 1;
+  }
+  else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
+  {
+    transmit_mailbox = 2;
+  }
+  else
+  {
+    transmit_mailbox = CAN_TxStatus_NoMailBox;
+  }
+
+  if (transmit_mailbox != CAN_TxStatus_NoMailBox)
+  {
+    /* Set up the Id */
+    CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
+    if (TxMessage->IDE == CAN_Id_Standard)
+    {
+      assert_param(IS_CAN_STDID(TxMessage->StdId));  
+      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
+                                                  TxMessage->RTR);
+    }
+    else
+    {
+      assert_param(IS_CAN_EXTID(TxMessage->ExtId));
+      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
+                                                  TxMessage->IDE | \
+                                                  TxMessage->RTR);
+    }
+    
+    /* Set up the DLC */
+    TxMessage->DLC &= (uint8_t)0x0000000F;
+    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
+    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
+
+    /* Set up the data field */
+    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
+                                             ((uint32_t)TxMessage->Data[2] << 16) |
+                                             ((uint32_t)TxMessage->Data[1] << 8) | 
+                                             ((uint32_t)TxMessage->Data[0]));
+    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
+                                             ((uint32_t)TxMessage->Data[6] << 16) |
+                                             ((uint32_t)TxMessage->Data[5] << 8) |
+                                             ((uint32_t)TxMessage->Data[4]));
+    /* Request transmission */
+    CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
+  }
+  return transmit_mailbox;
+}
+
+/**
+  * @brief  Checks the transmission status of a CAN Frame.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
+  * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
+  *         CAN_TxStatus_Failed in an other case.
+  */
+uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
+{
+  uint32_t state = 0;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
+ 
+  switch (TransmitMailbox)
+  {
+    case (CAN_TXMAILBOX_0): 
+      state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
+      break;
+    case (CAN_TXMAILBOX_1): 
+      state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
+      break;
+    case (CAN_TXMAILBOX_2): 
+      state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
+      break;
+    default:
+      state = CAN_TxStatus_Failed;
+      break;
+  }
+  switch (state)
+  {
+      /* transmit pending  */
+    case (0x0): state = CAN_TxStatus_Pending;
+      break;
+      /* transmit failed  */
+     case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
+      break;
+     case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
+      break;
+     case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
+      break;
+      /* transmit succeeded  */
+    case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
+      break;
+    case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
+      break;
+    case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
+      break;
+    default: state = CAN_TxStatus_Failed;
+      break;
+  }
+  return (uint8_t) state;
+}
+
+/**
+  * @brief  Cancels a transmit request.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @param  Mailbox: Mailbox number.
+  * @retval None
+  */
+void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
+  /* abort transmission */
+  switch (Mailbox)
+  {
+    case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
+      break;
+    case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
+      break;
+    case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
+      break;
+    default:
+      break;
+  }
+}
+/**
+  * @}
+  */
+
+
+/** @defgroup CAN_Group3 CAN Frames Reception functions
+ *  @brief    CAN Frames Reception functions 
+ *
+@verbatim    
+ ===============================================================================
+                ##### CAN Frames Reception functions #####
+ ===============================================================================  
+    [..] This section provides functions allowing to 
+      (+) Receive a correct CAN frame
+      (+) Release a specified receive FIFO (2 FIFOs are available)
+      (+) Return the number of the pending received CAN frames
+   
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Receives a correct CAN frame.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
+  * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
+  *         CAN DLC, CAN data and FMI number.
+  * @retval None
+  */
+void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FIFO(FIFONumber));
+  /* Get the Id */
+  RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
+  if (RxMessage->IDE == CAN_Id_Standard)
+  {
+    RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
+  }
+  else
+  {
+    RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
+  }
+  
+  RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
+  /* Get the DLC */
+  RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
+  /* Get the FMI */
+  RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
+  /* Get the data field */
+  RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
+  RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
+  RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
+  RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
+  RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
+  RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
+  RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
+  RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
+  /* Release the FIFO */
+  /* Release FIFO0 */
+  if (FIFONumber == CAN_FIFO0)
+  {
+    CANx->RF0R |= CAN_RF0R_RFOM0;
+  }
+  /* Release FIFO1 */
+  else /* FIFONumber == CAN_FIFO1 */
+  {
+    CANx->RF1R |= CAN_RF1R_RFOM1;
+  }
+}
+
+/**
+  * @brief  Releases the specified receive FIFO.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
+  * @retval None
+  */
+void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FIFO(FIFONumber));
+  /* Release FIFO0 */
+  if (FIFONumber == CAN_FIFO0)
+  {
+    CANx->RF0R |= CAN_RF0R_RFOM0;
+  }
+  /* Release FIFO1 */
+  else /* FIFONumber == CAN_FIFO1 */
+  {
+    CANx->RF1R |= CAN_RF1R_RFOM1;
+  }
+}
+
+/**
+  * @brief  Returns the number of pending received messages.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
+  * @retval NbMessage : which is the number of pending message.
+  */
+uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
+{
+  uint8_t message_pending=0;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FIFO(FIFONumber));
+  if (FIFONumber == CAN_FIFO0)
+  {
+    message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
+  }
+  else if (FIFONumber == CAN_FIFO1)
+  {
+    message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
+  }
+  else
+  {
+    message_pending = 0;
+  }
+  return message_pending;
+}
+/**
+  * @}
+  */
+
+
+/** @defgroup CAN_Group4 CAN Operation modes functions
+ *  @brief    CAN Operation modes functions 
+ *
+@verbatim    
+ ===============================================================================
+                    ##### CAN Operation modes functions #####
+ ===============================================================================  
+    [..] This section provides functions allowing to select the CAN Operation modes
+      (+) sleep mode
+      (+) normal mode 
+      (+) initialization mode
+   
+@endverbatim
+  * @{
+  */
+  
+  
+/**
+  * @brief  Selects the CAN Operation mode.
+  * @param  CAN_OperatingMode: CAN Operating Mode.
+  *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
+  * @retval status of the requested mode which can be 
+  *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
+  *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
+  */
+uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
+{
+  uint8_t status = CAN_ModeStatus_Failed;
+  
+  /* Timeout for INAK or also for SLAK bits*/
+  uint32_t timeout = INAK_TIMEOUT; 
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
+
+  if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
+  {
+    /* Request initialisation */
+    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
+
+    /* Wait the acknowledge */
+    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
+    {
+      timeout--;
+    }
+    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
+    {
+      status = CAN_ModeStatus_Failed;
+    }
+    else
+    {
+      status = CAN_ModeStatus_Success;
+    }
+  }
+  else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
+  {
+    /* Request leave initialisation and sleep mode  and enter Normal mode */
+    CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
+
+    /* Wait the acknowledge */
+    while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
+    {
+      timeout--;
+    }
+    if ((CANx->MSR & CAN_MODE_MASK) != 0)
+    {
+      status = CAN_ModeStatus_Failed;
+    }
+    else
+    {
+      status = CAN_ModeStatus_Success;
+    }
+  }
+  else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
+  {
+    /* Request Sleep mode */
+    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
+
+    /* Wait the acknowledge */
+    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
+    {
+      timeout--;
+    }
+    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
+    {
+      status = CAN_ModeStatus_Failed;
+    }
+    else
+    {
+      status = CAN_ModeStatus_Success;
+    }
+  }
+  else
+  {
+    status = CAN_ModeStatus_Failed;
+  }
+
+  return  (uint8_t) status;
+}
+
+/**
+  * @brief  Enters the Sleep (low power) mode.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
+  */
+uint8_t CAN_Sleep(CAN_TypeDef* CANx)
+{
+  uint8_t sleepstatus = CAN_Sleep_Failed;
+  
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+    
+  /* Request Sleep mode */
+   CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
+   
+  /* Sleep mode status */
+  if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
+  {
+    /* Sleep mode not entered */
+    sleepstatus =  CAN_Sleep_Ok;
+  }
+  /* return sleep mode status */
+   return (uint8_t)sleepstatus;
+}
+
+/**
+  * @brief  Wakes up the CAN peripheral from sleep mode .
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
+  */
+uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
+{
+  uint32_t wait_slak = SLAK_TIMEOUT;
+  uint8_t wakeupstatus = CAN_WakeUp_Failed;
+  
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+    
+  /* Wake up request */
+  CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
+    
+  /* Sleep mode status */
+  while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
+  {
+   wait_slak--;
+  }
+  if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
+  {
+   /* wake up done : Sleep mode exited */
+    wakeupstatus = CAN_WakeUp_Ok;
+  }
+  /* return wakeup status */
+  return (uint8_t)wakeupstatus;
+}
+/**
+  * @}
+  */
+
+
+/** @defgroup CAN_Group5 CAN Bus Error management functions
+ *  @brief    CAN Bus Error management functions 
+ *
+@verbatim    
+ ===============================================================================
+                ##### CAN Bus Error management functions #####
+ ===============================================================================  
+    [..] This section provides functions allowing to 
+      (+) Return the CANx's last error code (LEC)
+      (+) Return the CANx Receive Error Counter (REC)
+      (+) Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
+   
+      -@- If TEC is greater than 255, The CAN is in bus-off state.
+      -@- if REC or TEC are greater than 96, an Error warning flag occurs.
+      -@- if REC or TEC are greater than 127, an Error Passive Flag occurs.
+                        
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Returns the CANx's last error code (LEC).
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @retval Error code: 
+  *          - CAN_ERRORCODE_NoErr: No Error  
+  *          - CAN_ERRORCODE_StuffErr: Stuff Error
+  *          - CAN_ERRORCODE_FormErr: Form Error
+  *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
+  *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
+  *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
+  *          - CAN_ERRORCODE_CRCErr: CRC Error
+  *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
+  */
+uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
+{
+  uint8_t errorcode=0;
+  
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  
+  /* Get the error code*/
+  errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
+  
+  /* Return the error code*/
+  return errorcode;
+}
+
+/**
+  * @brief  Returns the CANx Receive Error Counter (REC).
+  * @note   In case of an error during reception, this counter is incremented 
+  *         by 1 or by 8 depending on the error condition as defined by the CAN 
+  *         standard. After every successful reception, the counter is 
+  *         decremented by 1 or reset to 120 if its value was higher than 128. 
+  *         When the counter value exceeds 127, the CAN controller enters the 
+  *         error passive state.  
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
+  * @retval CAN Receive Error Counter. 
+  */
+uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
+{
+  uint8_t counter=0;
+  
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  
+  /* Get the Receive Error Counter*/
+  counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
+  
+  /* Return the Receive Error Counter*/
+  return counter;
+}
+
+
+/**
+  * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @retval LSB of the 9-bit CAN Transmit Error Counter. 
+  */
+uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
+{
+  uint8_t counter=0;
+  
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  
+  /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
+  counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
+  
+  /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
+  return counter;
+}
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Group6 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+              ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+     [..] This section provides functions allowing to configure the CAN Interrupts 
+          and to get the status and clear flags and Interrupts pending bits.
+  
+          The CAN provides 14 Interrupts sources and 15 Flags:
+
+   
+  *** Flags ***
+  =============
+    [..] The 15 flags can be divided on 4 groups: 
+
+      (+) Transmit Flags
+        (++) CAN_FLAG_RQCP0, 
+        (++) CAN_FLAG_RQCP1, 
+        (++) CAN_FLAG_RQCP2  : Request completed MailBoxes 0, 1 and 2  Flags
+                               Set when when the last request (transmit or abort)
+                               has been performed. 
+
+      (+) Receive Flags
+
+
+        (++) CAN_FLAG_FMP0,
+        (++) CAN_FLAG_FMP1   : FIFO 0 and 1 Message Pending Flags 
+                               set to signal that messages are pending in the receive 
+                               FIFO.
+                               These Flags are cleared only by hardware. 
+
+        (++) CAN_FLAG_FF0,
+        (++) CAN_FLAG_FF1    : FIFO 0 and 1 Full Flags
+                               set when three messages are stored in the selected 
+                               FIFO.                        
+
+        (++) CAN_FLAG_FOV0              
+        (++) CAN_FLAG_FOV1   : FIFO 0 and 1 Overrun Flags
+                               set when a new message has been received and passed 
+                               the filter while the FIFO was full.         
+
+      (+) Operating Mode Flags
+
+        (++) CAN_FLAG_WKU    : Wake up Flag
+                               set to signal that a SOF bit has been detected while 
+                               the CAN hardware was in Sleep mode. 
+        
+        (++) CAN_FLAG_SLAK   : Sleep acknowledge Flag
+                               Set to signal that the CAN has entered Sleep Mode. 
+    
+      (+) Error Flags
+
+        (++) CAN_FLAG_EWG    : Error Warning Flag
+                               Set when the warning limit has been reached (Receive 
+                               Error Counter or Transmit Error Counter greater than 96). 
+                               This Flag is cleared only by hardware.
+                            
+        (++) CAN_FLAG_EPV    : Error Passive Flag
+                               Set when the Error Passive limit has been reached 
+                               (Receive Error Counter or Transmit Error Counter 
+                               greater than 127).
+                               This Flag is cleared only by hardware.
+                             
+        (++) CAN_FLAG_BOF    : Bus-Off Flag
+                               set when CAN enters the bus-off state. The bus-off 
+                               state is entered on TEC overflow, greater than 255.
+                               This Flag is cleared only by hardware.
+                                   
+        (++) CAN_FLAG_LEC    : Last error code Flag
+                               set If a message has been transferred (reception or
+                               transmission) with error, and the error code is hold.              
+                           
+  *** Interrupts ***
+  ==================
+    [..] The 14 interrupts can be divided on 4 groups: 
+  
+      (+) Transmit interrupt
+  
+        (++) CAN_IT_TME   :  Transmit mailbox empty Interrupt
+                             if enabled, this interrupt source is pending when 
+                             no transmit request are pending for Tx mailboxes.      
+
+      (+) Receive Interrupts
+         
+        (++) CAN_IT_FMP0,
+        (++) CAN_IT_FMP1    :  FIFO 0 and FIFO1 message pending Interrupts
+                               if enabled, these interrupt sources are pending 
+                               when messages are pending in the receive FIFO.
+                               The corresponding interrupt pending bits are cleared 
+                               only by hardware.
+                
+        (++) CAN_IT_FF0,              
+        (++) CAN_IT_FF1     :  FIFO 0 and FIFO1 full Interrupts
+                               if enabled, these interrupt sources are pending 
+                               when three messages are stored in the selected FIFO.
+        
+        (++) CAN_IT_FOV0,        
+        (++) CAN_IT_FOV1    :  FIFO 0 and FIFO1 overrun Interrupts        
+                               if enabled, these interrupt sources are pending 
+                               when a new message has been received and passed 
+                               the filter while the FIFO was full.
+
+      (+) Operating Mode Interrupts
+         
+        (++) CAN_IT_WKU     :  Wake-up Interrupt
+                               if enabled, this interrupt source is pending when 
+                               a SOF bit has been detected while the CAN hardware 
+                               was in Sleep mode.
+                                  
+        (++) CAN_IT_SLK     :  Sleep acknowledge Interrupt
+                               if enabled, this interrupt source is pending when 
+                               the CAN has entered Sleep Mode.       
+
+      (+) Error Interrupts 
+        
+        (++) CAN_IT_EWG     :  Error warning Interrupt 
+                               if enabled, this interrupt source is pending when
+                               the warning limit has been reached (Receive Error 
+                               Counter or Transmit Error Counter=96). 
+                               
+        (++) CAN_IT_EPV     :  Error passive Interrupt        
+                               if enabled, this interrupt source is pending when
+                               the Error Passive limit has been reached (Receive 
+                               Error Counter or Transmit Error Counter>127).
+                          
+        (++) CAN_IT_BOF     :  Bus-off Interrupt
+                               if enabled, this interrupt source is pending when
+                               CAN enters the bus-off state. The bus-off state is 
+                               entered on TEC overflow, greater than 255.
+                               This Flag is cleared only by hardware.
+                                  
+        (++) CAN_IT_LEC     :  Last error code Interrupt        
+                               if enabled, this interrupt source is pending  when
+                               a message has been transferred (reception or
+                               transmission) with error, and the error code is hold.
+                          
+        (++) CAN_IT_ERR     :  Error Interrupt
+                               if enabled, this interrupt source is pending when 
+                               an error condition is pending.      
+                      
+    [..] Managing the CAN controller events :
+ 
+         The user should identify which mode will be used in his application to 
+         manage the CAN controller events: Polling mode or Interrupt mode.
+  
+      (#) In the Polling Mode it is advised to use the following functions:
+        (++) CAN_GetFlagStatus() : to check if flags events occur. 
+        (++) CAN_ClearFlag()     : to clear the flags events.
+  
+
+  
+      (#) In the Interrupt Mode it is advised to use the following functions:
+        (++) CAN_ITConfig()       : to enable or disable the interrupt source.
+        (++) CAN_GetITStatus()    : to check if Interrupt occurs.
+        (++) CAN_ClearITPendingBit() : to clear the Interrupt pending Bit 
+            (corresponding Flag).
+        -@@-  This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
+             pending bits since there are cleared only by hardware. 
+  
+@endverbatim
+  * @{
+  */ 
+/**
+  * @brief  Enables or disables the specified CANx interrupts.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
+  *          This parameter can be: 
+  *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
+  *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
+  *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
+  *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
+  *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
+  *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
+  *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
+  *            @arg CAN_IT_WKU: Wake-up Interrupt
+  *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
+  *            @arg CAN_IT_EWG: Error warning Interrupt
+  *            @arg CAN_IT_EPV: Error passive Interrupt
+  *            @arg CAN_IT_BOF: Bus-off Interrupt  
+  *            @arg CAN_IT_LEC: Last error code Interrupt
+  *            @arg CAN_IT_ERR: Error Interrupt
+  * @param  NewState: new state of the CAN interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_IT(CAN_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected CANx interrupt */
+    CANx->IER |= CAN_IT;
+  }
+  else
+  {
+    /* Disable the selected CANx interrupt */
+    CANx->IER &= ~CAN_IT;
+  }
+}
+/**
+  * @brief  Checks whether the specified CAN flag is set or not.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
+  *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
+  *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
+  *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
+  *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
+  *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
+  *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
+  *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
+  *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
+  *            @arg CAN_FLAG_WKU: Wake up Flag
+  *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
+  *            @arg CAN_FLAG_EWG: Error Warning Flag
+  *            @arg CAN_FLAG_EPV: Error Passive Flag  
+  *            @arg CAN_FLAG_BOF: Bus-Off Flag    
+  *            @arg CAN_FLAG_LEC: Last error code Flag      
+  * @retval The new state of CAN_FLAG (SET or RESET).
+  */
+FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
+  
+
+  if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
+  { 
+    /* Check the status of the specified CAN flag */
+    if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    { 
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    { 
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
+  { 
+    /* Check the status of the specified CAN flag */
+    if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    { 
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    { 
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
+  { 
+    /* Check the status of the specified CAN flag */
+    if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    { 
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    { 
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
+  { 
+    /* Check the status of the specified CAN flag */
+    if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    { 
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    { 
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
+  { 
+    /* Check the status of the specified CAN flag */
+    if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    { 
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    { 
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  /* Return the CAN_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the CAN's pending flags.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_FLAG: specifies the flag to clear.
+  *          This parameter can be one of the following values:
+  *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
+  *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
+  *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
+  *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
+  *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
+  *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
+  *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
+  *            @arg CAN_FLAG_WKU: Wake up Flag
+  *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
+  *            @arg CAN_FLAG_LEC: Last error code Flag        
+  * @retval None
+  */
+void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
+{
+  uint32_t flagtmp=0;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
+  
+  if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
+  {
+    /* Clear the selected CAN flags */
+    CANx->ESR = (uint32_t)RESET;
+  }
+  else /* MSR or TSR or RF0R or RF1R */
+  {
+    flagtmp = CAN_FLAG & 0x000FFFFF;
+
+    if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
+    {
+      /* Receive Flags */
+      CANx->RF0R = (uint32_t)(flagtmp);
+    }
+    else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
+    {
+      /* Receive Flags */
+      CANx->RF1R = (uint32_t)(flagtmp);
+    }
+    else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
+    {
+      /* Transmit Flags */
+      CANx->TSR = (uint32_t)(flagtmp);
+    }
+    else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
+    {
+      /* Operating mode Flags */
+      CANx->MSR = (uint32_t)(flagtmp);
+    }
+  }
+}
+
+/**
+  * @brief  Checks whether the specified CANx interrupt has occurred or not.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_IT: specifies the CAN interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
+  *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
+  *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
+  *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
+  *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
+  *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
+  *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
+  *            @arg CAN_IT_WKU: Wake-up Interrupt
+  *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
+  *            @arg CAN_IT_EWG: Error warning Interrupt
+  *            @arg CAN_IT_EPV: Error passive Interrupt
+  *            @arg CAN_IT_BOF: Bus-off Interrupt  
+  *            @arg CAN_IT_LEC: Last error code Interrupt
+  *            @arg CAN_IT_ERR: Error Interrupt
+  * @retval The current state of CAN_IT (SET or RESET).
+  */
+ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
+{
+  ITStatus itstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_IT(CAN_IT));
+  
+  /* check the interrupt enable bit */
+ if((CANx->IER & CAN_IT) != RESET)
+ {
+   /* in case the Interrupt is enabled, .... */
+    switch (CAN_IT)
+    {
+      case CAN_IT_TME:
+        /* Check CAN_TSR_RQCPx bits */
+        itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
+        break;
+      case CAN_IT_FMP0:
+        /* Check CAN_RF0R_FMP0 bit */
+        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
+        break;
+      case CAN_IT_FF0:
+        /* Check CAN_RF0R_FULL0 bit */
+        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
+        break;
+      case CAN_IT_FOV0:
+        /* Check CAN_RF0R_FOVR0 bit */
+        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
+        break;
+      case CAN_IT_FMP1:
+        /* Check CAN_RF1R_FMP1 bit */
+        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
+        break;
+      case CAN_IT_FF1:
+        /* Check CAN_RF1R_FULL1 bit */
+        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
+        break;
+      case CAN_IT_FOV1:
+        /* Check CAN_RF1R_FOVR1 bit */
+        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
+        break;
+      case CAN_IT_WKU:
+        /* Check CAN_MSR_WKUI bit */
+        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
+        break;
+      case CAN_IT_SLK:
+        /* Check CAN_MSR_SLAKI bit */
+        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
+        break;
+      case CAN_IT_EWG:
+        /* Check CAN_ESR_EWGF bit */
+        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
+        break;
+      case CAN_IT_EPV:
+        /* Check CAN_ESR_EPVF bit */
+        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
+        break;
+      case CAN_IT_BOF:
+        /* Check CAN_ESR_BOFF bit */
+        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
+        break;
+      case CAN_IT_LEC:
+        /* Check CAN_ESR_LEC bit */
+        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
+        break;
+      case CAN_IT_ERR:
+        /* Check CAN_MSR_ERRI bit */ 
+        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
+        break;
+      default:
+        /* in case of error, return RESET */
+        itstatus = RESET;
+        break;
+    }
+  }
+  else
+  {
+   /* in case the Interrupt is not enabled, return RESET */
+    itstatus  = RESET;
+  }
+  
+  /* Return the CAN_IT status */
+  return  itstatus;
+}
+
+/**
+  * @brief  Clears the CANx's interrupt pending bits.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_IT: specifies the interrupt pending bit to clear.
+  *          This parameter can be one of the following values:
+  *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
+  *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
+  *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
+  *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
+  *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
+  *            @arg CAN_IT_WKU: Wake-up Interrupt
+  *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
+  *            @arg CAN_IT_EWG: Error warning Interrupt
+  *            @arg CAN_IT_EPV: Error passive Interrupt
+  *            @arg CAN_IT_BOF: Bus-off Interrupt  
+  *            @arg CAN_IT_LEC: Last error code Interrupt
+  *            @arg CAN_IT_ERR: Error Interrupt 
+  * @retval None
+  */
+void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_CLEAR_IT(CAN_IT));
+
+  switch (CAN_IT)
+  {
+    case CAN_IT_TME:
+      /* Clear CAN_TSR_RQCPx (rc_w1)*/
+      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
+      break;
+    case CAN_IT_FF0:
+      /* Clear CAN_RF0R_FULL0 (rc_w1)*/
+      CANx->RF0R = CAN_RF0R_FULL0; 
+      break;
+    case CAN_IT_FOV0:
+      /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
+      CANx->RF0R = CAN_RF0R_FOVR0; 
+      break;
+    case CAN_IT_FF1:
+      /* Clear CAN_RF1R_FULL1 (rc_w1)*/
+      CANx->RF1R = CAN_RF1R_FULL1;  
+      break;
+    case CAN_IT_FOV1:
+      /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
+      CANx->RF1R = CAN_RF1R_FOVR1; 
+      break;
+    case CAN_IT_WKU:
+      /* Clear CAN_MSR_WKUI (rc_w1)*/
+      CANx->MSR = CAN_MSR_WKUI;  
+      break;
+    case CAN_IT_SLK:
+      /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
+      CANx->MSR = CAN_MSR_SLAKI;   
+      break;
+    case CAN_IT_EWG:
+      /* Clear CAN_MSR_ERRI (rc_w1) */
+      CANx->MSR = CAN_MSR_ERRI;
+       /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
+      break;
+    case CAN_IT_EPV:
+      /* Clear CAN_MSR_ERRI (rc_w1) */
+      CANx->MSR = CAN_MSR_ERRI; 
+       /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
+      break;
+    case CAN_IT_BOF:
+      /* Clear CAN_MSR_ERRI (rc_w1) */ 
+      CANx->MSR = CAN_MSR_ERRI; 
+       /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
+       break;
+    case CAN_IT_LEC:
+      /*  Clear LEC bits */
+      CANx->ESR = RESET; 
+      /* Clear CAN_MSR_ERRI (rc_w1) */
+      CANx->MSR = CAN_MSR_ERRI; 
+      break;
+    case CAN_IT_ERR:
+      /*Clear LEC bits */
+      CANx->ESR = RESET; 
+      /* Clear CAN_MSR_ERRI (rc_w1) */
+      CANx->MSR = CAN_MSR_ERRI; 
+       /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
+       break;
+    default:
+       break;
+   }
+}
+ /**
+  * @}
+  */
+
+/**
+  * @brief  Checks whether the CAN interrupt has occurred or not.
+  * @param  CAN_Reg: specifies the CAN interrupt register to check.
+  * @param  It_Bit: specifies the interrupt source bit to check.
+  * @retval The new state of the CAN Interrupt (SET or RESET).
+  */
+static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
+{
+  ITStatus pendingbitstatus = RESET;
+  
+  if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
+  {
+    /* CAN_IT is set */
+    pendingbitstatus = SET;
+  }
+  else
+  {
+    /* CAN_IT is reset */
+    pendingbitstatus = RESET;
+  }
+  return pendingbitstatus;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_crc.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_crc.c
new file mode 100644
index 0000000..be2cac9
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_crc.c
@@ -0,0 +1,133 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_crc.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides all the CRC firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_crc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CRC 
+  * @brief CRC driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup CRC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Resets the CRC Data register (DR).
+  * @param  None
+  * @retval None
+  */
+void CRC_ResetDR(void)
+{
+  /* Reset CRC generator */
+  CRC->CR = CRC_CR_RESET;
+}
+
+/**
+  * @brief  Computes the 32-bit CRC of a given data word(32-bit).
+  * @param  Data: data word(32-bit) to compute its CRC
+  * @retval 32-bit CRC
+  */
+uint32_t CRC_CalcCRC(uint32_t Data)
+{
+  CRC->DR = Data;
+  
+  return (CRC->DR);
+}
+
+/**
+  * @brief  Computes the 32-bit CRC of a given buffer of data word(32-bit).
+  * @param  pBuffer: pointer to the buffer containing the data to be computed
+  * @param  BufferLength: length of the buffer to be computed					
+  * @retval 32-bit CRC
+  */
+uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
+{
+  uint32_t index = 0;
+  
+  for(index = 0; index < BufferLength; index++)
+  {
+    CRC->DR = pBuffer[index];
+  }
+  return (CRC->DR);
+}
+
+/**
+  * @brief  Returns the current CRC value.
+  * @param  None
+  * @retval 32-bit CRC
+  */
+uint32_t CRC_GetCRC(void)
+{
+  return (CRC->DR);
+}
+
+/**
+  * @brief  Stores a 8-bit data in the Independent Data(ID) register.
+  * @param  IDValue: 8-bit value to be stored in the ID register 					
+  * @retval None
+  */
+void CRC_SetIDRegister(uint8_t IDValue)
+{
+  CRC->IDR = IDValue;
+}
+
+/**
+  * @brief  Returns the 8-bit data stored in the Independent Data(ID) register
+  * @param  None
+  * @retval 8-bit value of the ID register 
+  */
+uint8_t CRC_GetIDRegister(void)
+{
+  return (CRC->IDR);
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp.c
new file mode 100644
index 0000000..963e3ba
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp.c
@@ -0,0 +1,934 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_cryp.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the  Cryptographic processor (CRYP) peripheral:
+  *           + Initialization and Configuration functions
+  *           + Data treatment functions 
+  *           + Context swapping functions     
+  *           + DMA interface function       
+  *           + Interrupts and flags management       
+  *
+@verbatim
+ ===================================================================      
+                 ##### How to use this driver #####
+ =================================================================== 
+ [..]
+   (#) Enable the CRYP controller clock using 
+       RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_CRYP, ENABLE); function.
+  
+   (#) Initialise the CRYP using CRYP_Init(), CRYP_KeyInit() and if needed 
+       CRYP_IVInit(). 
+  
+   (#) Flush the IN and OUT FIFOs by using CRYP_FIFOFlush() function.
+  
+   (#) Enable the CRYP controller using the CRYP_Cmd() function. 
+  
+   (#) If using DMA for Data input and output transfer, activate the needed DMA 
+       Requests using CRYP_DMACmd() function 
+  
+   (#) If DMA is not used for data transfer, use CRYP_DataIn() and  CRYP_DataOut() 
+       functions to enter data to IN FIFO and get result from OUT FIFO.
+  
+   (#) To control CRYP events you can use one of the following two methods:
+       (++) Check on CRYP flags using the CRYP_GetFlagStatus() function.  
+       (++) Use CRYP interrupts through the function CRYP_ITConfig() at 
+            initialization phase and CRYP_GetITStatus() function into interrupt 
+            routines in processing phase.
+         
+   (#) Save and restore Cryptographic processor context using CRYP_SaveContext() 
+       and CRYP_RestoreContext() functions.     
+  
+  
+ *** Procedure to perform an encryption or a decryption ***
+ ========================================================== 
+  
+ *** Initialization ***
+ ====================== 
+ [..] 
+   (#) Initialize the peripheral using CRYP_Init(), CRYP_KeyInit() and CRYP_IVInit 
+       functions:
+       (++) Configure the key size (128-, 192- or 256-bit, in the AES only) 
+       (++) Enter the symmetric key 
+       (++) Configure the data type
+       (++) In case of decryption in AES-ECB or AES-CBC, you must prepare 
+            the key: configure the key preparation mode. Then Enable the CRYP 
+            peripheral using CRYP_Cmd() function: the BUSY flag is set. 
+            Wait until BUSY flag is reset : the key is prepared for decryption
+       (++) Configure the algorithm and chaining (the DES/TDES in ECB/CBC, the 
+            AES in ECB/CBC/CTR) 
+       (++) Configure the direction (encryption/decryption).
+       (++) Write the initialization vectors (in CBC or CTR modes only)
+  
+   (#) Flush the IN and OUT FIFOs using the CRYP_FIFOFlush() function
+  
+  
+  *** Basic Processing mode (polling mode) *** 
+  ============================================  
+  [..]
+    (#) Enable the cryptographic processor using CRYP_Cmd() function.
+  
+    (#) Write the first blocks in the input FIFO (2 to 8 words) using 
+        CRYP_DataIn() function.
+  
+    (#) Repeat the following sequence until the complete message has been 
+        processed:
+  
+        (++) Wait for flag CRYP_FLAG_OFNE occurs (using CRYP_GetFlagStatus() 
+            function), then read the OUT-FIFO using CRYP_DataOut() function
+            (1 block or until the FIFO is empty)
+  
+         (++) Wait for flag CRYP_FLAG_IFNF occurs, (using CRYP_GetFlagStatus() 
+            function then write the IN FIFO using CRYP_DataIn() function 
+            (1 block or until the FIFO is full)
+  
+    (#) At the end of the processing, CRYP_FLAG_BUSY flag will be reset and 
+          both FIFOs are empty (CRYP_FLAG_IFEM is set and CRYP_FLAG_OFNE is 
+          reset). You can disable the peripheral using CRYP_Cmd() function.
+  
+ *** Interrupts Processing mode *** 
+ ==================================
+ [..] In this mode, Processing is done when the data are transferred by the 
+      CPU during interrupts.
+  
+    (#) Enable the interrupts CRYP_IT_INI and CRYP_IT_OUTI using CRYP_ITConfig()
+        function.
+  
+    (#) Enable the cryptographic processor using CRYP_Cmd() function.
+  
+    (#) In the CRYP_IT_INI interrupt handler : load the input message into the 
+         IN FIFO using CRYP_DataIn() function . You can load 2 or 4 words at a 
+         time, or load data until the IN FIFO is full. When the last word of
+         the message has been entered into the IN FIFO, disable the CRYP_IT_INI 
+         interrupt (using CRYP_ITConfig() function).
+  
+    (#) In the CRYP_IT_OUTI interrupt handler : read the output message from 
+         the OUT FIFO using CRYP_DataOut() function. You can read 1 block (2 or 
+         4 words) at a time or read data until the FIFO is empty.
+         When the last word has been read, INIM=0, BUSY=0 and both FIFOs are 
+         empty (CRYP_FLAG_IFEM is set and CRYP_FLAG_OFNE is reset). 
+         You can disable the CRYP_IT_OUTI interrupt (using CRYP_ITConfig() 
+         function) and you can disable the peripheral using CRYP_Cmd() function.
+  
+ *** DMA Processing mode *** 
+ ===========================
+ [..] In this mode, Processing is done when the DMA is used to transfer the 
+      data from/to the memory.
+  
+    (#) Configure the DMA controller to transfer the input data from the 
+         memory using DMA_Init() function. 
+         The transfer length is the length of the message. 
+         As message padding is not managed by the peripheral, the message 
+         length must be an entire number of blocks. The data are transferred 
+         in burst mode. The burst length is 4 words in the AES and 2 or 4 
+         words in the DES/TDES. The DMA should be configured to set an 
+         interrupt on transfer completion of the output data to indicate that 
+         the processing is finished. 
+         Refer to DMA peripheral driver for more details.  
+  
+     (#) Enable the cryptographic processor using CRYP_Cmd() function. 
+         Enable the DMA requests CRYP_DMAReq_DataIN and CRYP_DMAReq_DataOUT 
+         using CRYP_DMACmd() function.
+  
+     (#) All the transfers and processing are managed by the DMA and the 
+         cryptographic processor. The DMA transfer complete interrupt indicates 
+         that the processing is complete. Both FIFOs are normally empty and 
+         CRYP_FLAG_BUSY flag is reset.
+  
+    @endverbatim
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_cryp.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CRYP 
+  * @brief CRYP driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define FLAG_MASK     ((uint8_t)0x20)
+#define MAX_TIMEOUT   ((uint16_t)0xFFFF)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup CRYP_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup CRYP_Group1 Initialization and Configuration functions
+ *  @brief    Initialization and Configuration functions 
+ *
+@verbatim    
+ ===============================================================================
+             ##### Initialization and Configuration functions #####
+ ===============================================================================  
+ [..] This section provides functions allowing to 
+   (+) Initialize the cryptographic Processor using CRYP_Init() function 
+       (++)  Encrypt or Decrypt 
+       (++)  mode : TDES-ECB, TDES-CBC, 
+                    DES-ECB, DES-CBC, 
+                    AES-ECB, AES-CBC, AES-CTR, AES-Key, AES-GCM, AES-CCM 
+       (++) DataType :  32-bit data, 16-bit data, bit data or bit-string
+       (++) Key Size (only in AES modes)
+   (+) Configure the Encrypt or Decrypt Key using CRYP_KeyInit() function 
+   (+) Configure the Initialization Vectors(IV) for CBC and CTR modes using 
+       CRYP_IVInit() function.  
+   (+) Flushes the IN and OUT FIFOs : using CRYP_FIFOFlush() function.                         
+   (+) Enable or disable the CRYP Processor using CRYP_Cmd() function 
+       
+@endverbatim
+  * @{
+  */
+/**
+  * @brief  Deinitializes the CRYP peripheral registers to their default reset values
+  * @param  None
+  * @retval None
+  */
+void CRYP_DeInit(void)
+{
+  /* Enable CRYP reset state */
+  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
+
+  /* Release CRYP from reset state */
+  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
+}
+
+/**
+  * @brief  Initializes the CRYP peripheral according to the specified parameters
+  *         in the CRYP_InitStruct.
+  * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure that contains
+  *         the configuration information for the CRYP peripheral.
+  * @retval None
+  */
+void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
+  assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
+  assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));
+
+  /* Select Algorithm mode*/  
+  CRYP->CR &= ~CRYP_CR_ALGOMODE;
+  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
+
+  /* Select dataType */ 
+  CRYP->CR &= ~CRYP_CR_DATATYPE;
+  CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
+
+  /* select Key size (used only with AES algorithm) */
+  if ((CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_ECB) &&
+      (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_CBC) &&
+      (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_ECB) &&
+      (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_CBC))
+  {
+    assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
+    CRYP->CR &= ~CRYP_CR_KEYSIZE;
+    CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
+                                                  configured once the key has 
+                                                  been prepared */
+  }
+
+  /* Select data Direction */ 
+  CRYP->CR &= ~CRYP_CR_ALGODIR;
+  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
+}
+
+/**
+  * @brief  Fills each CRYP_InitStruct member with its default value.
+  * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
+{
+  /* Initialize the CRYP_AlgoDir member */
+  CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
+
+  /* initialize the CRYP_AlgoMode member */
+  CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
+
+  /* initialize the CRYP_DataType member */
+  CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
+  
+  /* Initialize the CRYP_KeySize member */
+  CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
+}
+
+/**
+  * @brief  Initializes the CRYP Keys according to the specified parameters in
+  *         the CRYP_KeyInitStruct.
+  * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure that
+  *         contains the configuration information for the CRYP Keys.
+  * @retval None
+  */
+void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
+{
+  /* Key Initialisation */
+  CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
+  CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
+  CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
+  CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
+  CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
+  CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
+  CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
+  CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
+}
+
+/**
+  * @brief  Fills each CRYP_KeyInitStruct member with its default value.
+  * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure 
+  *         which will be initialized.
+  * @retval None
+  */
+void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
+{
+  CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
+  CRYP_KeyInitStruct->CRYP_Key0Right = 0;
+  CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
+  CRYP_KeyInitStruct->CRYP_Key1Right = 0;
+  CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
+  CRYP_KeyInitStruct->CRYP_Key2Right = 0;
+  CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
+  CRYP_KeyInitStruct->CRYP_Key3Right = 0;
+}
+/**
+  * @brief  Initializes the CRYP Initialization Vectors(IV) according to the
+  *         specified parameters in the CRYP_IVInitStruct.
+  * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef structure that contains
+  *         the configuration information for the CRYP Initialization Vectors(IV).
+  * @retval None
+  */
+void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
+{
+  CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
+  CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
+  CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
+  CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
+}
+
+/**
+  * @brief  Fills each CRYP_IVInitStruct member with its default value.
+  * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef Initialization 
+  *         Vectors(IV) structure which will be initialized.
+  * @retval None
+  */
+void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
+{
+  CRYP_IVInitStruct->CRYP_IV0Left  = 0;
+  CRYP_IVInitStruct->CRYP_IV0Right = 0;
+  CRYP_IVInitStruct->CRYP_IV1Left  = 0;
+  CRYP_IVInitStruct->CRYP_IV1Right = 0;
+}
+
+/**
+  * @brief  Configures the AES-CCM and AES-GCM phases
+  * @note   This function is used only with AES-CCM or AES-GCM Algorithms  
+  * @param  CRYP_Phase: specifies the CRYP AES-CCM and AES-GCM phase to be configured.
+  *           This parameter can be one of the following values:
+  *            @arg CRYP_Phase_Init: Initialization phase
+  *            @arg CRYP_Phase_Header: Header phase
+  *            @arg CRYP_Phase_Payload: Payload phase
+  *            @arg CRYP_Phase_Final: Final phase 
+  * @retval None
+  */
+void CRYP_PhaseConfig(uint32_t CRYP_Phase)
+{ uint32_t tempcr = 0;
+
+  /* Check the parameter */
+  assert_param(IS_CRYP_PHASE(CRYP_Phase));
+
+  /* Get the CR register */
+  tempcr = CRYP->CR;
+  
+  /* Reset the phase configuration bits: GCMP_CCMPH */
+  tempcr &= (uint32_t)(~CRYP_CR_GCM_CCMPH);
+  /* Set the selected phase */
+  tempcr |= (uint32_t)CRYP_Phase;
+
+  /* Set the CR register */ 
+  CRYP->CR = tempcr;    
+}
+
+/**
+  * @brief  Flushes the IN and OUT FIFOs (that is read and write pointers of the 
+  *         FIFOs are reset)
+  * @note   The FIFOs must be flushed only when BUSY flag is reset.  
+  * @param  None
+  * @retval None
+  */
+void CRYP_FIFOFlush(void)
+{
+  /* Reset the read and write pointers of the FIFOs */
+  CRYP->CR |= CRYP_CR_FFLUSH;
+}
+
+/**
+  * @brief  Enables or disables the CRYP peripheral.
+  * @param  NewState: new state of the CRYP peripheral.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void CRYP_Cmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the Cryptographic processor */
+    CRYP->CR |= CRYP_CR_CRYPEN;
+  }
+  else
+  {
+    /* Disable the Cryptographic processor */
+    CRYP->CR &= ~CRYP_CR_CRYPEN;
+  }
+}
+/**
+  * @}
+  */
+  
+/** @defgroup CRYP_Group2 CRYP Data processing functions
+ *  @brief    CRYP Data processing functions
+ *
+@verbatim    
+ ===============================================================================
+                    ##### CRYP Data processing functions #####
+ ===============================================================================  
+ [..] This section provides functions allowing the encryption and decryption 
+      operations: 
+   (+) Enter data to be treated in the IN FIFO : using CRYP_DataIn() function.
+   (+) Get the data result from the OUT FIFO : using CRYP_DataOut() function.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Writes data in the Data Input register (DIN).
+  * @note   After the DIN register has been read once or several times, 
+  *         the FIFO must be flushed (using CRYP_FIFOFlush() function).  
+  * @param  Data: data to write in Data Input register
+  * @retval None
+  */
+void CRYP_DataIn(uint32_t Data)
+{
+  CRYP->DR = Data;
+}
+
+/**
+  * @brief  Returns the last data entered into the output FIFO.
+  * @param  None
+  * @retval Last data entered into the output FIFO.
+  */
+uint32_t CRYP_DataOut(void)
+{
+  return CRYP->DOUT;
+}
+/**
+  * @}
+  */
+  
+/** @defgroup CRYP_Group3 Context swapping functions
+ *  @brief   Context swapping functions
+ *
+@verbatim   
+ ===============================================================================
+                      ##### Context swapping functions #####
+ ===============================================================================  
+ [..] This section provides functions allowing to save and store CRYP Context
+
+ [..] It is possible to interrupt an encryption/ decryption/ key generation process 
+      to perform another processing with a higher priority, and to complete the 
+      interrupted process later on, when the higher-priority task is complete. To do 
+      so, the context of the interrupted task must be saved from the CRYP registers 
+      to memory, and then be restored from memory to the CRYP registers.
+   
+   (#) To save the current context, use CRYP_SaveContext() function
+   (#) To restore the saved context, use CRYP_RestoreContext() function 
+
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Saves the CRYP peripheral Context. 
+  * @note   This function stops DMA transfer before to save the context. After 
+  *         restoring the context, you have to enable the DMA again (if the DMA
+  *         was previously used).
+  * @param  CRYP_ContextSave: pointer to a CRYP_Context structure that contains
+  *         the repository for current context.
+  * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure that 
+  *         contains the configuration information for the CRYP Keys.  
+  * @retval None
+  */
+ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
+                             CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
+{
+  __IO uint32_t timeout = 0;
+  uint32_t ckeckmask = 0, bitstatus;    
+  ErrorStatus status = ERROR;
+
+  /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
+  CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
+    
+  /* Wait until both the IN and OUT FIFOs are empty  
+    (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
+     BUSY bit is cleared. */
+
+  if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
+  { 
+    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
+  }
+  else /* AES or DES */
+  {
+    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
+  }           
+   
+  do 
+  {
+    bitstatus = CRYP->SR & ckeckmask;
+    timeout++;
+  }
+  while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
+     
+  if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
+  {
+    status = ERROR;
+  }
+  else
+  {      
+    /* Stop DMA transfers on the OUT FIFO by 
+       - writing the DOEN bit to 0 in the CRYP_DMACR register 
+       - and clear the CRYPEN bit. */
+
+    CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
+    CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
+
+    /* Save the current configuration (bit 19, bit[17:16] and bits [9:2] in the CRYP_CR register) */
+    CRYP_ContextSave->CR_CurrentConfig  = CRYP->CR & (CRYP_CR_GCM_CCMPH |
+                                                      CRYP_CR_KEYSIZE  |
+                                                      CRYP_CR_DATATYPE |
+                                                      CRYP_CR_ALGOMODE |
+                                                      CRYP_CR_ALGODIR);
+
+    /* and, if not in ECB mode, the initialization vectors. */
+    CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
+    CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
+    CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
+    CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
+
+    /* save The key value */
+    CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
+    CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
+    CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
+    CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
+    CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
+    CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
+    CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
+    CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
+
+    /* Save the content of context swap registers */
+    CRYP_ContextSave->CRYP_CSGCMCCMR[0] = CRYP->CSGCMCCM0R;
+    CRYP_ContextSave->CRYP_CSGCMCCMR[1] = CRYP->CSGCMCCM1R;
+    CRYP_ContextSave->CRYP_CSGCMCCMR[2] = CRYP->CSGCMCCM2R;
+    CRYP_ContextSave->CRYP_CSGCMCCMR[3] = CRYP->CSGCMCCM3R;
+    CRYP_ContextSave->CRYP_CSGCMCCMR[4] = CRYP->CSGCMCCM4R;
+    CRYP_ContextSave->CRYP_CSGCMCCMR[5] = CRYP->CSGCMCCM5R;
+    CRYP_ContextSave->CRYP_CSGCMCCMR[6] = CRYP->CSGCMCCM6R;
+    CRYP_ContextSave->CRYP_CSGCMCCMR[7] = CRYP->CSGCMCCM7R;
+    
+    CRYP_ContextSave->CRYP_CSGCMR[0] = CRYP->CSGCM0R;
+    CRYP_ContextSave->CRYP_CSGCMR[1] = CRYP->CSGCM1R;
+    CRYP_ContextSave->CRYP_CSGCMR[2] = CRYP->CSGCM2R;
+    CRYP_ContextSave->CRYP_CSGCMR[3] = CRYP->CSGCM3R;
+    CRYP_ContextSave->CRYP_CSGCMR[4] = CRYP->CSGCM4R;
+    CRYP_ContextSave->CRYP_CSGCMR[5] = CRYP->CSGCM5R;
+    CRYP_ContextSave->CRYP_CSGCMR[6] = CRYP->CSGCM6R;
+    CRYP_ContextSave->CRYP_CSGCMR[7] = CRYP->CSGCM7R;
+    
+   /* When needed, save the DMA status (pointers for IN and OUT messages, 
+      number of remaining bytes, etc.) */
+     
+    status = SUCCESS;
+  }
+
+   return status;
+}
+
+/**
+  * @brief  Restores the CRYP peripheral Context.
+  * @note   Since teh DMA transfer is stopped in CRYP_SaveContext() function,
+  *         after restoring the context, you have to enable the DMA again (if the
+  *         DMA was previously used).  
+  * @param  CRYP_ContextRestore: pointer to a CRYP_Context structure that contains
+  *         the repository for saved context.
+  * @note   The data that were saved during context saving must be rewrited into
+  *         the IN FIFO.
+  * @retval None
+  */
+void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
+{
+
+  /* Configure the processor with the saved configuration */
+  CRYP->CR = CRYP_ContextRestore->CR_CurrentConfig;
+
+  /* restore The key value */
+  CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
+  CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
+  CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
+  CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
+  CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
+  CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
+  CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
+  CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
+
+  /* and the initialization vectors. */
+  CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
+  CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
+  CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
+  CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
+
+  /* Restore the content of context swap registers */
+  CRYP->CSGCMCCM0R = CRYP_ContextRestore->CRYP_CSGCMCCMR[0];
+  CRYP->CSGCMCCM1R = CRYP_ContextRestore->CRYP_CSGCMCCMR[1];
+  CRYP->CSGCMCCM2R = CRYP_ContextRestore->CRYP_CSGCMCCMR[2];
+  CRYP->CSGCMCCM3R = CRYP_ContextRestore->CRYP_CSGCMCCMR[3];
+  CRYP->CSGCMCCM4R = CRYP_ContextRestore->CRYP_CSGCMCCMR[4];
+  CRYP->CSGCMCCM5R = CRYP_ContextRestore->CRYP_CSGCMCCMR[5];
+  CRYP->CSGCMCCM6R = CRYP_ContextRestore->CRYP_CSGCMCCMR[6];
+  CRYP->CSGCMCCM7R = CRYP_ContextRestore->CRYP_CSGCMCCMR[7];
+  
+  CRYP->CSGCM0R = CRYP_ContextRestore->CRYP_CSGCMR[0];
+  CRYP->CSGCM1R = CRYP_ContextRestore->CRYP_CSGCMR[1];
+  CRYP->CSGCM2R = CRYP_ContextRestore->CRYP_CSGCMR[2];
+  CRYP->CSGCM3R = CRYP_ContextRestore->CRYP_CSGCMR[3];
+  CRYP->CSGCM4R = CRYP_ContextRestore->CRYP_CSGCMR[4];
+  CRYP->CSGCM5R = CRYP_ContextRestore->CRYP_CSGCMR[5];
+  CRYP->CSGCM6R = CRYP_ContextRestore->CRYP_CSGCMR[6];
+  CRYP->CSGCM7R = CRYP_ContextRestore->CRYP_CSGCMR[7];
+  
+  /* Enable the cryptographic processor */
+  CRYP->CR |= CRYP_CR_CRYPEN;
+}
+/**
+  * @}
+  */
+
+/** @defgroup CRYP_Group4 CRYP's DMA interface Configuration function
+ *  @brief   CRYP's DMA interface Configuration function 
+ *
+@verbatim   
+ ===============================================================================
+             ##### CRYP's DMA interface Configuration function #####
+ ===============================================================================  
+ [..] This section provides functions allowing to configure the DMA interface for 
+      CRYP data input and output transfer.
+   
+ [..] When the DMA mode is enabled (using the CRYP_DMACmd() function), data can be 
+      transferred:
+   (+) From memory to the CRYP IN FIFO using the DMA peripheral by enabling 
+       the CRYP_DMAReq_DataIN request.
+   (+) From the CRYP OUT FIFO to the memory using the DMA peripheral by enabling 
+       the CRYP_DMAReq_DataOUT request.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the CRYP DMA interface.
+  * @param  CRYP_DMAReq: specifies the CRYP DMA transfer request to be enabled or disabled.
+  *           This parameter can be any combination of the following values:
+  *            @arg CRYP_DMAReq_DataOUT: DMA for outgoing(Tx) data transfer
+  *            @arg CRYP_DMAReq_DataIN: DMA for incoming(Rx) data transfer
+  * @param  NewState: new state of the selected CRYP DMA transfer request.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected CRYP DMA request */
+    CRYP->DMACR |= CRYP_DMAReq;
+  }
+  else
+  {
+    /* Disable the selected CRYP DMA request */
+    CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup CRYP_Group5 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+              ##### Interrupts and flags management functions #####
+ ===============================================================================  
+ 
+ [..] This section provides functions allowing to configure the CRYP Interrupts and 
+      to get the status and Interrupts pending bits.
+
+ [..] The CRYP provides 2 Interrupts sources and 7 Flags:
+
+ *** Flags : ***
+ ===============
+ [..] 
+   (#) CRYP_FLAG_IFEM :  Set when Input FIFO is empty. This Flag is cleared only
+       by hardware.
+      
+   (#) CRYP_FLAG_IFNF :  Set when Input FIFO is not full. This Flag is cleared 
+       only by hardware.
+
+
+   (#) CRYP_FLAG_INRIS  : Set when Input FIFO Raw interrupt is pending it gives 
+       the raw interrupt state prior to masking of the input FIFO service interrupt.
+       This Flag is cleared only by hardware.
+     
+   (#) CRYP_FLAG_OFNE   : Set when Output FIFO not empty. This Flag is cleared 
+       only by hardware.
+        
+   (#) CRYP_FLAG_OFFU   : Set when Output FIFO is full. This Flag is cleared only 
+       by hardware.
+                           
+   (#) CRYP_FLAG_OUTRIS : Set when Output FIFO Raw interrupt is pending it gives 
+       the raw interrupt state prior to masking of the output FIFO service interrupt.
+       This Flag is cleared only by hardware.
+                               
+   (#) CRYP_FLAG_BUSY   : Set when the CRYP core is currently processing a block 
+       of data or a key preparation (for AES decryption). This Flag is cleared 
+       only by hardware. To clear it, the CRYP core must be disabled and the last
+       processing has completed. 
+
+ *** Interrupts : ***
+ ====================
+ [..]
+   (#) CRYP_IT_INI   : The input FIFO service interrupt is asserted when there 
+      are less than 4 words in the input FIFO. This interrupt is associated to 
+      CRYP_FLAG_INRIS flag.
+
+      -@- This interrupt is cleared by performing write operations to the input FIFO 
+          until it holds 4 or more words. The input FIFO service interrupt INMIS is 
+          enabled with the CRYP enable bit. Consequently, when CRYP is disabled, the 
+          INMIS signal is low even if the input FIFO is empty.
+
+
+
+   (#) CRYP_IT_OUTI  : The output FIFO service interrupt is asserted when there 
+       is one or more (32-bit word) data items in the output FIFO. This interrupt 
+       is associated to CRYP_FLAG_OUTRIS flag.
+
+       -@- This interrupt is cleared by reading data from the output FIFO until there 
+           is no valid (32-bit) word left (that is, the interrupt follows the state 
+           of the OFNE (output FIFO not empty) flag).
+
+ *** Managing the CRYP controller events : ***
+ =============================================
+ [..] The user should identify which mode will be used in his application to manage 
+      the CRYP controller events: Polling mode or Interrupt mode.
+
+   (#) In the Polling Mode it is advised to use the following functions:
+       (++) CRYP_GetFlagStatus() : to check if flags events occur. 
+
+       -@@- The CRYPT flags do not need to be cleared since they are cleared as 
+            soon as the associated event are reset.   
+
+
+   (#) In the Interrupt Mode it is advised to use the following functions:
+       (++) CRYP_ITConfig()       : to enable or disable the interrupt source.
+       (++) CRYP_GetITStatus()    : to check if Interrupt occurs.
+
+       -@@- The CRYPT interrupts have no pending bits, the interrupt is cleared as 
+             soon as the associated event is reset. 
+
+@endverbatim
+  * @{
+  */ 
+
+/**
+  * @brief  Enables or disables the specified CRYP interrupts.
+  * @param  CRYP_IT: specifies the CRYP interrupt source to be enabled or disabled.
+  *          This parameter can be any combination of the following values:
+  *            @arg CRYP_IT_INI: Input FIFO interrupt
+  *            @arg CRYP_IT_OUTI: Output FIFO interrupt
+  * @param  NewState: new state of the specified CRYP interrupt.
+  *           This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected CRYP interrupt */
+    CRYP->IMSCR |= CRYP_IT;
+  }
+  else
+  {
+    /* Disable the selected CRYP interrupt */
+    CRYP->IMSCR &= (uint8_t)~CRYP_IT;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified CRYP interrupt has occurred or not.
+  * @note   This function checks the status of the masked interrupt (i.e the 
+  *         interrupt should be previously enabled).     
+  * @param  CRYP_IT: specifies the CRYP (masked) interrupt source to check.
+  *           This parameter can be one of the following values:
+  *            @arg CRYP_IT_INI: Input FIFO interrupt
+  *            @arg CRYP_IT_OUTI: Output FIFO interrupt
+  * @retval The new state of CRYP_IT (SET or RESET).
+  */
+ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
+{
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_CRYP_GET_IT(CRYP_IT));
+
+  /* Check the status of the specified CRYP interrupt */
+  if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
+  {
+    /* CRYP_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* CRYP_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the CRYP_IT status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Returns whether CRYP peripheral is enabled or disabled.
+  * @param  none.
+  * @retval Current state of the CRYP peripheral (ENABLE or DISABLE).
+  */
+FunctionalState CRYP_GetCmdStatus(void)
+{
+  FunctionalState state = DISABLE;
+
+  if ((CRYP->CR & CRYP_CR_CRYPEN) != 0)
+  {
+    /* CRYPEN bit is set */
+    state = ENABLE;
+  }
+  else
+  {
+    /* CRYPEN bit is reset */
+    state = DISABLE;
+  }
+  return state;
+}
+
+/**
+  * @brief  Checks whether the specified CRYP flag is set or not.
+  * @param  CRYP_FLAG: specifies the CRYP flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg CRYP_FLAG_IFEM: Input FIFO Empty flag.
+  *            @arg CRYP_FLAG_IFNF: Input FIFO Not Full flag.
+  *            @arg CRYP_FLAG_OFNE: Output FIFO Not Empty flag.
+  *            @arg CRYP_FLAG_OFFU: Output FIFO Full flag.
+  *            @arg CRYP_FLAG_BUSY: Busy flag.
+  *            @arg CRYP_FLAG_OUTRIS: Output FIFO raw interrupt flag.
+  *            @arg CRYP_FLAG_INRIS: Input FIFO raw interrupt flag.
+  * @retval The new state of CRYP_FLAG (SET or RESET).
+  */
+FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t tempreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));
+
+  /* check if the FLAG is in RISR register */
+  if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
+  {
+    tempreg = CRYP->RISR;
+  }
+  else  /* The FLAG is in SR register */
+  {
+    tempreg = CRYP->SR;
+  }
+
+
+  /* Check the status of the specified CRYP flag */
+  if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
+  {
+    /* CRYP_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* CRYP_FLAG is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the CRYP_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_aes.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_aes.c
new file mode 100644
index 0000000..efcab7b
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_aes.c
@@ -0,0 +1,1707 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_cryp_aes.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides high level functions to encrypt and decrypt an 
+  *          input message using AES in ECB/CBC/CTR/GCM/CCM modes.
+  *          It uses the stm32f4xx_cryp.c/.h drivers to access the STM32F4xx CRYP
+  *          peripheral.
+  *          AES-ECB/CBC/CTR/GCM/CCM modes are available on STM32F437x Devices.
+  *          For STM32F41xx Devices, only AES-ECB/CBC/CTR modes are available.
+  *
+@verbatim
+ ===================================================================
+                  ##### How to use this driver #####
+ ===================================================================
+ [..]
+   (#) Enable The CRYP controller clock using 
+      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_CRYP, ENABLE); function.
+  
+   (#) Encrypt and decrypt using AES in ECB Mode using CRYP_AES_ECB() function.
+  
+   (#) Encrypt and decrypt using AES in CBC Mode using CRYP_AES_CBC() function.
+  
+   (#) Encrypt and decrypt using AES in CTR Mode using CRYP_AES_CTR() function.
+
+   (#) Encrypt and decrypt using AES in GCM Mode using CRYP_AES_GCM() function.
+   
+   (#) Encrypt and decrypt using AES in CCM Mode using CRYP_AES_CCM() function.
+     
+@endverbatim
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_cryp.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CRYP 
+  * @brief CRYP driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define AESBUSY_TIMEOUT    ((uint32_t) 0x00010000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup CRYP_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup CRYP_Group6 High Level AES functions
+ *  @brief   High Level AES functions 
+ *
+@verbatim   
+ ===============================================================================
+                       ##### High Level AES functions #####
+ ===============================================================================
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Encrypt and decrypt using AES in ECB Mode
+  * @param  Mode: encryption or decryption Mode.
+  *          This parameter can be one of the following values:
+  *            @arg MODE_ENCRYPT: Encryption
+  *            @arg MODE_DECRYPT: Decryption
+  * @param  Key: Key used for AES algorithm.
+  * @param  Keysize: length of the Key, must be a 128, 192 or 256.
+  * @param  Input: pointer to the Input buffer.
+  * @param  Ilength: length of the Input buffer, must be a multiple of 16.
+  * @param  Output: pointer to the returned buffer.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: Operation done
+  *          - ERROR: Operation failed
+  */
+ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
+                         uint8_t* Input, uint32_t Ilength, uint8_t* Output)
+{
+  CRYP_InitTypeDef AES_CRYP_InitStructure;
+  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+  uint32_t i = 0;
+
+  /* Crypto structures initialisation*/
+  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
+
+  switch(Keysize)
+  {
+    case 128:
+    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 192:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 256:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    default:
+    break;
+  }
+
+  /*------------------ AES Decryption ------------------*/
+  if(Mode == MODE_DECRYPT) /* AES decryption */
+  {
+    /* Flush IN/OUT FIFOs */
+    CRYP_FIFOFlush();
+
+    /* Crypto Init for Key preparation for decryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
+    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
+    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
+    CRYP_Init(&AES_CRYP_InitStructure);
+
+    /* Key Initialisation */
+    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
+
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+
+    /* wait until the Busy flag is RESET */
+    do
+    {
+      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+      counter++;
+    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+   {
+       status = ERROR;
+    }
+    else
+    {
+      /* Crypto Init for decryption process */  
+      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
+    }
+  }
+  /*------------------ AES Encryption ------------------*/
+  else /* AES encryption */
+  {
+
+    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
+
+    /* Crypto Init for Encryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
+  }
+
+  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
+  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+  CRYP_Init(&AES_CRYP_InitStructure);
+
+  /* Flush IN/OUT FIFOs */
+  CRYP_FIFOFlush();
+
+  /* Enable Crypto processor */
+  CRYP_Cmd(ENABLE);
+
+  if(CRYP_GetCmdStatus() == DISABLE)
+  {
+    /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+       the CRYP peripheral (please check the device sales type. */
+    return(ERROR);
+  }
+  
+  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
+  {
+
+    /* Write the Input block in the IN FIFO */
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+
+    /* Wait until the complete message has been processed */
+    counter = 0;
+    do
+    {
+      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+      counter++;
+    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+   {
+       status = ERROR;
+    }
+    else
+    {
+
+      /* Read the Output block from the Output FIFO */
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
+      outputaddr+=4;
+    }
+  }
+
+  /* Disable Crypto */
+  CRYP_Cmd(DISABLE);
+
+  return status; 
+}
+
+/**
+  * @brief  Encrypt and decrypt using AES in CBC Mode
+  * @param  Mode: encryption or decryption Mode.
+  *          This parameter can be one of the following values:
+  *            @arg MODE_ENCRYPT: Encryption
+  *            @arg MODE_DECRYPT: Decryption
+  * @param  InitVectors: Initialisation Vectors used for AES algorithm.
+  * @param  Key: Key used for AES algorithm.
+  * @param  Keysize: length of the Key, must be a 128, 192 or 256.
+  * @param  Input: pointer to the Input buffer.
+  * @param  Ilength: length of the Input buffer, must be a multiple of 16.
+  * @param  Output: pointer to the returned buffer.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: Operation done
+  *          - ERROR: Operation failed
+  */
+ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
+                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
+                         uint8_t *Output)
+{
+  CRYP_InitTypeDef AES_CRYP_InitStructure;
+  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
+  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+  uint32_t ivaddr = (uint32_t)InitVectors;
+  uint32_t i = 0;
+
+  /* Crypto structures initialisation*/
+  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
+
+  switch(Keysize)
+  {
+    case 128:
+    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 192:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 256:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    default:
+    break;
+  }
+
+  /* CRYP Initialization Vectors */
+  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
+
+
+  /*------------------ AES Decryption ------------------*/
+  if(Mode == MODE_DECRYPT) /* AES decryption */
+  {
+    /* Flush IN/OUT FIFOs */
+    CRYP_FIFOFlush();
+
+    /* Crypto Init for Key preparation for decryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
+    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
+    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
+
+    CRYP_Init(&AES_CRYP_InitStructure);
+
+    /* Key Initialisation */
+    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
+
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+
+    /* wait until the Busy flag is RESET */
+    do
+    {
+      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+      counter++;
+    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+   {
+       status = ERROR;
+    }
+    else
+    {
+      /* Crypto Init for decryption process */  
+      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
+    }
+  }
+  /*------------------ AES Encryption ------------------*/
+  else /* AES encryption */
+  {
+    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
+
+    /* Crypto Init for Encryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
+  }
+  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
+  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+  CRYP_Init(&AES_CRYP_InitStructure);
+
+  /* CRYP Initialization Vectors */
+  CRYP_IVInit(&AES_CRYP_IVInitStructure);
+
+  /* Flush IN/OUT FIFOs */
+  CRYP_FIFOFlush();
+
+  /* Enable Crypto processor */
+  CRYP_Cmd(ENABLE);
+
+  if(CRYP_GetCmdStatus() == DISABLE)
+  {
+    /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+       the CRYP peripheral (please check the device sales type. */
+    return(ERROR);
+  }
+  
+  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
+  {
+
+    /* Write the Input block in the IN FIFO */
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    /* Wait until the complete message has been processed */
+    counter = 0;
+    do
+    {
+      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+      counter++;
+    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+   {
+       status = ERROR;
+    }
+    else
+    {
+
+      /* Read the Output block from the Output FIFO */
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+    }
+  }
+
+  /* Disable Crypto */
+  CRYP_Cmd(DISABLE);
+
+  return status;
+}
+
+/**
+  * @brief  Encrypt and decrypt using AES in CTR Mode
+  * @param  Mode: encryption or decryption Mode.
+  *           This parameter can be one of the following values:
+  *            @arg MODE_ENCRYPT: Encryption
+  *            @arg MODE_DECRYPT: Decryption
+  * @param  InitVectors: Initialisation Vectors used for AES algorithm.
+  * @param  Key: Key used for AES algorithm.
+  * @param  Keysize: length of the Key, must be a 128, 192 or 256.
+  * @param  Input: pointer to the Input buffer.
+  * @param  Ilength: length of the Input buffer, must be a multiple of 16.
+  * @param  Output: pointer to the returned buffer.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: Operation done
+  *          - ERROR: Operation failed
+  */
+ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
+                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
+                         uint8_t *Output)
+{
+  CRYP_InitTypeDef AES_CRYP_InitStructure;
+  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
+  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+  uint32_t ivaddr     = (uint32_t)InitVectors;
+  uint32_t i = 0;
+
+  /* Crypto structures initialisation*/
+  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
+
+  switch(Keysize)
+  {
+    case 128:
+    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 192:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 256:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    default:
+    break;
+  }
+  /* CRYP Initialization Vectors */
+  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
+
+  /* Key Initialisation */
+  CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
+
+  /*------------------ AES Decryption ------------------*/
+  if(Mode == MODE_DECRYPT) /* AES decryption */
+  {
+    /* Crypto Init for decryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
+  }
+  /*------------------ AES Encryption ------------------*/
+  else /* AES encryption */
+  {
+    /* Crypto Init for Encryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
+  }
+  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
+  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+  CRYP_Init(&AES_CRYP_InitStructure);
+
+  /* CRYP Initialization Vectors */
+  CRYP_IVInit(&AES_CRYP_IVInitStructure);
+
+  /* Flush IN/OUT FIFOs */
+  CRYP_FIFOFlush();
+
+  /* Enable Crypto processor */
+  CRYP_Cmd(ENABLE);
+
+  if(CRYP_GetCmdStatus() == DISABLE)
+  {
+    /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+       the CRYP peripheral (please check the device sales type. */
+    return(ERROR);
+  }
+  
+  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
+  {
+
+    /* Write the Input block in the IN FIFO */
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    /* Wait until the complete message has been processed */
+    counter = 0;
+    do
+    {
+      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+      counter++;
+    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+   {
+       status = ERROR;
+    }
+    else
+    {
+
+      /* Read the Output block from the Output FIFO */
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+    }
+  }
+  /* Disable Crypto */
+  CRYP_Cmd(DISABLE);
+
+  return status;
+}
+
+/**
+  * @brief  Encrypt and decrypt using AES in GCM Mode. The GCM and CCM modes
+  *         are available only on STM32F437x Devices.
+  * @param  Mode: encryption or decryption Mode.
+  *          This parameter can be one of the following values:
+  *            @arg MODE_ENCRYPT: Encryption
+  *            @arg MODE_DECRYPT: Decryption
+  * @param  InitVectors: Initialisation Vectors used for AES algorithm.
+  * @param  Key: Key used for AES algorithm.
+  * @param  Keysize: length of the Key, must be a 128, 192 or 256.
+  * @param  Input: pointer to the Input buffer.
+  * @param  Ilength: length of the Input buffer in bytes, must be a multiple of 16.
+  * @param  Header: pointer to the header buffer.
+  * @param  Hlength: length of the header buffer in bytes, must be a multiple of 16.  
+  * @param  Output: pointer to the returned buffer.
+  * @param  AuthTAG: pointer to the authentication TAG buffer.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: Operation done
+  *          - ERROR: Operation failed
+  */
+ErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
+                         uint8_t *Key, uint16_t Keysize,
+                         uint8_t *Input, uint32_t ILength,
+                         uint8_t *Header, uint32_t HLength,
+                         uint8_t *Output, uint8_t *AuthTAG)
+{
+  CRYP_InitTypeDef AES_CRYP_InitStructure;
+  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
+  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+  uint32_t ivaddr     = (uint32_t)InitVectors;
+  uint32_t headeraddr = (uint32_t)Header;
+  uint32_t tagaddr = (uint32_t)AuthTAG;
+  uint64_t headerlength = HLength * 8;/* header length in bits */
+  uint64_t inputlength = ILength * 8;/* input length in bits */
+  uint32_t loopcounter = 0;
+
+  /* Crypto structures initialisation*/
+  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
+
+  switch(Keysize)
+  {
+    case 128:
+    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 192:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 256:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    default:
+    break;
+  }
+  
+  /* CRYP Initialization Vectors */
+  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
+  
+  /*------------------ AES Encryption ------------------*/
+  if(Mode == MODE_ENCRYPT) /* AES encryption */
+  {
+    /* Flush IN/OUT FIFOs */
+    CRYP_FIFOFlush();
+    
+    /* Key Initialisation */
+    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
+    
+    /* CRYP Initialization Vectors */
+    CRYP_IVInit(&AES_CRYP_IVInitStructure);
+    
+    /* Crypto Init for Key preparation for decryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
+    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
+    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+    CRYP_Init(&AES_CRYP_InitStructure);
+    
+    /***************************** Init phase *********************************/
+    /* Select init phase */
+    CRYP_PhaseConfig(CRYP_Phase_Init);
+    
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+    
+    /* Wait for CRYPEN bit to be 0 */
+    while(CRYP_GetCmdStatus() == ENABLE)
+    {
+    }
+    
+    /***************************** header phase *******************************/
+    if(HLength != 0)
+    {
+      /* Select header phase */
+      CRYP_PhaseConfig(CRYP_Phase_Header);
+      
+      /* Enable Crypto processor */
+      CRYP_Cmd(ENABLE);
+      
+      if(CRYP_GetCmdStatus() == DISABLE)
+      {
+         /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+            the CRYP peripheral (please check the device sales type. */
+         return(ERROR);
+      }
+      
+      for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
+      {
+        /* Wait until the IFEM flag is reset */
+        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
+        {
+        }
+        
+        /* Write the Input block in the IN FIFO */
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+      }
+      
+      /* Wait until the complete message has been processed */
+      counter = 0;
+      do
+      {
+        busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+        counter++;
+      }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+      if (busystatus != RESET)
+      {
+        status = ERROR;
+      }
+    }
+    
+    /**************************** payload phase *******************************/
+    if(ILength != 0)
+    {
+      /* Select payload phase */
+      CRYP_PhaseConfig(CRYP_Phase_Payload);
+      
+      /* Enable Crypto processor */
+      CRYP_Cmd(ENABLE);
+      
+      if(CRYP_GetCmdStatus() == DISABLE)
+      {
+        /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+           the CRYP peripheral (please check the device sales type. */
+        return(ERROR);
+      }
+      
+      for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
+      {
+        /* Wait until the IFEM flag is reset */
+        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
+        {
+        }
+        /* Write the Input block in the IN FIFO */
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        
+        /* Wait until the complete message has been processed */
+        counter = 0;
+        do
+        {
+          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+          counter++;
+        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+        if (busystatus != RESET)
+        {
+          status = ERROR;
+        }
+        else
+        {
+          /* Wait until the OFNE flag is reset */
+          while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
+          {
+          }
+          
+          /* Read the Output block from the Output FIFO */
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+        }
+      }
+    }
+    
+    /***************************** final phase ********************************/
+    /* Select final phase */
+    CRYP_PhaseConfig(CRYP_Phase_Final);
+    
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+    
+    if(CRYP_GetCmdStatus() == DISABLE)
+    {
+      /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+         the CRYP peripheral (please check the device sales type. */
+      return(ERROR);
+    }
+    
+    /* Write number of bits concatenated with header in the IN FIFO */
+    CRYP_DataIn(__REV(headerlength>>32));
+    CRYP_DataIn(__REV(headerlength));
+    CRYP_DataIn(__REV(inputlength>>32));
+    CRYP_DataIn(__REV(inputlength));
+    /* Wait until the OFNE flag is reset */
+    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
+    {
+    }
+    
+    tagaddr = (uint32_t)AuthTAG;
+    /* Read the Auth TAG in the IN FIFO */
+    *(uint32_t*)(tagaddr) = CRYP_DataOut();
+    tagaddr+=4;
+    *(uint32_t*)(tagaddr) = CRYP_DataOut();
+    tagaddr+=4;
+    *(uint32_t*)(tagaddr) = CRYP_DataOut();
+    tagaddr+=4;
+    *(uint32_t*)(tagaddr) = CRYP_DataOut();
+    tagaddr+=4;
+  }
+  /*------------------ AES Decryption ------------------*/
+  else /* AES decryption */
+  {
+    /* Flush IN/OUT FIFOs */
+    CRYP_FIFOFlush();
+    
+    /* Key Initialisation */
+    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
+    
+    /* CRYP Initialization Vectors */
+    CRYP_IVInit(&AES_CRYP_IVInitStructure);
+    
+    /* Crypto Init for Key preparation for decryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
+    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
+    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+    CRYP_Init(&AES_CRYP_InitStructure);
+    
+    /***************************** Init phase *********************************/
+    /* Select init phase */
+    CRYP_PhaseConfig(CRYP_Phase_Init);
+    
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+    
+    /* Wait for CRYPEN bit to be 0 */
+    while(CRYP_GetCmdStatus() == ENABLE)
+    {
+    }
+    
+    /***************************** header phase *******************************/
+    if(HLength != 0)
+    {
+      /* Select header phase */
+      CRYP_PhaseConfig(CRYP_Phase_Header);
+      
+      /* Enable Crypto processor */
+      CRYP_Cmd(ENABLE);
+      
+      if(CRYP_GetCmdStatus() == DISABLE)
+      {
+        /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+           the CRYP peripheral (please check the device sales type. */
+        return(ERROR);
+      }
+      
+      for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
+      {
+        /* Wait until the IFEM flag is reset */
+        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
+        {
+        }
+        
+        /* Write the Input block in the IN FIFO */
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+      }
+      
+      /* Wait until the complete message has been processed */
+      counter = 0;
+      do
+      {
+        busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+        counter++;
+      }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+      if (busystatus != RESET)
+      {
+        status = ERROR;
+      }
+    }
+    
+    /**************************** payload phase *******************************/
+    if(ILength != 0)
+    {
+      /* Select payload phase */
+      CRYP_PhaseConfig(CRYP_Phase_Payload);
+
+      /* Enable Crypto processor */
+      CRYP_Cmd(ENABLE);
+      
+      if(CRYP_GetCmdStatus() == DISABLE)
+      {
+        /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+           the CRYP peripheral (please check the device sales type. */
+        return(ERROR);
+      }
+      
+      for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
+      {
+        /* Wait until the IFEM flag is reset */
+        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
+        {
+        }
+        /* Write the Input block in the IN FIFO */
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        
+        /* Wait until the complete message has been processed */
+        counter = 0;
+        do
+        {
+          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+          counter++;
+        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+        if (busystatus != RESET)
+        {
+          status = ERROR;
+        }
+        else
+        {
+          /* Wait until the OFNE flag is reset */
+          while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
+          {
+          }
+          
+          /* Read the Output block from the Output FIFO */
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+        }
+      }
+    }
+    
+    /***************************** final phase ********************************/
+    /* Select final phase */
+    CRYP_PhaseConfig(CRYP_Phase_Final);
+
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+    
+    if(CRYP_GetCmdStatus() == DISABLE)
+    {
+      /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+         the CRYP peripheral (please check the device sales type. */
+      return(ERROR);
+    }
+    
+    /* Write number of bits concatenated with header in the IN FIFO */
+    CRYP_DataIn(__REV(headerlength>>32));
+    CRYP_DataIn(__REV(headerlength));
+    CRYP_DataIn(__REV(inputlength>>32));
+    CRYP_DataIn(__REV(inputlength));
+    /* Wait until the OFNE flag is reset */
+    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
+    {
+    }
+    
+    tagaddr = (uint32_t)AuthTAG;
+    /* Read the Auth TAG in the IN FIFO */
+    *(uint32_t*)(tagaddr) = CRYP_DataOut();
+    tagaddr+=4;
+    *(uint32_t*)(tagaddr) = CRYP_DataOut();
+    tagaddr+=4;
+    *(uint32_t*)(tagaddr) = CRYP_DataOut();
+    tagaddr+=4;
+    *(uint32_t*)(tagaddr) = CRYP_DataOut();
+    tagaddr+=4;
+  }
+  /* Disable Crypto */
+  CRYP_Cmd(DISABLE);
+
+  return status;
+}
+
+/**
+  * @brief  Encrypt and decrypt using AES in CCM Mode. The GCM and CCM modes
+  *         are available only on STM32F437x Devices.
+  * @param  Mode: encryption or decryption Mode.
+  *          This parameter can be one of the following values:
+  *            @arg MODE_ENCRYPT: Encryption
+  *            @arg MODE_DECRYPT: Decryption
+  * @param  Nonce: the nounce used for AES algorithm. It shall be unique for each processing.
+  * @param  Key: Key used for AES algorithm.
+  * @param  Keysize: length of the Key, must be a 128, 192 or 256.
+  * @param  Input: pointer to the Input buffer.
+  * @param  Ilength: length of the Input buffer in bytes, must be a multiple of 16.
+  * @param  Header: pointer to the header buffer.
+  * @param  Hlength: length of the header buffer in bytes.
+  * @param  HBuffer: pointer to temporary buffer used to append the header
+  *         HBuffer size must be equal to Hlength + 21
+  * @param  Output: pointer to the returned buffer.
+  * @param  AuthTAG: pointer to the authentication TAG buffer.
+  * @param  TAGSize: the size of the TAG (called also MAC).
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: Operation done
+  *          - ERROR: Operation failed
+  */
+ErrorStatus CRYP_AES_CCM(uint8_t Mode, 
+                         uint8_t* Nonce, uint32_t NonceSize,
+                         uint8_t *Key, uint16_t Keysize,
+                         uint8_t *Input, uint32_t ILength,
+                         uint8_t *Header, uint32_t HLength, uint8_t *HBuffer,
+                         uint8_t *Output,
+                         uint8_t *AuthTAG, uint32_t TAGSize)
+{
+  CRYP_InitTypeDef AES_CRYP_InitStructure;
+  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
+  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+  uint32_t headeraddr = (uint32_t)Header;
+  uint32_t tagaddr = (uint32_t)AuthTAG;
+  uint32_t headersize = HLength;
+  uint32_t loopcounter = 0;
+  uint32_t bufferidx = 0;
+  uint8_t blockb0[16] = {0};/* Block B0 */
+  uint8_t ctr[16] = {0}; /* Counter */
+  uint32_t temptag[4] = {0}; /* temporary TAG (MAC) */
+  uint32_t ctraddr = (uint32_t)ctr;
+  uint32_t b0addr = (uint32_t)blockb0;
+  
+  /************************ Formatting the header block ***********************/
+  if(headersize != 0)
+  {
+    /* Check that the associated data (or header) length is lower than 2^16 - 2^8 = 65536 - 256 = 65280 */
+    if(headersize < 65280)
+    {
+      HBuffer[bufferidx++] = (uint8_t) ((headersize >> 8) & 0xFF);
+      HBuffer[bufferidx++] = (uint8_t) ((headersize) & 0xFF);
+      headersize += 2;
+    }
+    else
+    {
+      /* header is encoded as 0xff || 0xfe || [headersize]32, i.e., six octets */
+      HBuffer[bufferidx++] = 0xFF;
+      HBuffer[bufferidx++] = 0xFE;
+      HBuffer[bufferidx++] = headersize & 0xff000000;
+      HBuffer[bufferidx++] = headersize & 0x00ff0000;
+      HBuffer[bufferidx++] = headersize & 0x0000ff00;
+      HBuffer[bufferidx++] = headersize & 0x000000ff;
+      headersize += 6;
+    }
+    /* Copy the header buffer in internal buffer "HBuffer" */
+    for(loopcounter = 0; loopcounter < headersize; loopcounter++)
+    {
+      HBuffer[bufferidx++] = Header[loopcounter];
+    }
+    /* Check if the header size is modulo 16 */
+    if ((headersize % 16) != 0)
+    {
+      /* Padd the header buffer with 0s till the HBuffer length is modulo 16 */
+      for(loopcounter = headersize; loopcounter <= ((headersize/16) + 1) * 16; loopcounter++)
+      {
+        HBuffer[loopcounter] = 0;
+      }
+      /* Set the header size to modulo 16 */
+      headersize = ((headersize/16) + 1) * 16;
+    }
+    /* set the pointer headeraddr to HBuffer */
+    headeraddr = (uint32_t)HBuffer;
+  }
+  /************************* Formatting the block B0 **************************/
+  if(headersize != 0)
+  {
+    blockb0[0] = 0x40;
+  }
+  /* Flags byte */
+  blockb0[0] |= 0u | (((( (uint8_t) TAGSize - 2) / 2) & 0x07 ) << 3 ) | ( ( (uint8_t) (15 - NonceSize) - 1) & 0x07);
+  
+  for (loopcounter = 0; loopcounter < NonceSize; loopcounter++)
+  {
+    blockb0[loopcounter+1] = Nonce[loopcounter];
+  }
+  for ( ; loopcounter < 13; loopcounter++)
+  {
+    blockb0[loopcounter+1] = 0;
+  }
+  
+  blockb0[14] = ((ILength >> 8) & 0xFF);
+  blockb0[15] = (ILength & 0xFF);
+  
+  /************************* Formatting the initial counter *******************/
+  /* Byte 0:
+     Bits 7 and 6 are reserved and shall be set to 0
+     Bits 3, 4, and 5 shall also be set to 0, to ensure that all the counter blocks
+     are distinct from B0
+     Bits 0, 1, and 2 contain the same encoding of q as in B0
+  */
+  ctr[0] = blockb0[0] & 0x07;
+  /* byte 1 to NonceSize is the IV (Nonce) */
+  for(loopcounter = 1; loopcounter < NonceSize + 1; loopcounter++)
+  {
+    ctr[loopcounter] = blockb0[loopcounter];
+  }
+  /* Set the LSB to 1 */
+  ctr[15] |= 0x01;
+  
+  /* Crypto structures initialisation*/
+  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
+  
+  switch(Keysize)
+  {
+    case 128:
+    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 192:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    case 256:
+    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+    keyaddr+=4;
+    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+    break;
+    default:
+    break;
+  }
+  
+  /* CRYP Initialization Vectors */
+  AES_CRYP_IVInitStructure.CRYP_IV0Left = (__REV(*(uint32_t*)(ctraddr)));
+  ctraddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV0Right= (__REV(*(uint32_t*)(ctraddr)));
+  ctraddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV1Left = (__REV(*(uint32_t*)(ctraddr)));
+  ctraddr+=4;
+  AES_CRYP_IVInitStructure.CRYP_IV1Right= (__REV(*(uint32_t*)(ctraddr)));
+  
+  /*------------------ AES Encryption ------------------*/
+  if(Mode == MODE_ENCRYPT) /* AES encryption */
+  {
+    /* Flush IN/OUT FIFOs */
+    CRYP_FIFOFlush();
+    
+    /* Key Initialisation */
+    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
+    
+    /* CRYP Initialization Vectors */
+    CRYP_IVInit(&AES_CRYP_IVInitStructure);
+    
+    /* Crypto Init for Key preparation for decryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
+    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
+    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+    CRYP_Init(&AES_CRYP_InitStructure);
+    
+    /***************************** Init phase *********************************/
+    /* Select init phase */
+    CRYP_PhaseConfig(CRYP_Phase_Init);
+    
+    b0addr = (uint32_t)blockb0;
+    /* Write the blockb0 block in the IN FIFO */
+    CRYP_DataIn((*(uint32_t*)(b0addr)));
+    b0addr+=4;
+    CRYP_DataIn((*(uint32_t*)(b0addr)));
+    b0addr+=4;
+    CRYP_DataIn((*(uint32_t*)(b0addr)));
+    b0addr+=4;
+    CRYP_DataIn((*(uint32_t*)(b0addr)));
+    
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+    
+    /* Wait for CRYPEN bit to be 0 */
+    while(CRYP_GetCmdStatus() == ENABLE)
+    {
+    }
+    /***************************** header phase *******************************/
+    if(headersize != 0)
+    {
+      /* Select header phase */
+      CRYP_PhaseConfig(CRYP_Phase_Header);
+      
+      /* Enable Crypto processor */
+      CRYP_Cmd(ENABLE);
+      
+      if(CRYP_GetCmdStatus() == DISABLE)
+      {
+         /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+            the CRYP peripheral (please check the device sales type. */
+         return(ERROR);
+      }
+      
+      for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
+      {
+        /* Wait until the IFEM flag is reset */
+        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
+        {
+        }
+        
+        /* Write the Input block in the IN FIFO */
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+      }
+      
+      /* Wait until the complete message has been processed */
+      counter = 0;
+      do
+      {
+        busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+        counter++;
+      }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+      if (busystatus != RESET)
+      {
+        status = ERROR;
+      }
+    }
+    
+    /**************************** payload phase *******************************/
+    if(ILength != 0)
+    {
+      /* Select payload phase */
+      CRYP_PhaseConfig(CRYP_Phase_Payload);
+      
+      /* Enable Crypto processor */
+      CRYP_Cmd(ENABLE);
+      
+      if(CRYP_GetCmdStatus() == DISABLE)
+      {
+        /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+           the CRYP peripheral (please check the device sales type. */
+        return(ERROR);
+      }
+      
+      for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
+      {
+        /* Wait until the IFEM flag is reset */
+        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
+        {
+        }
+        
+        /* Write the Input block in the IN FIFO */
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        
+        /* Wait until the complete message has been processed */
+        counter = 0;
+        do
+        {
+          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+          counter++;
+        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+        if (busystatus != RESET)
+        {
+          status = ERROR;
+        }
+        else
+        {
+          /* Wait until the OFNE flag is reset */
+          while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
+          {
+          }
+          
+          /* Read the Output block from the Output FIFO */
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+        }
+      }
+    }
+    
+    /***************************** final phase ********************************/
+    /* Select final phase */
+    CRYP_PhaseConfig(CRYP_Phase_Final);
+    
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+    
+    if(CRYP_GetCmdStatus() == DISABLE)
+    {
+      /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+         the CRYP peripheral (please check the device sales type. */
+      return(ERROR);
+    }
+    
+    ctraddr = (uint32_t)ctr;
+    /* Write the counter block in the IN FIFO */
+    CRYP_DataIn(*(uint32_t*)(ctraddr));
+    ctraddr+=4;
+    CRYP_DataIn(*(uint32_t*)(ctraddr));
+    ctraddr+=4;
+    CRYP_DataIn(*(uint32_t*)(ctraddr));
+    ctraddr+=4;
+    /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
+    CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
+    
+    /* Wait until the OFNE flag is reset */
+    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
+    {
+    }
+    
+    /* Read the Auth TAG in the IN FIFO */
+    temptag[0] = CRYP_DataOut();
+    temptag[1] = CRYP_DataOut();
+    temptag[2] = CRYP_DataOut();
+    temptag[3] = CRYP_DataOut();
+  }
+  /*------------------ AES Decryption ------------------*/
+  else /* AES decryption */
+  {
+    /* Flush IN/OUT FIFOs */
+    CRYP_FIFOFlush();
+    
+    /* Key Initialisation */
+    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
+    
+    /* CRYP Initialization Vectors */
+    CRYP_IVInit(&AES_CRYP_IVInitStructure);
+    
+    /* Crypto Init for Key preparation for decryption process */
+    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
+    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
+    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+    CRYP_Init(&AES_CRYP_InitStructure);
+    
+    /***************************** Init phase *********************************/
+    /* Select init phase */
+    CRYP_PhaseConfig(CRYP_Phase_Init);
+    
+    b0addr = (uint32_t)blockb0;
+    /* Write the blockb0 block in the IN FIFO */
+    CRYP_DataIn((*(uint32_t*)(b0addr)));
+    b0addr+=4;
+    CRYP_DataIn((*(uint32_t*)(b0addr)));
+    b0addr+=4;
+    CRYP_DataIn((*(uint32_t*)(b0addr)));
+    b0addr+=4;
+    CRYP_DataIn((*(uint32_t*)(b0addr)));
+    
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+    
+    /* Wait for CRYPEN bit to be 0 */
+    while(CRYP_GetCmdStatus() == ENABLE)
+    {
+    }
+    
+    /***************************** header phase *******************************/
+    if(headersize != 0)
+    {
+      /* Select header phase */
+      CRYP_PhaseConfig(CRYP_Phase_Header);
+      
+      /* Enable Crypto processor */
+      CRYP_Cmd(ENABLE);
+      
+      if(CRYP_GetCmdStatus() == DISABLE)
+      {
+        /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+           the CRYP peripheral (please check the device sales type. */
+        return(ERROR);
+      }
+      
+      for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
+      {
+        /* Wait until the IFEM flag is reset */
+        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
+        {
+        }
+        
+        /* Write the Input block in the IN FIFO */
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+        CRYP_DataIn(*(uint32_t*)(headeraddr));
+        headeraddr+=4;
+      }
+      
+      /* Wait until the complete message has been processed */
+      counter = 0;
+      do
+      {
+        busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+        counter++;
+      }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+      if (busystatus != RESET)
+      {
+        status = ERROR;
+      }
+    }
+    
+    /**************************** payload phase *******************************/
+    if(ILength != 0)
+    {
+      /* Select payload phase */
+      CRYP_PhaseConfig(CRYP_Phase_Payload);
+
+      /* Enable Crypto processor */
+      CRYP_Cmd(ENABLE);
+      
+      if(CRYP_GetCmdStatus() == DISABLE)
+      {
+        /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+           the CRYP peripheral (please check the device sales type. */
+        return(ERROR);
+      }
+      
+      for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
+      {
+        /* Wait until the IFEM flag is reset */
+        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
+        {
+        }
+        
+        /* Write the Input block in the IN FIFO */
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        CRYP_DataIn(*(uint32_t*)(inputaddr));
+        inputaddr+=4;
+        
+        /* Wait until the complete message has been processed */
+        counter = 0;
+        do
+        {
+          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+          counter++;
+        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
+
+        if (busystatus != RESET)
+        {
+          status = ERROR;
+        }
+        else
+        {
+          /* Wait until the OFNE flag is reset */
+          while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
+          {
+          }
+          
+          /* Read the Output block from the Output FIFO */
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+          *(uint32_t*)(outputaddr) = CRYP_DataOut();
+          outputaddr+=4;
+        }
+      }
+    }
+    
+    /***************************** final phase ********************************/
+    /* Select final phase */
+    CRYP_PhaseConfig(CRYP_Phase_Final);
+    
+    /* Enable Crypto processor */
+    CRYP_Cmd(ENABLE);
+    
+    if(CRYP_GetCmdStatus() == DISABLE)
+    {
+      /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+         the CRYP peripheral (please check the device sales type. */
+      return(ERROR);
+    }
+    
+    ctraddr = (uint32_t)ctr;
+    /* Write the counter block in the IN FIFO */
+    CRYP_DataIn(*(uint32_t*)(ctraddr));
+    ctraddr+=4;
+    CRYP_DataIn(*(uint32_t*)(ctraddr));
+    ctraddr+=4;
+    CRYP_DataIn(*(uint32_t*)(ctraddr));
+    ctraddr+=4;
+    /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
+    CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
+    
+    /* Wait until the OFNE flag is reset */
+    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
+    {
+    }
+    
+    /* Read the Authentaication TAG (MAC) in the IN FIFO */
+    temptag[0] = CRYP_DataOut();
+    temptag[1] = CRYP_DataOut();
+    temptag[2] = CRYP_DataOut();
+    temptag[3] = CRYP_DataOut();
+  }
+  
+  /* Copy temporary authentication TAG in user TAG buffer */
+  for(loopcounter = 0; (loopcounter < TAGSize); loopcounter++)
+  {
+    /* Set the authentication TAG buffer */
+    *((uint8_t*)tagaddr+loopcounter) = *((uint8_t*)temptag+loopcounter);
+  }
+  
+  /* Disable Crypto */
+  CRYP_Cmd(DISABLE);
+
+  return status;
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_des.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_des.c
new file mode 100644
index 0000000..c73635a
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_des.c
@@ -0,0 +1,308 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_cryp_des.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides high level functions to encrypt and decrypt an 
+  *          input message using DES in ECB/CBC modes.
+  *          It uses the stm32f4xx_cryp.c/.h drivers to access the STM32F4xx CRYP
+  *          peripheral.
+  *
+@verbatim
+  
+ ===================================================================
+                  ##### How to use this driver #####
+ ===================================================================
+ [..] 
+   (#) Enable The CRYP controller clock using 
+       RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_CRYP, ENABLE); function.
+  
+   (#) Encrypt and decrypt using DES in ECB Mode using CRYP_DES_ECB() function.
+  
+   (#) Encrypt and decrypt using DES in CBC Mode using CRYP_DES_CBC() function.
+  
+@endverbatim
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_cryp.h"
+
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CRYP 
+  * @brief CRYP driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define DESBUSY_TIMEOUT    ((uint32_t) 0x00010000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+
+/** @defgroup CRYP_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup CRYP_Group8 High Level DES functions
+ *  @brief   High Level DES functions 
+ *
+@verbatim   
+ ===============================================================================
+                       ##### High Level DES functions #####
+ ===============================================================================
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Encrypt and decrypt using DES in ECB Mode
+  * @param  Mode: encryption or decryption Mode.
+  *           This parameter can be one of the following values:
+  *            @arg MODE_ENCRYPT: Encryption
+  *            @arg MODE_DECRYPT: Decryption
+  * @param  Key: Key used for DES algorithm.
+  * @param  Ilength: length of the Input buffer, must be a multiple of 8.
+  * @param  Input: pointer to the Input buffer.
+  * @param  Output: pointer to the returned buffer.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: Operation done
+  *          - ERROR: Operation failed
+  */
+ErrorStatus CRYP_DES_ECB(uint8_t Mode, uint8_t Key[8], uint8_t *Input, 
+                         uint32_t Ilength, uint8_t *Output)
+{
+  CRYP_InitTypeDef DES_CRYP_InitStructure;
+  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+  uint32_t i = 0;
+
+  /* Crypto structures initialisation*/
+  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
+
+  /* Crypto Init for Encryption process */
+  if( Mode == MODE_ENCRYPT ) /* DES encryption */
+  {
+     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
+  }
+  else/* if( Mode == MODE_DECRYPT )*/ /* DES decryption */
+  {      
+     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
+  }
+
+  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_ECB;
+  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+  CRYP_Init(&DES_CRYP_InitStructure);
+
+  /* Key Initialisation */
+  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
+
+  /* Flush IN/OUT FIFO */
+  CRYP_FIFOFlush();
+
+  /* Enable Crypto processor */
+  CRYP_Cmd(ENABLE);
+
+  if(CRYP_GetCmdStatus() == DISABLE)
+  {
+    /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+       the CRYP peripheral (please check the device sales type. */
+    return(ERROR);
+  }
+  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
+  {
+
+    /* Write the Input block in the Input FIFO */
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+
+/* Wait until the complete message has been processed */
+    counter = 0;
+    do
+    {
+      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+      counter++;
+    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+   {
+       status = ERROR;
+    }
+    else
+    {
+
+      /* Read the Output block from the Output FIFO */
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+    }
+  }
+
+  /* Disable Crypto */
+  CRYP_Cmd(DISABLE);
+
+  return status; 
+}
+
+/**
+  * @brief  Encrypt and decrypt using DES in CBC Mode
+  * @param  Mode: encryption or decryption Mode.
+  *          This parameter can be one of the following values:
+  *            @arg MODE_ENCRYPT: Encryption
+  *            @arg MODE_DECRYPT: Decryption
+  * @param  Key: Key used for DES algorithm.
+  * @param  InitVectors: Initialisation Vectors used for DES algorithm.
+  * @param  Ilength: length of the Input buffer, must be a multiple of 8.
+  * @param  Input: pointer to the Input buffer.
+  * @param  Output: pointer to the returned buffer.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: Operation done
+  *          - ERROR: Operation failed
+  */
+ErrorStatus CRYP_DES_CBC(uint8_t Mode, uint8_t Key[8], uint8_t InitVectors[8],
+                         uint8_t *Input, uint32_t Ilength, uint8_t *Output)
+{
+  CRYP_InitTypeDef DES_CRYP_InitStructure;
+  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
+  CRYP_IVInitTypeDef DES_CRYP_IVInitStructure;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+  uint32_t ivaddr     = (uint32_t)InitVectors;
+  uint32_t i = 0;
+
+  /* Crypto structures initialisation*/
+  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
+
+  /* Crypto Init for Encryption process */
+  if(Mode == MODE_ENCRYPT) /* DES encryption */
+  {
+     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
+  }
+  else /*if(Mode == MODE_DECRYPT)*/ /* DES decryption */
+  {
+     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
+  }
+
+  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_CBC;
+  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+  CRYP_Init(&DES_CRYP_InitStructure);
+
+  /* Key Initialisation */
+  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
+
+  /* Initialization Vectors */
+  DES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  DES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
+  CRYP_IVInit(&DES_CRYP_IVInitStructure);
+
+  /* Flush IN/OUT FIFO */
+  CRYP_FIFOFlush();
+  
+  /* Enable Crypto processor */
+  CRYP_Cmd(ENABLE);
+
+  if(CRYP_GetCmdStatus() == DISABLE)
+  {
+    /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+       the CRYP peripheral (please check the device sales type. */
+    return(ERROR);
+  }
+  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
+  {
+    /* Write the Input block in the Input FIFO */
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+
+    /* Wait until the complete message has been processed */
+    counter = 0;
+    do
+    {
+      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+      counter++;
+    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+   {
+       status = ERROR;
+    }
+    else
+    {
+      /* Read the Output block from the Output FIFO */
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+    }
+  }
+
+  /* Disable Crypto */
+  CRYP_Cmd(DISABLE);
+
+  return status; 
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_tdes.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_tdes.c
new file mode 100644
index 0000000..af08a6a
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_tdes.c
@@ -0,0 +1,325 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_cryp_tdes.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides high level functions to encrypt and decrypt an 
+  *          input message using TDES in ECB/CBC modes .
+  *          It uses the stm32f4xx_cryp.c/.h drivers to access the STM32F4xx CRYP
+  *          peripheral.
+  *
+@verbatim
+
+ ===============================================================================
+                           ##### How to use this driver #####
+ ===============================================================================
+ [..]
+   (#) Enable The CRYP controller clock using 
+       RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_CRYP, ENABLE); function.
+  
+   (#) Encrypt and decrypt using TDES in ECB Mode using CRYP_TDES_ECB() function.
+  
+   (#) Encrypt and decrypt using TDES in CBC Mode using CRYP_TDES_CBC() function.
+  
+@endverbatim
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_cryp.h"
+
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CRYP 
+  * @brief CRYP driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define TDESBUSY_TIMEOUT    ((uint32_t) 0x00010000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+
+/** @defgroup CRYP_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup CRYP_Group7 High Level TDES functions
+ *  @brief   High Level TDES functions 
+ *
+@verbatim   
+ ===============================================================================
+                      ##### High Level TDES functions #####
+ ===============================================================================
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Encrypt and decrypt using TDES in ECB Mode
+  * @param  Mode: encryption or decryption Mode.
+  *           This parameter can be one of the following values:
+  *            @arg MODE_ENCRYPT: Encryption
+  *            @arg MODE_DECRYPT: Decryption
+  * @param  Key: Key used for TDES algorithm.
+  * @param  Ilength: length of the Input buffer, must be a multiple of 8.
+  * @param  Input: pointer to the Input buffer.
+  * @param  Output: pointer to the returned buffer.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: Operation done
+  *          - ERROR: Operation failed
+  */
+ErrorStatus CRYP_TDES_ECB(uint8_t Mode, uint8_t Key[24], uint8_t *Input, 
+                          uint32_t Ilength, uint8_t *Output)
+{
+  CRYP_InitTypeDef TDES_CRYP_InitStructure;
+  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+  uint32_t i = 0;
+
+  /* Crypto structures initialisation*/
+  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
+
+  /* Crypto Init for Encryption process */
+  if(Mode == MODE_ENCRYPT) /* TDES encryption */
+  {
+     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
+  }
+  else /*if(Mode == MODE_DECRYPT)*/ /* TDES decryption */
+  {
+     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
+  }
+
+  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
+  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+  CRYP_Init(&TDES_CRYP_InitStructure);
+
+  /* Key Initialisation */
+  TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
+
+  /* Flush IN/OUT FIFO */
+  CRYP_FIFOFlush();
+
+  /* Enable Crypto processor */
+  CRYP_Cmd(ENABLE);
+
+  if(CRYP_GetCmdStatus() == DISABLE)
+  {
+    /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+       the CRYP peripheral (please check the device sales type. */
+    return(ERROR);
+  }
+  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
+  {
+    /* Write the Input block in the Input FIFO */
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+
+    /* Wait until the complete message has been processed */
+    counter = 0;
+    do
+    {
+      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+      counter++;
+    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+    {
+       status = ERROR;
+    }
+    else
+    {
+
+      /* Read the Output block from the Output FIFO */
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+    }
+  }
+
+  /* Disable Crypto */
+  CRYP_Cmd(DISABLE);
+
+  return status; 
+}
+
+/**
+  * @brief  Encrypt and decrypt using TDES in CBC Mode
+  * @param  Mode: encryption or decryption Mode.
+  *           This parameter can be one of the following values:
+  *            @arg MODE_ENCRYPT: Encryption
+  *            @arg MODE_DECRYPT: Decryption
+  * @param  Key: Key used for TDES algorithm.
+  * @param  InitVectors: Initialisation Vectors used for TDES algorithm.
+  * @param  Input: pointer to the Input buffer.
+  * @param  Ilength: length of the Input buffer, must be a multiple of 8.
+  * @param  Output: pointer to the returned buffer.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: Operation done
+  *          - ERROR: Operation failed
+  */
+ErrorStatus CRYP_TDES_CBC(uint8_t Mode, uint8_t Key[24], uint8_t InitVectors[8],
+                          uint8_t *Input, uint32_t Ilength, uint8_t *Output)
+{
+  CRYP_InitTypeDef TDES_CRYP_InitStructure;
+  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
+  CRYP_IVInitTypeDef TDES_CRYP_IVInitStructure;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+  uint32_t ivaddr     = (uint32_t)InitVectors;
+  uint32_t i = 0;
+
+  /* Crypto structures initialisation*/
+  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
+
+  /* Crypto Init for Encryption process */
+  if(Mode == MODE_ENCRYPT) /* TDES encryption */
+  {
+    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
+  }
+  else
+  {
+    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
+  }
+  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_CBC;
+  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
+
+  CRYP_Init(&TDES_CRYP_InitStructure);
+
+  /* Key Initialisation */
+  TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
+  keyaddr+=4;
+  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
+  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
+
+  /* Initialization Vectors */
+  TDES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
+  ivaddr+=4;
+  TDES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
+  CRYP_IVInit(&TDES_CRYP_IVInitStructure);
+
+  /* Flush IN/OUT FIFO */
+  CRYP_FIFOFlush();
+
+  /* Enable Crypto processor */
+  CRYP_Cmd(ENABLE);
+
+  if(CRYP_GetCmdStatus() == DISABLE)
+  {
+    /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
+       the CRYP peripheral (please check the device sales type. */
+    return(ERROR);
+  }
+  
+  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
+  {
+    /* Write the Input block in the Input FIFO */
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+    CRYP_DataIn(*(uint32_t*)(inputaddr));
+    inputaddr+=4;
+
+    /* Wait until the complete message has been processed */
+    counter = 0;
+    do
+    {
+      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
+      counter++;
+    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+   {
+       status = ERROR;
+    }
+    else
+    {
+
+      /* Read the Output block from the Output FIFO */
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+      *(uint32_t*)(outputaddr) = CRYP_DataOut();
+      outputaddr+=4;
+    }
+  }
+
+  /* Disable Crypto */
+  CRYP_Cmd(DISABLE);
+
+  return status; 
+}
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c
new file mode 100644
index 0000000..b203f3d
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c
@@ -0,0 +1,714 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dac.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+   * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Digital-to-Analog Converter (DAC) peripheral: 
+  *           + DAC channels configuration: trigger, output buffer, data format
+  *           + DMA management      
+  *           + Interrupts and flags management
+  *
+ @verbatim      
+ ===============================================================================
+                      ##### DAC Peripheral features #####
+ ===============================================================================
+    [..]        
+      *** DAC Channels ***
+      ====================  
+    [..]  
+    The device integrates two 12-bit Digital Analog Converters that can 
+    be used independently or simultaneously (dual mode):
+      (#) DAC channel1 with DAC_OUT1 (PA4) as output
+      (#) DAC channel2 with DAC_OUT2 (PA5) as output
+  
+      *** DAC Triggers ***
+      ====================
+    [..]
+    Digital to Analog conversion can be non-triggered using DAC_Trigger_None
+    and DAC_OUT1/DAC_OUT2 is available once writing to DHRx register 
+    using DAC_SetChannel1Data() / DAC_SetChannel2Data() functions.
+    [..] 
+    Digital to Analog conversion can be triggered by:
+      (#) External event: EXTI Line 9 (any GPIOx_Pin9) using DAC_Trigger_Ext_IT9.
+          The used pin (GPIOx_Pin9) must be configured in input mode.
+  
+      (#) Timers TRGO: TIM2, TIM4, TIM5, TIM6, TIM7 and TIM8 
+          (DAC_Trigger_T2_TRGO, DAC_Trigger_T4_TRGO...)
+          The timer TRGO event should be selected using TIM_SelectOutputTrigger()
+  
+      (#) Software using DAC_Trigger_Software
+  
+      *** DAC Buffer mode feature ***
+      =============================== 
+      [..] 
+      Each DAC channel integrates an output buffer that can be used to 
+      reduce the output impedance, and to drive external loads directly
+      without having to add an external operational amplifier.
+      To enable, the output buffer use  
+      DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
+      [..]           
+      (@) Refer to the device datasheet for more details about output 
+          impedance value with and without output buffer.
+            
+       *** DAC wave generation feature ***
+       =================================== 
+       [..]     
+       Both DAC channels can be used to generate
+         (#) Noise wave using DAC_WaveGeneration_Noise
+         (#) Triangle wave using DAC_WaveGeneration_Triangle
+          
+          -@-  Wave generation can be disabled using DAC_WaveGeneration_None
+  
+       *** DAC data format ***
+       =======================
+       [..]   
+       The DAC data format can be:
+         (#) 8-bit right alignment using DAC_Align_8b_R
+         (#) 12-bit left alignment using DAC_Align_12b_L
+         (#) 12-bit right alignment using DAC_Align_12b_R
+  
+       *** DAC data value to voltage correspondence ***  
+       ================================================ 
+       [..] 
+       The analog output voltage on each DAC channel pin is determined
+       by the following equation: 
+       DAC_OUTx = VREF+ * DOR / 4095
+       with  DOR is the Data Output Register
+          VEF+ is the input voltage reference (refer to the device datasheet)
+        e.g. To set DAC_OUT1 to 0.7V, use
+          DAC_SetChannel1Data(DAC_Align_12b_R, 868);
+          Assuming that VREF+ = 3.3V, DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V
+  
+       *** DMA requests  ***
+       =====================
+       [..]    
+       A DMA1 request can be generated when an external trigger (but not
+       a software trigger) occurs if DMA1 requests are enabled using
+       DAC_DMACmd()
+       [..]
+       DMA1 requests are mapped as following:
+         (#) DAC channel1 : mapped on DMA1 Stream5 channel7 which must be 
+             already configured
+         (#) DAC channel2 : mapped on DMA1 Stream6 channel7 which must be 
+             already configured
+  
+      
+                      ##### How to use this driver #####
+ ===============================================================================
+    [..]          
+      (+) DAC APB clock must be enabled to get write access to DAC
+          registers using
+          RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE)
+      (+) Configure DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) in analog mode.
+      (+) Configure the DAC channel using DAC_Init() function
+      (+) Enable the DAC channel using DAC_Cmd() function
+   
+ @endverbatim    
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_dac.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DAC 
+  * @brief DAC driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* CR register Mask */
+#define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
+
+/* DAC Dual Channels SWTRIG masks */
+#define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
+#define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
+
+/* DHR registers offsets */
+#define DHR12R1_OFFSET             ((uint32_t)0x00000008)
+#define DHR12R2_OFFSET             ((uint32_t)0x00000014)
+#define DHR12RD_OFFSET             ((uint32_t)0x00000020)
+
+/* DOR register offset */
+#define DOR_OFFSET                 ((uint32_t)0x0000002C)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup DAC_Private_Functions
+  * @{
+  */
+
+/** @defgroup DAC_Group1 DAC channels configuration
+ *  @brief   DAC channels configuration: trigger, output buffer, data format 
+ *
+@verbatim   
+ ===============================================================================
+   ##### DAC channels configuration: trigger, output buffer, data format #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the DAC peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void DAC_DeInit(void)
+{
+  /* Enable DAC reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
+  /* Release DAC from reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
+}
+
+/**
+  * @brief  Initializes the DAC peripheral according to the specified parameters
+  *         in the DAC_InitStruct.
+  * @param  DAC_Channel: the selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
+  *         the configuration information for the  specified DAC channel.
+  * @retval None
+  */
+void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
+{
+  uint32_t tmpreg1 = 0, tmpreg2 = 0;
+
+  /* Check the DAC parameters */
+  assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
+  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
+  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
+  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
+
+/*---------------------------- DAC CR Configuration --------------------------*/
+  /* Get the DAC CR value */
+  tmpreg1 = DAC->CR;
+  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
+  tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
+  /* Configure for the selected DAC channel: buffer output, trigger, 
+     wave generation, mask/amplitude for wave generation */
+  /* Set TSELx and TENx bits according to DAC_Trigger value */
+  /* Set WAVEx bits according to DAC_WaveGeneration value */
+  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
+  /* Set BOFFx bit according to DAC_OutputBuffer value */   
+  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
+             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
+             DAC_InitStruct->DAC_OutputBuffer);
+  /* Calculate CR register value depending on DAC_Channel */
+  tmpreg1 |= tmpreg2 << DAC_Channel;
+  /* Write to DAC CR */
+  DAC->CR = tmpreg1;
+}
+
+/**
+  * @brief  Fills each DAC_InitStruct member with its default value.
+  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will 
+  *         be initialized.
+  * @retval None
+  */
+void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
+{
+/*--------------- Reset DAC init structure parameters values -----------------*/
+  /* Initialize the DAC_Trigger member */
+  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
+  /* Initialize the DAC_WaveGeneration member */
+  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
+  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
+  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
+  /* Initialize the DAC_OutputBuffer member */
+  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
+}
+
+/**
+  * @brief  Enables or disables the specified DAC channel.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  NewState: new state of the DAC channel. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @note   When the DAC channel is enabled the trigger source can no more be modified.
+  * @retval None
+  */
+void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC channel */
+    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
+  }
+  else
+  {
+    /* Disable the selected DAC channel */
+    DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
+  }
+}
+
+/**
+  * @brief  Enables or disables the selected DAC channel software trigger.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  NewState: new state of the selected DAC channel software trigger.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable software trigger for the selected DAC channel */
+    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
+  }
+  else
+  {
+    /* Disable software trigger for the selected DAC channel */
+    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
+  }
+}
+
+/**
+  * @brief  Enables or disables simultaneously the two DAC channels software triggers.
+  * @param  NewState: new state of the DAC channels software triggers.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable software trigger for both DAC channels */
+    DAC->SWTRIGR |= DUAL_SWTRIG_SET;
+  }
+  else
+  {
+    /* Disable software trigger for both DAC channels */
+    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
+  }
+}
+
+/**
+  * @brief  Enables or disables the selected DAC channel wave generation.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_Wave: specifies the wave type to enable or disable.
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Wave_Noise: noise wave generation
+  *            @arg DAC_Wave_Triangle: triangle wave generation
+  * @param  NewState: new state of the selected DAC channel wave generation.
+  *          This parameter can be: ENABLE or DISABLE.  
+  * @retval None
+  */
+void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_WAVE(DAC_Wave)); 
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected wave generation for the selected DAC channel */
+    DAC->CR |= DAC_Wave << DAC_Channel;
+  }
+  else
+  {
+    /* Disable the selected wave generation for the selected DAC channel */
+    DAC->CR &= ~(DAC_Wave << DAC_Channel);
+  }
+}
+
+/**
+  * @brief  Set the specified data holding register value for DAC channel1.
+  * @param  DAC_Align: Specifies the data alignment for DAC channel1.
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Align_8b_R: 8bit right data alignment selected
+  *            @arg DAC_Align_12b_L: 12bit left data alignment selected
+  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
+  * @param  Data: Data to be loaded in the selected data holding register.
+  * @retval None
+  */
+void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
+{  
+  __IO uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data));
+  
+  tmp = (uint32_t)DAC_BASE; 
+  tmp += DHR12R1_OFFSET + DAC_Align;
+
+  /* Set the DAC channel1 selected data holding register */
+  *(__IO uint32_t *) tmp = Data;
+}
+
+/**
+  * @brief  Set the specified data holding register value for DAC channel2.
+  * @param  DAC_Align: Specifies the data alignment for DAC channel2.
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Align_8b_R: 8bit right data alignment selected
+  *            @arg DAC_Align_12b_L: 12bit left data alignment selected
+  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
+  * @param  Data: Data to be loaded in the selected data holding register.
+  * @retval None
+  */
+void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data));
+  
+  tmp = (uint32_t)DAC_BASE;
+  tmp += DHR12R2_OFFSET + DAC_Align;
+
+  /* Set the DAC channel2 selected data holding register */
+  *(__IO uint32_t *)tmp = Data;
+}
+
+/**
+  * @brief  Set the specified data holding register value for dual channel DAC.
+  * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Align_8b_R: 8bit right data alignment selected
+  *            @arg DAC_Align_12b_L: 12bit left data alignment selected
+  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
+  * @param  Data2: Data for DAC Channel2 to be loaded in the selected data holding register.
+  * @param  Data1: Data for DAC Channel1 to be loaded in the selected data  holding register.
+  * @note   In dual mode, a unique register access is required to write in both
+  *          DAC channels at the same time.
+  * @retval None
+  */
+void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
+{
+  uint32_t data = 0, tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data1));
+  assert_param(IS_DAC_DATA(Data2));
+  
+  /* Calculate and set dual DAC data holding register value */
+  if (DAC_Align == DAC_Align_8b_R)
+  {
+    data = ((uint32_t)Data2 << 8) | Data1; 
+  }
+  else
+  {
+    data = ((uint32_t)Data2 << 16) | Data1;
+  }
+  
+  tmp = (uint32_t)DAC_BASE;
+  tmp += DHR12RD_OFFSET + DAC_Align;
+
+  /* Set the dual DAC selected data holding register */
+  *(__IO uint32_t *)tmp = data;
+}
+
+/**
+  * @brief  Returns the last data output value of the selected DAC channel.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @retval The selected DAC channel data output value.
+  */
+uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
+{
+  __IO uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  
+  tmp = (uint32_t) DAC_BASE ;
+  tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
+  
+  /* Returns the DAC channel data output register value */
+  return (uint16_t) (*(__IO uint32_t*) tmp);
+}
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Group2 DMA management functions
+ *  @brief   DMA management functions
+ *
+@verbatim   
+ ===============================================================================
+                       ##### DMA management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified DAC channel DMA request.
+  * @note   When enabled DMA1 is generated when an external trigger (EXTI Line9,
+  *         TIM2, TIM4, TIM5, TIM6, TIM7 or TIM8  but not a software trigger) occurs.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  NewState: new state of the selected DAC channel DMA request.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @note   The DAC channel1 is mapped on DMA1 Stream 5 channel7 which must be
+  *          already configured.
+  * @note   The DAC channel2 is mapped on DMA1 Stream 6 channel7 which must be
+  *          already configured.    
+  * @retval None
+  */
+void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC channel DMA request */
+    DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
+  }
+  else
+  {
+    /* Disable the selected DAC channel DMA request */
+    DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Group3 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+             ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified DAC interrupts.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
+  *          This parameter can be the following values:
+  *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
+  * @note   The DMA underrun occurs when a second external trigger arrives before the 
+  *         acknowledgement for the first external trigger is received (first request).
+  * @param  NewState: new state of the specified DAC interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */ 
+void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_DAC_IT(DAC_IT)); 
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC interrupts */
+    DAC->CR |=  (DAC_IT << DAC_Channel);
+  }
+  else
+  {
+    /* Disable the selected DAC interrupts */
+    DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
+  }
+}
+
+/**
+  * @brief  Checks whether the specified DAC flag is set or not.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_FLAG: specifies the flag to check. 
+  *          This parameter can be only of the following value:
+  *            @arg DAC_FLAG_DMAUDR: DMA underrun flag
+  * @note   The DMA underrun occurs when a second external trigger arrives before the 
+  *         acknowledgement for the first external trigger is received (first request).
+  * @retval The new state of DAC_FLAG (SET or RESET).
+  */
+FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_FLAG(DAC_FLAG));
+
+  /* Check the status of the specified DAC flag */
+  if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
+  {
+    /* DAC_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DAC_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the DAC_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DAC channel's pending flags.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_FLAG: specifies the flag to clear. 
+  *          This parameter can be of the following value:
+  *            @arg DAC_FLAG_DMAUDR: DMA underrun flag 
+  * @note   The DMA underrun occurs when a second external trigger arrives before the 
+  *         acknowledgement for the first external trigger is received (first request).                           
+  * @retval None
+  */
+void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_FLAG(DAC_FLAG));
+
+  /* Clear the selected DAC flags */
+  DAC->SR = (DAC_FLAG << DAC_Channel);
+}
+
+/**
+  * @brief  Checks whether the specified DAC interrupt has occurred or not.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_IT: specifies the DAC interrupt source to check. 
+  *          This parameter can be the following values:
+  *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
+  * @note   The DMA underrun occurs when a second external trigger arrives before the 
+  *         acknowledgement for the first external trigger is received (first request).
+  * @retval The new state of DAC_IT (SET or RESET).
+  */
+ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t enablestatus = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_IT(DAC_IT));
+
+  /* Get the DAC_IT enable bit status */
+  enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
+  
+  /* Check the status of the specified DAC interrupt */
+  if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
+  {
+    /* DAC_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DAC_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the DAC_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DAC channel's interrupt pending bits.
+  * @param  DAC_Channel: The selected DAC channel. 
+  *          This parameter can be one of the following values:
+  *            @arg DAC_Channel_1: DAC Channel1 selected
+  *            @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
+  *          This parameter can be the following values:
+  *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         
+  * @note   The DMA underrun occurs when a second external trigger arrives before the 
+  *         acknowledgement for the first external trigger is received (first request).                           
+  * @retval None
+  */
+void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_IT(DAC_IT)); 
+
+  /* Clear the selected DAC interrupt pending bits */
+  DAC->SR = (DAC_IT << DAC_Channel);
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dbgmcu.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dbgmcu.c
new file mode 100644
index 0000000..91fe34c
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dbgmcu.c
@@ -0,0 +1,180 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dbgmcu.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides all the DBGMCU firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_dbgmcu.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DBGMCU 
+  * @brief DBGMCU driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define IDCODE_DEVID_MASK    ((uint32_t)0x00000FFF)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup DBGMCU_Private_Functions
+  * @{
+  */ 
+
+/**
+  * @brief  Returns the device revision identifier.
+  * @param  None
+  * @retval Device revision identifier
+  */
+uint32_t DBGMCU_GetREVID(void)
+{
+   return(DBGMCU->IDCODE >> 16);
+}
+
+/**
+  * @brief  Returns the device identifier.
+  * @param  None
+  * @retval Device identifier
+  */
+uint32_t DBGMCU_GetDEVID(void)
+{
+   return(DBGMCU->IDCODE & IDCODE_DEVID_MASK);
+}
+
+/**
+  * @brief  Configures low power mode behavior when the MCU is in Debug mode.
+  * @param  DBGMCU_Periph: specifies the low power mode.
+  *   This parameter can be any combination of the following values:
+  *     @arg DBGMCU_SLEEP: Keep debugger connection during SLEEP mode              
+  *     @arg DBGMCU_STOP: Keep debugger connection during STOP mode               
+  *     @arg DBGMCU_STANDBY: Keep debugger connection during STANDBY mode        
+  * @param  NewState: new state of the specified low power mode in Debug mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    DBGMCU->CR |= DBGMCU_Periph;
+  }
+  else
+  {
+    DBGMCU->CR &= ~DBGMCU_Periph;
+  }
+}
+
+/**
+  * @brief  Configures APB1 peripheral behavior when the MCU is in Debug mode.
+  * @param  DBGMCU_Periph: specifies the APB1 peripheral.
+  *   This parameter can be any combination of the following values:        
+  *     @arg DBGMCU_TIM2_STOP: TIM2 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM3_STOP: TIM3 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM4_STOP: TIM4 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM5_STOP: TIM5 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM6_STOP: TIM6 counter stopped when Core is halted          
+  *     @arg DBGMCU_TIM7_STOP: TIM7 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM12_STOP: TIM12 counter stopped when Core is halted  
+  *     @arg DBGMCU_TIM13_STOP: TIM13 counter stopped when Core is halted  
+  *     @arg DBGMCU_TIM14_STOP: TIM14 counter stopped when Core is halted 
+  *     @arg DBGMCU_RTC_STOP: RTC Calendar and Wakeup counter stopped when Core is halted.                                                                                
+  *     @arg DBGMCU_WWDG_STOP: Debug WWDG stopped when Core is halted
+  *     @arg DBGMCU_IWDG_STOP: Debug IWDG stopped when Core is halted        
+  *     @arg DBGMCU_I2C1_SMBUS_TIMEOUT: I2C1 SMBUS timeout mode stopped when Core is halted
+  *     @arg DBGMCU_I2C2_SMBUS_TIMEOUT: I2C2 SMBUS timeout mode stopped when Core is halted
+  *     @arg DBGMCU_I2C3_SMBUS_TIMEOUT: I2C3 SMBUS timeout mode stopped when Core is halted
+  *     @arg DBGMCU_CAN2_STOP: Debug CAN1 stopped when Core is halted           
+  *     @arg DBGMCU_CAN1_STOP: Debug CAN2 stopped when Core is halted        
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DBGMCU_APB1PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DBGMCU_APB1PERIPH(DBGMCU_Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    DBGMCU->APB1FZ |= DBGMCU_Periph;
+  }
+  else
+  {
+    DBGMCU->APB1FZ &= ~DBGMCU_Periph;
+  }
+}
+
+/**
+  * @brief  Configures APB2 peripheral behavior when the MCU is in Debug mode.
+  * @param  DBGMCU_Periph: specifies the APB2 peripheral.
+  *   This parameter can be any combination of the following values:       
+  *     @arg DBGMCU_TIM1_STOP: TIM1 counter stopped when Core is halted                
+  *     @arg DBGMCU_TIM8_STOP: TIM8 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM9_STOP: TIM9 counter stopped when Core is halted   
+  *     @arg DBGMCU_TIM10_STOP: TIM10 counter stopped when Core is halted   
+  *     @arg DBGMCU_TIM11_STOP: TIM11 counter stopped when Core is halted                                                                                  
+  * @param  NewState: new state of the specified peripheral in Debug mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DBGMCU_APB2PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DBGMCU_APB2PERIPH(DBGMCU_Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    DBGMCU->APB2FZ |= DBGMCU_Periph;
+  }
+  else
+  {
+    DBGMCU->APB2FZ &= ~DBGMCU_Periph;
+  }
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dcmi.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dcmi.c
new file mode 100644
index 0000000..0f23f3c
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dcmi.c
@@ -0,0 +1,538 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dcmi.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the DCMI peripheral:           
+  *           + Initialization and Configuration
+  *           + Image capture functions  
+  *           + Interrupts and flags management
+  *
+ @verbatim          
+ ===============================================================================
+                        ##### How to use this driver #####
+ ===============================================================================  
+    [..]       
+      The sequence below describes how to use this driver to capture image
+      from a camera module connected to the DCMI Interface.
+      This sequence does not take into account the configuration of the  
+      camera module, which should be made before to configure and enable
+      the DCMI to capture images.
+             
+      (#) Enable the clock for the DCMI and associated GPIOs using the following 
+          functions:
+          RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_DCMI, ENABLE);
+          RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
+  
+      (#) DCMI pins configuration 
+        (++) Connect the involved DCMI pins to AF13 using the following function 
+            GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_DCMI); 
+        (++) Configure these DCMI pins in alternate function mode by calling 
+            the function GPIO_Init();
+      
+      (#) Declare a DCMI_InitTypeDef structure, for example:
+          DCMI_InitTypeDef  DCMI_InitStructure;
+          and fill the DCMI_InitStructure variable with the allowed values
+          of the structure member.
+    
+      (#) Initialize the DCMI interface by calling the function
+          DCMI_Init(&DCMI_InitStructure); 
+    
+      (#) Configure the DMA2_Stream1 channel1 to transfer Data from DCMI DR
+          register to the destination memory buffer.
+    
+      (#) Enable DCMI interface using the function
+          DCMI_Cmd(ENABLE);
+                   
+      (#) Start the image capture using the function
+          DCMI_CaptureCmd(ENABLE);
+                   
+      (#) At this stage the DCMI interface waits for the first start of frame,
+          then a DMA request is generated continuously/once (depending on the
+          mode used, Continuous/Snapshot) to transfer the received data into
+          the destination memory. 
+     
+      -@-  If you need to capture only a rectangular window from the received
+           image, you have to use the DCMI_CROPConfig() function to configure 
+           the coordinates and size of the window to be captured, then enable 
+           the Crop feature using DCMI_CROPCmd(ENABLE);  
+           In this case, the Crop configuration should be made before to enable
+           and start the DCMI interface. 
+
+ @endverbatim     
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_dcmi.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DCMI 
+  * @brief DCMI driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup DCMI_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup DCMI_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Initialization and Configuration functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the DCMI registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void DCMI_DeInit(void)
+{
+  DCMI->CR = 0x0;
+  DCMI->IER = 0x0;
+  DCMI->ICR = 0x1F;
+  DCMI->ESCR = 0x0;
+  DCMI->ESUR = 0x0;
+  DCMI->CWSTRTR = 0x0;
+  DCMI->CWSIZER = 0x0;
+}
+
+/**
+  * @brief  Initializes the DCMI according to the specified parameters in the DCMI_InitStruct.
+  * @param  DCMI_InitStruct: pointer to a DCMI_InitTypeDef structure that contains 
+  *         the configuration information for the DCMI.
+  * @retval None
+  */
+void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
+{
+  uint32_t temp = 0x0;
+  
+  /* Check the parameters */
+  assert_param(IS_DCMI_CAPTURE_MODE(DCMI_InitStruct->DCMI_CaptureMode));
+  assert_param(IS_DCMI_SYNCHRO(DCMI_InitStruct->DCMI_SynchroMode));
+  assert_param(IS_DCMI_PCKPOLARITY(DCMI_InitStruct->DCMI_PCKPolarity));
+  assert_param(IS_DCMI_VSPOLARITY(DCMI_InitStruct->DCMI_VSPolarity));
+  assert_param(IS_DCMI_HSPOLARITY(DCMI_InitStruct->DCMI_HSPolarity));
+  assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
+  assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));
+
+  /* The DCMI configuration registers should be programmed correctly before 
+  enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
+  DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
+   
+  /* Reset the old DCMI configuration */
+  temp = DCMI->CR;
+  
+  temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
+                      DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
+                      DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
+                  
+  /* Sets the new configuration of the DCMI peripheral */
+  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
+                     DCMI_InitStruct->DCMI_SynchroMode |
+                     DCMI_InitStruct->DCMI_PCKPolarity |
+                     DCMI_InitStruct->DCMI_VSPolarity |
+                     DCMI_InitStruct->DCMI_HSPolarity |
+                     DCMI_InitStruct->DCMI_CaptureRate |
+                     DCMI_InitStruct->DCMI_ExtendedDataMode);
+
+  DCMI->CR = temp;                              
+}
+
+/**
+  * @brief  Fills each DCMI_InitStruct member with its default value.
+  * @param  DCMI_InitStruct : pointer to a DCMI_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
+{
+  /* Set the default configuration */
+  DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
+  DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
+  DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
+  DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
+  DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
+  DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
+  DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
+}
+
+/**
+  * @brief  Initializes the DCMI peripheral CROP mode according to the specified
+  *         parameters in the DCMI_CROPInitStruct.
+  * @note   This function should be called before to enable and start the DCMI interface.   
+  * @param  DCMI_CROPInitStruct:  pointer to a DCMI_CROPInitTypeDef structure that 
+  *         contains the configuration information for the DCMI peripheral CROP mode.
+  * @retval None
+  */
+void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
+{  
+  /* Sets the CROP window coordinates */
+  DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
+                  ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
+
+  /* Sets the CROP window size */
+  DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
+                  ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
+}
+
+/**
+  * @brief  Enables or disables the DCMI Crop feature.
+  * @note   This function should be called before to enable and start the DCMI interface.
+  * @param  NewState: new state of the DCMI Crop feature. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DCMI_CROPCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  if (NewState != DISABLE)
+  {
+    /* Enable the DCMI Crop feature */
+    DCMI->CR |= (uint32_t)DCMI_CR_CROP;
+  }
+  else
+  {
+    /* Disable the DCMI Crop feature */
+    DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
+  }
+}
+
+/**
+  * @brief  Sets the embedded synchronization codes
+  * @param  DCMI_CodesInitTypeDef: pointer to a DCMI_CodesInitTypeDef structure that
+  *         contains the embedded synchronization codes for the DCMI peripheral.
+  * @retval None
+  */
+void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
+{
+  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
+                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
+                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
+                          ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
+}
+
+/**
+  * @brief  Enables or disables the DCMI JPEG format.
+  * @note   The Crop and Embedded Synchronization features cannot be used in this mode.  
+  * @param  NewState: new state of the DCMI JPEG format. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DCMI_JPEGCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+  if (NewState != DISABLE)
+  {
+    /* Enable the DCMI JPEG format */
+    DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
+  }
+  else
+  {
+    /* Disable the DCMI JPEG format */
+    DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup DCMI_Group2 Image capture functions
+ *  @brief   Image capture functions
+ *
+@verbatim   
+ ===============================================================================
+                    ##### Image capture functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Enables or disables the DCMI interface.
+  * @param  NewState: new state of the DCMI interface. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DCMI_Cmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the DCMI by setting ENABLE bit */
+    DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
+  }
+  else
+  {
+    /* Disable the DCMI by clearing ENABLE bit */
+    DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
+  }
+}
+
+/**
+  * @brief  Enables or disables the DCMI Capture.
+  * @param  NewState: new state of the DCMI capture. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DCMI_CaptureCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  if (NewState != DISABLE)
+  {
+    /* Enable the DCMI Capture */
+    DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
+  }
+  else
+  {
+    /* Disable the DCMI Capture */
+    DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
+  }
+}
+
+/**
+  * @brief  Reads the data stored in the DR register.
+  * @param  None 
+  * @retval Data register value
+  */
+uint32_t DCMI_ReadData(void)
+{
+  return DCMI->DR;
+}
+/**
+  * @}
+  */
+
+/** @defgroup DCMI_Group3 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+             ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the DCMI interface interrupts.
+  * @param  DCMI_IT: specifies the DCMI interrupt sources to be enabled or disabled. 
+  *          This parameter can be any combination of the following values:
+  *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
+  *            @arg DCMI_IT_OVF: Overflow interrupt mask
+  *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
+  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
+  *            @arg DCMI_IT_LINE: Line interrupt mask
+  * @param  NewState: new state of the specified DCMI interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the Interrupt sources */
+    DCMI->IER |= DCMI_IT;
+  }
+  else
+  {
+    /* Disable the Interrupt sources */
+    DCMI->IER &= (uint16_t)(~DCMI_IT);
+  }  
+}
+
+/**
+  * @brief  Checks whether the  DCMI interface flag is set or not.
+  * @param  DCMI_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg DCMI_FLAG_FRAMERI: Frame capture complete Raw flag mask
+  *            @arg DCMI_FLAG_OVFRI: Overflow Raw flag mask
+  *            @arg DCMI_FLAG_ERRRI: Synchronization error Raw flag mask
+  *            @arg DCMI_FLAG_VSYNCRI: VSYNC Raw flag mask
+  *            @arg DCMI_FLAG_LINERI: Line Raw flag mask
+  *            @arg DCMI_FLAG_FRAMEMI: Frame capture complete Masked flag mask
+  *            @arg DCMI_FLAG_OVFMI: Overflow Masked flag mask
+  *            @arg DCMI_FLAG_ERRMI: Synchronization error Masked flag mask
+  *            @arg DCMI_FLAG_VSYNCMI: VSYNC Masked flag mask
+  *            @arg DCMI_FLAG_LINEMI: Line Masked flag mask
+  *            @arg DCMI_FLAG_HSYNC: HSYNC flag mask
+  *            @arg DCMI_FLAG_VSYNC: VSYNC flag mask
+  *            @arg DCMI_FLAG_FNE: Fifo not empty flag mask
+  * @retval The new state of DCMI_FLAG (SET or RESET).
+  */
+FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t dcmireg, tempreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
+  
+  /* Get the DCMI register index */
+  dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
+  
+  if (dcmireg == 0x00) /* The FLAG is in RISR register */
+  {
+    tempreg= DCMI->RISR;
+  }
+  else if (dcmireg == 0x02) /* The FLAG is in SR register */
+  {
+    tempreg = DCMI->SR;
+  }
+  else /* The FLAG is in MISR register */
+  {
+    tempreg = DCMI->MISR;
+  }
+  
+  if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the DCMI_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DCMI's pending flags.
+  * @param  DCMI_FLAG: specifies the flag to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg DCMI_FLAG_FRAMERI: Frame capture complete Raw flag mask
+  *            @arg DCMI_FLAG_OVFRI: Overflow Raw flag mask
+  *            @arg DCMI_FLAG_ERRRI: Synchronization error Raw flag mask
+  *            @arg DCMI_FLAG_VSYNCRI: VSYNC Raw flag mask
+  *            @arg DCMI_FLAG_LINERI: Line Raw flag mask
+  * @retval None
+  */
+void DCMI_ClearFlag(uint16_t DCMI_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
+  
+  /* Clear the flag by writing in the ICR register 1 in the corresponding 
+  Flag position*/
+  
+  DCMI->ICR = DCMI_FLAG;
+}
+
+/**
+  * @brief  Checks whether the DCMI interrupt has occurred or not.
+  * @param  DCMI_IT: specifies the DCMI interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
+  *            @arg DCMI_IT_OVF: Overflow interrupt mask
+  *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
+  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
+  *            @arg DCMI_IT_LINE: Line interrupt mask
+  * @retval The new state of DCMI_IT (SET or RESET).
+  */
+ITStatus DCMI_GetITStatus(uint16_t DCMI_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t itstatus = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_DCMI_GET_IT(DCMI_IT));
+  
+  itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
+  
+  if ((itstatus != (uint16_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the DCMI's interrupt pending bits.
+  * @param  DCMI_IT: specifies the DCMI interrupt pending bit to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
+  *            @arg DCMI_IT_OVF: Overflow interrupt mask
+  *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
+  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
+  *            @arg DCMI_IT_LINE: Line interrupt mask
+  * @retval None
+  */
+void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
+{
+  /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
+  corresponding pending Bit position*/
+  
+  DCMI->ICR = DCMI_IT;
+}
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma.c
new file mode 100644
index 0000000..7882a52
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma.c
@@ -0,0 +1,1301 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dma.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Direct Memory Access controller (DMA):           
+  *           + Initialization and Configuration
+  *           + Data Counter
+  *           + Double Buffer mode configuration and command  
+  *           + Interrupts and flags management
+  *           
+  @verbatim      
+ ===============================================================================      
+                       ##### How to use this driver #####
+ ===============================================================================
+    [..] 
+      (#) Enable The DMA controller clock using RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA1, ENABLE)
+          function for DMA1 or using RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2, ENABLE)
+          function for DMA2.
+  
+      (#) Enable and configure the peripheral to be connected to the DMA Stream
+          (except for internal SRAM / FLASH memories: no initialization is 
+          necessary). 
+          
+      (#) For a given Stream, program the required configuration through following parameters:   
+          Source and Destination addresses, Transfer Direction, Transfer size, Source and Destination 
+          data formats, Circular or Normal mode, Stream Priority level, Source and Destination 
+          Incrementation mode, FIFO mode and its Threshold (if needed), Burst 
+          mode for Source and/or Destination (if needed) using the DMA_Init() function.
+          To avoid filling unneccessary fields, you can call DMA_StructInit() function
+          to initialize a given structure with default values (reset values), the modify
+          only necessary fields 
+          (ie. Source and Destination addresses, Transfer size and Data Formats).
+  
+      (#) Enable the NVIC and the corresponding interrupt(s) using the function 
+          DMA_ITConfig() if you need to use DMA interrupts. 
+  
+      (#) Optionally, if the Circular mode is enabled, you can use the Double buffer mode by configuring 
+          the second Memory address and the first Memory to be used through the function 
+          DMA_DoubleBufferModeConfig(). Then enable the Double buffer mode through the function
+          DMA_DoubleBufferModeCmd(). These operations must be done before step 6.
+      
+      (#) Enable the DMA stream using the DMA_Cmd() function. 
+                  
+      (#) Activate the needed Stream Request using PPP_DMACmd() function for
+          any PPP peripheral except internal SRAM and FLASH (ie. SPI, USART ...)
+          The function allowing this operation is provided in each PPP peripheral
+          driver (ie. SPI_DMACmd for SPI peripheral).
+          Once the Stream is enabled, it is not possible to modify its configuration
+          unless the stream is stopped and disabled.
+          After enabling the Stream, it is advised to monitor the EN bit status using
+          the function DMA_GetCmdStatus(). In case of configuration errors or bus errors
+          this bit will remain reset and all transfers on this Stream will remain on hold.      
+  
+      (#) Optionally, you can configure the number of data to be transferred
+          when the Stream is disabled (ie. after each Transfer Complete event
+          or when a Transfer Error occurs) using the function DMA_SetCurrDataCounter().
+          And you can get the number of remaining data to be transferred using 
+          the function DMA_GetCurrDataCounter() at run time (when the DMA Stream is
+          enabled and running).  
+                     
+      (#) To control DMA events you can use one of the following two methods:
+        (##) Check on DMA Stream flags using the function DMA_GetFlagStatus().  
+        (##) Use DMA interrupts through the function DMA_ITConfig() at initialization
+             phase and DMA_GetITStatus() function into interrupt routines in
+             communication phase.
+    [..]     
+          After checking on a flag you should clear it using DMA_ClearFlag()
+          function. And after checking on an interrupt event you should 
+          clear it using DMA_ClearITPendingBit() function.    
+                
+      (#) Optionally, if Circular mode and Double Buffer mode are enabled, you can modify
+          the Memory Addresses using the function DMA_MemoryTargetConfig(). Make sure that
+          the Memory Address to be modified is not the one currently in use by DMA Stream.
+          This condition can be monitored using the function DMA_GetCurrentMemoryTarget().
+                
+      (#) Optionally, Pause-Resume operations may be performed:
+          The DMA_Cmd() function may be used to perform Pause-Resume operation. 
+          When a transfer is ongoing, calling this function to disable the 
+          Stream will cause the transfer to be paused. All configuration registers 
+          and the number of remaining data will be preserved. When calling again 
+          this function to re-enable the Stream, the transfer will be resumed from 
+          the point where it was paused.          
+                   
+      -@- Memory-to-Memory transfer is possible by setting the address of the memory into
+           the Peripheral registers. In this mode, Circular mode and Double Buffer mode
+           are not allowed.
+    
+      -@- The FIFO is used mainly to reduce bus usage and to allow data 
+           packing/unpacking: it is possible to set different Data Sizes for 
+           the Peripheral and the Memory (ie. you can set Half-Word data size 
+           for the peripheral to access its data register and set Word data size
+           for the Memory to gain in access time. Each two Half-words will be 
+           packed and written in a single access to a Word in the Memory).
+      
+      -@- When FIFO is disabled, it is not allowed to configure different 
+           Data Sizes for Source and Destination. In this case the Peripheral 
+           Data Size will be applied to both Source and Destination.               
+  
+  @endverbatim
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_dma.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DMA 
+  * @brief DMA driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* Masks Definition */
+#define TRANSFER_IT_ENABLE_MASK (uint32_t)(DMA_SxCR_TCIE | DMA_SxCR_HTIE | \
+                                           DMA_SxCR_TEIE | DMA_SxCR_DMEIE)
+
+#define DMA_Stream0_IT_MASK     (uint32_t)(DMA_LISR_FEIF0 | DMA_LISR_DMEIF0 | \
+                                           DMA_LISR_TEIF0 | DMA_LISR_HTIF0 | \
+                                           DMA_LISR_TCIF0)
+
+#define DMA_Stream1_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 6)
+#define DMA_Stream2_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 16)
+#define DMA_Stream3_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 22)
+#define DMA_Stream4_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK | (uint32_t)0x20000000)
+#define DMA_Stream5_IT_MASK     (uint32_t)(DMA_Stream1_IT_MASK | (uint32_t)0x20000000)
+#define DMA_Stream6_IT_MASK     (uint32_t)(DMA_Stream2_IT_MASK | (uint32_t)0x20000000)
+#define DMA_Stream7_IT_MASK     (uint32_t)(DMA_Stream3_IT_MASK | (uint32_t)0x20000000)
+#define TRANSFER_IT_MASK        (uint32_t)0x0F3C0F3C
+#define HIGH_ISR_MASK           (uint32_t)0x20000000
+#define RESERVED_MASK           (uint32_t)0x0F7D0F7D  
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+
+/** @defgroup DMA_Private_Functions
+  * @{
+  */
+
+/** @defgroup DMA_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions
+ *
+@verbatim   
+ ===============================================================================
+                ##### Initialization and Configuration functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides functions allowing to initialize the DMA Stream source
+    and destination addresses, incrementation and data sizes, transfer direction, 
+    buffer size, circular/normal mode selection, memory-to-memory mode selection 
+    and Stream priority value.
+    [..]
+    The DMA_Init() function follows the DMA configuration procedures as described in
+    reference manual (RM0090) except the first point: waiting on EN bit to be reset.
+    This condition should be checked by user application using the function DMA_GetCmdStatus()
+    before calling the DMA_Init() function.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitialize the DMAy Streamx registers to their default reset values.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *         to 7 to select the DMA Stream.
+  * @retval None
+  */
+void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+
+  /* Disable the selected DMAy Streamx */
+  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
+
+  /* Reset DMAy Streamx control register */
+  DMAy_Streamx->CR  = 0;
+  
+  /* Reset DMAy Streamx Number of Data to Transfer register */
+  DMAy_Streamx->NDTR = 0;
+  
+  /* Reset DMAy Streamx peripheral address register */
+  DMAy_Streamx->PAR  = 0;
+  
+  /* Reset DMAy Streamx memory 0 address register */
+  DMAy_Streamx->M0AR = 0;
+
+  /* Reset DMAy Streamx memory 1 address register */
+  DMAy_Streamx->M1AR = 0;
+
+  /* Reset DMAy Streamx FIFO control register */
+  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
+
+  /* Reset interrupt pending bits for the selected stream */
+  if (DMAy_Streamx == DMA1_Stream0)
+  {
+    /* Reset interrupt pending bits for DMA1 Stream0 */
+    DMA1->LIFCR = DMA_Stream0_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA1_Stream1)
+  {
+    /* Reset interrupt pending bits for DMA1 Stream1 */
+    DMA1->LIFCR = DMA_Stream1_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA1_Stream2)
+  {
+    /* Reset interrupt pending bits for DMA1 Stream2 */
+    DMA1->LIFCR = DMA_Stream2_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA1_Stream3)
+  {
+    /* Reset interrupt pending bits for DMA1 Stream3 */
+    DMA1->LIFCR = DMA_Stream3_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA1_Stream4)
+  {
+    /* Reset interrupt pending bits for DMA1 Stream4 */
+    DMA1->HIFCR = DMA_Stream4_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA1_Stream5)
+  {
+    /* Reset interrupt pending bits for DMA1 Stream5 */
+    DMA1->HIFCR = DMA_Stream5_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA1_Stream6)
+  {
+    /* Reset interrupt pending bits for DMA1 Stream6 */
+    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA1_Stream7)
+  {
+    /* Reset interrupt pending bits for DMA1 Stream7 */
+    DMA1->HIFCR = DMA_Stream7_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA2_Stream0)
+  {
+    /* Reset interrupt pending bits for DMA2 Stream0 */
+    DMA2->LIFCR = DMA_Stream0_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA2_Stream1)
+  {
+    /* Reset interrupt pending bits for DMA2 Stream1 */
+    DMA2->LIFCR = DMA_Stream1_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA2_Stream2)
+  {
+    /* Reset interrupt pending bits for DMA2 Stream2 */
+    DMA2->LIFCR = DMA_Stream2_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA2_Stream3)
+  {
+    /* Reset interrupt pending bits for DMA2 Stream3 */
+    DMA2->LIFCR = DMA_Stream3_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA2_Stream4)
+  {
+    /* Reset interrupt pending bits for DMA2 Stream4 */
+    DMA2->HIFCR = DMA_Stream4_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA2_Stream5)
+  {
+    /* Reset interrupt pending bits for DMA2 Stream5 */
+    DMA2->HIFCR = DMA_Stream5_IT_MASK;
+  }
+  else if (DMAy_Streamx == DMA2_Stream6)
+  {
+    /* Reset interrupt pending bits for DMA2 Stream6 */
+    DMA2->HIFCR = DMA_Stream6_IT_MASK;
+  }
+  else 
+  {
+    if (DMAy_Streamx == DMA2_Stream7)
+    {
+      /* Reset interrupt pending bits for DMA2 Stream7 */
+      DMA2->HIFCR = DMA_Stream7_IT_MASK;
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the DMAy Streamx according to the specified parameters in 
+  *         the DMA_InitStruct structure.
+  * @note   Before calling this function, it is recommended to check that the Stream 
+  *         is actually disabled using the function DMA_GetCmdStatus().  
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *         to 7 to select the DMA Stream.
+  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
+  *         the configuration information for the specified DMA Stream.  
+  * @retval None
+  */
+void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_CHANNEL(DMA_InitStruct->DMA_Channel));
+  assert_param(IS_DMA_DIRECTION(DMA_InitStruct->DMA_DIR));
+  assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
+  assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
+  assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));
+  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
+  assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
+  assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
+  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
+  assert_param(IS_DMA_FIFO_MODE_STATE(DMA_InitStruct->DMA_FIFOMode));
+  assert_param(IS_DMA_FIFO_THRESHOLD(DMA_InitStruct->DMA_FIFOThreshold));
+  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
+  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));
+
+  /*------------------------- DMAy Streamx CR Configuration ------------------*/
+  /* Get the DMAy_Streamx CR value */
+  tmpreg = DMAy_Streamx->CR;
+
+  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
+  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
+                         DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | \
+                         DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | \
+                         DMA_SxCR_DIR));
+
+  /* Configure DMAy Streamx: */
+  /* Set CHSEL bits according to DMA_CHSEL value */
+  /* Set DIR bits according to DMA_DIR value */
+  /* Set PINC bit according to DMA_PeripheralInc value */
+  /* Set MINC bit according to DMA_MemoryInc value */
+  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
+  /* Set MSIZE bits according to DMA_MemoryDataSize value */
+  /* Set CIRC bit according to DMA_Mode value */
+  /* Set PL bits according to DMA_Priority value */
+  /* Set MBURST bits according to DMA_MemoryBurst value */
+  /* Set PBURST bits according to DMA_PeripheralBurst value */
+  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
+            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
+            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
+            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
+            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
+
+  /* Write to DMAy Streamx CR register */
+  DMAy_Streamx->CR = tmpreg;
+
+  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
+  /* Get the DMAy_Streamx FCR value */
+  tmpreg = DMAy_Streamx->FCR;
+
+  /* Clear DMDIS and FTH bits */
+  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
+
+  /* Configure DMAy Streamx FIFO: 
+    Set DMDIS bits according to DMA_FIFOMode value 
+    Set FTH bits according to DMA_FIFOThreshold value */
+  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
+
+  /* Write to DMAy Streamx CR */
+  DMAy_Streamx->FCR = tmpreg;
+
+  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
+  /* Write to DMAy Streamx NDTR register */
+  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
+
+  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
+  /* Write to DMAy Streamx PAR */
+  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
+
+  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
+  /* Write to DMAy Streamx M0AR */
+  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
+}
+
+/**
+  * @brief  Fills each DMA_InitStruct member with its default value.
+  * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will 
+  *         be initialized.
+  * @retval None
+  */
+void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
+{
+  /*-------------- Reset DMA init structure parameters values ----------------*/
+  /* Initialize the DMA_Channel member */
+  DMA_InitStruct->DMA_Channel = 0;
+
+  /* Initialize the DMA_PeripheralBaseAddr member */
+  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
+
+  /* Initialize the DMA_Memory0BaseAddr member */
+  DMA_InitStruct->DMA_Memory0BaseAddr = 0;
+
+  /* Initialize the DMA_DIR member */
+  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
+
+  /* Initialize the DMA_BufferSize member */
+  DMA_InitStruct->DMA_BufferSize = 0;
+
+  /* Initialize the DMA_PeripheralInc member */
+  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
+
+  /* Initialize the DMA_MemoryInc member */
+  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
+
+  /* Initialize the DMA_PeripheralDataSize member */
+  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
+
+  /* Initialize the DMA_MemoryDataSize member */
+  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
+
+  /* Initialize the DMA_Mode member */
+  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
+
+  /* Initialize the DMA_Priority member */
+  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
+
+  /* Initialize the DMA_FIFOMode member */
+  DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
+
+  /* Initialize the DMA_FIFOThreshold member */
+  DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
+
+  /* Initialize the DMA_MemoryBurst member */
+  DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
+
+  /* Initialize the DMA_PeripheralBurst member */
+  DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
+}
+
+/**
+  * @brief  Enables or disables the specified DMAy Streamx.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *         to 7 to select the DMA Stream.
+  * @param  NewState: new state of the DMAy Streamx. 
+  *          This parameter can be: ENABLE or DISABLE.
+  *
+  * @note  This function may be used to perform Pause-Resume operation. When a
+  *        transfer is ongoing, calling this function to disable the Stream will
+  *        cause the transfer to be paused. All configuration registers and the
+  *        number of remaining data will be preserved. When calling again this
+  *        function to re-enable the Stream, the transfer will be resumed from
+  *        the point where it was paused.          
+  *    
+  * @note  After configuring the DMA Stream (DMA_Init() function) and enabling the
+  *        stream, it is recommended to check (or wait until) the DMA Stream is
+  *        effectively enabled. A Stream may remain disabled if a configuration 
+  *        parameter is wrong.
+  *        After disabling a DMA Stream, it is also recommended to check (or wait
+  *        until) the DMA Stream is effectively disabled. If a Stream is disabled 
+  *        while a data transfer is ongoing, the current data will be transferred
+  *        and the Stream will be effectively disabled only after the transfer of
+  *        this single data is finished.            
+  *    
+  * @retval None
+  */
+void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMAy Streamx by setting EN bit */
+    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
+  }
+  else
+  {
+    /* Disable the selected DMAy Streamx by clearing EN bit */
+    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
+  }
+}
+
+/**
+  * @brief  Configures, when the PINC (Peripheral Increment address mode) bit is
+  *         set, if the peripheral address should be incremented with the data 
+  *         size (configured with PSIZE bits) or by a fixed offset equal to 4
+  *         (32-bit aligned addresses).
+  *   
+  * @note   This function has no effect if the Peripheral Increment mode is disabled.
+  *     
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  DMA_Pincos: specifies the Peripheral increment offset size.
+  *          This parameter can be one of the following values:
+  *            @arg DMA_PINCOS_Psize: Peripheral address increment is done  
+  *                                   accordingly to PSIZE parameter.
+  *            @arg DMA_PINCOS_WordAligned: Peripheral address increment offset is 
+  *                                         fixed to 4 (32-bit aligned addresses). 
+  * @retval None
+  */
+void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));
+
+  /* Check the needed Peripheral increment offset */
+  if(DMA_Pincos != DMA_PINCOS_Psize)
+  {
+    /* Configure DMA_SxCR_PINCOS bit with the input parameter */
+    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
+  }
+  else
+  {
+    /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
+    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
+  }
+}
+
+/**
+  * @brief  Configures, when the DMAy Streamx is disabled, the flow controller for
+  *         the next transactions (Peripheral or Memory).
+  *       
+  * @note   Before enabling this feature, check if the used peripheral supports 
+  *         the Flow Controller mode or not.    
+  *  
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  DMA_FlowCtrl: specifies the DMA flow controller.
+  *          This parameter can be one of the following values:
+  *            @arg DMA_FlowCtrl_Memory: DMAy_Streamx transactions flow controller is 
+  *                                      the DMA controller.
+  *            @arg DMA_FlowCtrl_Peripheral: DMAy_Streamx transactions flow controller 
+  *                                          is the peripheral.    
+  * @retval None
+  */
+void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));
+
+  /* Check the needed flow controller  */
+  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
+  {
+    /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
+    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
+  }
+  else
+  {
+    /* Clear the PFCTRL bit: Memory is the flow controller */
+    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Group2 Data Counter functions
+ *  @brief   Data Counter functions 
+ *
+@verbatim   
+ ===============================================================================
+                      ##### Data Counter functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides function allowing to configure and read the buffer size
+    (number of data to be transferred). 
+    [..]
+    The DMA data counter can be written only when the DMA Stream is disabled 
+    (ie. after transfer complete event).
+    [..]
+    The following function can be used to write the Stream data counter value:
+      (+) void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter);
+      -@- It is advised to use this function rather than DMA_Init() in situations 
+          where only the Data buffer needs to be reloaded.
+      -@- If the Source and Destination Data Sizes are different, then the value 
+          written in data counter, expressing the number of transfers, is relative 
+          to the number of transfers from the Peripheral point of view.
+          ie. If Memory data size is Word, Peripheral data size is Half-Words, 
+          then the value to be configured in the data counter is the number 
+          of Half-Words to be transferred from/to the peripheral.
+    [..]
+    The DMA data counter can be read to indicate the number of remaining transfers for
+    the relative DMA Stream. This counter is decremented at the end of each data 
+    transfer and when the transfer is complete: 
+      (+) If Normal mode is selected: the counter is set to 0.
+      (+) If Circular mode is selected: the counter is reloaded with the initial value
+          (configured before enabling the DMA Stream)
+     [..]
+     The following function can be used to read the Stream data counter value:
+       (+) uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx);
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Writes the number of data units to be transferred on the DMAy Streamx.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  Counter: Number of data units to be transferred (from 0 to 65535) 
+  *          Number of data items depends only on the Peripheral data format.
+  *            
+  * @note   If Peripheral data format is Bytes: number of data units is equal 
+  *         to total number of bytes to be transferred.
+  *           
+  * @note   If Peripheral data format is Half-Word: number of data units is  
+  *         equal to total number of bytes to be transferred / 2.
+  *           
+  * @note   If Peripheral data format is Word: number of data units is equal 
+  *         to total  number of bytes to be transferred / 4.
+  *      
+  * @note   In Memory-to-Memory transfer mode, the memory buffer pointed by 
+  *         DMAy_SxPAR register is considered as Peripheral.
+  *      
+  * @retval The number of remaining data units in the current DMAy Streamx transfer.
+  */
+void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+
+  /* Write the number of data units to be transferred */
+  DMAy_Streamx->NDTR = (uint16_t)Counter;
+}
+
+/**
+  * @brief  Returns the number of remaining data units in the current DMAy Streamx transfer.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @retval The number of remaining data units in the current DMAy Streamx transfer.
+  */
+uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+
+  /* Return the number of remaining data units for DMAy Streamx */
+  return ((uint16_t)(DMAy_Streamx->NDTR));
+}
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Group3 Double Buffer mode functions
+ *  @brief   Double Buffer mode functions 
+ *
+@verbatim   
+ ===============================================================================
+                    ##### Double Buffer mode functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides function allowing to configure and control the double 
+    buffer mode parameters.
+    
+    [..]
+    The Double Buffer mode can be used only when Circular mode is enabled.
+    The Double Buffer mode cannot be used when transferring data from Memory to Memory.
+    
+    [..]
+    The Double Buffer mode allows to set two different Memory addresses from/to which
+    the DMA controller will access alternatively (after completing transfer to/from 
+    target memory 0, it will start transfer to/from target memory 1).
+    This allows to reduce software overhead for double buffering and reduce the CPU
+    access time.
+    
+    [..]
+    Two functions must be called before calling the DMA_Init() function:
+      (+) void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, 
+          uint32_t Memory1BaseAddr, uint32_t DMA_CurrentMemory);
+      (+) void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
+      
+    [..]
+    DMA_DoubleBufferModeConfig() is called to configure the Memory 1 base address 
+    and the first Memory target from/to which the transfer will start after 
+    enabling the DMA Stream. Then DMA_DoubleBufferModeCmd() must be called 
+    to enable the Double Buffer mode (or disable it when it should not be used).
+  
+    [..]
+    Two functions can be called dynamically when the transfer is ongoing (or when the DMA Stream is 
+    stopped) to modify on of the target Memories addresses or to check wich Memory target is currently
+    used:
+      (+) void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, 
+                uint32_t MemoryBaseAddr, uint32_t DMA_MemoryTarget);
+      (+) uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx);
+      
+    [..]
+    DMA_MemoryTargetConfig() can be called to modify the base address of one of 
+    the two target Memories.
+    The Memory of which the base address will be modified must not be currently 
+    be used by the DMA Stream (ie. if the DMA Stream is currently transferring 
+    from Memory 1 then you can only modify base address of target Memory 0 and vice versa).
+    To check this condition, it is recommended to use the function DMA_GetCurrentMemoryTarget() which
+    returns the index of the Memory target currently in use by the DMA Stream.
+
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Configures, when the DMAy Streamx is disabled, the double buffer mode 
+  *         and the current memory target.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  Memory1BaseAddr: the base address of the second buffer (Memory 1)  
+  * @param  DMA_CurrentMemory: specifies which memory will be first buffer for
+  *         the transactions when the Stream will be enabled. 
+  *          This parameter can be one of the following values:
+  *            @arg DMA_Memory_0: Memory 0 is the current buffer.
+  *            @arg DMA_Memory_1: Memory 1 is the current buffer.  
+  *       
+  * @note   Memory0BaseAddr is set by the DMA structure configuration in DMA_Init().
+  *   
+  * @retval None
+  */
+void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
+                                uint32_t DMA_CurrentMemory)
+{  
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));
+
+  if (DMA_CurrentMemory != DMA_Memory_0)
+  {
+    /* Set Memory 1 as current memory address */
+    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
+  }
+  else
+  {
+    /* Set Memory 0 as current memory address */
+    DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
+  }
+
+  /* Write to DMAy Streamx M1AR */
+  DMAy_Streamx->M1AR = Memory1BaseAddr;
+}
+
+/**
+  * @brief  Enables or disables the double buffer mode for the selected DMA stream.
+  * @note   This function can be called only when the DMA Stream is disabled.  
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  NewState: new state of the DMAy Streamx double buffer mode. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
+{  
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* Configure the Double Buffer mode */
+  if (NewState != DISABLE)
+  {
+    /* Enable the Double buffer mode */
+    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
+  }
+  else
+  {
+    /* Disable the Double buffer mode */
+    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
+  }
+}
+
+/**
+  * @brief  Configures the Memory address for the next buffer transfer in double
+  *         buffer mode (for dynamic use). This function can be called when the
+  *         DMA Stream is enabled and when the transfer is ongoing.  
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  MemoryBaseAddr: The base address of the target memory buffer
+  * @param  DMA_MemoryTarget: Next memory target to be used. 
+  *         This parameter can be one of the following values:
+  *            @arg DMA_Memory_0: To use the memory address 0
+  *            @arg DMA_Memory_1: To use the memory address 1
+  * 
+  * @note    It is not allowed to modify the Base Address of a target Memory when
+  *          this target is involved in the current transfer. ie. If the DMA Stream
+  *          is currently transferring to/from Memory 1, then it not possible to
+  *          modify Base address of Memory 1, but it is possible to modify Base
+  *          address of Memory 0.
+  *          To know which Memory is currently used, you can use the function
+  *          DMA_GetCurrentMemoryTarget().             
+  *  
+  * @retval None
+  */
+void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
+                           uint32_t DMA_MemoryTarget)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
+    
+  /* Check the Memory target to be configured */
+  if (DMA_MemoryTarget != DMA_Memory_0)
+  {
+    /* Write to DMAy Streamx M1AR */
+    DMAy_Streamx->M1AR = MemoryBaseAddr;    
+  }  
+  else
+  {
+    /* Write to DMAy Streamx M0AR */
+    DMAy_Streamx->M0AR = MemoryBaseAddr;  
+  }
+}
+
+/**
+  * @brief  Returns the current memory target used by double buffer transfer.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @retval The memory target number: 0 for Memory0 or 1 for Memory1. 
+  */
+uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
+{
+  uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+
+  /* Get the current memory target */
+  if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
+  {
+    /* Current memory buffer used is Memory 1 */
+    tmp = 1;
+  }  
+  else
+  {
+    /* Current memory buffer used is Memory 0 */
+    tmp = 0;    
+  }
+  return tmp;
+}
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Group4 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Interrupts and flags management functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides functions allowing to
+      (+) Check the DMA enable status
+      (+) Check the FIFO status 
+      (+) Configure the DMA Interrupts sources and check or clear the flags or 
+          pending bits status.  
+           
+    [..]
+      (#) DMA Enable status:
+          After configuring the DMA Stream (DMA_Init() function) and enabling 
+          the stream, it is recommended to check (or wait until) the DMA Stream 
+          is effectively enabled. A Stream may remain disabled if a configuration 
+          parameter is wrong. After disabling a DMA Stream, it is also recommended 
+          to check (or wait until) the DMA Stream is effectively disabled. 
+          If a Stream is disabled while a data transfer is ongoing, the current 
+          data will be transferred and the Stream will be effectively disabled 
+          only after this data transfer completion.
+          To monitor this state it is possible to use the following function:
+        (++) FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx); 
+ 
+      (#) FIFO Status:
+          It is possible to monitor the FIFO status when a transfer is ongoing 
+          using the following function:
+        (++) uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx); 
+ 
+      (#) DMA Interrupts and Flags:
+          The user should identify which mode will be used in his application 
+          to manage the DMA controller events: Polling mode or Interrupt mode. 
+    
+    *** Polling Mode ***
+    ====================
+    [..]
+    Each DMA stream can be managed through 4 event Flags:
+    (x : DMA Stream number )
+      (#) DMA_FLAG_FEIFx  : to indicate that a FIFO Mode Transfer Error event occurred.
+      (#) DMA_FLAG_DMEIFx : to indicate that a Direct Mode Transfer Error event occurred.
+      (#) DMA_FLAG_TEIFx  : to indicate that a Transfer Error event occurred.
+      (#) DMA_FLAG_HTIFx  : to indicate that a Half-Transfer Complete event occurred.
+      (#) DMA_FLAG_TCIFx  : to indicate that a Transfer Complete event occurred .       
+    [..]
+    In this Mode it is advised to use the following functions:
+      (+) FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
+      (+) void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
+
+    *** Interrupt Mode ***
+    ======================
+    [..]
+    Each DMA Stream can be managed through 4 Interrupts:
+
+    *** Interrupt Source ***
+    ========================
+    [..]
+      (#) DMA_IT_FEIFx  : specifies the interrupt source for the  FIFO Mode Transfer Error event.
+      (#) DMA_IT_DMEIFx : specifies the interrupt source for the Direct Mode Transfer Error event.
+      (#) DMA_IT_TEIFx  : specifies the interrupt source for the Transfer Error event.
+      (#) DMA_IT_HTIFx  : specifies the interrupt source for the Half-Transfer Complete event.
+      (#) DMA_IT_TCIFx  : specifies the interrupt source for the a Transfer Complete event. 
+    [..]
+    In this Mode it is advised to use the following functions:
+      (+) void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState);
+      (+) ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
+      (+) void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Returns the status of EN bit for the specified DMAy Streamx.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  *   
+  * @note    After configuring the DMA Stream (DMA_Init() function) and enabling
+  *          the stream, it is recommended to check (or wait until) the DMA Stream
+  *          is effectively enabled. A Stream may remain disabled if a configuration
+  *          parameter is wrong.
+  *          After disabling a DMA Stream, it is also recommended to check (or wait 
+  *          until) the DMA Stream is effectively disabled. If a Stream is disabled
+  *          while a data transfer is ongoing, the current data will be transferred
+  *          and the Stream will be effectively disabled only after the transfer
+  *          of this single data is finished.  
+  *      
+  * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
+  */
+FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
+{
+  FunctionalState state = DISABLE;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+
+  if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
+  {
+    /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
+    state = ENABLE;
+  }
+  else
+  {
+    /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
+        all transfers are complete) */
+    state = DISABLE;
+  }
+  return state;
+}
+
+/**
+  * @brief  Returns the current DMAy Streamx FIFO filled level.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0 
+  *         to 7 to select the DMA Stream.
+  * @retval The FIFO filling state.
+  *           - DMA_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
+  *                                               and not empty.
+  *           - DMA_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
+  *           - DMA_FIFOStatus_HalfFull: if more than 1 half-full.
+  *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
+  *           - DMA_FIFOStatus_Empty: when FIFO is empty
+  *           - DMA_FIFOStatus_Full: when FIFO is full
+  */
+uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
+{
+  uint32_t tmpreg = 0;
+ 
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  
+  /* Get the FIFO level bits */
+  tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
+  
+  return tmpreg;
+}
+
+/**
+  * @brief  Checks whether the specified DMAy Streamx flag is set or not.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  DMA_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg DMA_FLAG_TCIFx:  Streamx transfer complete flag
+  *            @arg DMA_FLAG_HTIFx:  Streamx half transfer complete flag
+  *            @arg DMA_FLAG_TEIFx:  Streamx transfer error flag
+  *            @arg DMA_FLAG_DMEIFx: Streamx direct mode error flag
+  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
+  *         Where x can be 0 to 7 to select the DMA Stream.
+  * @retval The new state of DMA_FLAG (SET or RESET).
+  */
+FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  DMA_TypeDef* DMAy;
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
+
+  /* Determine the DMA to which belongs the stream */
+  if (DMAy_Streamx < DMA2_Stream0)
+  {
+    /* DMAy_Streamx belongs to DMA1 */
+    DMAy = DMA1; 
+  } 
+  else 
+  {
+    /* DMAy_Streamx belongs to DMA2 */
+    DMAy = DMA2; 
+  }
+
+  /* Check if the flag is in HISR or LISR */
+  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
+  {
+    /* Get DMAy HISR register value */
+    tmpreg = DMAy->HISR;
+  }
+  else
+  {
+    /* Get DMAy LISR register value */
+    tmpreg = DMAy->LISR;
+  }   
+ 
+  /* Mask the reserved bits */
+  tmpreg &= (uint32_t)RESERVED_MASK;
+
+  /* Check the status of the specified DMA flag */
+  if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
+  {
+    /* DMA_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DMA_FLAG is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the DMA_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DMAy Streamx's pending flags.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  DMA_FLAG: specifies the flag to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg DMA_FLAG_TCIFx:  Streamx transfer complete flag
+  *            @arg DMA_FLAG_HTIFx:  Streamx half transfer complete flag
+  *            @arg DMA_FLAG_TEIFx:  Streamx transfer error flag
+  *            @arg DMA_FLAG_DMEIFx: Streamx direct mode error flag
+  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
+  *         Where x can be 0 to 7 to select the DMA Stream.   
+  * @retval None
+  */
+void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
+{
+  DMA_TypeDef* DMAy;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
+
+  /* Determine the DMA to which belongs the stream */
+  if (DMAy_Streamx < DMA2_Stream0)
+  {
+    /* DMAy_Streamx belongs to DMA1 */
+    DMAy = DMA1; 
+  } 
+  else 
+  {
+    /* DMAy_Streamx belongs to DMA2 */
+    DMAy = DMA2; 
+  }
+
+  /* Check if LIFCR or HIFCR register is targeted */
+  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
+  {
+    /* Set DMAy HIFCR register clear flag bits */
+    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
+  }
+  else 
+  {
+    /* Set DMAy LIFCR register clear flag bits */
+    DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
+  }    
+}
+
+/**
+  * @brief  Enables or disables the specified DMAy Streamx interrupts.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param DMA_IT: specifies the DMA interrupt sources to be enabled or disabled. 
+  *          This parameter can be any combination of the following values:
+  *            @arg DMA_IT_TC:  Transfer complete interrupt mask
+  *            @arg DMA_IT_HT:  Half transfer complete interrupt mask
+  *            @arg DMA_IT_TE:  Transfer error interrupt mask
+  *            @arg DMA_IT_FE:  FIFO error interrupt mask
+  * @param  NewState: new state of the specified DMA interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* Check if the DMA_IT parameter contains a FIFO interrupt */
+  if ((DMA_IT & DMA_IT_FE) != 0)
+  {
+    if (NewState != DISABLE)
+    {
+      /* Enable the selected DMA FIFO interrupts */
+      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
+    }    
+    else 
+    {
+      /* Disable the selected DMA FIFO interrupts */
+      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
+    }
+  }
+
+  /* Check if the DMA_IT parameter contains a Transfer interrupt */
+  if (DMA_IT != DMA_IT_FE)
+  {
+    if (NewState != DISABLE)
+    {
+      /* Enable the selected DMA transfer interrupts */
+      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
+    }
+    else
+    {
+      /* Disable the selected DMA transfer interrupts */
+      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
+    }    
+  }
+}
+
+/**
+  * @brief  Checks whether the specified DMAy Streamx interrupt has occurred or not.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  DMA_IT: specifies the DMA interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg DMA_IT_TCIFx:  Streamx transfer complete interrupt
+  *            @arg DMA_IT_HTIFx:  Streamx half transfer complete interrupt
+  *            @arg DMA_IT_TEIFx:  Streamx transfer error interrupt
+  *            @arg DMA_IT_DMEIFx: Streamx direct mode error interrupt
+  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
+  *         Where x can be 0 to 7 to select the DMA Stream.
+  * @retval The new state of DMA_IT (SET or RESET).
+  */
+ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
+{
+  ITStatus bitstatus = RESET;
+  DMA_TypeDef* DMAy;
+  uint32_t tmpreg = 0, enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_GET_IT(DMA_IT));
+ 
+  /* Determine the DMA to which belongs the stream */
+  if (DMAy_Streamx < DMA2_Stream0)
+  {
+    /* DMAy_Streamx belongs to DMA1 */
+    DMAy = DMA1; 
+  } 
+  else 
+  {
+    /* DMAy_Streamx belongs to DMA2 */
+    DMAy = DMA2; 
+  }
+
+  /* Check if the interrupt enable bit is in the CR or FCR register */
+  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
+  {
+    /* Get the interrupt enable position mask in CR register */
+    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
+    
+    /* Check the enable bit in CR register */
+    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
+  }
+  else 
+  {
+    /* Check the enable bit in FCR register */
+    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
+  }
+ 
+  /* Check if the interrupt pending flag is in LISR or HISR */
+  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
+  {
+    /* Get DMAy HISR register value */
+    tmpreg = DMAy->HISR ;
+  }
+  else
+  {
+    /* Get DMAy LISR register value */
+    tmpreg = DMAy->LISR ;
+  } 
+
+  /* mask all reserved bits */
+  tmpreg &= (uint32_t)RESERVED_MASK;
+
+  /* Check the status of the specified DMA interrupt */
+  if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
+  {
+    /* DMA_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DMA_IT is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the DMA_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DMAy Streamx's interrupt pending bits.
+  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
+  *          to 7 to select the DMA Stream.
+  * @param  DMA_IT: specifies the DMA interrupt pending bit to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg DMA_IT_TCIFx:  Streamx transfer complete interrupt
+  *            @arg DMA_IT_HTIFx:  Streamx half transfer complete interrupt
+  *            @arg DMA_IT_TEIFx:  Streamx transfer error interrupt
+  *            @arg DMA_IT_DMEIFx: Streamx direct mode error interrupt
+  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
+  *         Where x can be 0 to 7 to select the DMA Stream.
+  * @retval None
+  */
+void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
+{
+  DMA_TypeDef* DMAy;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
+  assert_param(IS_DMA_CLEAR_IT(DMA_IT));
+
+  /* Determine the DMA to which belongs the stream */
+  if (DMAy_Streamx < DMA2_Stream0)
+  {
+    /* DMAy_Streamx belongs to DMA1 */
+    DMAy = DMA1; 
+  } 
+  else 
+  {
+    /* DMAy_Streamx belongs to DMA2 */
+    DMAy = DMA2; 
+  }
+
+  /* Check if LIFCR or HIFCR register is targeted */
+  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
+  {
+    /* Set DMAy HIFCR register clear interrupt bits */
+    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
+  }
+  else 
+  {
+    /* Set DMAy LIFCR register clear interrupt bits */
+    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
+  }   
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma2d.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma2d.c
new file mode 100644
index 0000000..821c27e
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma2d.c
@@ -0,0 +1,784 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_dma2d.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the DMA2D controller (DMA2D) peripheral:
+  *           + Initialization and configuration
+  *           + Interrupts and flags management
+  *           
+  @verbatim  
+ ===============================================================================
+                      ##### How to use this driver #####
+ ===============================================================================
+    [..]
+        (#) Enable DMA2D clock using 
+            RCC_APB2PeriphResetCmd(RCC_APB2Periph_DMA2D, ENABLE) function.
+            
+        (#) Configures DMA2D
+          (++) transfer mode 
+          (++) pixel format, line_number, pixel_per_line
+          (++) output memory address
+          (++) alpha value
+          (++) output offset
+          (++) Default color (RGB)
+           
+        (#) Configures Foreground or/and background
+          (++) memory address
+          (++) alpha value
+          (++) offset and default color
+  
+        (#) Call the DMA2D_Start() to enable the DMA2D controller.
+        
+    @endverbatim
+  
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_dma2d.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DMA2D 
+  * @brief DMA2D driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+#define CR_MASK                     ((uint32_t)0xFFFCE0FC)  /* DMA2D CR Mask */
+#define PFCCR_MASK                  ((uint32_t)0x00FC00C0)  /* DMA2D FGPFCCR Mask */
+#define DEAD_MASK                   ((uint32_t)0xFFFF00FE)  /* DMA2D DEAD Mask */
+
+/** @defgroup DMA2D_Private_Functions
+  * @{
+  */
+
+/** @defgroup DMA2D_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim
+ ===============================================================================
+            ##### Initialization and Configuration functions #####
+ ===============================================================================
+    [..]  This section provides functions allowing to:
+      (+) Initialize and configure the DMA2D
+      (+) Start/Abort/Suspend Transfer
+      (+) Initialize, configure and set Foreground and background
+      (+) configure and enable DeadTime
+      (+) configure lineWatermark
+    
+    
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the DMA2D peripheral registers to their default reset
+  *         values.
+  * @param  None
+  * @retval None
+  */
+
+void DMA2D_DeInit(void)
+{
+  /* Enable DMA2D reset state */
+  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2D, ENABLE);
+  /* Release DMA2D from reset state */
+  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2D, DISABLE);
+}
+
+
+/**
+  * @brief  Initializes the DMA2D peripheral according to the specified parameters
+  *         in the DMA2D_InitStruct.
+  * @note   This function can be used only when the DMA2D is disabled.
+  * @param  DMA2D_InitStruct: pointer to a DMA2D_InitTypeDef structure that contains
+  *         the configuration information for the specified DMA2D peripheral.
+  * @retval None
+  */
+void DMA2D_Init(DMA2D_InitTypeDef* DMA2D_InitStruct)
+{
+
+  uint32_t outgreen = 0;
+  uint32_t outred   = 0;
+  uint32_t outalpha = 0;
+  uint32_t pixline  = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA2D_MODE(DMA2D_InitStruct->DMA2D_Mode));
+  assert_param(IS_DMA2D_CMODE(DMA2D_InitStruct->DMA2D_CMode));
+  assert_param(IS_DMA2D_OGREEN(DMA2D_InitStruct->DMA2D_OutputGreen));
+  assert_param(IS_DMA2D_ORED(DMA2D_InitStruct->DMA2D_OutputRed));
+  assert_param(IS_DMA2D_OBLUE(DMA2D_InitStruct->DMA2D_OutputBlue));
+  assert_param(IS_DMA2D_OALPHA(DMA2D_InitStruct->DMA2D_OutputAlpha));
+  assert_param(IS_DMA2D_OUTPUT_OFFSET(DMA2D_InitStruct->DMA2D_OutputOffset));
+  assert_param(IS_DMA2D_LINE(DMA2D_InitStruct->DMA2D_NumberOfLine));
+  assert_param(IS_DMA2D_PIXEL(DMA2D_InitStruct->DMA2D_PixelPerLine));
+
+  /* Configures the DMA2D operation mode */
+  DMA2D->CR &= (uint32_t)CR_MASK;
+  DMA2D->CR |= (DMA2D_InitStruct->DMA2D_Mode);
+
+  /* Configures the color mode of the output image */
+  DMA2D->OPFCCR &= ~(uint32_t)DMA2D_OPFCCR_CM;
+  DMA2D->OPFCCR |= (DMA2D_InitStruct->DMA2D_CMode);
+
+  /* Configures the output color */
+
+  if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_ARGB8888)
+  {
+    outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 8;
+    outred = DMA2D_InitStruct->DMA2D_OutputRed << 16;
+    outalpha = DMA2D_InitStruct->DMA2D_OutputAlpha << 24;
+  }
+  else
+  
+    if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_RGB888)
+    {
+      outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 8;
+      outred = DMA2D_InitStruct->DMA2D_OutputRed << 16;
+      outalpha = (uint32_t)0x00000000;
+    }
+     
+  else
+
+    if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_RGB565)
+    {
+      outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 5;
+      outred = DMA2D_InitStruct->DMA2D_OutputRed << 11;
+      outalpha = (uint32_t)0x00000000;
+    }
+
+  else
+
+    if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_ARGB1555)
+    {  
+      outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 5;
+      outred = DMA2D_InitStruct->DMA2D_OutputRed << 10;
+      outalpha = DMA2D_InitStruct->DMA2D_OutputAlpha << 15;
+    }
+
+  else /* DMA2D_CMode = DMA2D_ARGB4444 */
+  {
+    outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 4;
+    outred = DMA2D_InitStruct->DMA2D_OutputRed << 8;
+    outalpha = DMA2D_InitStruct->DMA2D_OutputAlpha << 12;
+  }  
+  DMA2D->OCOLR |= ((outgreen) | (outred) | (DMA2D_InitStruct->DMA2D_OutputBlue) | (outalpha));
+
+  /* Configures the output memory address */
+  DMA2D->OMAR = (DMA2D_InitStruct->DMA2D_OutputMemoryAdd);
+
+  /* Configure  the line Offset */
+  DMA2D->OOR &= ~(uint32_t)DMA2D_OOR_LO;
+  DMA2D->OOR |= (DMA2D_InitStruct->DMA2D_OutputOffset);
+
+  /* Configure the number of line and pixel per line */
+  pixline = DMA2D_InitStruct->DMA2D_PixelPerLine << 16; 
+  DMA2D->NLR &= ~(DMA2D_NLR_NL | DMA2D_NLR_PL);
+  DMA2D->NLR |= ((DMA2D_InitStruct->DMA2D_NumberOfLine) | (pixline));
+
+/**
+  * @brief  Fills each DMA2D_InitStruct member with its default value.
+  * @param  DMA2D_InitStruct: pointer to a DMA2D_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+}
+void DMA2D_StructInit(DMA2D_InitTypeDef* DMA2D_InitStruct)
+{
+  /* Initialize the transfer mode member */
+  DMA2D_InitStruct->DMA2D_Mode = DMA2D_M2M;
+
+  /* Initialize the output color mode members */
+  DMA2D_InitStruct->DMA2D_CMode = DMA2D_ARGB8888;
+
+  /* Initialize the alpha and RGB values */
+  DMA2D_InitStruct->DMA2D_OutputGreen = 0x00;
+  DMA2D_InitStruct->DMA2D_OutputBlue = 0x00;
+  DMA2D_InitStruct->DMA2D_OutputRed = 0x00;
+  DMA2D_InitStruct->DMA2D_OutputAlpha = 0x00;
+
+  /* Initialize the output memory address */
+  DMA2D_InitStruct->DMA2D_OutputMemoryAdd = 0x00;
+
+  /* Initialize the output offset */
+  DMA2D_InitStruct->DMA2D_OutputOffset = 0x00;
+
+  /* Initialize the number of line and the number of pixel per line */
+  DMA2D_InitStruct->DMA2D_NumberOfLine = 0x00;
+  DMA2D_InitStruct->DMA2D_PixelPerLine = 0x00;
+}
+
+/**
+  * @brief  Start the DMA2D transfer.
+  * @param 
+  * @retval None
+  */
+
+void DMA2D_StartTransfer(void)
+{
+    /* Start DMA2D transfer by setting START bit */
+    DMA2D->CR |= (uint32_t)DMA2D_CR_START;
+}
+
+/**
+  * @brief  Aboart the DMA2D transfer.
+  * @param
+  * @retval None
+  */
+
+void DMA2D_AbortTransfer(void)
+{
+    /* Start DMA2D transfer by setting START bit */
+    DMA2D->CR |= (uint32_t)DMA2D_CR_ABORT;
+
+}
+
+/**
+  * @brief  Stop or continue the DMA2D transfer.
+  * @param  NewState: new state of the DMA2D peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DMA2D_Suspend(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Suspend DMA2D transfer by setting STOP bit */
+    DMA2D->CR |= (uint32_t)DMA2D_CR_SUSP;
+  }
+  else
+  {
+    /* Continue DMA2D transfer by clearing STOP bit */
+    DMA2D->CR &= ~(uint32_t)DMA2D_CR_SUSP;
+  }
+}
+
+/**
+  * @brief  Configures the Foreground according to the specified parameters
+  *         in the DMA2D_FGStruct.
+  * @note   This function can be used only when the transfer is disabled.
+  * @param  DMA2D_FGStruct: pointer to a DMA2D_FGTypeDef structure that contains
+  *         the configuration information for the specified Background.
+  * @retval None
+  */
+void DMA2D_FGConfig(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct)
+{
+
+  uint32_t fg_clutcolormode = 0;
+  uint32_t fg_clutsize = 0;
+  uint32_t fg_alpha_mode = 0;
+  uint32_t fg_alphavalue = 0;
+  uint32_t fg_colorgreen = 0;
+  uint32_t fg_colorred = 0;
+
+  assert_param(IS_DMA2D_FGO(DMA2D_FG_InitStruct->DMA2D_FGO));
+  assert_param(IS_DMA2D_FGCM(DMA2D_FG_InitStruct->DMA2D_FGCM));
+  assert_param(IS_DMA2D_FG_CLUT_CM(DMA2D_FG_InitStruct->DMA2D_FG_CLUT_CM));
+  assert_param(IS_DMA2D_FG_CLUT_SIZE(DMA2D_FG_InitStruct->DMA2D_FG_CLUT_SIZE));
+  assert_param(IS_DMA2D_FG_ALPHA_MODE(DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_MODE));
+  assert_param(IS_DMA2D_FG_ALPHA_VALUE(DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_VALUE));
+  assert_param(IS_DMA2D_FGC_BLUE(DMA2D_FG_InitStruct->DMA2D_FGC_BLUE));
+  assert_param(IS_DMA2D_FGC_GREEN(DMA2D_FG_InitStruct->DMA2D_FGC_GREEN));
+  assert_param(IS_DMA2D_FGC_RED(DMA2D_FG_InitStruct->DMA2D_FGC_RED));
+
+  /* Configures the FG memory address */
+  DMA2D->FGMAR = (DMA2D_FG_InitStruct->DMA2D_FGMA);
+
+  /* Configures the FG offset */
+  DMA2D->FGOR &= ~(uint32_t)DMA2D_FGOR_LO;
+  DMA2D->FGOR |= (DMA2D_FG_InitStruct->DMA2D_FGO);
+
+  /* Configures foreground Pixel Format Convertor */
+  DMA2D->FGPFCCR &= (uint32_t)PFCCR_MASK;
+  fg_clutcolormode = DMA2D_FG_InitStruct->DMA2D_FG_CLUT_CM << 4;
+  fg_clutsize = DMA2D_FG_InitStruct->DMA2D_FG_CLUT_SIZE << 8;
+  fg_alpha_mode = DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_MODE << 16;
+  fg_alphavalue = DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_VALUE << 24;
+  DMA2D->FGPFCCR |= (DMA2D_FG_InitStruct->DMA2D_FGCM | fg_clutcolormode | fg_clutsize | \
+                    fg_alpha_mode | fg_alphavalue);
+
+  /* Configures foreground color */
+  DMA2D->FGCOLR &= ~(DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | DMA2D_FGCOLR_RED);
+  fg_colorgreen = DMA2D_FG_InitStruct->DMA2D_FGC_GREEN << 8;
+  fg_colorred = DMA2D_FG_InitStruct->DMA2D_FGC_RED << 16;
+  DMA2D->FGCOLR |= (DMA2D_FG_InitStruct->DMA2D_FGC_BLUE | fg_colorgreen | fg_colorred);
+
+  /* Configures foreground CLUT memory address */
+  DMA2D->FGCMAR = DMA2D_FG_InitStruct->DMA2D_FGCMAR;
+}
+
+/**
+  * @brief  Fills each DMA2D_FGStruct member with its default value.
+  * @param  DMA2D_FGStruct: pointer to a DMA2D_FGTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void DMA2D_FG_StructInit(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct)
+{
+  /*!< Initialize the DMA2D foreground memory address */
+  DMA2D_FG_InitStruct->DMA2D_FGMA = 0x00;
+
+  /*!< Initialize the DMA2D foreground offset */
+  DMA2D_FG_InitStruct->DMA2D_FGO = 0x00;
+
+  /*!< Initialize the DMA2D foreground color mode */
+  DMA2D_FG_InitStruct->DMA2D_FGCM = CM_ARGB8888;
+
+  /*!< Initialize the DMA2D foreground CLUT color mode */
+  DMA2D_FG_InitStruct->DMA2D_FG_CLUT_CM = CLUT_CM_ARGB8888;
+
+  /*!< Initialize the DMA2D foreground CLUT size */
+  DMA2D_FG_InitStruct->DMA2D_FG_CLUT_SIZE = 0x00;
+
+  /*!< Initialize the DMA2D foreground alpha mode */
+  DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_MODE = NO_MODIF_ALPHA_VALUE;
+
+  /*!< Initialize the DMA2D foreground alpha value */
+  DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_VALUE = 0x00;
+
+  /*!< Initialize the DMA2D foreground blue value */
+  DMA2D_FG_InitStruct->DMA2D_FGC_BLUE = 0x00;
+
+  /*!< Initialize the DMA2D foreground green value */
+  DMA2D_FG_InitStruct->DMA2D_FGC_GREEN = 0x00;
+
+  /*!< Initialize the DMA2D foreground red value */
+  DMA2D_FG_InitStruct->DMA2D_FGC_RED = 0x00;
+
+  /*!< Initialize the DMA2D foreground CLUT memory address */
+  DMA2D_FG_InitStruct->DMA2D_FGCMAR = 0x00;
+}
+
+
+/**
+  * @brief  Configures the Background according to the specified parameters
+  *         in the DMA2D_BGStruct.
+  * @note   This function can be used only when the transfer is disabled.
+  * @param  DMA2D_BGStruct: pointer to a DMA2D_BGTypeDef structure that contains
+  *         the configuration information for the specified Background.
+  * @retval None
+  */
+void DMA2D_BGConfig(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct)
+{
+
+  uint32_t bg_clutcolormode = 0;
+  uint32_t bg_clutsize = 0;
+  uint32_t bg_alpha_mode = 0;
+  uint32_t bg_alphavalue = 0;
+  uint32_t bg_colorgreen = 0;
+  uint32_t bg_colorred = 0;
+
+  assert_param(IS_DMA2D_BGO(DMA2D_BG_InitStruct->DMA2D_BGO));
+  assert_param(IS_DMA2D_BGCM(DMA2D_BG_InitStruct->DMA2D_BGCM));
+  assert_param(IS_DMA2D_BG_CLUT_CM(DMA2D_BG_InitStruct->DMA2D_BG_CLUT_CM));
+  assert_param(IS_DMA2D_BG_CLUT_SIZE(DMA2D_BG_InitStruct->DMA2D_BG_CLUT_SIZE));
+  assert_param(IS_DMA2D_BG_ALPHA_MODE(DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_MODE));
+  assert_param(IS_DMA2D_BG_ALPHA_VALUE(DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_VALUE));
+  assert_param(IS_DMA2D_BGC_BLUE(DMA2D_BG_InitStruct->DMA2D_BGC_BLUE));
+  assert_param(IS_DMA2D_BGC_GREEN(DMA2D_BG_InitStruct->DMA2D_BGC_GREEN));
+  assert_param(IS_DMA2D_BGC_RED(DMA2D_BG_InitStruct->DMA2D_BGC_RED));
+
+  /* Configures the BG memory address */
+  DMA2D->BGMAR = (DMA2D_BG_InitStruct->DMA2D_BGMA);
+
+  /* Configures the BG offset */
+  DMA2D->BGOR &= ~(uint32_t)DMA2D_BGOR_LO;
+  DMA2D->BGOR |= (DMA2D_BG_InitStruct->DMA2D_BGO);
+
+  /* Configures background Pixel Format Convertor */
+  DMA2D->BGPFCCR &= (uint32_t)PFCCR_MASK;
+  bg_clutcolormode = DMA2D_BG_InitStruct->DMA2D_BG_CLUT_CM << 4;
+  bg_clutsize = DMA2D_BG_InitStruct->DMA2D_BG_CLUT_SIZE << 8;
+  bg_alpha_mode = DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_MODE << 16;
+  bg_alphavalue = DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_VALUE << 24;
+  DMA2D->BGPFCCR |= (DMA2D_BG_InitStruct->DMA2D_BGCM | bg_clutcolormode | bg_clutsize | \
+                    bg_alpha_mode | bg_alphavalue);
+
+  /* Configures background color */
+  DMA2D->BGCOLR &= ~(DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | DMA2D_BGCOLR_RED);
+  bg_colorgreen = DMA2D_BG_InitStruct->DMA2D_BGC_GREEN << 8;
+  bg_colorred = DMA2D_BG_InitStruct->DMA2D_BGC_RED << 16;
+  DMA2D->BGCOLR |= (DMA2D_BG_InitStruct->DMA2D_BGC_BLUE | bg_colorgreen | bg_colorred);
+  
+  /* Configures background CLUT memory address */
+  DMA2D->BGCMAR = DMA2D_BG_InitStruct->DMA2D_BGCMAR;
+
+}
+
+/**
+  * @brief  Fills each DMA2D_BGStruct member with its default value.
+  * @param  DMA2D_BGStruct: pointer to a DMA2D_BGTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void DMA2D_BG_StructInit(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct)
+{
+  /*!< Initialize the DMA2D background memory address */
+  DMA2D_BG_InitStruct->DMA2D_BGMA = 0x00;
+
+  /*!< Initialize the DMA2D background offset */
+  DMA2D_BG_InitStruct->DMA2D_BGO = 0x00;
+
+  /*!< Initialize the DMA2D background color mode */
+  DMA2D_BG_InitStruct->DMA2D_BGCM = CM_ARGB8888;
+
+  /*!< Initialize the DMA2D background CLUT color mode */
+  DMA2D_BG_InitStruct->DMA2D_BG_CLUT_CM = CLUT_CM_ARGB8888;
+
+  /*!< Initialize the DMA2D background CLUT size */
+  DMA2D_BG_InitStruct->DMA2D_BG_CLUT_SIZE = 0x00;
+
+  /*!< Initialize the DMA2D background alpha mode */
+  DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_MODE = NO_MODIF_ALPHA_VALUE;
+
+  /*!< Initialize the DMA2D background alpha value */
+  DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_VALUE = 0x00;
+
+  /*!< Initialize the DMA2D background blue value */
+  DMA2D_BG_InitStruct->DMA2D_BGC_BLUE = 0x00;
+
+  /*!< Initialize the DMA2D background green value */
+  DMA2D_BG_InitStruct->DMA2D_BGC_GREEN = 0x00;
+
+  /*!< Initialize the DMA2D background red value */
+  DMA2D_BG_InitStruct->DMA2D_BGC_RED = 0x00;
+
+  /*!< Initialize the DMA2D background CLUT memory address */
+  DMA2D_BG_InitStruct->DMA2D_BGCMAR = 0x00;
+}
+
+/**
+  * @brief  Start the automatic loading of the CLUT or abort the transfer.
+  * @param  NewState: new state of the DMA2D peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+
+void DMA2D_FGStart(FunctionalState NewState) 
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Start the automatic loading of the CLUT */
+    DMA2D->FGPFCCR |= DMA2D_FGPFCCR_START;
+  }
+  else
+  {
+    /* abort the transfer */
+    DMA2D->FGPFCCR &= (uint32_t)~DMA2D_FGPFCCR_START;
+  }
+}
+
+/**
+  * @brief  Start the automatic loading of the CLUT or abort the transfer.
+  * @param  NewState: new state of the DMA2D peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+  
+void DMA2D_BGStart(FunctionalState NewState) 
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Start the automatic loading of the CLUT */
+    DMA2D->BGPFCCR |= DMA2D_BGPFCCR_START;
+  }
+  else
+  {
+    /* abort the transfer */
+    DMA2D->BGPFCCR &= (uint32_t)~DMA2D_BGPFCCR_START;
+  }
+}
+
+/**
+  * @brief  Configures the DMA2D dead time.
+  * @param  DMA2D_DeadTime: specifies the DMA2D dead time.
+  *   This parameter can be one of the following values:
+  * @retval None
+  */
+void DMA2D_DeadTimeConfig(uint32_t DMA2D_DeadTime, FunctionalState NewState)
+{
+   uint32_t DeadTime;
+
+  /* Check the parameters */
+  assert_param(IS_DMA2D_DEAD_TIME(DMA2D_DeadTime));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable and Configures the dead time */
+    DMA2D->AMTCR &= (uint32_t)DEAD_MASK;
+    DeadTime = DMA2D_DeadTime << 8;
+    DMA2D->AMTCR |= (DeadTime | DMA2D_AMTCR_EN);
+  }
+  else
+  {
+     DMA2D->AMTCR &= ~(uint32_t)DMA2D_AMTCR_EN;
+  }
+}
+
+/**
+  * @brief  Define the configuration of the line watermark .
+  * @param  DMA2D_LWatermarkConfig: Line Watermark configuration.
+  * @retval None
+  */
+
+void DMA2D_LineWatermarkConfig(uint32_t DMA2D_LWatermarkConfig)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA2D_LineWatermark(DMA2D_LWatermarkConfig));
+
+  /* Sets the Line watermark configuration */
+  DMA2D->LWR = (uint32_t)DMA2D_LWatermarkConfig;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA2D_Group2 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim
+ ===============================================================================
+            ##### Interrupts and flags management functions #####
+ ===============================================================================
+
+    [..] This section provides functions allowing to configure the DMA2D 
+         Interrupts and to get the status and clear flags and Interrupts 
+         pending bits.
+    [..] The DMA2D provides 6 Interrupts sources and 6 Flags
+    
+    *** Flags ***
+    =============
+    [..]
+      (+) DMA2D_FLAG_CE : Configuration Error Interrupt flag
+      (+) DMA2D_FLAG_CAE: CLUT Access Error Interrupt flag
+      (+) DMA2D_FLAG_TW:  Transfer Watermark Interrupt flag
+      (+) DMA2D_FLAG_TC:  Transfer Complete interrupt flag
+      (+) DMA2D_FLAG_TE:  Transfer Error interrupt flag
+      (+) DMA2D_FLAG_CTC: CLUT Transfer Complete Interrupt flag
+      
+    *** Interrupts ***
+    ==================
+    [..]
+      (+) DMA2D_IT_CE: Configuration Error Interrupt is generated when a wrong 
+                       configuration is detected
+      (+) DMA2D_IT_CAE: CLUT Access Error Interrupt
+      (+) DMA2D_IT_TW: Transfer Watermark Interrupt is generated when 
+                       the programmed watermark is reached 
+      (+) DMA2D_IT_TE: Transfer Error interrupt is generated when the CPU trying 
+                       to access the CLUT while a CLUT loading or a DMA2D1 transfer 
+                       is on going       
+      (+) DMA2D_IT_CTC: CLUT Transfer Complete Interrupt 
+      (+) DMA2D_IT_TC: Transfer Complete interrupt         
+@endverbatim
+  * @{
+  */
+/**
+  * @brief  Enables or disables the specified DMA2D's interrupts.
+  * @param  DMA2D_IT: specifies the DMA2D interrupts sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg DMA2D_IT_CE:   Configuration Error Interrupt Enable.
+  *     @arg DMA2D_IT_CTC:  CLUT Transfer Complete Interrupt Enable.
+  *     @arg DMA2D_IT_CAE:  CLUT Access Error Interrupt Enable.
+  *     @arg DMA2D_IT_TW:   Transfer Watermark Interrupt Enable.
+  *     @arg DMA2D_IT_TC:   Transfer Complete interrupt enable.
+  *     @arg DMA2D_IT_TE:   Transfer Error interrupt enable.
+  * @param NewState: new state of the specified DMA2D interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+
+void DMA2D_ITConfig(uint32_t DMA2D_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA2D_IT(DMA2D_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMA2D interrupts */
+    DMA2D->CR |= DMA2D_IT;
+  }
+  else
+  {
+    /* Disable the selected DMA2D interrupts */
+    DMA2D->CR &= (uint32_t)~DMA2D_IT;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified DMA2D's flag is set or not.
+  * @param  DMA2D_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg DMA2D_FLAG_CE:   Configuration Error Interrupt flag.
+  *     @arg DMA2D_FLAG_CTC:  CLUT Transfer Complete Interrupt flag.
+  *     @arg DMA2D_FLAG_CAE:  CLUT Access Error Interrupt flag.
+  *     @arg DMA2D_FLAG_TW:   Transfer Watermark Interrupt flag.
+  *     @arg DMA2D_FLAG_TC:   Transfer Complete interrupt flag.
+  *     @arg DMA2D_FLAG_TE:   Transfer Error interrupt flag.
+  * @retval The new state of DMA2D_FLAG (SET or RESET).
+  */
+
+FlagStatus DMA2D_GetFlagStatus(uint32_t DMA2D_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_DMA2D_GET_FLAG(DMA2D_FLAG));
+  
+  /* Check the status of the specified DMA2D flag */
+  if (((DMA2D->ISR) & DMA2D_FLAG) != (uint32_t)RESET)
+  {
+    /* DMA2D_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DMA2D_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the DMA2D_FLAG status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the DMA2D's pending flags.
+  * @param  DMA2D_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg DMA2D_FLAG_CE:   Configuration Error Interrupt flag.
+  *     @arg DMA2D_FLAG_CTC:  CLUT Transfer Complete Interrupt flag.
+  *     @arg DMA2D_FLAG_CAE:  CLUT Access Error Interrupt flag.
+  *     @arg DMA2D_FLAG_TW:   Transfer Watermark Interrupt flag.
+  *     @arg DMA2D_FLAG_TC:   Transfer Complete interrupt flag.
+  *     @arg DMA2D_FLAG_TE:   Transfer Error interrupt flag.
+  * @retval None
+  */
+void DMA2D_ClearFlag(uint32_t DMA2D_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA2D_GET_FLAG(DMA2D_FLAG));
+    
+  /* Clear the corresponding DMA2D flag */
+  DMA2D->IFCR = (uint32_t)DMA2D_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified DMA2D's interrupt has occurred or not.
+  * @param  DMA2D_IT: specifies the DMA2D interrupts sources to check.
+  *   This parameter can be one of the following values:
+  *     @arg DMA2D_IT_CE:   Configuration Error Interrupt Enable.
+  *     @arg DMA2D_IT_CTC:  CLUT Transfer Complete Interrupt Enable.
+  *     @arg DMA2D_IT_CAE:  CLUT Access Error Interrupt Enable.
+  *     @arg DMA2D_IT_TW:   Transfer Watermark Interrupt Enable.
+  *     @arg DMA2D_IT_TC:   Transfer Complete interrupt enable.
+  *     @arg DMA2D_IT_TE:   Transfer Error interrupt enable.
+  * @retval The new state of the DMA2D_IT (SET or RESET).
+  */
+ITStatus DMA2D_GetITStatus(uint32_t DMA2D_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t DMA2D_IT_FLAG = DMA2D_IT >> 8;
+  
+  /* Check the parameters */
+  assert_param(IS_DMA2D_IT(DMA2D_IT));
+
+  if ((DMA2D->ISR & DMA2D_IT_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  
+  if (((DMA2D->CR & DMA2D_IT) != (uint32_t)RESET) && (bitstatus != (uint32_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the DMA2D's interrupt pending bits.
+  * @param  DMA2D_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg DMA2D_IT_CE:   Configuration Error Interrupt.
+  *     @arg DMA2D_IT_CTC:  CLUT Transfer Complete Interrupt.
+  *     @arg DMA2D_IT_CAE:  CLUT Access Error Interrupt.
+  *     @arg DMA2D_IT_TW:   Transfer Watermark Interrupt.
+  *     @arg DMA2D_IT_TC:   Transfer Complete interrupt.
+  *     @arg DMA2D_IT_TE:   Transfer Error interrupt.
+  * @retval None
+  */
+void DMA2D_ClearITPendingBit(uint32_t DMA2D_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA2D_IT(DMA2D_IT));
+  DMA2D_IT = DMA2D_IT >> 8;
+    
+  /* Clear the corresponding DMA2D Interrupt */
+  DMA2D->IFCR = (uint32_t)DMA2D_IT;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_exti.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_exti.c
new file mode 100644
index 0000000..74bf92c
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_exti.c
@@ -0,0 +1,311 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_exti.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the EXTI peripheral:           
+  *           + Initialization and Configuration
+  *           + Interrupts and flags management
+  *
+@verbatim  
+
+ ===============================================================================
+                              ##### EXTI features #####
+ ===============================================================================
+
+ [..] External interrupt/event lines are mapped as following:
+   (#) All available GPIO pins are connected to the 16 external 
+       interrupt/event lines from EXTI0 to EXTI15.
+   (#) EXTI line 16 is connected to the PVD Output
+   (#) EXTI line 17 is connected to the RTC Alarm event
+   (#) EXTI line 18 is connected to the USB OTG FS Wakeup from suspend event
+   (#) EXTI line 19 is connected to the Ethernet Wakeup event
+   (#) EXTI line 20 is connected to the USB OTG HS (configured in FS) Wakeup event 
+   (#) EXTI line 21 is connected to the RTC Tamper and Time Stamp events
+   (#) EXTI line 22 is connected to the RTC Wakeup event
+
+                       ##### How to use this driver #####
+ ===============================================================================
+ 
+ [..] In order to use an I/O pin as an external interrupt source, follow steps 
+      below:
+   (#) Configure the I/O in input mode using GPIO_Init()
+   (#) Select the input source pin for the EXTI line using SYSCFG_EXTILineConfig()
+   (#) Select the mode(interrupt, event) and configure the trigger 
+       selection (Rising, falling or both) using EXTI_Init()
+   (#) Configure NVIC IRQ channel mapped to the EXTI line using NVIC_Init()
+
+ [..]     
+   (@) SYSCFG APB clock must be enabled to get write access to SYSCFG_EXTICRx
+       registers using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
+
+@endverbatim
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_exti.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup EXTI 
+  * @brief EXTI driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+#define EXTI_LINENONE    ((uint32_t)0x00000)  /* No interrupt selected */
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup EXTI_Private_Functions
+  * @{
+  */
+
+/** @defgroup EXTI_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+             ##### Initialization and Configuration functions #####
+ ===============================================================================
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the EXTI peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void EXTI_DeInit(void)
+{
+  EXTI->IMR = 0x00000000;
+  EXTI->EMR = 0x00000000;
+  EXTI->RTSR = 0x00000000;
+  EXTI->FTSR = 0x00000000;
+  EXTI->PR = 0x007FFFFF;
+}
+
+/**
+  * @brief  Initializes the EXTI peripheral according to the specified
+  *         parameters in the EXTI_InitStruct.
+  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
+  *         that contains the configuration information for the EXTI peripheral.
+  * @retval None
+  */
+void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
+{
+  uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
+  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
+  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
+  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));
+
+  tmp = (uint32_t)EXTI_BASE;
+     
+  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
+  {
+    /* Clear EXTI line configuration */
+    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
+    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
+    
+    tmp += EXTI_InitStruct->EXTI_Mode;
+
+    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
+
+    /* Clear Rising Falling edge configuration */
+    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
+    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
+    
+    /* Select the trigger for the selected external interrupts */
+    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
+    {
+      /* Rising Falling edge */
+      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
+      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
+    }
+    else
+    {
+      tmp = (uint32_t)EXTI_BASE;
+      tmp += EXTI_InitStruct->EXTI_Trigger;
+
+      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
+    }
+  }
+  else
+  {
+    tmp += EXTI_InitStruct->EXTI_Mode;
+
+    /* Disable the selected external lines */
+    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
+  }
+}
+
+/**
+  * @brief  Fills each EXTI_InitStruct member with its reset value.
+  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
+{
+  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
+  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
+  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
+  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
+}
+
+/**
+  * @brief  Generates a Software interrupt on selected EXTI line.
+  * @param  EXTI_Line: specifies the EXTI line on which the software interrupt
+  *         will be generated.
+  *         This parameter can be any combination of EXTI_Linex where x can be (0..22)
+  * @retval None
+  */
+void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+  
+  EXTI->SWIER |= EXTI_Line;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Group2 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions 
+ *
+@verbatim   
+ ===============================================================================
+             ##### Interrupts and flags management functions #####
+ ===============================================================================
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Checks whether the specified EXTI line flag is set or not.
+  * @param  EXTI_Line: specifies the EXTI line flag to check.
+  *          This parameter can be EXTI_Linex where x can be(0..22)
+  * @retval The new state of EXTI_Line (SET or RESET).
+  */
+FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
+  
+  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the EXTI's line pending flags.
+  * @param  EXTI_Line: specifies the EXTI lines flags to clear.
+  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
+  * @retval None
+  */
+void EXTI_ClearFlag(uint32_t EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+  
+  EXTI->PR = EXTI_Line;
+}
+
+/**
+  * @brief  Checks whether the specified EXTI line is asserted or not.
+  * @param  EXTI_Line: specifies the EXTI line to check.
+  *          This parameter can be EXTI_Linex where x can be(0..22)
+  * @retval The new state of EXTI_Line (SET or RESET).
+  */
+ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
+  
+  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+  
+}
+
+/**
+  * @brief  Clears the EXTI's line pending bits.
+  * @param  EXTI_Line: specifies the EXTI lines to clear.
+  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
+  * @retval None
+  */
+void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+  
+  EXTI->PR = EXTI_Line;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash.c
new file mode 100644
index 0000000..df4c5c6
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash.c
@@ -0,0 +1,1612 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_flash.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the FLASH peripheral:
+  *            + FLASH Interface configuration
+  *            + FLASH Memory Programming
+  *            + Option Bytes Programming
+  *            + Interrupts and flags management
+  *  
+ @verbatim    
+ ===============================================================================
+                        ##### How to use this driver #####
+ ===============================================================================
+    [..]                             
+      This driver provides functions to configure and program the FLASH memory 
+      of all STM32F4xx devices. These functions are split in 4 groups:
+   
+      (#) FLASH Interface configuration functions: this group includes the
+          management of the following features:
+        (++) Set the latency
+        (++) Enable/Disable the prefetch buffer
+        (++) Enable/Disable the Instruction cache and the Data cache
+        (++) Reset the Instruction cache and the Data cache
+    
+      (#) FLASH Memory Programming functions: this group includes all needed
+          functions to erase and program the main memory:
+        (++) Lock and Unlock the FLASH interface
+        (++) Erase function: Erase sector, erase all sectors
+        (++) Program functions: byte, half word, word and double word
+    
+      (#) Option Bytes Programming functions: this group includes all needed
+          functions to manage the Option Bytes:
+        (++) Set/Reset the write protection
+        (++) Set the Read protection Level
+        (++) Set the BOR level
+        (++) Program the user Option Bytes
+        (++) Launch the Option Bytes loader
+    
+      (#) Interrupts and flags management functions: this group 
+          includes all needed functions to:
+        (++) Enable/Disable the FLASH interrupt sources
+        (++) Get flags status
+        (++) Clear flags
+        (++) Get FLASH operation status
+        (++) Wait for last FLASH operation   
+ @endverbatim
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_flash.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup FLASH 
+  * @brief FLASH driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/ 
+#define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup FLASH_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup FLASH_Group1 FLASH Interface configuration functions
+  *  @brief   FLASH Interface configuration functions 
+ *
+
+@verbatim   
+ ===============================================================================
+              ##### FLASH Interface configuration functions #####
+ ===============================================================================
+    [..]
+      This group includes the following functions:
+      (+) void FLASH_SetLatency(uint32_t FLASH_Latency)
+          To correctly read data from FLASH memory, the number of wait states (LATENCY) 
+          must be correctly programmed according to the frequency of the CPU clock 
+          (HCLK) and the supply voltage of the device.
+    [..]      
+      For STM32F405xx/07xx and STM32F415xx/17xx devices
+ +-------------------------------------------------------------------------------------+
+ | Latency       |                HCLK clock frequency (MHz)                           |
+ |               |---------------------------------------------------------------------|
+ |               | voltage range  | voltage range  | voltage range   | voltage range   |
+ |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |5WS(6CPU cycle)|150< HCLK <= 168|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120|
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140|
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |7WS(8CPU cycle)|      NA        |      NA        |154 < HCLK <= 168|140 < HCLK <= 160|
+ +---------------|----------------|----------------|-----------------|-----------------+
+
+    [..]      
+      For STM32F42xxx/43xxx devices
+ +-------------------------------------------------------------------------------------+
+ | Latency       |                HCLK clock frequency (MHz)                           |
+ |               |---------------------------------------------------------------------|
+ |               | voltage range  | voltage range  | voltage range   | voltage range   |
+ |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |5WS(6CPU cycle)|120< HCLK <= 180|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120|
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140|
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |7WS(8CPU cycle)|      NA        |168< HCLK <= 180|154 < HCLK <= 176|140 < HCLK <= 160|
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |8WS(9CPU cycle)|      NA        |      NA        |176 < HCLK <= 180|160 < HCLK <= 168|
+ +-------------------------------------------------------------------------------------+
+   
+    [..]
+    For STM32F401x devices
+ +-------------------------------------------------------------------------------------+
+ | Latency       |                HCLK clock frequency (MHz)                           |
+ |               |---------------------------------------------------------------------|
+ |               | voltage range  | voltage range  | voltage range   | voltage range   |
+ |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |2WS(3CPU cycle)|60 < HCLK <= 84 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |3WS(4CPU cycle)|      NA        |72 < HCLK <= 84 |66 < HCLK <= 84  |60 < HCLK <= 80  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |4WS(5CPU cycle)|      NA        |      NA        |      NA         |80 < HCLK <= 84  |
+ +-------------------------------------------------------------------------------------+
+
+    [..]
+    For STM32F411xE devices
+ +-------------------------------------------------------------------------------------+
+ | Latency       |                HCLK clock frequency (MHz)                           |
+ |               |---------------------------------------------------------------------|
+ |               | voltage range  | voltage range  | voltage range   | voltage range   |
+ |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 18   |0 < HCLK <= 16   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |1WS(2CPU cycle)|30 < HCLK <= 64 |24 < HCLK <= 48 |18 < HCLK <= 36  |16 < HCLK <= 32  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |2WS(3CPU cycle)|64 < HCLK <= 90 |48 < HCLK <= 72 |36 < HCLK <= 54  |32 < HCLK <= 48  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |3WS(4CPU cycle)|90 < HCLK <= 100|72 < HCLK <= 96 |54 < HCLK <= 72  |48 < HCLK <= 64  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |4WS(5CPU cycle)|      NA        |96 < HCLK <= 100|72 < HCLK <= 90  |64 < HCLK <= 80  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |5WS(6CPU cycle)|      NA        |       NA       |90 < HCLK <= 100 |80 < HCLK <= 96  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |6WS(7CPU cycle)|      NA        |       NA       |        NA       |96 < HCLK <= 100 |
+ +-------------------------------------------------------------------------------------+
+ 
+ [..]
+ +-------------------------------------------------------------------------------------------------------------------+
+ |               | voltage range  | voltage range  | voltage range   | voltage range   | voltage range 2.7 V - 3.6 V |
+ |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   | with External Vpp = 9V      |
+ |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|
+ |Max Parallelism|      x32       |               x16                |       x8        |          x64                |
+ |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|
+ |PSIZE[1:0]     |      10        |               01                 |       00        |           11                |
+ +-------------------------------------------------------------------------------------------------------------------+
+
+      -@- On STM32F405xx/407xx and STM32F415xx/417xx devices: 
+           (++) when VOS = '0' Scale 2 mode, the maximum value of fHCLK = 144MHz. 
+           (++) when VOS = '1' Scale 1 mode, the maximum value of fHCLK = 168MHz. 
+          [..] 
+          On STM32F42xxx/43xxx devices:
+           (++) when VOS[1:0] = '0x01' Scale 3 mode, the maximum value of fHCLK is 120MHz.
+           (++) when VOS[1:0] = '0x10' Scale 2 mode, the maximum value of fHCLK is 144MHz if OverDrive OFF and 168MHz if OverDrive ON.
+           (++) when VOS[1:0] = '0x11' Scale 1 mode, the maximum value of fHCLK is 168MHz if OverDrive OFF and 180MHz if OverDrive ON. 
+          [..]
+          On STM32F401x devices:
+           (++) when VOS[1:0] = '0x01' Scale 3 mode, the maximum value of fHCLK is 60MHz.
+           (++) when VOS[1:0] = '0x10' Scale 2 mode, the maximum value of fHCLK is 84MHz.
+          [..]  
+          On STM32F411xE devices:
+           (++) when VOS[1:0] = '0x01' Scale 3 mode, the maximum value of fHCLK is 64MHz.
+           (++) when VOS[1:0] = '0x10' Scale 2 mode, the maximum value of fHCLK is 84MHz.
+           (++) when VOS[1:0] = '0x11' Scale 1 mode, the maximum value of fHCLK is 100MHz.
+
+        For more details please refer product DataSheet 
+           You can use PWR_MainRegulatorModeConfig() function to control VOS bits.
+
+      (+) void FLASH_PrefetchBufferCmd(FunctionalState NewState)
+      (+) void FLASH_InstructionCacheCmd(FunctionalState NewState)
+      (+) void FLASH_DataCacheCmd(FunctionalState NewState)
+      (+) void FLASH_InstructionCacheReset(void)
+      (+) void FLASH_DataCacheReset(void)
+      
+    [..]   
+      The unlock sequence is not needed for these functions.
+ 
+@endverbatim
+  * @{
+  */
+ 
+/**
+  * @brief  Sets the code latency value.  
+  * @param  FLASH_Latency: specifies the FLASH Latency value.
+  *          This parameter can be one of the following values:
+  *            @arg FLASH_Latency_0: FLASH Zero Latency cycle
+  *            @arg FLASH_Latency_1: FLASH One Latency cycle
+  *            @arg FLASH_Latency_2: FLASH Two Latency cycles
+  *            @arg FLASH_Latency_3: FLASH Three Latency cycles
+  *            @arg FLASH_Latency_4: FLASH Four Latency cycles 
+  *            @arg FLASH_Latency_5: FLASH Five Latency cycles 
+  *            @arg FLASH_Latency_6: FLASH Six Latency cycles
+  *            @arg FLASH_Latency_7: FLASH Seven Latency cycles 
+  *            @arg FLASH_Latency_8: FLASH Eight Latency cycles
+  *            @arg FLASH_Latency_9: FLASH Nine Latency cycles
+  *            @arg FLASH_Latency_10: FLASH Teen Latency cycles 
+  *            @arg FLASH_Latency_11: FLASH Eleven Latency cycles 
+  *            @arg FLASH_Latency_12: FLASH Twelve Latency cycles
+  *            @arg FLASH_Latency_13: FLASH Thirteen Latency cycles
+  *            @arg FLASH_Latency_14: FLASH Fourteen Latency cycles
+  *            @arg FLASH_Latency_15: FLASH Fifteen Latency cycles 
+  *              
+  * @note For STM32F405xx/407xx, STM32F415xx/417xx and STM32F401xx/411xE devices this parameter
+  *       can be a value between FLASH_Latency_0 and FLASH_Latency_7.
+  *
+  * @note For STM32F42xxx/43xxx devices this parameter can be a value between 
+  *       FLASH_Latency_0 and FLASH_Latency_15. 
+  *         
+  * @retval None
+  */
+void FLASH_SetLatency(uint32_t FLASH_Latency)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
+  
+  /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
+  *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
+}
+
+/**
+  * @brief  Enables or disables the Prefetch Buffer.
+  * @param  NewState: new state of the Prefetch Buffer.
+  *          This parameter  can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FLASH_PrefetchBufferCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  /* Enable or disable the Prefetch Buffer */
+  if(NewState != DISABLE)
+  {
+    FLASH->ACR |= FLASH_ACR_PRFTEN;
+  }
+  else
+  {
+    FLASH->ACR &= (~FLASH_ACR_PRFTEN);
+  }
+}
+
+/**
+  * @brief  Enables or disables the Instruction Cache feature.
+  * @param  NewState: new state of the Instruction Cache.
+  *          This parameter  can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FLASH_InstructionCacheCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if(NewState != DISABLE)
+  {
+    FLASH->ACR |= FLASH_ACR_ICEN;
+  }
+  else
+  {
+    FLASH->ACR &= (~FLASH_ACR_ICEN);
+  }
+}
+
+/**
+  * @brief  Enables or disables the Data Cache feature.
+  * @param  NewState: new state of the Data Cache.
+  *          This parameter  can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FLASH_DataCacheCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if(NewState != DISABLE)
+  {
+    FLASH->ACR |= FLASH_ACR_DCEN;
+  }
+  else
+  {
+    FLASH->ACR &= (~FLASH_ACR_DCEN);
+  }
+}
+
+/**
+  * @brief  Resets the Instruction Cache.
+  * @note   This function must be used only when the Instruction Cache is disabled.  
+  * @param  None
+  * @retval None
+  */
+void FLASH_InstructionCacheReset(void)
+{
+  FLASH->ACR |= FLASH_ACR_ICRST;
+}
+
+/**
+  * @brief  Resets the Data Cache.
+  * @note   This function must be used only when the Data Cache is disabled.  
+  * @param  None
+  * @retval None
+  */
+void FLASH_DataCacheReset(void)
+{
+  FLASH->ACR |= FLASH_ACR_DCRST;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Group2 FLASH Memory Programming functions
+ *  @brief   FLASH Memory Programming functions
+ *
+@verbatim   
+ ===============================================================================
+                ##### FLASH Memory Programming functions #####
+ ===============================================================================   
+    [..]
+      This group includes the following functions:
+      (+) void FLASH_Unlock(void)
+      (+) void FLASH_Lock(void)
+      (+) FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
+      (+) FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)       
+      (+) FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
+      (+) FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
+      (+) FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
+      (+) FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
+          The following functions can be used only for STM32F42xxx/43xxx devices. 
+      (+) FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
+      (+) FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)    
+    [..]   
+      Any operation of erase or program should follow these steps:
+      (#) Call the FLASH_Unlock() function to enable the FLASH control register access
+
+      (#) Call the desired function to erase sector(s) or program data
+
+      (#) Call the FLASH_Lock() function to disable the FLASH control register access
+          (recommended to protect the FLASH memory against possible unwanted operation)
+    
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Unlocks the FLASH control register access
+  * @param  None
+  * @retval None
+  */
+void FLASH_Unlock(void)
+{
+  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
+  {
+    /* Authorize the FLASH Registers access */
+    FLASH->KEYR = FLASH_KEY1;
+    FLASH->KEYR = FLASH_KEY2;
+  }  
+}
+
+/**
+  * @brief  Locks the FLASH control register access
+  * @param  None
+  * @retval None
+  */
+void FLASH_Lock(void)
+{
+  /* Set the LOCK Bit to lock the FLASH Registers access */
+  FLASH->CR |= FLASH_CR_LOCK;
+}
+
+/**
+  * @brief  Erases a specified FLASH Sector.
+  *
+  * @note   If an erase and a program operations are requested simustaneously,    
+  *         the erase operation is performed before the program one.
+  *
+  * @param  FLASH_Sector: The Sector number to be erased.
+  *
+  *  @note  For STM32F405xx/407xx and STM32F415xx/417xx devices this parameter can 
+  *         be a value between FLASH_Sector_0 and FLASH_Sector_11.
+  *
+  *         For STM32F42xxx/43xxx devices this parameter can be a value between 
+  *         FLASH_Sector_0 and FLASH_Sector_23.
+  *
+  *         For STM32F401xx devices this parameter can be a value between 
+  *         FLASH_Sector_0 and FLASH_Sector_5.
+  *
+  *         For STM32F411xE devices this parameter can be a value between 
+  *         FLASH_Sector_0 and FLASH_Sector_7.
+  *
+  * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
+  *          This parameter can be one of the following values:
+  *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
+  *                                  the operation will be done by byte (8-bit) 
+  *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
+  *                                  the operation will be done by half word (16-bit)
+  *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
+  *                                  the operation will be done by word (32-bit)
+  *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
+  *                                  the operation will be done by double word (64-bit)
+  *       
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
+{
+  uint32_t tmp_psize = 0x0;
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
+  assert_param(IS_VOLTAGERANGE(VoltageRange));
+  
+  if(VoltageRange == VoltageRange_1)
+  {
+     tmp_psize = FLASH_PSIZE_BYTE;
+  }
+  else if(VoltageRange == VoltageRange_2)
+  {
+    tmp_psize = FLASH_PSIZE_HALF_WORD;
+  }
+  else if(VoltageRange == VoltageRange_3)
+  {
+    tmp_psize = FLASH_PSIZE_WORD;
+  }
+  else
+  {
+    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
+  }
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+  
+  if(status == FLASH_COMPLETE)
+  { 
+    /* if the previous operation is completed, proceed to erase the sector */
+    FLASH->CR &= CR_PSIZE_MASK;
+    FLASH->CR |= tmp_psize;
+    FLASH->CR &= SECTOR_MASK;
+    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
+    FLASH->CR |= FLASH_CR_STRT;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation();
+    
+    /* if the erase operation is completed, disable the SER Bit */
+    FLASH->CR &= (~FLASH_CR_SER);
+    FLASH->CR &= SECTOR_MASK; 
+  }
+  /* Return the Erase Status */
+  return status;
+}
+
+/**
+  * @brief  Erases all FLASH Sectors.
+  *
+  * @note   If an erase and a program operations are requested simustaneously,    
+  *         the erase operation is performed before the program one.
+  *  
+  * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
+  *          This parameter can be one of the following values:
+  *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
+  *                                  the operation will be done by byte (8-bit) 
+  *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
+  *                                  the operation will be done by half word (16-bit)
+  *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
+  *                                  the operation will be done by word (32-bit)
+  *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
+  *                                  the operation will be done by double word (64-bit)
+  *       
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
+{
+  uint32_t tmp_psize = 0x0;
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+  assert_param(IS_VOLTAGERANGE(VoltageRange));
+  
+  if(VoltageRange == VoltageRange_1)
+  {
+     tmp_psize = FLASH_PSIZE_BYTE;
+  }
+  else if(VoltageRange == VoltageRange_2)
+  {
+    tmp_psize = FLASH_PSIZE_HALF_WORD;
+  }
+  else if(VoltageRange == VoltageRange_3)
+  {
+    tmp_psize = FLASH_PSIZE_WORD;
+  }
+  else
+  {
+    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
+  }  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all sectors */
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)    
+    FLASH->CR &= CR_PSIZE_MASK;
+    FLASH->CR |= tmp_psize;
+    FLASH->CR |= (FLASH_CR_MER1 | FLASH_CR_MER2);
+    FLASH->CR |= FLASH_CR_STRT;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation();
+
+    /* if the erase operation is completed, disable the MER Bit */
+    FLASH->CR &= ~(FLASH_CR_MER1 | FLASH_CR_MER2);
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+#if defined (STM32F40_41xxx) || defined (STM32F401xx) || defined (STM32F411xE) 
+    FLASH->CR &= CR_PSIZE_MASK;
+    FLASH->CR |= tmp_psize;
+    FLASH->CR |= FLASH_CR_MER;
+    FLASH->CR |= FLASH_CR_STRT;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation();
+
+    /* if the erase operation is completed, disable the MER Bit */
+    FLASH->CR &= (~FLASH_CR_MER);
+#endif /* STM32F40_41xxx || STM32F401xx || STM32F411xE */
+
+  }   
+  /* Return the Erase Status */
+  return status;
+}
+
+/**
+  * @brief  Erases all FLASH Sectors in Bank 1.
+  *
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *      
+  * @note   If an erase and a program operations are requested simultaneously,    
+  *         the erase operation is performed before the program one. 
+  *  
+  * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
+  *          This parameter can be one of the following values:
+  *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
+  *                                  the operation will be done by byte (8-bit) 
+  *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
+  *                                  the operation will be done by half word (16-bit)
+  *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
+  *                                  the operation will be done by word (32-bit)
+  *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
+  *                                  the operation will be done by double word (64-bit)
+  *       
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
+{
+  uint32_t tmp_psize = 0x0;
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+  assert_param(IS_VOLTAGERANGE(VoltageRange));
+  
+  if(VoltageRange == VoltageRange_1)
+  {
+     tmp_psize = FLASH_PSIZE_BYTE;
+  }
+  else if(VoltageRange == VoltageRange_2)
+  {
+    tmp_psize = FLASH_PSIZE_HALF_WORD;
+  }
+  else if(VoltageRange == VoltageRange_3)
+  {
+    tmp_psize = FLASH_PSIZE_WORD;
+  }
+  else
+  {
+    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
+  }  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all sectors */
+     FLASH->CR &= CR_PSIZE_MASK;
+     FLASH->CR |= tmp_psize;
+     FLASH->CR |= FLASH_CR_MER1;
+     FLASH->CR |= FLASH_CR_STRT;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation();
+
+    /* if the erase operation is completed, disable the MER Bit */
+    FLASH->CR &= (~FLASH_CR_MER1);
+
+  }   
+  /* Return the Erase Status */
+  return status;
+}
+
+
+/**
+  * @brief  Erases all FLASH Sectors in Bank 2.
+  *
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *     
+  * @note   If an erase and a program operations are requested simultaneously,    
+  *         the erase operation is performed before the program one.
+  *     
+  * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
+  *          This parameter can be one of the following values:
+  *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
+  *                                  the operation will be done by byte (8-bit) 
+  *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
+  *                                  the operation will be done by half word (16-bit)
+  *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
+  *                                  the operation will be done by word (32-bit)
+  *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
+  *                                  the operation will be done by double word (64-bit)
+  *       
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)
+{
+  uint32_t tmp_psize = 0x0;
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+  assert_param(IS_VOLTAGERANGE(VoltageRange));
+  
+  if(VoltageRange == VoltageRange_1)
+  {
+     tmp_psize = FLASH_PSIZE_BYTE;
+  }
+  else if(VoltageRange == VoltageRange_2)
+  {
+    tmp_psize = FLASH_PSIZE_HALF_WORD;
+  }
+  else if(VoltageRange == VoltageRange_3)
+  {
+    tmp_psize = FLASH_PSIZE_WORD;
+  }
+  else
+  {
+    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
+  }  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all sectors */
+     FLASH->CR &= CR_PSIZE_MASK;
+     FLASH->CR |= tmp_psize;
+     FLASH->CR |= FLASH_CR_MER2;
+     FLASH->CR |= FLASH_CR_STRT;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation();
+
+    /* if the erase operation is completed, disable the MER Bit */
+    FLASH->CR &= (~FLASH_CR_MER2);
+
+  }   
+  /* Return the Erase Status */
+  return status;
+}
+
+/**
+  * @brief  Programs a double word (64-bit) at a specified address.
+  * @note   This function must be used when the device voltage range is from
+  *         2.7V to 3.6V and an External Vpp is present.
+  *
+  * @note   If an erase and a program operations are requested simustaneously,    
+  *         the erase operation is performed before the program one.
+  *  
+  * @param  Address: specifies the address to be programmed.
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new data */
+    FLASH->CR &= CR_PSIZE_MASK;
+    FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
+    FLASH->CR |= FLASH_CR_PG;
+  
+    *(__IO uint64_t*)Address = Data;
+        
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation();
+
+    /* if the program operation is completed, disable the PG Bit */
+    FLASH->CR &= (~FLASH_CR_PG);
+  } 
+  /* Return the Program Status */
+  return status;
+}
+
+/**
+  * @brief  Programs a word (32-bit) at a specified address.
+  *
+  * @note   This function must be used when the device voltage range is from 2.7V to 3.6V. 
+  *
+  * @note   If an erase and a program operations are requested simustaneously,    
+  *         the erase operation is performed before the program one.
+  *  
+  * @param  Address: specifies the address to be programmed.
+  *         This parameter can be any address in Program memory zone or in OTP zone.  
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new data */
+    FLASH->CR &= CR_PSIZE_MASK;
+    FLASH->CR |= FLASH_PSIZE_WORD;
+    FLASH->CR |= FLASH_CR_PG;
+  
+    *(__IO uint32_t*)Address = Data;
+        
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation();
+
+    /* if the program operation is completed, disable the PG Bit */
+    FLASH->CR &= (~FLASH_CR_PG);
+  } 
+  /* Return the Program Status */
+  return status;
+}
+
+/**
+  * @brief  Programs a half word (16-bit) at a specified address. 
+  * @note   This function must be used when the device voltage range is from 2.1V to 3.6V. 
+  *
+  * @note   If an erase and a program operations are requested simustaneously,    
+  *         the erase operation is performed before the program one.
+  * 
+  * @param  Address: specifies the address to be programmed.
+  *         This parameter can be any address in Program memory zone or in OTP zone.  
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new data */
+    FLASH->CR &= CR_PSIZE_MASK;
+    FLASH->CR |= FLASH_PSIZE_HALF_WORD;
+    FLASH->CR |= FLASH_CR_PG;
+  
+    *(__IO uint16_t*)Address = Data;
+        
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation();
+
+    /* if the program operation is completed, disable the PG Bit */
+    FLASH->CR &= (~FLASH_CR_PG);
+  } 
+  /* Return the Program Status */
+  return status;
+}
+
+/**
+  * @brief  Programs a byte (8-bit) at a specified address.
+  * @note   This function can be used within all the device supply voltage ranges.  
+  *
+  * @note   If an erase and a program operations are requested simustaneously,    
+  *         the erase operation is performed before the program one.
+  * 
+  * @param  Address: specifies the address to be programmed.
+  *         This parameter can be any address in Program memory zone or in OTP zone.  
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new data */
+    FLASH->CR &= CR_PSIZE_MASK;
+    FLASH->CR |= FLASH_PSIZE_BYTE;
+    FLASH->CR |= FLASH_CR_PG;
+  
+    *(__IO uint8_t*)Address = Data;
+        
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation();
+
+    /* if the program operation is completed, disable the PG Bit */
+    FLASH->CR &= (~FLASH_CR_PG);
+  } 
+
+  /* Return the Program Status */
+  return status;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Group3 Option Bytes Programming functions
+ *  @brief   Option Bytes Programming functions 
+ *
+@verbatim   
+ ===============================================================================
+                ##### Option Bytes Programming functions #####
+ ===============================================================================  
+    [..]
+      This group includes the following functions:
+      (+) void FLASH_OB_Unlock(void)
+      (+) void FLASH_OB_Lock(void)
+      (+) void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
+      (+) void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)  
+      (+) void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PCROPSelect)
+      (+) void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
+      (+) void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState) 
+      (+) void FLASH_OB_RDPConfig(uint8_t OB_RDP)
+      (+) void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
+      (+) void FLASH_OB_BORConfig(uint8_t OB_BOR)
+      (+) FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data)
+      (+) FLASH_Status FLASH_OB_Launch(void)
+      (+) uint32_t FLASH_OB_GetUser(void)
+      (+) uint8_t FLASH_OB_GetWRP(void)
+      (+) uint8_t FLASH_OB_GetWRP1(void)
+      (+) uint8_t FLASH_OB_GetPCROP(void)
+      (+) uint8_t FLASH_OB_GetPCROP1(void)
+      (+) uint8_t FLASH_OB_GetRDP(void)
+      (+) uint8_t FLASH_OB_GetBOR(void)
+    [..]  
+      The following function can be used only for STM32F42xxx/43xxx devices. 
+      (+) void FLASH_OB_BootConfig(uint8_t OB_BOOT)
+    [..]   
+     Any operation of erase or program should follow these steps:
+      (#) Call the FLASH_OB_Unlock() function to enable the FLASH option control 
+          register access
+
+      (#) Call one or several functions to program the desired Option Bytes:
+        (++) void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) 
+             => to Enable/Disable the desired sector write protection
+        (++) void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read 
+             Protection Level
+        (++) void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) 
+             => to configure the user Option Bytes.
+        (++) void FLASH_OB_BORConfig(uint8_t OB_BOR) => to set the BOR Level 			 
+
+      (#) Once all needed Option Bytes to be programmed are correctly written, 
+          call the FLASH_OB_Launch() function to launch the Option Bytes 
+          programming process.
+     
+      -@- When changing the IWDG mode from HW to SW or from SW to HW, a system 
+          reset is needed to make the change effective.  
+
+      (#) Call the FLASH_OB_Lock() function to disable the FLASH option control 
+          register access (recommended to protect the Option Bytes against 
+          possible unwanted operations)
+    
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Unlocks the FLASH Option Control Registers access.
+  * @param  None
+  * @retval None
+  */
+void FLASH_OB_Unlock(void)
+{
+  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
+  {
+    /* Authorizes the Option Byte register programming */
+    FLASH->OPTKEYR = FLASH_OPT_KEY1;
+    FLASH->OPTKEYR = FLASH_OPT_KEY2;
+  }  
+}
+
+/**
+  * @brief  Locks the FLASH Option Control Registers access.
+  * @param  None
+  * @retval None
+  */
+void FLASH_OB_Lock(void)
+{
+  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
+  FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
+}
+
+/**
+  * @brief  Enables or disables the write protection of the desired sectors, for the first
+  *         1 Mb of the Flash  
+  *
+  * @note   When the memory read protection level is selected (RDP level = 1), 
+  *         it is not possible to program or erase the flash sector i if CortexM4  
+  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
+  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
+  * 
+  * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
+  *          This parameter can be one of the following values:
+  *            @arg OB_WRP: A value between OB_WRP_Sector0 and OB_WRP_Sector11                      
+  *            @arg OB_WRP_Sector_All
+  * @param  Newstate: new state of the Write Protection.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None  
+  */
+void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
+{ 
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Check the parameters */
+  assert_param(IS_OB_WRP(OB_WRP));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  status = FLASH_WaitForLastOperation();
+
+  if(status == FLASH_COMPLETE)
+  { 
+    if(NewState != DISABLE)
+    {
+      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
+    }
+    else
+    {
+      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
+    }
+  }
+}
+
+/**
+  * @brief  Enables or disables the write protection of the desired sectors, for the second
+  *         1 Mb of the Flash  
+  *           
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *   
+  * @note   When the memory read out protection is selected (RDP level = 1), 
+  *         it is not possible to program or erase the flash sector i if CortexM4  
+  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
+  * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).      
+  * 
+  * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
+  *          This parameter can be one of the following values:
+  *            @arg OB_WRP: A value between OB_WRP_Sector12 and OB_WRP_Sector23
+  *            @arg OB_WRP_Sector_All                        
+  * @param  Newstate: new state of the Write Protection.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None  
+  */
+void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)
+{ 
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Check the parameters */
+  assert_param(IS_OB_WRP(OB_WRP));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  status = FLASH_WaitForLastOperation();
+
+  if(status == FLASH_COMPLETE)
+  { 
+    if(NewState != DISABLE)
+    {
+      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
+    }
+    else
+    {
+      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
+    }
+  }
+}
+
+/**
+  * @brief  Select the Protection Mode (SPRMOD). 
+  * 
+  * @note   This function can be used only for STM32F42xxx/43xxx and STM32F401xx/411xE devices.       
+  * 
+  * @note   After PCROP activation, Option Byte modification is not possible. 
+  *         Exception made for the global Read Out Protection modification level (level1 to level0) 
+  * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible 
+  *   
+  * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
+  *   
+  * @note   Some Precautions should be taken when activating the PCROP feature :
+  *         The active value of nWRPi bits is inverted when PCROP mode is active, this means if SPRMOD = 1
+  *         and WRPi = 1 (default value), then the user sector i is read/write protected.
+  *         In order to avoid activation of PCROP Mode for undesired sectors, please follow the
+  *         below safety sequence :       
+  *         - Disable PCROP for all Sectors using FLASH_OB_PCROPConfig(OB_PCROP_Sector_All, DISABLE) function 
+  *           for Bank1 or FLASH_OB_PCROP1Config(OB_PCROP_Sector_All, DISABLE) function for Bank2   
+  *         - Enable PCROP for the desired Sector i using FLASH_OB_PCROPConfig(Sector i, ENABLE) function
+  *         - Activate the PCROP Mode FLASH_OB_PCROPSelectionConfig() function. 
+  * 
+  * @param  OB_PCROP:  Select the Protection Mode of nWPRi bits 
+  *          This parameter can be one of the following values:
+  *            @arg OB_PcROP_Disable: nWRPi control the write protection of respective user sectors.
+  *            @arg OB_PcROP_Enable: nWRPi control the  read&write protection (PCROP) of respective user sectors.
+  * @retval None
+  */
+void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP)
+{  
+  uint8_t optiontmp = 0xFF;
+      
+  /* Check the parameters */
+  assert_param(IS_OB_PCROP_SELECT(OB_PcROP));
+  
+  /* Mask SPRMOD bit */
+  optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
+  /* Update Option Byte */
+  *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PcROP | optiontmp); 
+    
+}
+
+/**
+  * @brief  Enables or disables the read/write protection (PCROP) of the desired 
+  *         sectors, for the first 1 MB of the Flash.
+  *           
+  * @note   This function can be used only for STM32F42xxx/43xxx and STM32F401xx/411xE devices. 
+  *   
+  * @param  OB_PCROP: specifies the sector(s) to be read/write protected or unprotected.
+  *          This parameter can be one of the following values:
+  *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector11 for 
+  *                           STM32F42xxx/43xxx devices and between OB_PCROP_Sector0 and 
+  *                           OB_PCROP_Sector5 for STM32F401xx/411xE devices.
+  *            @arg OB_PCROP_Sector_All
+  * @param  Newstate: new state of the Write Protection.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None  
+  */
+void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
+{ 
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Check the parameters */
+  assert_param(IS_OB_PCROP(OB_PCROP));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  status = FLASH_WaitForLastOperation();
+
+  if(status == FLASH_COMPLETE)
+  { 
+    if(NewState != DISABLE)
+    {
+      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
+    }
+    else
+    {
+      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_PCROP);
+    }
+  }
+}
+
+/**
+   * @brief Enables or disables the read/write protection (PCROP) of the desired 
+  *         sectors
+  *           
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *   
+  * @param  OB_PCROP: specifies the sector(s) to be read/write protected or unprotected.
+  *          This parameter can be one of the following values:
+  *            @arg OB_PCROP: A value between OB_PCROP_Sector12 and OB_PCROP_Sector23 
+  *            @arg OB_PCROP_Sector_All
+  * @param  Newstate: new state of the Write Protection.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None  
+  */
+void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState)
+{ 
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Check the parameters */
+  assert_param(IS_OB_PCROP(OB_PCROP));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  status = FLASH_WaitForLastOperation();
+
+  if(status == FLASH_COMPLETE)
+  { 
+    if(NewState != DISABLE)
+    {
+      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
+    }
+    else
+    {
+      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_PCROP);
+    }
+  }
+}
+
+
+/**
+  * @brief  Sets the read protection level.
+  * @param  OB_RDP: specifies the read protection level.
+  *          This parameter can be one of the following values:
+  *            @arg OB_RDP_Level_0: No protection
+  *            @arg OB_RDP_Level_1: Read protection of the memory
+  *            @arg OB_RDP_Level_2: Full chip protection
+  *   
+  * /!\ Warning /!\ When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
+  *    
+  * @retval None
+  */
+void FLASH_OB_RDPConfig(uint8_t OB_RDP)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_OB_RDP(OB_RDP));
+
+  status = FLASH_WaitForLastOperation();
+
+  if(status == FLASH_COMPLETE)
+  {
+    *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
+
+  }
+}
+
+/**
+  * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
+  * @param  OB_IWDG: Selects the IWDG mode
+  *          This parameter can be one of the following values:
+  *            @arg OB_IWDG_SW: Software IWDG selected
+  *            @arg OB_IWDG_HW: Hardware IWDG selected
+  * @param  OB_STOP: Reset event when entering STOP mode.
+  *          This parameter  can be one of the following values:
+  *            @arg OB_STOP_NoRST: No reset generated when entering in STOP
+  *            @arg OB_STOP_RST: Reset generated when entering in STOP
+  * @param  OB_STDBY: Reset event when entering Standby mode.
+  *          This parameter  can be one of the following values:
+  *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
+  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
+  * @retval None
+  */
+void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
+{
+  uint8_t optiontmp = 0xFF;
+  FLASH_Status status = FLASH_COMPLETE; 
+
+  /* Check the parameters */
+  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
+  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
+  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+  
+  if(status == FLASH_COMPLETE)
+  { 
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+    /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
+    optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+#if defined (STM32F40_41xxx) || defined (STM32F401xx) || defined (STM32F411xE)
+    /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
+    optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
+#endif /* STM32F40_41xxx || STM32F401xx || STM32F411xE */ 
+
+    /* Update User Option Byte */
+    *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
+  }  
+}
+
+/**
+  * @brief  Configure the Dual Bank Boot.
+  *   
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *      
+  * @param  OB_BOOT: specifies the Dual Bank Boot Option byte.
+  *          This parameter can be one of the following values:
+  *            @arg OB_Dual_BootEnabled: Dual Bank Boot Enable
+  *            @arg OB_Dual_BootDisabled: Dual Bank Boot Disabled
+  * @retval None
+  */
+void FLASH_OB_BootConfig(uint8_t OB_BOOT)
+{
+  /* Check the parameters */
+  assert_param(IS_OB_BOOT(OB_BOOT));
+
+  /* Set Dual Bank Boot */
+  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
+  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOOT;
+
+}
+
+/**
+  * @brief  Sets the BOR Level. 
+  * @param  OB_BOR: specifies the Option Bytes BOR Reset Level.
+  *          This parameter can be one of the following values:
+  *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
+  *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
+  *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
+  *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
+  * @retval None
+  */
+void FLASH_OB_BORConfig(uint8_t OB_BOR)
+{
+  /* Check the parameters */
+  assert_param(IS_OB_BOR(OB_BOR));
+
+  /* Set the BOR Level */
+  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
+  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
+
+}
+
+/**
+  * @brief  Launch the option byte loading.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_OB_Launch(void)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Set the OPTSTRT bit in OPTCR register */
+  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation();
+
+  return status;
+}
+
+/**
+  * @brief  Returns the FLASH User Option Bytes values.
+  * @param  None
+  * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
+  *         and RST_STDBY(Bit2).
+  */
+uint8_t FLASH_OB_GetUser(void)
+{
+  /* Return the User Option Byte */
+  return (uint8_t)(FLASH->OPTCR >> 5);
+}
+
+/**
+  * @brief  Returns the FLASH Write Protection Option Bytes value.
+  * @param  None
+  * @retval The FLASH Write Protection  Option Bytes value
+  */
+uint16_t FLASH_OB_GetWRP(void)
+{
+  /* Return the FLASH write protection Register value */
+  return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
+}
+
+/**
+  * @brief  Returns the FLASH Write Protection Option Bytes value.
+  *   
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *   
+  * @param  None
+  * @retval The FLASH Write Protection  Option Bytes value
+  */
+uint16_t FLASH_OB_GetWRP1(void)
+{
+  /* Return the FLASH write protection Register value */
+  return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
+}
+
+/**
+  * @brief  Returns the FLASH PC Read/Write Protection Option Bytes value.
+  *   
+  * @note   This function can be used only for STM32F42xxx/43xxx devices and STM32F401xx/411xE devices.
+  *   
+  * @param  None
+  * @retval The FLASH PC Read/Write Protection Option Bytes value
+  */
+uint16_t FLASH_OB_GetPCROP(void)
+{
+  /* Return the FLASH PC Read/write protection Register value */
+  return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
+}
+
+/**
+  * @brief  Returns the FLASH PC Read/Write Protection Option Bytes value.
+  *   
+  * @note   This function can be used only for STM32F42xxx/43xxx devices. 
+  *     
+  * @param  None
+  * @retval The FLASH PC Read/Write Protection Option Bytes value
+  */
+uint16_t FLASH_OB_GetPCROP1(void)
+{
+  /* Return the FLASH write protection Register value */
+  return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
+}
+
+/**
+  * @brief  Returns the FLASH Read Protection level.
+  * @param  None
+  * @retval FLASH ReadOut Protection Status:
+  *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
+  *           - RESET, when OB_RDP_Level_0 is set
+  */
+FlagStatus FLASH_OB_GetRDP(void)
+{
+  FlagStatus readstatus = RESET;
+
+  if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
+  {
+    readstatus = SET;
+  }
+  else
+  {
+    readstatus = RESET;
+  }
+  return readstatus;
+}
+
+/**
+  * @brief  Returns the FLASH BOR level.
+  * @param  None
+  * @retval The FLASH BOR level:
+  *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
+  *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
+  *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
+  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
+  */
+uint8_t FLASH_OB_GetBOR(void)
+{
+  /* Return the FLASH BOR level */
+  return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Group4 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+              ##### Interrupts and flags management functions #####
+ ===============================================================================  
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified FLASH interrupts.
+  * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
+  *          This parameter can be any combination of the following values:
+  *            @arg FLASH_IT_ERR: FLASH Error Interrupt
+  *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
+  * @retval None 
+  */
+void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_IT(FLASH_IT)); 
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if(NewState != DISABLE)
+  {
+    /* Enable the interrupt sources */
+    FLASH->CR |= FLASH_IT;
+  }
+  else
+  {
+    /* Disable the interrupt sources */
+    FLASH->CR &= ~(uint32_t)FLASH_IT;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified FLASH flag is set or not.
+  * @param  FLASH_FLAG: specifies the FLASH flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
+  *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
+  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
+  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
+  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
+  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
+  *            @arg FLASH_FLAG_RDERR: FLASH (PCROP) Read Protection error flag (STM32F42xx/43xxx and STM32F401xx/411xE devices) 
+  *            @arg FLASH_FLAG_BSY: FLASH Busy flag
+  * @retval The new state of FLASH_FLAG (SET or RESET).
+  */
+FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
+
+  if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the new state of FLASH_FLAG (SET or RESET) */
+  return bitstatus; 
+}
+
+/**
+  * @brief  Clears the FLASH's pending flags.
+  * @param  FLASH_FLAG: specifies the FLASH flags to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
+  *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
+  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
+  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
+  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
+  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
+  *            @arg FLASH_FLAG_RDERR: FLASH Read Protection error flag (STM32F42xx/43xxx and STM32F401xx/411xE devices)   
+  * @retval None
+  */
+void FLASH_ClearFlag(uint32_t FLASH_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
+  
+  /* Clear the flags */
+  FLASH->SR = FLASH_FLAG;
+}
+
+/**
+  * @brief  Returns the FLASH Status.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_RD, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_GetStatus(void)
+{
+  FLASH_Status flashstatus = FLASH_COMPLETE;
+  
+  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
+  {
+    flashstatus = FLASH_BUSY;
+  }
+  else 
+  {  
+    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
+    { 
+      flashstatus = FLASH_ERROR_WRP;
+    }
+    else
+    {
+      if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
+      { 
+        flashstatus = FLASH_ERROR_RD;
+      } 
+      else 
+      {
+        if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
+        {
+          flashstatus = FLASH_ERROR_PROGRAM; 
+        }
+        else
+        {
+          if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
+          {
+            flashstatus = FLASH_ERROR_OPERATION;
+          }
+          else
+          {
+            flashstatus = FLASH_COMPLETE;
+          }
+        }
+      }
+    }
+  }
+  /* Return the FLASH Status */
+  return flashstatus;
+}
+
+/**
+  * @brief  Waits for a FLASH operation to complete.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
+  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
+  */
+FLASH_Status FLASH_WaitForLastOperation(void)
+{ 
+  __IO FLASH_Status status = FLASH_COMPLETE;
+   
+  /* Check for the FLASH Status */
+  status = FLASH_GetStatus();
+
+  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
+     Even if the FLASH operation fails, the BUSY flag will be reset and an error
+     flag will be set */
+  while(status == FLASH_BUSY)
+  {
+    status = FLASH_GetStatus();
+  }
+  /* Return the operation status */
+  return status;
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash_ramfunc.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash_ramfunc.c
new file mode 100644
index 0000000..6ed3b32
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash_ramfunc.c
@@ -0,0 +1,158 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_flash_ramfunc.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   FLASH RAMFUNC module driver.
+  *          This file provides a FLASH firmware functions which should be 
+  *          executed from internal SRAM
+  *            + Stop/Start the flash interface while System Run
+  *            + Enable/Disable the flash sleep while System Run
+  *  
+ @verbatim    
+ ==============================================================================
+                    ##### APIs executed from Internal RAM #####
+  ==============================================================================
+  [..]
+    *** ARM Compiler ***
+    --------------------
+    [..] RAM functions are defined using the toolchain options. 
+         Functions that are be executed in RAM should reside in a separate
+         source module. Using the 'Options for File' dialog you can simply change
+         the 'Code / Const' area of a module to a memory space in physical RAM.
+         Available memory areas are declared in the 'Target' tab of the 
+         Options for Target' dialog.
+
+    *** ICCARM Compiler ***
+    -----------------------
+    [..] RAM functions are defined using a specific toolchain keyword "__ramfunc".
+
+    *** GNU Compiler ***
+    --------------------
+    [..] RAM functions are defined using a specific toolchain attribute
+         "__attribute__((section(".RamFunc")))".
+  
+  @endverbatim
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_flash_ramfunc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup FLASH RAMFUNC 
+  * @brief FLASH RAMFUNC driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup FLASH_RAMFUNC_Private_Functions
+  * @{
+  */
+
+/** @defgroup FLASH_RAMFUNC_Group1 Peripheral features functions executed from internal RAM 
+  *  @brief Peripheral Extended features functions 
+  *
+@verbatim   
+
+ ===============================================================================
+                      ##### ramfunc functions #####
+ ===============================================================================
+    [..]
+    This subsection provides a set of functions that should be executed from RAM 
+    transfers.
+    
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief Start/Stop the flash interface while System Run
+  * @note  This mode is only available for STM32F411xx devices. 
+  * @note  This mode could n't be set while executing with the flash itself. 
+  *        It should be done with specific routine executed from RAM.     
+  * @param  NewState: new state of the Smart Card mode.
+  *          This parameter can be: ENABLE or DISABLE.  
+  * @retval None
+  */
+__RAM_FUNC FLASH_FlashInterfaceCmd(FunctionalState NewState)
+{
+  if (NewState != DISABLE)
+  {
+    /* Start the flash interface while System Run */
+    CLEAR_BIT(PWR->CR, PWR_CR_FISSR);
+  }
+  else
+  {
+    /* Stop the flash interface while System Run */  
+    SET_BIT(PWR->CR, PWR_CR_FISSR);
+  }
+}
+
+/**
+  * @brief Enable/Disable the flash sleep while System Run
+  * @note  This mode is only available for STM32F411xx devices. 
+  * @note  This mode could n't be set while executing with the flash itself. 
+  *        It should be done with specific routine executed from RAM.     
+  * @param  NewState: new state of the Smart Card mode.
+  *          This parameter can be: ENABLE or DISABLE.  
+  * @retval None
+  */
+__RAM_FUNC FLASH_FlashSleepModeCmd(FunctionalState NewState)
+{
+  if (NewState != DISABLE)
+  {
+    /* Enable the flash sleep while System Run */
+    SET_BIT(PWR->CR, PWR_CR_FMSSR);
+  }
+  else
+  {
+    /* Disable the flash sleep while System Run */
+    CLEAR_BIT(PWR->CR, PWR_CR_FMSSR);
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fmc.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fmc.c
new file mode 100644
index 0000000..1f25511
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fmc.c
@@ -0,0 +1,1367 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_fmc.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the FMC peripheral:           
+  *           + Interface with SRAM, PSRAM, NOR and OneNAND memories
+  *           + Interface with NAND memories
+  *           + Interface with 16-bit PC Card compatible memories 
+  *           + Interface with SDRAM memories    
+  *           + Interrupts and flags management   
+  *           
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_fmc.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup FMC 
+  * @brief FMC driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+const FMC_NORSRAMTimingInitTypeDef FMC_DefaultTimingStruct = {0x0F, /* FMC_AddressSetupTime */
+                                                              0x0F, /* FMC_AddressHoldTime */
+                                                              0xFF, /* FMC_DataSetupTime */
+                                                              0x0F, /* FMC_BusTurnAroundDuration */
+                                                              0x0F, /* FMC_CLKDivision */
+                                                              0x0F, /* FMC_DataLatency */
+                                                              FMC_AccessMode_A /* FMC_AccessMode */
+                                                              };
+/* --------------------- FMC registers bit mask ---------------------------- */
+/* FMC BCRx Mask */
+#define BCR_MBKEN_SET              ((uint32_t)0x00000001)
+#define BCR_MBKEN_RESET            ((uint32_t)0x000FFFFE)
+#define BCR_FACCEN_SET             ((uint32_t)0x00000040)
+
+/* FMC PCRx Mask */
+#define PCR_PBKEN_SET              ((uint32_t)0x00000004)
+#define PCR_PBKEN_RESET            ((uint32_t)0x000FFFFB)
+#define PCR_ECCEN_SET              ((uint32_t)0x00000040)
+#define PCR_ECCEN_RESET            ((uint32_t)0x000FFFBF)
+#define PCR_MEMORYTYPE_NAND        ((uint32_t)0x00000008)
+
+/* FMC SDCRx write protection Mask*/
+#define SDCR_WriteProtection_RESET ((uint32_t)0x00007DFF) 
+
+/* FMC SDCMR Mask*/
+#define SDCMR_CTB1_RESET           ((uint32_t)0x003FFFEF)
+#define SDCMR_CTB2_RESET           ((uint32_t)0x003FFFF7)
+#define SDCMR_CTB1_2_RESET         ((uint32_t)0x003FFFE7)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup FMC_Private_Functions
+  * @{
+  */
+
+/** @defgroup FMC_Group1 NOR/SRAM Controller functions
+  * @brief    NOR/SRAM Controller functions 
+  *
+@verbatim   
+ ===============================================================================
+                    ##### NOR and SRAM Controller functions #####
+ ===============================================================================  
+
+ [..] The following sequence should be followed to configure the FMC to interface
+      with SRAM, PSRAM, NOR or OneNAND memory connected to the NOR/SRAM Bank:
+ 
+   (#) Enable the clock for the FMC and associated GPIOs using the following functions:
+          RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
+          RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
+
+   (#) FMC pins configuration 
+       (++) Connect the involved FMC pins to AF12 using the following function 
+            GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FMC); 
+       (++) Configure these FMC pins in alternate function mode by calling the function
+            GPIO_Init();    
+       
+   (#) Declare a FMC_NORSRAMInitTypeDef structure, for example:
+          FMC_NORSRAMInitTypeDef  FMC_NORSRAMInitStructure;
+      and fill the FMC_NORSRAMInitStructure variable with the allowed values of
+      the structure member.
+      
+   (#) Initialize the NOR/SRAM Controller by calling the function
+          FMC_NORSRAMInit(&FMC_NORSRAMInitStructure); 
+
+   (#) Then enable the NOR/SRAM Bank, for example:
+          FMC_NORSRAMCmd(FMC_Bank1_NORSRAM2, ENABLE);  
+
+   (#) At this stage you can read/write from/to the memory connected to the NOR/SRAM Bank. 
+   
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  De-initializes the FMC NOR/SRAM Banks registers to their default 
+  *   reset values.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank1_NORSRAM1: FMC Bank1 NOR/SRAM1  
+  *            @arg FMC_Bank1_NORSRAM2: FMC Bank1 NOR/SRAM2 
+  *            @arg FMC_Bank1_NORSRAM3: FMC Bank1 NOR/SRAM3 
+  *            @arg FMC_Bank1_NORSRAM4: FMC Bank1 NOR/SRAM4 
+  * @retval None
+  */
+void FMC_NORSRAMDeInit(uint32_t FMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FMC_NORSRAM_BANK(FMC_Bank));
+  
+  /* FMC_Bank1_NORSRAM1 */
+  if(FMC_Bank == FMC_Bank1_NORSRAM1)
+  {
+    FMC_Bank1->BTCR[FMC_Bank] = 0x000030DB;    
+  }
+  /* FMC_Bank1_NORSRAM2,  FMC_Bank1_NORSRAM3 or FMC_Bank1_NORSRAM4 */
+  else
+  {   
+    FMC_Bank1->BTCR[FMC_Bank] = 0x000030D2; 
+  }
+  FMC_Bank1->BTCR[FMC_Bank + 1] = 0x0FFFFFFF;
+  FMC_Bank1E->BWTR[FMC_Bank] = 0x0FFFFFFF;  
+}
+
+/**
+  * @brief  Initializes the FMC NOR/SRAM Banks according to the specified
+  *         parameters in the FMC_NORSRAMInitStruct.
+  * @param  FMC_NORSRAMInitStruct : pointer to a FMC_NORSRAMInitTypeDef structure
+  *         that contains the configuration information for the FMC NOR/SRAM 
+  *         specified Banks.                       
+  * @retval None
+  */
+void FMC_NORSRAMInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct)
+{
+  uint32_t tmpr = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_FMC_NORSRAM_BANK(FMC_NORSRAMInitStruct->FMC_Bank));
+  assert_param(IS_FMC_MUX(FMC_NORSRAMInitStruct->FMC_DataAddressMux));
+  assert_param(IS_FMC_MEMORY(FMC_NORSRAMInitStruct->FMC_MemoryType));
+  assert_param(IS_FMC_NORSRAM_MEMORY_WIDTH(FMC_NORSRAMInitStruct->FMC_MemoryDataWidth));
+  assert_param(IS_FMC_BURSTMODE(FMC_NORSRAMInitStruct->FMC_BurstAccessMode));
+  assert_param(IS_FMC_WAIT_POLARITY(FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity));
+  assert_param(IS_FMC_WRAP_MODE(FMC_NORSRAMInitStruct->FMC_WrapMode));
+  assert_param(IS_FMC_WAIT_SIGNAL_ACTIVE(FMC_NORSRAMInitStruct->FMC_WaitSignalActive));
+  assert_param(IS_FMC_WRITE_OPERATION(FMC_NORSRAMInitStruct->FMC_WriteOperation));
+  assert_param(IS_FMC_WAITE_SIGNAL(FMC_NORSRAMInitStruct->FMC_WaitSignal));
+  assert_param(IS_FMC_EXTENDED_MODE(FMC_NORSRAMInitStruct->FMC_ExtendedMode));
+  assert_param(IS_FMC_ASYNWAIT(FMC_NORSRAMInitStruct->FMC_AsynchronousWait));
+  assert_param(IS_FMC_WRITE_BURST(FMC_NORSRAMInitStruct->FMC_WriteBurst));
+  assert_param(IS_FMC_CONTINOUS_CLOCK(FMC_NORSRAMInitStruct->FMC_ContinousClock));  
+  assert_param(IS_FMC_ADDRESS_SETUP_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressSetupTime));
+  assert_param(IS_FMC_ADDRESS_HOLD_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressHoldTime));
+  assert_param(IS_FMC_DATASETUP_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataSetupTime));
+  assert_param(IS_FMC_TURNAROUND_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_BusTurnAroundDuration));
+  assert_param(IS_FMC_CLK_DIV(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision));
+  assert_param(IS_FMC_DATA_LATENCY(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataLatency));
+  assert_param(IS_FMC_ACCESS_MODE(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AccessMode)); 
+  
+  /* NOR/SRAM Bank control register configuration */ 
+  FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank] =   
+            (uint32_t)FMC_NORSRAMInitStruct->FMC_DataAddressMux |
+            FMC_NORSRAMInitStruct->FMC_MemoryType |
+            FMC_NORSRAMInitStruct->FMC_MemoryDataWidth |
+            FMC_NORSRAMInitStruct->FMC_BurstAccessMode |
+            FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity |
+            FMC_NORSRAMInitStruct->FMC_WrapMode |
+            FMC_NORSRAMInitStruct->FMC_WaitSignalActive |
+            FMC_NORSRAMInitStruct->FMC_WriteOperation |
+            FMC_NORSRAMInitStruct->FMC_WaitSignal |
+            FMC_NORSRAMInitStruct->FMC_ExtendedMode |
+            FMC_NORSRAMInitStruct->FMC_AsynchronousWait |
+            FMC_NORSRAMInitStruct->FMC_WriteBurst |
+            FMC_NORSRAMInitStruct->FMC_ContinousClock;
+
+            
+  if(FMC_NORSRAMInitStruct->FMC_MemoryType == FMC_MemoryType_NOR)
+  {
+    FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
+  }
+
+  /* Configure Continuous clock feature when bank2..4 is used */
+  if((FMC_NORSRAMInitStruct->FMC_ContinousClock == FMC_CClock_SyncAsync) && (FMC_NORSRAMInitStruct->FMC_Bank != FMC_Bank1_NORSRAM1))
+  {
+    tmpr = (uint32_t)((FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1+1]) & ~(((uint32_t)0x0F) << 20));    
+    
+    FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1]  |= FMC_NORSRAMInitStruct->FMC_ContinousClock;
+    FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1]  |= FMC_BurstAccessMode_Enable;
+    FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1+1] = (uint32_t)(tmpr | (((FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision)-1) << 20));
+  }
+  
+  /* NOR/SRAM Bank timing register configuration */
+  FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank+1] =   
+            (uint32_t)FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressSetupTime |
+            (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressHoldTime << 4) |
+            (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataSetupTime << 8) |
+            (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_BusTurnAroundDuration << 16) |
+            ((FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision) << 20) |
+            ((FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataLatency) << 24) |
+             FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AccessMode;
+     
+  /* NOR/SRAM Bank timing register for write configuration, if extended mode is used */
+  if(FMC_NORSRAMInitStruct->FMC_ExtendedMode == FMC_ExtendedMode_Enable)
+  {
+    assert_param(IS_FMC_ADDRESS_SETUP_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressSetupTime));
+    assert_param(IS_FMC_ADDRESS_HOLD_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressHoldTime));
+    assert_param(IS_FMC_DATASETUP_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataSetupTime));
+    assert_param(IS_FMC_CLK_DIV(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_CLKDivision));
+    assert_param(IS_FMC_DATA_LATENCY(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataLatency));
+    assert_param(IS_FMC_ACCESS_MODE(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AccessMode));
+    
+    FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank] =   
+               (uint32_t)FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressSetupTime |
+               (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressHoldTime << 4 )|
+               (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataSetupTime << 8) |
+               ((FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_CLKDivision) << 20) |
+               ((FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataLatency) << 24) |
+               FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AccessMode;
+  }
+  else
+  {
+    FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank] = 0x0FFFFFFF;
+  }
+  
+}
+
+/**
+  * @brief  Fills each FMC_NORSRAMInitStruct member with its default value.
+  * @param  FMC_NORSRAMInitStruct: pointer to a FMC_NORSRAMInitTypeDef structure 
+  *         which will be initialized.
+  * @retval None
+  */
+void FMC_NORSRAMStructInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct)
+{  
+  /* Reset NOR/SRAM Init structure parameters values */
+  FMC_NORSRAMInitStruct->FMC_Bank = FMC_Bank1_NORSRAM1;
+  FMC_NORSRAMInitStruct->FMC_DataAddressMux = FMC_DataAddressMux_Enable;
+  FMC_NORSRAMInitStruct->FMC_MemoryType = FMC_MemoryType_SRAM;
+  FMC_NORSRAMInitStruct->FMC_MemoryDataWidth = FMC_NORSRAM_MemoryDataWidth_16b;
+  FMC_NORSRAMInitStruct->FMC_BurstAccessMode = FMC_BurstAccessMode_Disable;
+  FMC_NORSRAMInitStruct->FMC_AsynchronousWait = FMC_AsynchronousWait_Disable;
+  FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity = FMC_WaitSignalPolarity_Low;
+  FMC_NORSRAMInitStruct->FMC_WrapMode = FMC_WrapMode_Disable;
+  FMC_NORSRAMInitStruct->FMC_WaitSignalActive = FMC_WaitSignalActive_BeforeWaitState;
+  FMC_NORSRAMInitStruct->FMC_WriteOperation = FMC_WriteOperation_Enable;
+  FMC_NORSRAMInitStruct->FMC_WaitSignal = FMC_WaitSignal_Enable;
+  FMC_NORSRAMInitStruct->FMC_ExtendedMode = FMC_ExtendedMode_Disable;
+  FMC_NORSRAMInitStruct->FMC_WriteBurst = FMC_WriteBurst_Disable;
+  FMC_NORSRAMInitStruct->FMC_ContinousClock = FMC_CClock_SyncOnly;
+  
+  FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct = (FMC_NORSRAMTimingInitTypeDef*)&FMC_DefaultTimingStruct;
+  FMC_NORSRAMInitStruct->FMC_WriteTimingStruct = (FMC_NORSRAMTimingInitTypeDef*)&FMC_DefaultTimingStruct;
+}
+
+/**
+  * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank1_NORSRAM1: FMC Bank1 NOR/SRAM1  
+  *            @arg FMC_Bank1_NORSRAM2: FMC Bank1 NOR/SRAM2 
+  *            @arg FMC_Bank1_NORSRAM3: FMC Bank1 NOR/SRAM3 
+  *            @arg FMC_Bank1_NORSRAM4: FMC Bank1 NOR/SRAM4 
+  * @param  NewState: new state of the FMC_Bank. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FMC_NORSRAMCmd(uint32_t FMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FMC_NORSRAM_BANK(FMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
+    FMC_Bank1->BTCR[FMC_Bank] |= BCR_MBKEN_SET;
+  }
+  else
+  {
+    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
+    FMC_Bank1->BTCR[FMC_Bank] &= BCR_MBKEN_RESET;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Group2 NAND Controller functions
+  * @brief    NAND Controller functions 
+  *
+@verbatim   
+ ===============================================================================
+                    ##### NAND Controller functions #####
+ ===============================================================================  
+
+ [..]  The following sequence should be followed to configure the FMC to interface 
+       with 8-bit or 16-bit NAND memory connected to the NAND Bank:
+ 
+  (#) Enable the clock for the FMC and associated GPIOs using the following functions:
+      (++)  RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
+      (++)  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
+
+  (#) FMC pins configuration 
+      (++) Connect the involved FMC pins to AF12 using the following function 
+           GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FMC); 
+      (++) Configure these FMC pins in alternate function mode by calling the function
+           GPIO_Init();    
+       
+  (#) Declare a FMC_NANDInitTypeDef structure, for example:
+      FMC_NANDInitTypeDef  FMC_NANDInitStructure;
+      and fill the FMC_NANDInitStructure variable with the allowed values of
+      the structure member.
+      
+  (#) Initialize the NAND Controller by calling the function
+      FMC_NANDInit(&FMC_NANDInitStructure); 
+
+  (#) Then enable the NAND Bank, for example:
+      FMC_NANDCmd(FMC_Bank3_NAND, ENABLE);  
+
+  (#) At this stage you can read/write from/to the memory connected to the NAND Bank. 
+   
+ [..]
+  (@) To enable the Error Correction Code (ECC), you have to use the function
+      FMC_NANDECCCmd(FMC_Bank3_NAND, ENABLE);  
+ [..]
+  (@) and to get the current ECC value you have to use the function
+      ECCval = FMC_GetECC(FMC_Bank3_NAND); 
+
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  De-initializes the FMC NAND Banks registers to their default reset values.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
+  *            @arg FMC_Bank3_NAND: FMC Bank3 NAND 
+  * @retval None
+  */
+void FMC_NANDDeInit(uint32_t FMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FMC_NAND_BANK(FMC_Bank));
+  
+  if(FMC_Bank == FMC_Bank2_NAND)
+  {
+    /* Set the FMC_Bank2 registers to their reset values */
+    FMC_Bank2->PCR2 = 0x00000018;
+    FMC_Bank2->SR2 = 0x00000040;
+    FMC_Bank2->PMEM2 = 0xFCFCFCFC;
+    FMC_Bank2->PATT2 = 0xFCFCFCFC;  
+  }
+  /* FMC_Bank3_NAND */  
+  else
+  {
+    /* Set the FMC_Bank3 registers to their reset values */
+    FMC_Bank3->PCR3 = 0x00000018;
+    FMC_Bank3->SR3 = 0x00000040;
+    FMC_Bank3->PMEM3 = 0xFCFCFCFC;
+    FMC_Bank3->PATT3 = 0xFCFCFCFC; 
+  }  
+}
+
+/**
+  * @brief  Initializes the FMC NAND Banks according to the specified parameters
+  *         in the FMC_NANDInitStruct.
+  * @param  FMC_NANDInitStruct : pointer to a FMC_NANDInitTypeDef structure that
+  *         contains the configuration information for the FMC NAND specified Banks.                       
+  * @retval None
+  */
+void FMC_NANDInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct)
+{
+  uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
+    
+  /* Check the parameters */
+  assert_param(IS_FMC_NAND_BANK(FMC_NANDInitStruct->FMC_Bank));
+  assert_param(IS_FMC_WAIT_FEATURE(FMC_NANDInitStruct->FMC_Waitfeature));
+  assert_param(IS_FMC_NAND_MEMORY_WIDTH(FMC_NANDInitStruct->FMC_MemoryDataWidth));
+  assert_param(IS_FMC_ECC_STATE(FMC_NANDInitStruct->FMC_ECC));
+  assert_param(IS_FMC_ECCPAGE_SIZE(FMC_NANDInitStruct->FMC_ECCPageSize));
+  assert_param(IS_FMC_TCLR_TIME(FMC_NANDInitStruct->FMC_TCLRSetupTime));
+  assert_param(IS_FMC_TAR_TIME(FMC_NANDInitStruct->FMC_TARSetupTime));
+  assert_param(IS_FMC_SETUP_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime));
+  assert_param(IS_FMC_WAIT_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime));
+  assert_param(IS_FMC_HOLD_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime));
+  assert_param(IS_FMC_HIZ_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime));
+  assert_param(IS_FMC_SETUP_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime));
+  assert_param(IS_FMC_WAIT_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime));
+  assert_param(IS_FMC_HOLD_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime));
+  assert_param(IS_FMC_HIZ_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime));
+  
+  /* Set the tmppcr value according to FMC_NANDInitStruct parameters */
+  tmppcr = (uint32_t)FMC_NANDInitStruct->FMC_Waitfeature |
+            PCR_MEMORYTYPE_NAND |
+            FMC_NANDInitStruct->FMC_MemoryDataWidth |
+            FMC_NANDInitStruct->FMC_ECC |
+            FMC_NANDInitStruct->FMC_ECCPageSize |
+            (FMC_NANDInitStruct->FMC_TCLRSetupTime << 9 )|
+            (FMC_NANDInitStruct->FMC_TARSetupTime << 13);
+            
+  /* Set tmppmem value according to FMC_CommonSpaceTimingStructure parameters */
+  tmppmem = (uint32_t)FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime |
+            (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime << 8) |
+            (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime << 16)|
+            (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime << 24); 
+            
+  /* Set tmppatt value according to FMC_AttributeSpaceTimingStructure parameters */
+  tmppatt = (uint32_t)FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime |
+            (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime << 8) |
+            (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime << 16)|
+            (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime << 24);
+  
+  if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
+  {
+    /* FMC_Bank2_NAND registers configuration */
+    FMC_Bank2->PCR2 = tmppcr;
+    FMC_Bank2->PMEM2 = tmppmem;
+    FMC_Bank2->PATT2 = tmppatt;
+  }
+  else
+  {
+    /* FMC_Bank3_NAND registers configuration */
+    FMC_Bank3->PCR3 = tmppcr;
+    FMC_Bank3->PMEM3 = tmppmem;
+    FMC_Bank3->PATT3 = tmppatt;
+  }
+}
+
+
+/**
+  * @brief  Fills each FMC_NANDInitStruct member with its default value.
+  * @param  FMC_NANDInitStruct: pointer to a FMC_NANDInitTypeDef structure which
+  *         will be initialized.
+  * @retval None
+  */
+void FMC_NANDStructInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct)
+{ 
+  /* Reset NAND Init structure parameters values */
+  FMC_NANDInitStruct->FMC_Bank = FMC_Bank2_NAND;
+  FMC_NANDInitStruct->FMC_Waitfeature = FMC_Waitfeature_Disable;
+  FMC_NANDInitStruct->FMC_MemoryDataWidth = FMC_NAND_MemoryDataWidth_16b;
+  FMC_NANDInitStruct->FMC_ECC = FMC_ECC_Disable;
+  FMC_NANDInitStruct->FMC_ECCPageSize = FMC_ECCPageSize_256Bytes;
+  FMC_NANDInitStruct->FMC_TCLRSetupTime = 0x0;
+  FMC_NANDInitStruct->FMC_TARSetupTime = 0x0;
+  FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime = 252;
+  FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime = 252;
+  FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime = 252;
+  FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime = 252;
+  FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime = 252;
+  FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime = 252;
+  FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime = 252;
+  FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime = 252;	  
+}
+
+/**
+  * @brief  Enables or disables the specified NAND Memory Bank.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
+  *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
+  * @param  NewState: new state of the FMC_Bank. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FMC_NANDCmd(uint32_t FMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FMC_NAND_BANK(FMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
+    if(FMC_Bank == FMC_Bank2_NAND)
+    {
+      FMC_Bank2->PCR2 |= PCR_PBKEN_SET;
+    }
+    else
+    {
+      FMC_Bank3->PCR3 |= PCR_PBKEN_SET;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
+    if(FMC_Bank == FMC_Bank2_NAND)
+    {
+      FMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
+    }
+    else
+    {
+      FMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
+    }
+  }
+}
+/**
+  * @brief  Enables or disables the FMC NAND ECC feature.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
+  *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
+  * @param  NewState: new state of the FMC NAND ECC feature.  
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FMC_NANDECCCmd(uint32_t FMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FMC_NAND_BANK(FMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
+    if(FMC_Bank == FMC_Bank2_NAND)
+    {
+      FMC_Bank2->PCR2 |= PCR_ECCEN_SET;
+    }
+    else
+    {
+      FMC_Bank3->PCR3 |= PCR_ECCEN_SET;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
+    if(FMC_Bank == FMC_Bank2_NAND)
+    {
+      FMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
+    }
+    else
+    {
+      FMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
+    }
+  }
+}
+
+/**
+  * @brief  Returns the error correction code register value.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
+  *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
+  * @retval The Error Correction Code (ECC) value.
+  */
+uint32_t FMC_GetECC(uint32_t FMC_Bank)
+{
+  uint32_t eccval = 0x00000000;
+  
+  if(FMC_Bank == FMC_Bank2_NAND)
+  {
+    /* Get the ECCR2 register value */
+    eccval = FMC_Bank2->ECCR2;
+  }
+  else
+  {
+    /* Get the ECCR3 register value */
+    eccval = FMC_Bank3->ECCR3;
+  }
+  /* Return the error correction code value */
+  return(eccval);
+}
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Group3 PCCARD Controller functions
+  * @brief    PCCARD Controller functions 
+  *
+@verbatim   
+ ===============================================================================
+                    ##### PCCARD Controller functions #####
+ ===============================================================================  
+
+ [..]  he following sequence should be followed to configure the FMC to interface 
+       with 16-bit PC Card compatible memory connected to the PCCARD Bank:
+ 
+  (#)  Enable the clock for the FMC and associated GPIOs using the following functions:
+       (++)  RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
+       (++)  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
+
+  (#) FMC pins configuration 
+       (++) Connect the involved FMC pins to AF12 using the following function 
+            GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FMC); 
+       (++) Configure these FMC pins in alternate function mode by calling the function
+            GPIO_Init();    
+       
+  (#) Declare a FMC_PCCARDInitTypeDef structure, for example:
+      FMC_PCCARDInitTypeDef  FMC_PCCARDInitStructure;
+      and fill the FMC_PCCARDInitStructure variable with the allowed values of
+      the structure member.
+      
+  (#) Initialize the PCCARD Controller by calling the function
+      FMC_PCCARDInit(&FMC_PCCARDInitStructure); 
+
+  (#) Then enable the PCCARD Bank:
+      FMC_PCCARDCmd(ENABLE);  
+
+  (#) At this stage you can read/write from/to the memory connected to the PCCARD Bank. 
+ 
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  De-initializes the FMC PCCARD Bank registers to their default reset values.
+  * @param  None                       
+  * @retval None
+  */
+void FMC_PCCARDDeInit(void)
+{
+  /* Set the FMC_Bank4 registers to their reset values */
+  FMC_Bank4->PCR4 = 0x00000018; 
+  FMC_Bank4->SR4 = 0x00000000;	
+  FMC_Bank4->PMEM4 = 0xFCFCFCFC;
+  FMC_Bank4->PATT4 = 0xFCFCFCFC;
+  FMC_Bank4->PIO4 = 0xFCFCFCFC;
+}
+
+/**
+  * @brief  Initializes the FMC PCCARD Bank according to the specified parameters
+  *         in the FMC_PCCARDInitStruct.
+  * @param  FMC_PCCARDInitStruct : pointer to a FMC_PCCARDInitTypeDef structure
+  *         that contains the configuration information for the FMC PCCARD Bank.                       
+  * @retval None
+  */
+void FMC_PCCARDInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_FMC_WAIT_FEATURE(FMC_PCCARDInitStruct->FMC_Waitfeature));
+  assert_param(IS_FMC_TCLR_TIME(FMC_PCCARDInitStruct->FMC_TCLRSetupTime));
+  assert_param(IS_FMC_TAR_TIME(FMC_PCCARDInitStruct->FMC_TARSetupTime));
+ 
+  assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime));
+  assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime));
+  assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime));
+  assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime));
+  
+  assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime));
+  assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime));
+  assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime));
+  assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime));
+  assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime));
+  assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime));
+  assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime));
+  assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime));
+  
+  /* Set the PCR4 register value according to FMC_PCCARDInitStruct parameters */
+  FMC_Bank4->PCR4 = (uint32_t)FMC_PCCARDInitStruct->FMC_Waitfeature |
+                     FMC_NAND_MemoryDataWidth_16b |  
+                     (FMC_PCCARDInitStruct->FMC_TCLRSetupTime << 9) |
+                     (FMC_PCCARDInitStruct->FMC_TARSetupTime << 13);
+            
+  /* Set PMEM4 register value according to FMC_CommonSpaceTimingStructure parameters */
+  FMC_Bank4->PMEM4 = (uint32_t)FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime |
+                      (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime << 8) |
+                      (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime << 16)|
+                      (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime << 24); 
+            
+  /* Set PATT4 register value according to FMC_AttributeSpaceTimingStructure parameters */
+  FMC_Bank4->PATT4 = (uint32_t)FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime |
+                      (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime << 8) |
+                      (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime << 16)|
+                      (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime << 24);	
+            
+  /* Set PIO4 register value according to FMC_IOSpaceTimingStructure parameters */
+  FMC_Bank4->PIO4 = (uint32_t)FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime |
+                     (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime << 8) |
+                     (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime << 16)|
+                     (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime << 24);             
+}
+
+/**
+  * @brief  Fills each FMC_PCCARDInitStruct member with its default value.
+  * @param  FMC_PCCARDInitStruct: pointer to a FMC_PCCARDInitTypeDef structure
+  *         which will be initialized.
+  * @retval None
+  */
+void FMC_PCCARDStructInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct)
+{
+  /* Reset PCCARD Init structure parameters values */
+  FMC_PCCARDInitStruct->FMC_Waitfeature = FMC_Waitfeature_Disable;
+  FMC_PCCARDInitStruct->FMC_TCLRSetupTime = 0;
+  FMC_PCCARDInitStruct->FMC_TARSetupTime = 0;
+  FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime = 252;	
+  FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime = 252;
+  FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime = 252;
+}
+
+/**
+  * @brief  Enables or disables the PCCARD Memory Bank.
+  * @param  NewState: new state of the PCCARD Memory Bank.  
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FMC_PCCARDCmd(FunctionalState NewState)
+{
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
+    FMC_Bank4->PCR4 |= PCR_PBKEN_SET;
+  }
+  else
+  {
+    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
+    FMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Group4  SDRAM Controller functions
+  * @brief    SDRAM Controller functions
+  *
+@verbatim   
+ ===============================================================================
+                     ##### SDRAM Controller functions ##### 
+ ===============================================================================  
+  
+ [..]  The following sequence should be followed to configure the FMC to interface
+       with SDRAM memory connected to the SDRAM Bank 1 or SDRAM bank 2:
+ 
+  (#) Enable the clock for the FMC and associated GPIOs using the following functions:
+      (++) RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
+      (++) RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
+
+  (#) FMC pins configuration 
+      (++) Connect the involved FMC pins to AF12 using the following function 
+           GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FMC); 
+      (++) Configure these FMC pins in alternate function mode by calling the function
+           GPIO_Init();    
+       
+  (#) Declare a FMC_SDRAMInitTypeDef structure, for example:
+       FMC_SDRAMInitTypeDef  FMC_SDRAMInitStructure;
+      and fill the FMC_SDRAMInitStructure variable with the allowed values of
+      the structure member.  
+      
+  (#) Initialize the SDRAM Controller by calling the function
+          FMC_SDRAMInit(&FMC_SDRAMInitStructure);
+          
+  (#) Declare a FMC_SDRAMCommandTypeDef structure, for example:
+        FMC_SDRAMCommandTypeDef  FMC_SDRAMCommandStructure;
+      and fill the FMC_SDRAMCommandStructure variable with the allowed values of
+      the structure member.        
+
+  (#) Configure the SDCMR register with the desired command parameters by calling 
+      the function FMC_SDRAMCmdConfig(&FMC_SDRAMCommandStructure);  
+
+  (#) At this stage, the SDRAM memory is ready for any valid command.
+   
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  De-initializes the FMC SDRAM Banks registers to their default 
+  *         reset values.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
+  *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM 
+  * @retval None
+  */
+void FMC_SDRAMDeInit(uint32_t FMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FMC_SDRAM_BANK(FMC_Bank));
+  
+  FMC_Bank5_6->SDCR[FMC_Bank] = 0x000002D0;
+  FMC_Bank5_6->SDTR[FMC_Bank] = 0x0FFFFFFF;    
+  FMC_Bank5_6->SDCMR = 0x00000000;
+  FMC_Bank5_6->SDRTR = 0x00000000;
+  FMC_Bank5_6->SDSR = 0x00000000; 
+}  
+
+/**
+  * @brief  Initializes the FMC SDRAM Banks according to the specified
+  *         parameters in the FMC_SDRAMInitStruct.
+  * @param  FMC_SDRAMInitStruct : pointer to a FMC_SDRAMInitTypeDef structure
+  *         that contains the configuration information for the FMC SDRAM 
+  *         specified Banks.                       
+  * @retval None
+  */
+void FMC_SDRAMInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct)
+{ 
+  /* temporary registers */
+  uint32_t tmpr1 = 0;
+  uint32_t tmpr2 = 0;
+  uint32_t tmpr3 = 0;
+  uint32_t tmpr4 = 0;
+  
+  /* Check the parameters */
+  
+  /* Control parameters */
+  assert_param(IS_FMC_SDRAM_BANK(FMC_SDRAMInitStruct->FMC_Bank));
+  assert_param(IS_FMC_COLUMNBITS_NUMBER(FMC_SDRAMInitStruct->FMC_ColumnBitsNumber)); 
+  assert_param(IS_FMC_ROWBITS_NUMBER(FMC_SDRAMInitStruct->FMC_RowBitsNumber));
+  assert_param(IS_FMC_SDMEMORY_WIDTH(FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth));
+  assert_param(IS_FMC_INTERNALBANK_NUMBER(FMC_SDRAMInitStruct->FMC_InternalBankNumber)); 
+  assert_param(IS_FMC_CAS_LATENCY(FMC_SDRAMInitStruct->FMC_CASLatency));
+  assert_param(IS_FMC_WRITE_PROTECTION(FMC_SDRAMInitStruct->FMC_WriteProtection));
+  assert_param(IS_FMC_SDCLOCK_PERIOD(FMC_SDRAMInitStruct->FMC_SDClockPeriod));
+  assert_param(IS_FMC_READ_BURST(FMC_SDRAMInitStruct->FMC_ReadBurst));
+  assert_param(IS_FMC_READPIPE_DELAY(FMC_SDRAMInitStruct->FMC_ReadPipeDelay));   
+  
+  /* Timing parameters */
+  assert_param(IS_FMC_LOADTOACTIVE_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)); 
+  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay));
+  assert_param(IS_FMC_SELFREFRESH_TIME(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime));
+  assert_param(IS_FMC_ROWCYCLE_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay));
+  assert_param(IS_FMC_WRITE_RECOVERY_TIME(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)); 
+  assert_param(IS_FMC_RP_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)); 
+  assert_param(IS_FMC_RCD_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay));    
+  
+  /* SDRAM bank control register configuration */ 
+  tmpr1 =   (uint32_t)FMC_SDRAMInitStruct->FMC_ColumnBitsNumber |
+             FMC_SDRAMInitStruct->FMC_RowBitsNumber |
+             FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth |
+             FMC_SDRAMInitStruct->FMC_InternalBankNumber |           
+             FMC_SDRAMInitStruct->FMC_CASLatency |
+             FMC_SDRAMInitStruct->FMC_WriteProtection |
+             FMC_SDRAMInitStruct->FMC_SDClockPeriod |
+             FMC_SDRAMInitStruct->FMC_ReadBurst | 
+             FMC_SDRAMInitStruct->FMC_ReadPipeDelay;
+            
+  if(FMC_SDRAMInitStruct->FMC_Bank == FMC_Bank1_SDRAM )
+  {
+    FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr1;
+  }
+  else   /* SDCR2 "don't care" bits configuration */
+  {
+    tmpr3 = (uint32_t)FMC_SDRAMInitStruct->FMC_SDClockPeriod |
+             FMC_SDRAMInitStruct->FMC_ReadBurst | 
+             FMC_SDRAMInitStruct->FMC_ReadPipeDelay;
+    
+    FMC_Bank5_6->SDCR[FMC_Bank1_SDRAM] = tmpr3;
+    FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr1;
+  }
+  /* SDRAM bank timing register configuration */
+  if(FMC_SDRAMInitStruct->FMC_Bank == FMC_Bank1_SDRAM )
+  {
+    tmpr2 =   (uint32_t)((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)-1) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay)-1) << 4) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime)-1) << 8) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay)-1) << 12) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)-1) << 16) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)-1) << 20) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay)-1) << 24);
+            
+            FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr2;
+  }
+  else   /* SDTR "don't care bits configuration */
+  {
+    tmpr2 =   (uint32_t)((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)-1) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay)-1) << 4) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime)-1) << 8) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)-1) << 16);
+            
+    tmpr4 =   (uint32_t)(((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay)-1) << 12) |
+            (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)-1) << 20);
+            
+            FMC_Bank5_6->SDTR[FMC_Bank1_SDRAM] = tmpr4;
+            FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr2;
+  }
+  
+}
+
+/**
+  * @brief  Fills each FMC_SDRAMInitStruct member with its default value.
+  * @param  FMC_SDRAMInitStruct: pointer to a FMC_SDRAMInitTypeDef structure 
+  *         which will be initialized.
+  * @retval None
+  */
+void FMC_SDRAMStructInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct)  
+{  
+  /* Reset SDRAM Init structure parameters values */
+  FMC_SDRAMInitStruct->FMC_Bank = FMC_Bank1_SDRAM;
+  FMC_SDRAMInitStruct->FMC_ColumnBitsNumber = FMC_ColumnBits_Number_8b;
+  FMC_SDRAMInitStruct->FMC_RowBitsNumber = FMC_RowBits_Number_11b; 
+  FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth = FMC_SDMemory_Width_16b;
+  FMC_SDRAMInitStruct->FMC_InternalBankNumber = FMC_InternalBank_Number_4; 
+  FMC_SDRAMInitStruct->FMC_CASLatency = FMC_CAS_Latency_1;  
+  FMC_SDRAMInitStruct->FMC_WriteProtection = FMC_Write_Protection_Enable;
+  FMC_SDRAMInitStruct->FMC_SDClockPeriod = FMC_SDClock_Disable;
+  FMC_SDRAMInitStruct->FMC_ReadBurst = FMC_Read_Burst_Disable;
+  FMC_SDRAMInitStruct->FMC_ReadPipeDelay = FMC_ReadPipe_Delay_0; 
+   
+  FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay = 16;
+  FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay = 16;
+  FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime = 16;
+  FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay = 16;
+  FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime = 16;
+  FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay = 16;
+  FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay = 16;
+  
+}
+
+/**
+  * @brief  Configures the SDRAM memory command issued when the device is accessed.   
+  * @param  FMC_SDRAMCommandStruct: pointer to a FMC_SDRAMCommandTypeDef structure 
+  *         which will be configured.
+  * @retval None
+  */
+void FMC_SDRAMCmdConfig(FMC_SDRAMCommandTypeDef* FMC_SDRAMCommandStruct)
+{
+  uint32_t tmpr = 0x0;
+    
+  /* check parameters */
+  assert_param(IS_FMC_COMMAND_MODE(FMC_SDRAMCommandStruct->FMC_CommandMode));
+  assert_param(IS_FMC_COMMAND_TARGET(FMC_SDRAMCommandStruct->FMC_CommandTarget));
+  assert_param(IS_FMC_AUTOREFRESH_NUMBER(FMC_SDRAMCommandStruct->FMC_AutoRefreshNumber));
+  assert_param(IS_FMC_MODE_REGISTER(FMC_SDRAMCommandStruct->FMC_ModeRegisterDefinition));
+  
+  tmpr =   (uint32_t)(FMC_SDRAMCommandStruct->FMC_CommandMode |
+                      FMC_SDRAMCommandStruct->FMC_CommandTarget |
+                     (((FMC_SDRAMCommandStruct->FMC_AutoRefreshNumber)-1)<<5) |
+                     ((FMC_SDRAMCommandStruct->FMC_ModeRegisterDefinition)<<9));
+  
+  FMC_Bank5_6->SDCMR = tmpr;
+
+}
+
+
+/**
+  * @brief  Returns the indicated FMC SDRAM bank mode status.
+  * @param  SDRAM_Bank: Defines the FMC SDRAM bank. This parameter can be 
+  *                     FMC_Bank1_SDRAM or FMC_Bank2_SDRAM. 
+  * @retval The FMC SDRAM bank mode status         
+  */
+uint32_t FMC_GetModeStatus(uint32_t SDRAM_Bank)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameter */
+  assert_param(IS_FMC_SDRAM_BANK(SDRAM_Bank));
+
+  /* Get the busy flag status */
+  if(SDRAM_Bank == FMC_Bank1_SDRAM)
+  {
+    tmpreg = (uint32_t)(FMC_Bank5_6->SDSR & FMC_SDSR_MODES1); 
+  }
+  else
+  {
+    tmpreg = ((uint32_t)(FMC_Bank5_6->SDSR & FMC_SDSR_MODES2) >> 2);
+  }
+  
+  /* Return the mode status */
+  return tmpreg;
+}
+
+/**
+  * @brief  defines the SDRAM Memory Refresh rate.
+  * @param  FMC_Count: specifies the Refresh timer count.       
+  * @retval None
+  */
+void FMC_SetRefreshCount(uint32_t FMC_Count)
+{
+  /* check the parameters */
+  assert_param(IS_FMC_REFRESH_COUNT(FMC_Count));
+  
+  FMC_Bank5_6->SDRTR |= (FMC_Count<<1);
+   
+}
+
+/**
+  * @brief  Sets the Number of consecutive SDRAM Memory auto Refresh commands.
+  * @param  FMC_Number: specifies the auto Refresh number.       
+  * @retval None
+  */
+void FMC_SetAutoRefresh_Number(uint32_t FMC_Number)
+{
+  /* check the parameters */
+  assert_param(IS_FMC_AUTOREFRESH_NUMBER(FMC_Number));
+  
+  FMC_Bank5_6->SDCMR |= (FMC_Number << 5);   
+}
+
+/**
+  * @brief  Enables or disables write protection to the specified FMC SDRAM Bank.
+  * @param  SDRAM_Bank: Defines the FMC SDRAM bank. This parameter can be 
+  *                     FMC_Bank1_SDRAM or FMC_Bank2_SDRAM.   
+  * @param  NewState: new state of the write protection flag.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FMC_SDRAMWriteProtectionConfig(uint32_t SDRAM_Bank, FunctionalState NewState)
+{
+  /* Check the parameter */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_FMC_SDRAM_BANK(SDRAM_Bank));
+  
+  if (NewState != DISABLE)
+  {
+    FMC_Bank5_6->SDCR[SDRAM_Bank] |= FMC_Write_Protection_Enable;    
+  }
+  else
+  {
+    FMC_Bank5_6->SDCR[SDRAM_Bank] &= SDCR_WriteProtection_RESET;
+  } 
+  
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup FMC_Group5  Interrupts and flags management functions
+  * @brief    Interrupts and flags management functions
+  *
+@verbatim   
+ ===============================================================================
+             ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified FMC interrupts.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
+  *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
+  *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
+  *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
+  *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM   
+  * @param  FMC_IT: specifies the FMC interrupt sources to be enabled or disabled.
+  *          This parameter can be any combination of the following values:
+  *            @arg FMC_IT_RisingEdge: Rising edge detection interrupt. 
+  *            @arg FMC_IT_Level: Level edge detection interrupt.
+  *            @arg FMC_IT_FallingEdge: Falling edge detection interrupt.
+  *            @arg FMC_IT_Refresh: Refresh error detection interrupt.  
+  * @param  NewState: new state of the specified FMC interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FMC_ITConfig(uint32_t FMC_Bank, uint32_t FMC_IT, FunctionalState NewState)
+{
+  assert_param(IS_FMC_IT_BANK(FMC_Bank));
+  assert_param(IS_FMC_IT(FMC_IT));	
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected FMC_Bank2 interrupts */
+    if(FMC_Bank == FMC_Bank2_NAND)
+    {
+      FMC_Bank2->SR2 |= FMC_IT;
+    }
+    /* Enable the selected FMC_Bank3 interrupts */
+    else if (FMC_Bank == FMC_Bank3_NAND)
+    {
+      FMC_Bank3->SR3 |= FMC_IT;
+    }
+    /* Enable the selected FMC_Bank4 interrupts */
+    else if (FMC_Bank == FMC_Bank4_PCCARD)
+    {
+      FMC_Bank4->SR4 |= FMC_IT;    
+    }
+    /* Enable the selected FMC_Bank5_6 interrupt */
+    else
+    {
+      /* Enables the interrupt if the refresh error flag is set */
+      FMC_Bank5_6->SDRTR |= FMC_IT; 
+    }
+  }
+  else
+  {
+    /* Disable the selected FMC_Bank2 interrupts */
+    if(FMC_Bank == FMC_Bank2_NAND)
+    {
+      
+      FMC_Bank2->SR2 &= (uint32_t)~FMC_IT;
+    }
+    /* Disable the selected FMC_Bank3 interrupts */
+    else if (FMC_Bank == FMC_Bank3_NAND)
+    {
+      FMC_Bank3->SR3 &= (uint32_t)~FMC_IT;
+    }
+    /* Disable the selected FMC_Bank4 interrupts */
+    else if(FMC_Bank == FMC_Bank4_PCCARD)
+    {
+      FMC_Bank4->SR4 &= (uint32_t)~FMC_IT;    
+    }
+    /* Disable the selected FMC_Bank5_6 interrupt */
+    else
+    {
+      /* Disables the interrupt if the refresh error flag is not set */
+      FMC_Bank5_6->SDRTR &= (uint32_t)~FMC_IT; 
+    }
+  }
+}
+
+/**
+  * @brief  Checks whether the specified FMC flag is set or not.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
+  *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
+  *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
+  *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
+  *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM 
+  *            @arg FMC_Bank1_SDRAM | FMC_Bank2_SDRAM: FMC Bank1 or Bank2 SDRAM    
+  * @param  FMC_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg FMC_FLAG_RisingEdge: Rising edge detection Flag.
+  *            @arg FMC_FLAG_Level: Level detection Flag.
+  *            @arg FMC_FLAG_FallingEdge: Falling edge detection Flag.
+  *            @arg FMC_FLAG_FEMPT: Fifo empty Flag.
+  *            @arg FMC_FLAG_Refresh: Refresh error Flag.
+  *            @arg FMC_FLAG_Busy: Busy status Flag.     
+  * @retval The new state of FMC_FLAG (SET or RESET).
+  */
+FlagStatus FMC_GetFlagStatus(uint32_t FMC_Bank, uint32_t FMC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t tmpsr = 0x00000000;
+  
+  /* Check the parameters */
+  assert_param(IS_FMC_GETFLAG_BANK(FMC_Bank));
+  assert_param(IS_FMC_GET_FLAG(FMC_FLAG));
+  
+  if(FMC_Bank == FMC_Bank2_NAND)
+  {
+    tmpsr = FMC_Bank2->SR2;
+  }  
+  else if(FMC_Bank == FMC_Bank3_NAND)
+  {
+    tmpsr = FMC_Bank3->SR3;
+  }
+  else if(FMC_Bank == FMC_Bank4_PCCARD)
+  {
+    tmpsr = FMC_Bank4->SR4;
+  }
+  else 
+  {
+    tmpsr = FMC_Bank5_6->SDSR;
+  }
+  
+  /* Get the flag status */
+  if ((tmpsr & FMC_FLAG) != FMC_FLAG )
+  {
+    bitstatus = RESET;
+  }
+  else
+  {
+    bitstatus = SET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the FMC's pending flags.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
+  *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
+  *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
+  *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
+  *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM  
+  * @param  FMC_FLAG: specifies the flag to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg FMC_FLAG_RisingEdge: Rising edge detection Flag.
+  *            @arg FMC_FLAG_Level: Level detection Flag.
+  *            @arg FMC_FLAG_FallingEdge: Falling edge detection Flag.
+  *            @arg FMC_FLAG_Refresh: Refresh error Flag.  
+  * @retval None
+  */
+void FMC_ClearFlag(uint32_t FMC_Bank, uint32_t FMC_FLAG)
+{
+ /* Check the parameters */
+  assert_param(IS_FMC_GETFLAG_BANK(FMC_Bank));
+  assert_param(IS_FMC_CLEAR_FLAG(FMC_FLAG)) ;
+    
+  if(FMC_Bank == FMC_Bank2_NAND)
+  {
+    FMC_Bank2->SR2 &= (~FMC_FLAG); 
+  }  
+  else if(FMC_Bank == FMC_Bank3_NAND)
+  {
+    FMC_Bank3->SR3 &= (~FMC_FLAG);
+  }
+  else if(FMC_Bank == FMC_Bank4_PCCARD)
+  {
+    FMC_Bank4->SR4 &= (~FMC_FLAG);
+  }
+  /* FMC_Bank5_6 SDRAM*/
+  else
+  {
+    FMC_Bank5_6->SDRTR &= (~FMC_FLAG);
+  }
+  
+}
+
+/**
+  * @brief  Checks whether the specified FMC interrupt has occurred or not.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
+  *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
+  *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
+  *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
+  *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM   
+  * @param  FMC_IT: specifies the FMC interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg FMC_IT_RisingEdge: Rising edge detection interrupt. 
+  *            @arg FMC_IT_Level: Level edge detection interrupt.
+  *            @arg FMC_IT_FallingEdge: Falling edge detection interrupt.
+  *            @arg FMC_IT_Refresh: Refresh error detection interrupt.    
+  * @retval The new state of FMC_IT (SET or RESET).
+  */
+ITStatus FMC_GetITStatus(uint32_t FMC_Bank, uint32_t FMC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t tmpsr = 0x0;
+  uint32_t tmpsr2 = 0x0;
+  uint32_t itstatus = 0x0;
+  uint32_t itenable = 0x0; 
+  
+  /* Check the parameters */
+  assert_param(IS_FMC_IT_BANK(FMC_Bank));
+  assert_param(IS_FMC_GET_IT(FMC_IT));
+  
+  if(FMC_Bank == FMC_Bank2_NAND)
+  {
+    tmpsr = FMC_Bank2->SR2;
+  }  
+  else if(FMC_Bank == FMC_Bank3_NAND)
+  {
+    tmpsr = FMC_Bank3->SR3;
+  }
+  else if(FMC_Bank == FMC_Bank4_PCCARD)
+  {
+    tmpsr = FMC_Bank4->SR4;
+  }
+  /* FMC_Bank5_6 SDRAM*/
+  else
+  {
+    tmpsr = FMC_Bank5_6->SDRTR;
+    tmpsr2 = FMC_Bank5_6->SDSR;
+  } 
+  
+  /* get the IT enable bit status*/
+  itenable = tmpsr & FMC_IT;
+  
+  /* get the corresponding IT Flag status*/
+  if((FMC_Bank == FMC_Bank1_SDRAM) || (FMC_Bank == FMC_Bank2_SDRAM))
+  {
+    itstatus = tmpsr2 & FMC_SDSR_RE;  
+  }           
+  else
+  {
+    itstatus = tmpsr & (FMC_IT >> 3);  
+  }  
+  
+  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus; 
+}
+
+/**
+  * @brief  Clears the FMC's interrupt pending bits.
+  * @param  FMC_Bank: specifies the FMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
+  *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
+  *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
+  *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
+  *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM   
+  * @param  FMC_IT: specifies the interrupt pending bit to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg FMC_IT_RisingEdge: Rising edge detection interrupt. 
+  *            @arg FMC_IT_Level: Level edge detection interrupt.
+  *            @arg FMC_IT_FallingEdge: Falling edge detection interrupt.
+  *            @arg FMC_IT_Refresh: Refresh error detection interrupt.  
+  * @retval None
+  */
+void FMC_ClearITPendingBit(uint32_t FMC_Bank, uint32_t FMC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_FMC_IT_BANK(FMC_Bank));
+  assert_param(IS_FMC_IT(FMC_IT));
+    
+  if(FMC_Bank == FMC_Bank2_NAND)
+  {
+    FMC_Bank2->SR2 &= ~(FMC_IT >> 3); 
+  }  
+  else if(FMC_Bank == FMC_Bank3_NAND)
+  {
+    FMC_Bank3->SR3 &= ~(FMC_IT >> 3);
+  }
+  else if(FMC_Bank == FMC_Bank4_PCCARD)
+  {
+    FMC_Bank4->SR4 &= ~(FMC_IT >> 3);
+  }
+  /* FMC_Bank5_6 SDRAM*/
+  else
+  {
+    FMC_Bank5_6->SDRTR |= FMC_SDRTR_CRE;
+  }
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fsmc.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fsmc.c
new file mode 100644
index 0000000..3932bb5
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fsmc.c
@@ -0,0 +1,986 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_fsmc.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+ * @brief    This file provides firmware functions to manage the following 
+  *          functionalities of the FSMC peripheral:           
+  *           + Interface with SRAM, PSRAM, NOR and OneNAND memories
+  *           + Interface with NAND memories
+  *           + Interface with 16-bit PC Card compatible memories  
+  *           + Interrupts and flags management   
+  *           
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_fsmc.h"
+#include "stm32f4xx_rcc.h"
+// #include "stm32f4xx.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup FSMC 
+  * @brief FSMC driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+const FSMC_NORSRAMTimingInitTypeDef FSMC_DefaultTimingStruct = {0x0F, /* FSMC_AddressSetupTime */
+                                                                0x0F, /* FSMC_AddressHoldTime */
+                                                                0xFF, /* FSMC_DataSetupTime */
+                                                                0x0F, /* FSMC_BusTurnAroundDuration */
+                                                                0x0F, /* FSMC_CLKDivision */
+                                                                0x0F, /* FSMC_DataLatency */
+                                                                FSMC_AccessMode_A /* FSMC_AccessMode */
+                                                               };
+/* Private define ------------------------------------------------------------*/
+
+/* --------------------- FSMC registers bit mask ---------------------------- */
+/* FSMC BCRx Mask */
+#define BCR_MBKEN_SET          ((uint32_t)0x00000001)
+#define BCR_MBKEN_RESET        ((uint32_t)0x000FFFFE)
+#define BCR_FACCEN_SET         ((uint32_t)0x00000040)
+
+/* FSMC PCRx Mask */
+#define PCR_PBKEN_SET          ((uint32_t)0x00000004)
+#define PCR_PBKEN_RESET        ((uint32_t)0x000FFFFB)
+#define PCR_ECCEN_SET          ((uint32_t)0x00000040)
+#define PCR_ECCEN_RESET        ((uint32_t)0x000FFFBF)
+#define PCR_MEMORYTYPE_NAND    ((uint32_t)0x00000008)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup FSMC_Private_Functions
+  * @{
+  */
+
+/** @defgroup FSMC_Group1 NOR/SRAM Controller functions
+ *  @brief   NOR/SRAM Controller functions 
+ *
+@verbatim   
+ ===============================================================================
+                    ##### NOR and SRAM Controller functions #####
+ ===============================================================================  
+
+ [..] The following sequence should be followed to configure the FSMC to interface
+      with SRAM, PSRAM, NOR or OneNAND memory connected to the NOR/SRAM Bank:
+ 
+   (#) Enable the clock for the FSMC and associated GPIOs using the following functions:
+          RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
+          RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
+
+   (#) FSMC pins configuration 
+       (++) Connect the involved FSMC pins to AF12 using the following function 
+            GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FSMC); 
+       (++) Configure these FSMC pins in alternate function mode by calling the function
+            GPIO_Init();    
+       
+   (#) Declare a FSMC_NORSRAMInitTypeDef structure, for example:
+          FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
+      and fill the FSMC_NORSRAMInitStructure variable with the allowed values of
+      the structure member.
+      
+   (#) Initialize the NOR/SRAM Controller by calling the function
+          FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure); 
+
+   (#) Then enable the NOR/SRAM Bank, for example:
+          FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM2, ENABLE);  
+
+   (#) At this stage you can read/write from/to the memory connected to the NOR/SRAM Bank. 
+   
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  De-initializes the FSMC NOR/SRAM Banks registers to their default 
+  *   reset values.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
+  *            @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
+  *            @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
+  *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
+  * @retval None
+  */
+void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
+  
+  /* FSMC_Bank1_NORSRAM1 */
+  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
+  {
+    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
+  }
+  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
+  else
+  {   
+    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
+  }
+  FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
+  FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
+}
+
+/**
+  * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
+  *         parameters in the FSMC_NORSRAMInitStruct.
+  * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef structure
+  *         that contains the configuration information for the FSMC NOR/SRAM 
+  *         specified Banks.                       
+  * @retval None
+  */
+void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
+  assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
+  assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
+  assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
+  assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
+  assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
+  assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
+  assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
+  assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
+  assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
+  assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
+  assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
+  assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
+  assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
+  assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
+  assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
+  assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
+  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
+  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
+  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
+  
+  /* Bank1 NOR/SRAM control register configuration */ 
+  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
+            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
+            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
+            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
+            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
+            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
+            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
+            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
+            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
+            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
+            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
+            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
+            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
+  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
+  {
+    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
+  }
+  /* Bank1 NOR/SRAM timing register configuration */
+  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
+            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
+             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
+            
+    
+  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
+  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
+  {
+    assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
+    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
+    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
+    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
+    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
+    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
+    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
+              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
+              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
+              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
+              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
+              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
+               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
+  }
+  else
+  {
+    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
+  }
+}
+
+/**
+  * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
+  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef structure 
+  *         which will be initialized.
+  * @retval None
+  */
+void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
+{  
+  /* Reset NOR/SRAM Init structure parameters values */
+  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
+  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
+  FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
+  FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
+  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
+  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
+  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
+  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
+  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct = (FSMC_NORSRAMTimingInitTypeDef*)&FSMC_DefaultTimingStruct;
+  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct = (FSMC_NORSRAMTimingInitTypeDef*)&FSMC_DefaultTimingStruct;
+}
+
+/**
+  * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
+  *            @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
+  *            @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
+  *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
+  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
+    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
+  }
+  else
+  {
+    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
+    FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Group2 NAND Controller functions
+ *  @brief   NAND Controller functions 
+ *
+@verbatim   
+ ===============================================================================
+                    ##### NAND Controller functions #####
+ ===============================================================================  
+
+ [..]  The following sequence should be followed to configure the FSMC to interface 
+       with 8-bit or 16-bit NAND memory connected to the NAND Bank:
+ 
+  (#) Enable the clock for the FSMC and associated GPIOs using the following functions:
+      (++)  RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
+      (++)  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
+
+  (#) FSMC pins configuration 
+      (++) Connect the involved FSMC pins to AF12 using the following function 
+           GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FSMC); 
+      (++) Configure these FSMC pins in alternate function mode by calling the function
+           GPIO_Init();    
+       
+  (#) Declare a FSMC_NANDInitTypeDef structure, for example:
+      FSMC_NANDInitTypeDef  FSMC_NANDInitStructure;
+      and fill the FSMC_NANDInitStructure variable with the allowed values of
+      the structure member.
+      
+  (#) Initialize the NAND Controller by calling the function
+      FSMC_NANDInit(&FSMC_NANDInitStructure); 
+
+  (#) Then enable the NAND Bank, for example:
+      FSMC_NANDCmd(FSMC_Bank3_NAND, ENABLE);  
+
+  (#) At this stage you can read/write from/to the memory connected to the NAND Bank. 
+   
+ [..]
+  (@) To enable the Error Correction Code (ECC), you have to use the function
+      FSMC_NANDECCCmd(FSMC_Bank3_NAND, ENABLE);  
+ [..]
+  (@) and to get the current ECC value you have to use the function
+      ECCval = FSMC_GetECC(FSMC_Bank3_NAND); 
+
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  De-initializes the FSMC NAND Banks registers to their default reset values.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
+  * @retval None
+  */
+void FSMC_NANDDeInit(uint32_t FSMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* Set the FSMC_Bank2 registers to their reset values */
+    FSMC_Bank2->PCR2 = 0x00000018;
+    FSMC_Bank2->SR2 = 0x00000040;
+    FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
+    FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
+  }
+  /* FSMC_Bank3_NAND */  
+  else
+  {
+    /* Set the FSMC_Bank3 registers to their reset values */
+    FSMC_Bank3->PCR3 = 0x00000018;
+    FSMC_Bank3->SR3 = 0x00000040;
+    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
+    FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
+  }  
+}
+
+/**
+  * @brief  Initializes the FSMC NAND Banks according to the specified parameters
+  *         in the FSMC_NANDInitStruct.
+  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef structure that
+  *         contains the configuration information for the FSMC NAND specified Banks.                       
+  * @retval None
+  */
+void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
+{
+  uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
+    
+  /* Check the parameters */
+  assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
+  assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
+  assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
+  assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
+  assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
+  assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
+  assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
+  
+  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
+  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
+            PCR_MEMORYTYPE_NAND |
+            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
+            FSMC_NANDInitStruct->FSMC_ECC |
+            FSMC_NANDInitStruct->FSMC_ECCPageSize |
+            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
+            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
+            
+  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
+  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
+            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
+            
+  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
+  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
+            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
+  
+  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* FSMC_Bank2_NAND registers configuration */
+    FSMC_Bank2->PCR2 = tmppcr;
+    FSMC_Bank2->PMEM2 = tmppmem;
+    FSMC_Bank2->PATT2 = tmppatt;
+  }
+  else
+  {
+    /* FSMC_Bank3_NAND registers configuration */
+    FSMC_Bank3->PCR3 = tmppcr;
+    FSMC_Bank3->PMEM3 = tmppmem;
+    FSMC_Bank3->PATT3 = tmppatt;
+  }
+}
+
+
+/**
+  * @brief  Fills each FSMC_NANDInitStruct member with its default value.
+  * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef structure which
+  *         will be initialized.
+  * @retval None
+  */
+void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
+{ 
+  /* Reset NAND Init structure parameters values */
+  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
+  FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
+  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
+  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
+  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
+  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
+  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
+  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
+}
+
+/**
+  * @brief  Enables or disables the specified NAND Memory Bank.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
+    }
+    else
+    {
+      FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
+    }
+    else
+    {
+      FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
+    }
+  }
+}
+/**
+  * @brief  Enables or disables the FSMC NAND ECC feature.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @param  NewState: new state of the FSMC NAND ECC feature.  
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
+    }
+    else
+    {
+      FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
+    }
+    else
+    {
+      FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
+    }
+  }
+}
+
+/**
+  * @brief  Returns the error correction code register value.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @retval The Error Correction Code (ECC) value.
+  */
+uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
+{
+  uint32_t eccval = 0x00000000;
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* Get the ECCR2 register value */
+    eccval = FSMC_Bank2->ECCR2;
+  }
+  else
+  {
+    /* Get the ECCR3 register value */
+    eccval = FSMC_Bank3->ECCR3;
+  }
+  /* Return the error correction code value */
+  return(eccval);
+}
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Group3 PCCARD Controller functions
+ *  @brief   PCCARD Controller functions 
+ *
+@verbatim   
+ ===============================================================================
+                    ##### PCCARD Controller functions #####
+ ===============================================================================  
+
+ [..]  he following sequence should be followed to configure the FSMC to interface 
+       with 16-bit PC Card compatible memory connected to the PCCARD Bank:
+ 
+  (#)  Enable the clock for the FSMC and associated GPIOs using the following functions:
+       (++)  RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
+       (++)  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
+
+  (#) FSMC pins configuration 
+       (++) Connect the involved FSMC pins to AF12 using the following function 
+            GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FSMC); 
+       (++) Configure these FSMC pins in alternate function mode by calling the function
+            GPIO_Init();    
+       
+  (#) Declare a FSMC_PCCARDInitTypeDef structure, for example:
+      FSMC_PCCARDInitTypeDef  FSMC_PCCARDInitStructure;
+      and fill the FSMC_PCCARDInitStructure variable with the allowed values of
+      the structure member.
+      
+  (#) Initialize the PCCARD Controller by calling the function
+      FSMC_PCCARDInit(&FSMC_PCCARDInitStructure); 
+
+  (#) Then enable the PCCARD Bank:
+      FSMC_PCCARDCmd(ENABLE);  
+
+  (#) At this stage you can read/write from/to the memory connected to the PCCARD Bank. 
+ 
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  De-initializes the FSMC PCCARD Bank registers to their default reset values.
+  * @param  None                       
+  * @retval None
+  */
+void FSMC_PCCARDDeInit(void)
+{
+  /* Set the FSMC_Bank4 registers to their reset values */
+  FSMC_Bank4->PCR4 = 0x00000018; 
+  FSMC_Bank4->SR4 = 0x00000000;	
+  FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
+  FSMC_Bank4->PATT4 = 0xFCFCFCFC;
+  FSMC_Bank4->PIO4 = 0xFCFCFCFC;
+}
+
+/**
+  * @brief  Initializes the FSMC PCCARD Bank according to the specified parameters
+  *         in the FSMC_PCCARDInitStruct.
+  * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef structure
+  *         that contains the configuration information for the FSMC PCCARD Bank.                       
+  * @retval None
+  */
+void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
+  assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
+  assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
+ 
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
+  
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
+  
+  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
+  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
+                     FSMC_MemoryDataWidth_16b |  
+                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
+                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
+            
+  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
+  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
+                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
+            
+  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
+  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
+                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
+            
+  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
+  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
+                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
+}
+
+/**
+  * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
+  * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef structure
+  *         which will be initialized.
+  * @retval None
+  */
+void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
+{
+  /* Reset PCCARD Init structure parameters values */
+  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
+  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
+  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
+  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
+  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
+}
+
+/**
+  * @brief  Enables or disables the PCCARD Memory Bank.
+  * @param  NewState: new state of the PCCARD Memory Bank.  
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_PCCARDCmd(FunctionalState NewState)
+{
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
+    FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
+  }
+  else
+  {
+    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
+    FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Group4  Interrupts and flags management functions
+ *  @brief    Interrupts and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+             ##### Interrupts and flags management functions #####
+ ===============================================================================   
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified FSMC interrupts.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
+  *          This parameter can be any combination of the following values:
+  *            @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
+  *            @arg FSMC_IT_Level: Level edge detection interrupt.
+  *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
+  * @param  NewState: new state of the specified FSMC interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_IT(FSMC_IT));	
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected FSMC_Bank2 interrupts */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->SR2 |= FSMC_IT;
+    }
+    /* Enable the selected FSMC_Bank3 interrupts */
+    else if (FSMC_Bank == FSMC_Bank3_NAND)
+    {
+      FSMC_Bank3->SR3 |= FSMC_IT;
+    }
+    /* Enable the selected FSMC_Bank4 interrupts */
+    else
+    {
+      FSMC_Bank4->SR4 |= FSMC_IT;    
+    }
+  }
+  else
+  {
+    /* Disable the selected FSMC_Bank2 interrupts */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      
+      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
+    }
+    /* Disable the selected FSMC_Bank3 interrupts */
+    else if (FSMC_Bank == FSMC_Bank3_NAND)
+    {
+      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
+    }
+    /* Disable the selected FSMC_Bank4 interrupts */
+    else
+    {
+      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
+    }
+  }
+}
+
+/**
+  * @brief  Checks whether the specified FSMC flag is set or not.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_FLAG_RisingEdge: Rising edge detection Flag.
+  *            @arg FSMC_FLAG_Level: Level detection Flag.
+  *            @arg FSMC_FLAG_FallingEdge: Falling edge detection Flag.
+  *            @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
+  * @retval The new state of FSMC_FLAG (SET or RESET).
+  */
+FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t tmpsr = 0x00000000;
+  
+  /* Check the parameters */
+  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    tmpsr = FSMC_Bank2->SR2;
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    tmpsr = FSMC_Bank3->SR3;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    tmpsr = FSMC_Bank4->SR4;
+  } 
+  
+  /* Get the flag status */
+  if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the FSMC's pending flags.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_FLAG: specifies the flag to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg FSMC_FLAG_RisingEdge: Rising edge detection Flag.
+  *            @arg FSMC_FLAG_Level: Level detection Flag.
+  *            @arg FSMC_FLAG_FallingEdge: Falling edge detection Flag.
+  * @retval None
+  */
+void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
+{
+ /* Check the parameters */
+  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
+    
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    FSMC_Bank3->SR3 &= ~FSMC_FLAG;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    FSMC_Bank4->SR4 &= ~FSMC_FLAG;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified FSMC interrupt has occurred or not.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_IT: specifies the FSMC interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
+  *            @arg FSMC_IT_Level: Level edge detection interrupt.
+  *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
+  * @retval The new state of FSMC_IT (SET or RESET).
+  */
+ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
+  
+  /* Check the parameters */
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_GET_IT(FSMC_IT));
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    tmpsr = FSMC_Bank2->SR2;
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    tmpsr = FSMC_Bank3->SR3;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    tmpsr = FSMC_Bank4->SR4;
+  } 
+  
+  itstatus = tmpsr & FSMC_IT;
+  
+  itenable = tmpsr & (FSMC_IT >> 3);
+  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus; 
+}
+
+/**
+  * @brief  Clears the FSMC's interrupt pending bits.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *          This parameter can be one of the following values:
+  *            @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
+  *            @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *            @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_IT: specifies the interrupt pending bit to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
+  *            @arg FSMC_IT_Level: Level edge detection interrupt.
+  *            @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
+  * @retval None
+  */
+void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_IT(FSMC_IT));
+    
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
+  }
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_gpio.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_gpio.c
new file mode 100644
index 0000000..f448430
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_gpio.c
@@ -0,0 +1,612 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_gpio.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the GPIO peripheral:           
+  *           + Initialization and Configuration
+  *           + GPIO Read and Write
+  *           + GPIO Alternate functions configuration
+  * 
+@verbatim  
+ ===============================================================================
+                      ##### How to use this driver #####
+ ===============================================================================       
+ [..]             
+   (#) Enable the GPIO AHB clock using the following function
+       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
+               
+   (#) Configure the GPIO pin(s) using GPIO_Init()
+       Four possible configuration are available for each pin:
+       (++) Input: Floating, Pull-up, Pull-down.
+       (++) Output: Push-Pull (Pull-up, Pull-down or no Pull)
+            Open Drain (Pull-up, Pull-down or no Pull). In output mode, the speed 
+            is configurable: 2 MHz, 25 MHz, 50 MHz or 100 MHz.
+       (++) Alternate Function: Push-Pull (Pull-up, Pull-down or no Pull) Open 
+            Drain (Pull-up, Pull-down or no Pull).
+       (++) Analog: required mode when a pin is to be used as ADC channel or DAC 
+            output.
+   
+   (#) Peripherals alternate function:
+       (++) For ADC and DAC, configure the desired pin in analog mode using 
+            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AN;
+            (+++) For other peripherals (TIM, USART...):
+            (+++) Connect the pin to the desired peripherals' Alternate 
+                     Function (AF) using GPIO_PinAFConfig() function
+            (+++) Configure the desired pin in alternate function mode using
+                     GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
+            (+++) Select the type, pull-up/pull-down and output speed via 
+                     GPIO_PuPd, GPIO_OType and GPIO_Speed members
+            (+++) Call GPIO_Init() function
+          
+   (#) To get the level of a pin configured in input mode use GPIO_ReadInputDataBit()
+            
+   (#) To set/reset the level of a pin configured in output mode use 
+       GPIO_SetBits()/GPIO_ResetBits()
+                 
+   (#) During and just after reset, the alternate functions are not 
+       active and the GPIO pins are configured in input floating mode (except JTAG
+       pins).
+  
+   (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
+       (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
+       priority over the GPIO function.
+  
+   (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
+       general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
+       The HSE has priority over the GPIO function.
+               
+@endverbatim        
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_gpio.h"
+#include "stm32f4xx_rcc.h"
+#include "stm32f4xx_conf.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup GPIO 
+  * @brief GPIO driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup GPIO_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup GPIO_Group1 Initialization and Configuration
+ *  @brief   Initialization and Configuration
+ *
+@verbatim   
+ ===============================================================================
+                 ##### Initialization and Configuration #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
+  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices.  
+  * @retval None
+  */
+void GPIO_DeInit(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+
+  if (GPIOx == GPIOA)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
+  }
+  else if (GPIOx == GPIOB)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
+  }
+  else if (GPIOx == GPIOC)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
+  }
+  else if (GPIOx == GPIOD)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
+  }
+  else if (GPIOx == GPIOE)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
+  }
+  else if (GPIOx == GPIOF)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
+  }
+  else if (GPIOx == GPIOG)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
+  }
+  else if (GPIOx == GPIOH)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
+  }
+
+  else if (GPIOx == GPIOI)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
+  }
+  else if (GPIOx == GPIOJ)
+  {
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, ENABLE);
+    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, DISABLE);
+  }
+  else
+  {
+    if (GPIOx == GPIOK)
+    {
+      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
+      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_InitStruct.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices.   
+  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
+  *         the configuration information for the specified GPIO peripheral.
+  * @retval None
+  */
+void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
+{
+  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
+  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
+  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
+
+  /* ------------------------- Configure the port pins ---------------- */
+  /*-- GPIO Mode Configuration --*/
+  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
+  {
+    pos = ((uint32_t)0x01) << pinpos;
+    /* Get the port pins position */
+    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
+
+    if (currentpin == pos)
+    {
+      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
+      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
+
+      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
+      {
+        /* Check Speed mode parameters */
+        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
+
+        /* Speed mode configuration */
+        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
+        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
+
+        /* Check Output mode parameters */
+        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
+
+        /* Output mode configuration*/
+        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
+        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
+      }
+
+      /* Pull-up Pull down resistor configuration*/
+      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
+      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
+    }
+  }
+}
+
+/**
+  * @brief  Fills each GPIO_InitStruct member with its default value.
+  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
+{
+  /* Reset GPIO init structure parameters values */
+  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
+  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
+  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
+  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
+  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
+}
+
+/**
+  * @brief  Locks GPIO Pins configuration registers.
+  * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
+  *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
+  * @note   The configuration of the locked GPIO pins can no longer be modified
+  *         until the next reset.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @param  GPIO_Pin: specifies the port bit to be locked.
+  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
+  * @retval None
+  */
+void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  __IO uint32_t tmp = 0x00010000;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+
+  tmp |= GPIO_Pin;
+  /* Set LCKK bit */
+  GPIOx->LCKR = tmp;
+  /* Reset LCKK bit */
+  GPIOx->LCKR =  GPIO_Pin;
+  /* Set LCKK bit */
+  GPIOx->LCKR = tmp;
+  /* Read LCKK bit*/
+  tmp = GPIOx->LCKR;
+  /* Read LCKK bit*/
+  tmp = GPIOx->LCKR;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Group2 GPIO Read and Write
+ *  @brief   GPIO Read and Write
+ *
+@verbatim   
+ ===============================================================================
+                         ##### GPIO Read and Write #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Reads the specified input port pin.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @param  GPIO_Pin: specifies the port bit to read.
+  *         This parameter can be GPIO_Pin_x where x can be (0..15).
+  * @retval The input port pin value.
+  */
+uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  uint8_t bitstatus = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
+
+  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
+  {
+    bitstatus = (uint8_t)Bit_SET;
+  }
+  else
+  {
+    bitstatus = (uint8_t)Bit_RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Reads the specified GPIO input data port.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @retval GPIO input data port value.
+  */
+uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+
+  return ((uint16_t)GPIOx->IDR);
+}
+
+/**
+  * @brief  Reads the specified output data port bit.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @param  GPIO_Pin: specifies the port bit to read.
+  *          This parameter can be GPIO_Pin_x where x can be (0..15).
+  * @retval The output port pin value.
+  */
+uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  uint8_t bitstatus = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
+
+  if (((GPIOx->ODR) & GPIO_Pin) != (uint32_t)Bit_RESET)
+  {
+    bitstatus = (uint8_t)Bit_SET;
+  }
+  else
+  {
+    bitstatus = (uint8_t)Bit_RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Reads the specified GPIO output data port.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @retval GPIO output data port value.
+  */
+uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+
+  return ((uint16_t)GPIOx->ODR);
+}
+
+/**
+  * @brief  Sets the selected data port bits.
+  * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
+  *         accesses. In this way, there is no risk of an IRQ occurring between
+  *         the read and the modify access.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @param  GPIO_Pin: specifies the port bits to be written.
+  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
+  * @retval None
+  */
+void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+
+  GPIOx->BSRRL = GPIO_Pin;
+}
+
+/**
+  * @brief  Clears the selected data port bits.
+  * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
+  *         accesses. In this way, there is no risk of an IRQ occurring between
+  *         the read and the modify access.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @param  GPIO_Pin: specifies the port bits to be written.
+  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
+  * @retval None
+  */
+void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+
+  GPIOx->BSRRH = GPIO_Pin;
+}
+
+/**
+  * @brief  Sets or clears the selected data port bit.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @param  GPIO_Pin: specifies the port bit to be written.
+  *          This parameter can be one of GPIO_Pin_x where x can be (0..15).
+  * @param  BitVal: specifies the value to be written to the selected bit.
+  *          This parameter can be one of the BitAction enum values:
+  *            @arg Bit_RESET: to clear the port pin
+  *            @arg Bit_SET: to set the port pin
+  * @retval None
+  */
+void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
+  assert_param(IS_GPIO_BIT_ACTION(BitVal));
+
+  if (BitVal != Bit_RESET)
+  {
+    GPIOx->BSRRL = GPIO_Pin;
+  }
+  else
+  {
+    GPIOx->BSRRH = GPIO_Pin ;
+  }
+}
+
+/**
+  * @brief  Writes data to the specified GPIO data port.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @param  PortVal: specifies the value to be written to the port output data register.
+  * @retval None
+  */
+void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+
+  GPIOx->ODR = PortVal;
+}
+
+/**
+  * @brief  Toggles the specified GPIO pins..
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @param  GPIO_Pin: Specifies the pins to be toggled.
+  * @retval None
+  */
+void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+
+  GPIOx->ODR ^= GPIO_Pin;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Group3 GPIO Alternate functions configuration function
+ *  @brief   GPIO Alternate functions configuration function
+ *
+@verbatim   
+ ===============================================================================
+           ##### GPIO Alternate functions configuration function #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Changes the mapping of the specified pin.
+  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
+  *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
+  *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
+  * @param  GPIO_PinSource: specifies the pin for the Alternate function.
+  *         This parameter can be GPIO_PinSourcex where x can be (0..15).
+  * @param  GPIO_AFSelection: selects the pin to used as Alternate function.
+  *          This parameter can be one of the following values:
+  *            @arg GPIO_AF_RTC_50Hz: Connect RTC_50Hz pin to AF0 (default after reset) 
+  *            @arg GPIO_AF_MCO: Connect MCO pin (MCO1 and MCO2) to AF0 (default after reset) 
+  *            @arg GPIO_AF_TAMPER: Connect TAMPER pins (TAMPER_1 and TAMPER_2) to AF0 (default after reset) 
+  *            @arg GPIO_AF_SWJ: Connect SWJ pins (SWD and JTAG)to AF0 (default after reset) 
+  *            @arg GPIO_AF_TRACE: Connect TRACE pins to AF0 (default after reset)
+  *            @arg GPIO_AF_TIM1: Connect TIM1 pins to AF1
+  *            @arg GPIO_AF_TIM2: Connect TIM2 pins to AF1
+  *            @arg GPIO_AF_TIM3: Connect TIM3 pins to AF2
+  *            @arg GPIO_AF_TIM4: Connect TIM4 pins to AF2
+  *            @arg GPIO_AF_TIM5: Connect TIM5 pins to AF2
+  *            @arg GPIO_AF_TIM8: Connect TIM8 pins to AF3
+  *            @arg GPIO_AF_TIM9: Connect TIM9 pins to AF3
+  *            @arg GPIO_AF_TIM10: Connect TIM10 pins to AF3
+  *            @arg GPIO_AF_TIM11: Connect TIM11 pins to AF3
+  *            @arg GPIO_AF_I2C1: Connect I2C1 pins to AF4
+  *            @arg GPIO_AF_I2C2: Connect I2C2 pins to AF4
+  *            @arg GPIO_AF_I2C3: Connect I2C3 pins to AF4
+  *            @arg GPIO_AF_SPI1: Connect SPI1 pins to AF5
+  *            @arg GPIO_AF_SPI2: Connect SPI2/I2S2 pins to AF5
+  *            @arg GPIO_AF_SPI4: Connect SPI4 pins to AF5 
+  *            @arg GPIO_AF_SPI5: Connect SPI5 pins to AF5 
+  *            @arg GPIO_AF_SPI6: Connect SPI6 pins to AF5
+  *            @arg GPIO_AF_SAI1: Connect SAI1 pins to AF6 for STM32F42xxx/43xxx devices.       
+  *            @arg GPIO_AF_SPI3: Connect SPI3/I2S3 pins to AF6
+  *            @arg GPIO_AF_I2S3ext: Connect I2S3ext pins to AF7
+  *            @arg GPIO_AF_USART1: Connect USART1 pins to AF7
+  *            @arg GPIO_AF_USART2: Connect USART2 pins to AF7
+  *            @arg GPIO_AF_USART3: Connect USART3 pins to AF7
+  *            @arg GPIO_AF_UART4: Connect UART4 pins to AF8
+  *            @arg GPIO_AF_UART5: Connect UART5 pins to AF8
+  *            @arg GPIO_AF_USART6: Connect USART6 pins to AF8
+  *            @arg GPIO_AF_UART7: Connect UART7 pins to AF8
+  *            @arg GPIO_AF_UART8: Connect UART8 pins to AF8
+  *            @arg GPIO_AF_CAN1: Connect CAN1 pins to AF9
+  *            @arg GPIO_AF_CAN2: Connect CAN2 pins to AF9
+  *            @arg GPIO_AF_TIM12: Connect TIM12 pins to AF9
+  *            @arg GPIO_AF_TIM13: Connect TIM13 pins to AF9
+  *            @arg GPIO_AF_TIM14: Connect TIM14 pins to AF9
+  *            @arg GPIO_AF_OTG_FS: Connect OTG_FS pins to AF10
+  *            @arg GPIO_AF_OTG_HS: Connect OTG_HS pins to AF10
+  *            @arg GPIO_AF_ETH: Connect ETHERNET pins to AF11
+  *            @arg GPIO_AF_FSMC: Connect FSMC pins to AF12 
+  *            @arg GPIO_AF_FMC: Connect FMC pins to AF12 for STM32F42xxx/43xxx devices.   
+  *            @arg GPIO_AF_OTG_HS_FS: Connect OTG HS (configured in FS) pins to AF12
+  *            @arg GPIO_AF_SDIO: Connect SDIO pins to AF12
+  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
+  *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429xx/439xx devices. 
+  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
+  * @retval None
+  */
+void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
+{
+  uint32_t temp = 0x00;
+  uint32_t temp_2 = 0x00;
+  
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
+  assert_param(IS_GPIO_AF(GPIO_AF));
+  
+  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
+  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
+  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
+  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash.c
new file mode 100644
index 0000000..290e51f
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash.c
@@ -0,0 +1,726 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_hash.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the HASH / HMAC Processor (HASH) peripheral:           
+  *           - Initialization and Configuration functions
+  *           - Message Digest generation functions
+  *           - context swapping functions   
+  *           - DMA interface function       
+  *           - Interrupts and flags management       
+  *         
+@verbatim
+ ===================================================================      
+                 ##### How to use this driver #####
+ ===================================================================
+            
+ *** HASH operation : *** 
+ ========================                 
+ [..]
+   (#) Enable the HASH controller clock using 
+       RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_HASH, ENABLE) function.
+             
+   (#) Initialise the HASH using HASH_Init() function. 
+                 
+   (#) Reset the HASH processor core, so that the HASH will be ready 
+       to compute he message digest of a new message by using HASH_Reset() function.
+  
+   (#) Enable the HASH controller using the HASH_Cmd() function. 
+                  
+   (#) if using DMA for Data input transfer, Activate the DMA Request 
+       using HASH_DMACmd() function 
+                      
+   (#) if DMA is not used for data transfer, use HASH_DataIn() function 
+       to enter data to IN FIFO.
+               
+            
+   (#) Configure the Number of valid bits in last word of the message 
+       using HASH_SetLastWordValidBitsNbr() function.
+               
+   (#) if the message length is not an exact multiple of 512 bits, 
+       then the function HASH_StartDigest() must be called to launch the computation
+       of the final digest.     
+               
+   (#) Once computed, the digest can be read using HASH_GetDigest() function.         
+                     
+   (#) To control HASH events you can use one of the following wo methods:
+       (++) Check on HASH flags using the HASH_GetFlagStatus() function.  
+       (++) Use HASH interrupts through the function HASH_ITConfig() at 
+            initialization phase and HASH_GetITStatus() function into 
+            interrupt routines in hashing phase.
+            After checking on a flag you should clear it using HASH_ClearFlag()
+            function. And after checking on an interrupt event you should 
+            clear it using HASH_ClearITPendingBit() function.     
+                       
+   (#) Save and restore hash processor context using 
+       HASH_SaveContext() and HASH_RestoreContext() functions.     
+                
+  
+              
+ *** HMAC operation : *** 
+ ========================
+ [..] The HMAC algorithm is used for message authentication, by 
+      irreversibly binding the message being processed to a key chosen 
+      by the user. 
+      For HMAC specifications, refer to "HMAC: keyed-hashing for message 
+      authentication, H. Krawczyk, M. Bellare, R. Canetti, February 1997"
+            
+ [..] Basically, the HMAC algorithm consists of two nested hash operations:
+      HMAC(message) = Hash[((key | pad) XOR 0x5C) | Hash(((key | pad) XOR 0x36) | message)]
+      where:
+      (+) "pad" is a sequence of zeroes needed to extend the key to the 
+          length of the underlying hash function data block (that is 
+          512 bits for both the SHA-1 and MD5 hash algorithms)
+      (+) "|"   represents the concatenation operator 
+            
+           
+ [..]To compute the HMAC, four different phases are required:                  
+   (#) Initialise the HASH using HASH_Init() function to do HMAC 
+       operation. 
+                  
+   (#) The key (to be used for the inner hash function) is then given to the core. 
+       This operation follows the same mechanism as the one used to send the 
+       message in the hash operation (that is, by HASH_DataIn() function and, 
+       finally, HASH_StartDigest() function.
+            
+   (#) Once the last word has been entered and computation has started, 
+       the hash processor elaborates the key. It is then ready to accept the message
+       text using the same mechanism as the one used to send the message in the
+       hash operation.
+         
+   (#) After the first hash round, the hash processor returns "ready" to indicate 
+       that it is ready to receive the key to be used for the outer hash function 
+       (normally, this key is the same as the one used for the inner hash function). 
+       When the last word of the key is entered and computation starts, the HMAC 
+       result is made available using HASH_GetDigest() function.
+
+@endverbatim
+  *         
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_hash.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup HASH 
+  * @brief HASH driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/ 
+
+/** @defgroup HASH_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup HASH_Group1 Initialization and Configuration functions
+ *  @brief    Initialization and Configuration functions 
+ *
+@verbatim    
+ ===============================================================================
+              ##### Initialization and Configuration functions #####
+ ===============================================================================  
+ [..] This section provides functions allowing to 
+   (+) Initialize the HASH peripheral
+   (+) Configure the HASH Processor 
+   (+) MD5/SHA1, 
+   (+) HASH/HMAC, 
+   (+) datatype 
+   (+) HMAC Key (if mode = HMAC)
+   (+) Reset the HASH Processor 
+   
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  De-initializes the HASH peripheral registers to their default reset values
+  * @param  None
+  * @retval None
+  */
+void HASH_DeInit(void)
+{
+  /* Enable HASH reset state */
+  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
+  /* Release HASH from reset state */
+  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
+}
+
+/**
+  * @brief  Initializes the HASH peripheral according to the specified parameters
+  *         in the HASH_InitStruct structure.
+  * @note   the hash processor is reset when calling this function so that the
+  *         HASH will be ready to compute the message digest of a new message.
+  *         There is no need to call HASH_Reset() function.           
+  * @param  HASH_InitStruct: pointer to a HASH_InitTypeDef structure that contains
+  *         the configuration information for the HASH peripheral.
+  * @note   The field HASH_HMACKeyType in HASH_InitTypeDef must be filled only 
+  *          if the algorithm mode is HMAC.       
+  * @retval None
+  */
+void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
+  assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
+  assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
+  
+  /* Configure the Algorithm used, algorithm mode and the datatype */
+  HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
+  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
+               HASH_InitStruct->HASH_DataType | \
+               HASH_InitStruct->HASH_AlgoMode);
+  
+  /* if algorithm mode is HMAC, set the Key */  
+  if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
+  {
+    assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
+    HASH->CR &= ~HASH_CR_LKEY;
+    HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
+  }
+
+  /* Reset the HASH processor core, so that the HASH will be ready to compute 
+     the message digest of a new message */
+  HASH->CR |= HASH_CR_INIT;  
+}
+
+/**
+  * @brief  Fills each HASH_InitStruct member with its default value.
+  * @param  HASH_InitStruct : pointer to a HASH_InitTypeDef structure which will
+  *          be initialized.  
+  *  @note  The default values set are : Processor mode is HASH, Algorithm selected is SHA1,
+  *          Data type selected is 32b and HMAC Key Type is short key.  
+  * @retval None
+  */
+void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
+{
+  /* Initialize the HASH_AlgoSelection member */
+  HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
+
+  /* Initialize the HASH_AlgoMode member */
+  HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
+
+  /* Initialize the HASH_DataType member */
+  HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
+
+  /* Initialize the HASH_HMACKeyType member */
+  HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
+}
+
+/**
+  * @brief  Resets the HASH processor core, so that the HASH will be ready
+  *         to compute the message digest of a new message.
+  * @note   Calling this function will clear the HASH_SR_DCIS (Digest calculation 
+  *         completion interrupt status) bit corresponding to HASH_IT_DCI 
+  *         interrupt and HASH_FLAG_DCIS flag. 
+  * @param  None
+  * @retval None
+  */
+void HASH_Reset(void)
+{
+  /* Reset the HASH processor core */
+  HASH->CR |= HASH_CR_INIT;
+}
+/**
+  * @}
+  */
+ 
+/** @defgroup HASH_Group2 Message Digest generation functions
+ *  @brief    Message Digest generation functions
+ *
+@verbatim    
+ ===============================================================================
+                  ##### Message Digest generation functions #####
+ ===============================================================================  
+ [..] This section provides functions allowing the generation of message digest: 
+   (+) Push data in the IN FIFO : using HASH_DataIn()
+   (+) Get the number of words set in IN FIFO, use HASH_GetInFIFOWordsNbr()  
+   (+) set the last word valid bits number using HASH_SetLastWordValidBitsNbr() 
+   (+) start digest calculation : using HASH_StartDigest()
+   (+) Get the Digest message : using HASH_GetDigest()
+ 
+@endverbatim
+  * @{
+  */
+
+
+/**
+  * @brief  Configure the Number of valid bits in last word of the message
+  * @param  ValidNumber: Number of valid bits in last word of the message.
+  *           This parameter must be a number between 0 and 0x1F.
+  *             - 0x00: All 32 bits of the last data written are valid
+  *             - 0x01: Only bit [0] of the last data written is valid
+  *             - 0x02: Only bits[1:0] of the last data written are valid
+  *             - 0x03: Only bits[2:0] of the last data written are valid
+  *             - ...
+  *             - 0x1F: Only bits[30:0] of the last data written are valid    
+  * @note   The Number of valid bits must be set before to start the message 
+  *         digest competition (in Hash and HMAC) and key treatment(in HMAC).    
+  * @retval None
+  */
+void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
+{
+  /* Check the parameters */
+  assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
+  
+  /* Configure the Number of valid bits in last word of the message */
+  HASH->STR &= ~(HASH_STR_NBW);
+  HASH->STR |= ValidNumber;
+}
+
+/**
+  * @brief  Writes data in the Data Input FIFO
+  * @param  Data: new data of the message to be processed.
+  * @retval None
+  */
+void HASH_DataIn(uint32_t Data)
+{
+  /* Write in the DIN register a new data */
+  HASH->DIN = Data;
+}
+
+/**
+  * @brief  Returns the number of words already pushed into the IN FIFO.
+  * @param  None
+  * @retval The value of words already pushed into the IN FIFO.
+  */
+uint8_t HASH_GetInFIFOWordsNbr(void)
+{
+  /* Return the value of NBW bits */
+  return ((HASH->CR & HASH_CR_NBW) >> 8);
+}
+
+/**
+  * @brief  Provides the message digest result.
+  * @note   In MD5 mode, Data[7] to Data[4] filed of HASH_MsgDigest structure is not used
+  *         and is read as zero.
+  *         In SHA-1 mode, Data[7] to Data[5] filed of HASH_MsgDigest structure is not used
+  *         and is read as zero.    
+  *         In SHA-224 mode, Data[7] filed of HASH_MsgDigest structure is not used
+  *         and is read as zero.  
+  * @param  HASH_MessageDigest: pointer to a HASH_MsgDigest structure which will 
+  *         hold the message digest result 
+  * @retval None
+  */
+void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
+{
+  /* Get the data field */
+  HASH_MessageDigest->Data[0] = HASH->HR[0];
+  HASH_MessageDigest->Data[1] = HASH->HR[1];
+  HASH_MessageDigest->Data[2] = HASH->HR[2];
+  HASH_MessageDigest->Data[3] = HASH->HR[3];
+  HASH_MessageDigest->Data[4] = HASH->HR[4];
+  HASH_MessageDigest->Data[5] = HASH_DIGEST->HR[5];
+  HASH_MessageDigest->Data[6] = HASH_DIGEST->HR[6];
+  HASH_MessageDigest->Data[7] = HASH_DIGEST->HR[7];
+}
+
+/**
+  * @brief  Starts the message padding and calculation of the final message     
+  * @param  None
+  * @retval None
+  */
+void HASH_StartDigest(void)
+{
+  /* Start the Digest calculation */
+  HASH->STR |= HASH_STR_DCAL;
+}
+/**
+  * @}
+  */
+
+/** @defgroup HASH_Group3 Context swapping functions
+ *  @brief   Context swapping functions
+ *
+@verbatim   
+ ===============================================================================
+                      ##### Context swapping functions #####
+ ===============================================================================  
+ 
+ [..] This section provides functions allowing to save and store HASH Context
+  
+ [..] It is possible to interrupt a HASH/HMAC process to perform another processing 
+      with a higher priority, and to complete the interrupted process later on, when 
+      the higher priority task is complete. To do so, the context of the interrupted 
+      task must be saved from the HASH registers to memory, and then be restored 
+      from memory to the HASH registers.
+  
+   (#) To save the current context, use HASH_SaveContext() function
+   (#) To restore the saved context, use HASH_RestoreContext() function 
+  
+
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Save the Hash peripheral Context. 
+  * @note   The context can be saved only when no block is currently being 
+  *         processed. So user must wait for DINIS = 1 (the last block has been 
+  *         processed and the input FIFO is empty) or NBW != 0 (the FIFO is not 
+  *         full and no processing is ongoing).   
+  * @param  HASH_ContextSave: pointer to a HASH_Context structure that contains
+  *         the repository for current context.
+  * @retval None
+  */
+void HASH_SaveContext(HASH_Context* HASH_ContextSave)
+{
+  uint8_t i = 0;
+  
+  /* save context registers */
+  HASH_ContextSave->HASH_IMR = HASH->IMR;  
+  HASH_ContextSave->HASH_STR = HASH->STR;      
+  HASH_ContextSave->HASH_CR  = HASH->CR;     
+  for(i=0; i<=53;i++)
+  {
+     HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
+  }   
+}
+
+/**
+  * @brief  Restore the Hash peripheral Context.  
+  * @note   After calling this function, user can restart the processing from the
+  *         point where it has been interrupted.  
+  * @param  HASH_ContextRestore: pointer to a HASH_Context structure that contains
+  *         the repository for saved context.
+  * @retval None
+  */
+void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
+{
+  uint8_t i = 0;
+  
+  /* restore context registers */
+  HASH->IMR = HASH_ContextRestore->HASH_IMR;   
+  HASH->STR = HASH_ContextRestore->HASH_STR;     
+  HASH->CR = HASH_ContextRestore->HASH_CR;
+  
+  /* Initialize the hash processor */
+  HASH->CR |= HASH_CR_INIT; 
+  
+   /* continue restoring context registers */     
+  for(i=0; i<=53;i++)
+  {
+     HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
+  }   
+}
+/**
+  * @}
+  */
+
+/** @defgroup HASH_Group4 HASH's DMA interface Configuration function
+ *  @brief   HASH's DMA interface Configuration function 
+ *
+@verbatim   
+ ===============================================================================
+               ##### HASH's DMA interface Configuration function #####
+ ===============================================================================  
+
+ [..] This section provides functions allowing to configure the DMA interface for 
+      HASH/ HMAC data input transfer.
+   
+ [..] When the DMA mode is enabled (using the HASH_DMACmd() function), data can be 
+      sent to the IN FIFO using the DMA peripheral.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables auto-start message padding and
+  *         calculation of the final message digest at the end of DMA transfer.
+  * @param  NewState: new state of the selected HASH DMA transfer request.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void HASH_AutoStartDigest(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the auto start of the final message digest at the end of DMA transfer */
+    HASH->CR &= ~HASH_CR_MDMAT;
+  }
+  else
+  {
+    /* Disable the auto start of the final message digest at the end of DMA transfer */
+    HASH->CR |= HASH_CR_MDMAT;
+  }
+}
+  
+/**
+  * @brief  Enables or disables the HASH DMA interface.
+  * @note   The DMA is disabled by hardware after the end of transfer.
+  * @param  NewState: new state of the selected HASH DMA transfer request.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void HASH_DMACmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the HASH DMA request */
+    HASH->CR |= HASH_CR_DMAE;
+  }
+  else
+  {
+    /* Disable the HASH DMA request */
+    HASH->CR &= ~HASH_CR_DMAE;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup HASH_Group5 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+               ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+ [..] This section provides functions allowing to configure the HASH Interrupts and 
+      to get the status and clear flags and Interrupts pending bits.
+  
+ [..] The HASH provides 2 Interrupts sources and 5 Flags:
+  
+ *** Flags : ***
+ =============== 
+ [..]
+   (#) HASH_FLAG_DINIS : set when 16 locations are free in the Data IN FIFO 
+      which means that a  new block (512 bit) can be entered into the input buffer.
+                          
+   (#) HASH_FLAG_DCIS :  set when Digest calculation is complete
+      
+   (#) HASH_FLAG_DMAS :  set when HASH's DMA interface is enabled (DMAE=1) or 
+       a transfer is ongoing. This Flag is cleared only by hardware.
+                           
+   (#) HASH_FLAG_BUSY :  set when The hash core is processing a block of data
+       This Flag is cleared only by hardware. 
+                           
+   (#) HASH_FLAG_DINNE : set when Data IN FIFO is not empty which means that 
+       the Data IN FIFO contains at least one word of data. This Flag is cleared 
+       only by hardware.
+     
+ *** Interrupts : ***
+ ====================
+ [..]   
+   (#) HASH_IT_DINI  : if enabled, this interrupt source is pending when 16 
+       locations are free in the Data IN FIFO  which means that a new block (512 bit)
+       can be entered into the input buffer. This interrupt source is cleared using 
+       HASH_ClearITPendingBit(HASH_IT_DINI) function.
+   
+   (#) HASH_IT_DCI   : if enabled, this interrupt source is pending when Digest 
+       calculation is complete. This interrupt source is cleared using 
+       HASH_ClearITPendingBit(HASH_IT_DCI) function.
+
+ *** Managing the HASH controller events : ***
+ =============================================
+ [..] The user should identify which mode will be used in his application to manage 
+      the HASH controller events: Polling mode or Interrupt mode.
+  
+   (#) In the Polling Mode it is advised to use the following functions:
+       (++) HASH_GetFlagStatus() : to check if flags events occur. 
+       (++) HASH_ClearFlag()     : to clear the flags events.
+    
+   (#)  In the Interrupt Mode it is advised to use the following functions:
+       (++) HASH_ITConfig()       : to enable or disable the interrupt source.
+       (++) HASH_GetITStatus()    : to check if Interrupt occurs.
+       (++) HASH_ClearITPendingBit() : to clear the Interrupt pending Bit 
+            (corresponding Flag). 
+
+@endverbatim
+  * @{
+  */ 
+  
+/**
+  * @brief  Enables or disables the specified HASH interrupts.
+  * @param  HASH_IT: specifies the HASH interrupt source to be enabled or disabled.
+  *          This parameter can be any combination of the following values:
+  *            @arg HASH_IT_DINI: Data Input interrupt
+  *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
+  * @param  NewState: new state of the specified HASH interrupt.
+  *           This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void HASH_ITConfig(uint32_t HASH_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_HASH_IT(HASH_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected HASH interrupt */
+    HASH->IMR |= HASH_IT;
+  }
+  else
+  {
+    /* Disable the selected HASH interrupt */
+    HASH->IMR &= (uint32_t)(~HASH_IT);
+  }
+}
+
+/**
+  * @brief  Checks whether the specified HASH flag is set or not.
+  * @param  HASH_FLAG: specifies the HASH flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg HASH_FLAG_DINIS: Data input interrupt status flag
+  *            @arg HASH_FLAG_DCIS: Digest calculation completion interrupt status flag
+  *            @arg HASH_FLAG_BUSY: Busy flag
+  *            @arg HASH_FLAG_DMAS: DMAS Status flag
+  *            @arg HASH_FLAG_DINNE: Data Input register (DIN) not empty status flag
+  * @retval The new state of HASH_FLAG (SET or RESET)
+  */
+FlagStatus HASH_GetFlagStatus(uint32_t HASH_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t tempreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
+
+  /* check if the FLAG is in CR register */
+  if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint32_t)RESET ) 
+  {
+    tempreg = HASH->CR;
+  }
+  else /* The FLAG is in SR register */
+  {
+    tempreg = HASH->SR;
+  }
+
+  /* Check the status of the specified HASH flag */
+  if ((tempreg & HASH_FLAG) != (uint32_t)RESET)
+  {
+    /* HASH is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* HASH_FLAG is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the HASH_FLAG status */
+  return  bitstatus;
+}
+/**
+  * @brief  Clears the HASH flags.
+  * @param  HASH_FLAG: specifies the flag to clear. 
+  *          This parameter can be any combination of the following values:
+  *            @arg HASH_FLAG_DINIS: Data Input Flag
+  *            @arg HASH_FLAG_DCIS: Digest Calculation Completion Flag                       
+  * @retval None
+  */
+void HASH_ClearFlag(uint32_t HASH_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
+  
+  /* Clear the selected HASH flags */
+  HASH->SR = ~(uint32_t)HASH_FLAG;
+}
+/**
+  * @brief  Checks whether the specified HASH interrupt has occurred or not.
+  * @param  HASH_IT: specifies the HASH interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg HASH_IT_DINI: Data Input interrupt
+  *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
+  * @retval The new state of HASH_IT (SET or RESET).
+  */
+ITStatus HASH_GetITStatus(uint32_t HASH_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_HASH_GET_IT(HASH_IT));  
+
+
+  /* Check the status of the specified HASH interrupt */
+  tmpreg =  HASH->SR;
+
+  if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
+  {
+    /* HASH_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* HASH_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the HASH_IT status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the HASH interrupt pending bit(s).
+  * @param  HASH_IT: specifies the HASH interrupt pending bit(s) to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg HASH_IT_DINI: Data Input interrupt
+  *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
+  * @retval None
+  */
+void HASH_ClearITPendingBit(uint32_t HASH_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_HASH_IT(HASH_IT));
+
+  /* Clear the selected HASH interrupt pending bit */
+  HASH->SR = (uint32_t)(~HASH_IT);
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_md5.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_md5.c
new file mode 100644
index 0000000..6469116
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_md5.c
@@ -0,0 +1,320 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_hash_md5.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides high level functions to compute the HASH MD5 and
+  *          HMAC MD5 Digest of an input message.
+  *          It uses the stm32f4xx_hash.c/.h drivers to access the STM32F4xx HASH
+  *          peripheral.
+  *
+@verbatim
+ ===================================================================
+                  ##### How to use this driver #####
+ ===================================================================
+ [..]
+   (#) Enable The HASH controller clock using 
+       RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_HASH, ENABLE); function.
+  
+   (#) Calculate the HASH MD5 Digest using HASH_MD5() function.
+  
+   (#) Calculate the HMAC MD5 Digest using HMAC_MD5() function.
+  
+@endverbatim
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_hash.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup HASH 
+  * @brief HASH driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define MD5BUSY_TIMEOUT    ((uint32_t) 0x00010000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup HASH_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup HASH_Group7 High Level MD5 functions
+ *  @brief   High Level MD5 Hash and HMAC functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### High Level MD5 Hash and HMAC functions #####
+ ===============================================================================
+
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Compute the HASH MD5 digest.
+  * @param  Input: pointer to the Input buffer to be treated.
+  * @param  Ilen: length of the Input buffer.
+  * @param  Output: the returned digest
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: digest computation done
+  *          - ERROR: digest computation failed
+  */
+ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16])
+{
+  HASH_InitTypeDef MD5_HASH_InitStructure;
+  HASH_MsgDigest MD5_MessageDigest;
+  __IO uint16_t nbvalidbitsdata = 0;
+  uint32_t i = 0;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+
+
+  /* Number of valid bits in last word of the Input data */
+  nbvalidbitsdata = 8 * (Ilen % 4);
+
+  /* HASH peripheral initialization */
+  HASH_DeInit();
+
+  /* HASH Configuration */
+  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
+  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
+  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
+  HASH_Init(&MD5_HASH_InitStructure);
+
+  /* Configure the number of valid bits in last word of the data */
+  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
+
+  /* Write the Input block in the IN FIFO */
+  for(i=0; i<Ilen; i+=4)
+  {
+    HASH_DataIn(*(uint32_t*)inputaddr);
+    inputaddr+=4;
+  }
+
+  /* Start the HASH processor */
+  HASH_StartDigest();
+
+  /* wait until the Busy flag is RESET */
+  do
+  {
+    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
+    counter++;
+  }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
+
+  if (busystatus != RESET)
+  {
+     status = ERROR;
+  }
+  else
+  {
+    /* Read the message digest */
+    HASH_GetDigest(&MD5_MessageDigest);
+    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
+    outputaddr+=4;
+    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
+    outputaddr+=4;
+    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
+    outputaddr+=4;
+    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
+  }
+  return status; 
+}
+
+/**
+  * @brief  Compute the HMAC MD5 digest.
+  * @param  Key: pointer to the Key used for HMAC.
+  * @param  Keylen: length of the Key used for HMAC.
+  * @param  Input: pointer to the Input buffer to be treated.
+  * @param  Ilen: length of the Input buffer.
+  * @param  Output: the returned digest  
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: digest computation done
+  *          - ERROR: digest computation failed
+  */
+ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen, uint8_t *Input, 
+                     uint32_t Ilen, uint8_t Output[16])
+{
+  HASH_InitTypeDef MD5_HASH_InitStructure;
+  HASH_MsgDigest MD5_MessageDigest;
+  __IO uint16_t nbvalidbitsdata = 0;
+  __IO uint16_t nbvalidbitskey = 0;
+  uint32_t i = 0;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+
+  /* Number of valid bits in last word of the Input data */
+  nbvalidbitsdata = 8 * (Ilen % 4);
+
+  /* Number of valid bits in last word of the Key */
+  nbvalidbitskey = 8 * (Keylen % 4);
+   
+  /* HASH peripheral initialization */
+  HASH_DeInit();
+
+  /* HASH Configuration */
+  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
+  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
+  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
+  if(Keylen > 64)
+  {
+    /* HMAC long Key */
+    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
+  }
+  else
+  {
+    /* HMAC short Key */
+    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
+  }
+  HASH_Init(&MD5_HASH_InitStructure);
+
+  /* Configure the number of valid bits in last word of the Key */
+  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
+
+  /* Write the Key */
+  for(i=0; i<Keylen; i+=4)
+  {
+    HASH_DataIn(*(uint32_t*)keyaddr);
+    keyaddr+=4;
+  }
+  
+  /* Start the HASH processor */
+  HASH_StartDigest();
+
+  /* wait until the Busy flag is RESET */
+  do
+  {
+    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
+    counter++;
+  }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
+
+  if (busystatus != RESET)
+  {
+     status = ERROR;
+  }
+  else
+  {
+    /* Configure the number of valid bits in last word of the Input data */
+    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
+
+    /* Write the Input block in the IN FIFO */
+    for(i=0; i<Ilen; i+=4)
+    {
+      HASH_DataIn(*(uint32_t*)inputaddr);
+      inputaddr+=4;
+    }
+
+    /* Start the HASH processor */
+    HASH_StartDigest();
+
+    /* wait until the Busy flag is RESET */
+    counter =0;
+    do
+    {
+       busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
+       counter++;
+    }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+    {
+      status = ERROR;
+    }
+    else
+    {  
+      /* Configure the number of valid bits in last word of the Key */
+      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
+
+      /* Write the Key */
+      keyaddr = (uint32_t)Key;
+      for(i=0; i<Keylen; i+=4)
+      {
+        HASH_DataIn(*(uint32_t*)keyaddr);
+        keyaddr+=4;
+      }
+  
+       /* Start the HASH processor */
+       HASH_StartDigest();
+
+       /* wait until the Busy flag is RESET */
+       counter =0;
+       do
+       {
+          busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
+          counter++;
+      }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
+
+      if (busystatus != RESET)
+      {
+         status = ERROR;
+      }
+      else
+      {
+         /* Read the message digest */
+         HASH_GetDigest(&MD5_MessageDigest);
+         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
+         outputaddr+=4;
+         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
+         outputaddr+=4;
+         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
+         outputaddr+=4;
+         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
+      }
+    }
+  }
+  return status;  
+}
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_sha1.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_sha1.c
new file mode 100644
index 0000000..0a78998
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_sha1.c
@@ -0,0 +1,323 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_hash_sha1.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides high level functions to compute the HASH SHA1 and
+  *          HMAC SHA1 Digest of an input message.
+  *          It uses the stm32f4xx_hash.c/.h drivers to access the STM32F4xx HASH
+  *          peripheral.
+  *
+@verbatim
+ ===================================================================
+                 ##### How to use this driver #####
+ ===================================================================
+ [..]
+   (#) Enable The HASH controller clock using 
+       RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_HASH, ENABLE); function.
+  
+   (#) Calculate the HASH SHA1 Digest using HASH_SHA1() function.
+  
+   (#) Calculate the HMAC SHA1 Digest using HMAC_SHA1() function.
+  
+@endverbatim
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_hash.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup HASH 
+  * @brief HASH driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define SHA1BUSY_TIMEOUT    ((uint32_t) 0x00010000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup HASH_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup HASH_Group6 High Level SHA1 functions
+ *  @brief   High Level SHA1 Hash and HMAC functions 
+ *
+@verbatim   
+ ===============================================================================
+               ##### High Level SHA1 Hash and HMAC functions #####
+ ===============================================================================
+
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Compute the HASH SHA1 digest.
+  * @param  Input: pointer to the Input buffer to be treated.
+  * @param  Ilen: length of the Input buffer.
+  * @param  Output: the returned digest
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: digest computation done
+  *          - ERROR: digest computation failed
+  */
+ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
+{
+  HASH_InitTypeDef SHA1_HASH_InitStructure;
+  HASH_MsgDigest SHA1_MessageDigest;
+  __IO uint16_t nbvalidbitsdata = 0;
+  uint32_t i = 0;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+
+  /* Number of valid bits in last word of the Input data */
+  nbvalidbitsdata = 8 * (Ilen % 4);
+
+  /* HASH peripheral initialization */
+  HASH_DeInit();
+
+  /* HASH Configuration */
+  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
+  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
+  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
+  HASH_Init(&SHA1_HASH_InitStructure);
+
+  /* Configure the number of valid bits in last word of the data */
+  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
+
+  /* Write the Input block in the IN FIFO */
+  for(i=0; i<Ilen; i+=4)
+  {
+    HASH_DataIn(*(uint32_t*)inputaddr);
+    inputaddr+=4;
+  }
+
+  /* Start the HASH processor */
+  HASH_StartDigest();
+
+  /* wait until the Busy flag is RESET */
+  do
+  {
+    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
+    counter++;
+  }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
+
+  if (busystatus != RESET)
+  {
+     status = ERROR;
+  }
+  else
+  {
+    /* Read the message digest */
+    HASH_GetDigest(&SHA1_MessageDigest);
+    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
+    outputaddr+=4;
+    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
+    outputaddr+=4;
+    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
+    outputaddr+=4;
+    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
+    outputaddr+=4;
+    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
+  }
+  return status;
+}
+
+/**
+  * @brief  Compute the HMAC SHA1 digest.
+  * @param  Key: pointer to the Key used for HMAC.
+  * @param  Keylen: length of the Key used for HMAC.  
+  * @param  Input: pointer to the Input buffer to be treated.
+  * @param  Ilen: length of the Input buffer.
+  * @param  Output: the returned digest
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: digest computation done
+  *          - ERROR: digest computation failed
+  */
+ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
+                      uint32_t Ilen, uint8_t Output[20])
+{
+  HASH_InitTypeDef SHA1_HASH_InitStructure;
+  HASH_MsgDigest SHA1_MessageDigest;
+  __IO uint16_t nbvalidbitsdata = 0;
+  __IO uint16_t nbvalidbitskey = 0;
+  uint32_t i = 0;
+  __IO uint32_t counter = 0;
+  uint32_t busystatus = 0;
+  ErrorStatus status = SUCCESS;
+  uint32_t keyaddr    = (uint32_t)Key;
+  uint32_t inputaddr  = (uint32_t)Input;
+  uint32_t outputaddr = (uint32_t)Output;
+
+  /* Number of valid bits in last word of the Input data */
+  nbvalidbitsdata = 8 * (Ilen % 4);
+
+  /* Number of valid bits in last word of the Key */
+  nbvalidbitskey = 8 * (Keylen % 4);
+
+  /* HASH peripheral initialization */
+  HASH_DeInit();
+
+  /* HASH Configuration */
+  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
+  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
+  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
+  if(Keylen > 64)
+  {
+    /* HMAC long Key */
+    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
+  }
+  else
+  {
+    /* HMAC short Key */
+    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
+  }
+  HASH_Init(&SHA1_HASH_InitStructure);
+
+  /* Configure the number of valid bits in last word of the Key */
+  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
+
+  /* Write the Key */
+  for(i=0; i<Keylen; i+=4)
+  {
+    HASH_DataIn(*(uint32_t*)keyaddr);
+    keyaddr+=4;
+  }
+
+  /* Start the HASH processor */
+  HASH_StartDigest();
+
+  /* wait until the Busy flag is RESET */
+  do
+  {
+    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
+    counter++;
+  }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
+
+  if (busystatus != RESET)
+  {
+     status = ERROR;
+  }
+  else
+  {
+    /* Configure the number of valid bits in last word of the Input data */
+    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
+
+    /* Write the Input block in the IN FIFO */
+    for(i=0; i<Ilen; i+=4)
+    {
+      HASH_DataIn(*(uint32_t*)inputaddr);
+      inputaddr+=4;
+    }
+
+    /* Start the HASH processor */
+    HASH_StartDigest();
+
+
+    /* wait until the Busy flag is RESET */
+    counter =0;
+    do
+    {
+      busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
+      counter++;
+    }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
+
+    if (busystatus != RESET)
+    {
+      status = ERROR;
+    }
+    else
+    {  
+      /* Configure the number of valid bits in last word of the Key */
+      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
+
+      /* Write the Key */
+      keyaddr = (uint32_t)Key;
+      for(i=0; i<Keylen; i+=4)
+      {
+        HASH_DataIn(*(uint32_t*)keyaddr);
+        keyaddr+=4;
+      }
+
+      /* Start the HASH processor */
+      HASH_StartDigest();
+
+      /* wait until the Busy flag is RESET */
+      counter =0;
+      do
+      {
+        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
+        counter++;
+      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
+
+      if (busystatus != RESET)
+      {
+        status = ERROR;
+      }
+      else
+      {
+        /* Read the message digest */
+        HASH_GetDigest(&SHA1_MessageDigest);
+        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
+        outputaddr+=4;
+        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
+        outputaddr+=4;
+        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
+        outputaddr+=4;
+        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
+        outputaddr+=4;
+        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
+      }
+    }  
+  }
+  return status;  
+}
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_i2c.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_i2c.c
new file mode 100644
index 0000000..4bf6008
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_i2c.c
@@ -0,0 +1,1462 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_i2c.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Inter-integrated circuit (I2C)
+  *           + Initialization and Configuration
+  *           + Data transfers
+  *           + PEC management
+  *           + DMA transfers management
+  *           + Interrupts, events and flags management 
+  *           
+    @verbatim    
+ ===============================================================================
+                    ##### How to use this driver #####
+ ===============================================================================
+    [..]
+      (#) Enable peripheral clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2Cx, ENABLE)
+          function for I2C1, I2C2 or I2C3.
+  
+      (#) Enable SDA, SCL  and SMBA (when used) GPIO clocks using 
+          RCC_AHBPeriphClockCmd() function. 
+  
+      (#) Peripherals alternate function: 
+        (++) Connect the pin to the desired peripherals' Alternate 
+             Function (AF) using GPIO_PinAFConfig() function
+        (++) Configure the desired pin in alternate function by:
+             GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
+        (++) Select the type, pull-up/pull-down and output speed via 
+             GPIO_PuPd, GPIO_OType and GPIO_Speed members
+        (++) Call GPIO_Init() function
+             Recommended configuration is Push-Pull, Pull-up, Open-Drain.
+             Add an external pull up if necessary (typically 4.7 KOhm).      
+          
+      (#) Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged
+          Address using the I2C_Init() function.
+  
+      (#) Optionally you can enable/configure the following parameters without
+          re-initialization (i.e there is no need to call again I2C_Init() function):
+        (++) Enable the acknowledge feature using I2C_AcknowledgeConfig() function
+        (++) Enable the dual addressing mode using I2C_DualAddressCmd() function
+        (++) Enable the general call using the I2C_GeneralCallCmd() function
+        (++) Enable the clock stretching using I2C_StretchClockCmd() function
+        (++) Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
+             function.
+        (++) Configure the NACK position for Master Receiver mode in case of 
+             2 bytes reception using the function I2C_NACKPositionConfig().  
+        (++) Enable the PEC Calculation using I2C_CalculatePEC() function
+        (++) For SMBus Mode: 
+          (+++) Enable the Address Resolution Protocol (ARP) using I2C_ARPCmd() function
+          (+++) Configure the SMBusAlert pin using I2C_SMBusAlertConfig() function
+  
+      (#) Enable the NVIC and the corresponding interrupt using the function 
+          I2C_ITConfig() if you need to use interrupt mode. 
+  
+      (#) When using the DMA mode 
+        (++) Configure the DMA using DMA_Init() function
+        (++) Active the needed channel Request using I2C_DMACmd() or
+             I2C_DMALastTransferCmd() function.
+        -@@- When using DMA mode, I2C interrupts may be used at the same time to
+             control the communication flow (Start/Stop/Ack... events and errors).
+   
+      (#) Enable the I2C using the I2C_Cmd() function.
+   
+      (#) Enable the DMA using the DMA_Cmd() function when using DMA mode in the 
+          transfers. 
+  
+    @endverbatim  
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_i2c.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup I2C 
+  * @brief I2C driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+#define CR1_CLEAR_MASK    ((uint16_t)0xFBF5)      /*<! I2C registers Masks */
+#define FLAG_MASK         ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */
+#define ITEN_MASK         ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup I2C_Private_Functions
+  * @{
+  */
+
+/** @defgroup I2C_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+            ##### Initialization and Configuration functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @retval None
+  */
+void I2C_DeInit(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  if (I2Cx == I2C1)
+  {
+    /* Enable I2C1 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
+    /* Release I2C1 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
+  }
+  else if (I2Cx == I2C2)
+  {
+    /* Enable I2C2 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
+    /* Release I2C2 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
+  }
+  else 
+  {
+    if (I2Cx == I2C3)
+    {
+      /* Enable I2C3 reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
+      /* Release I2C3 from reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the I2Cx peripheral according to the specified 
+  *         parameters in the I2C_InitStruct.
+  *           
+  * @note   To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency 
+  *         (I2C peripheral input clock) must be a multiple of 10 MHz.  
+  *           
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
+  *         the configuration information for the specified I2C peripheral.
+  * @retval None
+  */
+void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
+{
+  uint16_t tmpreg = 0, freqrange = 0;
+  uint16_t result = 0x04;
+  uint32_t pclk1 = 8000000;
+  RCC_ClocksTypeDef  rcc_clocks;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
+  assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
+  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
+  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
+  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
+  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
+
+/*---------------------------- I2Cx CR2 Configuration ------------------------*/
+  /* Get the I2Cx CR2 value */
+  tmpreg = I2Cx->CR2;
+  /* Clear frequency FREQ[5:0] bits */
+  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
+  /* Get pclk1 frequency value */
+  RCC_GetClocksFreq(&rcc_clocks);
+  pclk1 = rcc_clocks.PCLK1_Frequency;
+  /* Set frequency bits depending on pclk1 value */
+  freqrange = (uint16_t)(pclk1 / 1000000);
+  tmpreg |= freqrange;
+  /* Write to I2Cx CR2 */
+  I2Cx->CR2 = tmpreg;
+
+/*---------------------------- I2Cx CCR Configuration ------------------------*/
+  /* Disable the selected I2C peripheral to configure TRISE */
+  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
+  /* Reset tmpreg value */
+  /* Clear F/S, DUTY and CCR[11:0] bits */
+  tmpreg = 0;
+
+  /* Configure speed in standard mode */
+  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
+  {
+    /* Standard mode speed calculate */
+    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
+    /* Test if CCR value is under 0x4*/
+    if (result < 0x04)
+    {
+      /* Set minimum allowed value */
+      result = 0x04;  
+    }
+    /* Set speed value for standard mode */
+    tmpreg |= result;	  
+    /* Set Maximum Rise Time for standard mode */
+    I2Cx->TRISE = freqrange + 1; 
+  }
+  /* Configure speed in fast mode */
+  /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
+     input clock) must be a multiple of 10 MHz */
+  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
+  {
+    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
+    {
+      /* Fast mode speed calculate: Tlow/Thigh = 2 */
+      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
+    }
+    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
+    {
+      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
+      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
+      /* Set DUTY bit */
+      result |= I2C_DutyCycle_16_9;
+    }
+
+    /* Test if CCR value is under 0x1*/
+    if ((result & I2C_CCR_CCR) == 0)
+    {
+      /* Set minimum allowed value */
+      result |= (uint16_t)0x0001;  
+    }
+    /* Set speed value and set F/S bit for fast mode */
+    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
+    /* Set Maximum Rise Time for fast mode */
+    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
+  }
+
+  /* Write to I2Cx CCR */
+  I2Cx->CCR = tmpreg;
+  /* Enable the selected I2C peripheral */
+  I2Cx->CR1 |= I2C_CR1_PE;
+
+/*---------------------------- I2Cx CR1 Configuration ------------------------*/
+  /* Get the I2Cx CR1 value */
+  tmpreg = I2Cx->CR1;
+  /* Clear ACK, SMBTYPE and  SMBUS bits */
+  tmpreg &= CR1_CLEAR_MASK;
+  /* Configure I2Cx: mode and acknowledgement */
+  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
+  /* Set ACK bit according to I2C_Ack value */
+  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
+  /* Write to I2Cx CR1 */
+  I2Cx->CR1 = tmpreg;
+
+/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
+  /* Set I2Cx Own Address1 and acknowledged address */
+  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
+}
+
+/**
+  * @brief  Fills each I2C_InitStruct member with its default value.
+  * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
+{
+/*---------------- Reset I2C init structure parameters values ----------------*/
+  /* initialize the I2C_ClockSpeed member */
+  I2C_InitStruct->I2C_ClockSpeed = 5000;
+  /* Initialize the I2C_Mode member */
+  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
+  /* Initialize the I2C_DutyCycle member */
+  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
+  /* Initialize the I2C_OwnAddress1 member */
+  I2C_InitStruct->I2C_OwnAddress1 = 0;
+  /* Initialize the I2C_Ack member */
+  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
+  /* Initialize the I2C_AcknowledgedAddress member */
+  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
+}
+
+/**
+  * @brief  Enables or disables the specified I2C peripheral.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx peripheral. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C peripheral */
+    I2Cx->CR1 |= I2C_CR1_PE;
+  }
+  else
+  {
+    /* Disable the selected I2C peripheral */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
+  }
+}
+
+/**
+  * @brief  Enables or disables the Analog filter of I2C peripheral.
+  * 
+  * @note   This function can be used only for STM32F42xxx/STM3243xxx, STM32F401xx and STM32F411xE devices.
+  *        
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the Analog filter. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @note   This function should be called before initializing and enabling
+            the I2C Peripheral.
+  * @retval None
+  */
+void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the analog filter */
+    I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
+  }
+  else
+  {
+    /* Disable the analog filter */
+    I2Cx->FLTR |= I2C_FLTR_ANOFF;
+  }
+}
+
+/**
+  * @brief  Configures the Digital noise filter of I2C peripheral.
+  * 
+  * @note   This function can be used only for STM32F42xxx/STM3243xxx, STM32F401xx and STM32F411xE devices.
+  *       
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_DigitalFilter: Coefficient of digital noise filter. 
+  *          This parameter can be a number between 0x00 and 0x0F.
+  * @note   This function should be called before initializing and enabling
+            the I2C Peripheral.
+  * @retval None
+  */
+void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter)
+{
+  uint16_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
+  
+  /* Get the old register value */
+  tmpreg = I2Cx->FLTR;
+  
+  /* Reset I2Cx DNF bit [3:0] */
+  tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
+  
+  /* Set I2Cx DNF coefficient */
+  tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
+  
+  /* Store the new register value */
+  I2Cx->FLTR = tmpreg;
+}
+
+/**
+  * @brief  Generates I2Cx communication START condition.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C START condition generation.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Generate a START condition */
+    I2Cx->CR1 |= I2C_CR1_START;
+  }
+  else
+  {
+    /* Disable the START condition generation */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
+  }
+}
+
+/**
+  * @brief  Generates I2Cx communication STOP condition.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C STOP condition generation.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Generate a STOP condition */
+    I2Cx->CR1 |= I2C_CR1_STOP;
+  }
+  else
+  {
+    /* Disable the STOP condition generation */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
+  }
+}
+
+/**
+  * @brief  Transmits the address byte to select the slave device.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  Address: specifies the slave address which will be transmitted
+  * @param  I2C_Direction: specifies whether the I2C device will be a Transmitter
+  *         or a Receiver. 
+  *          This parameter can be one of the following values
+  *            @arg I2C_Direction_Transmitter: Transmitter mode
+  *            @arg I2C_Direction_Receiver: Receiver mode
+  * @retval None.
+  */
+void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_DIRECTION(I2C_Direction));
+  /* Test on the direction to set/reset the read/write bit */
+  if (I2C_Direction != I2C_Direction_Transmitter)
+  {
+    /* Set the address bit0 for read */
+    Address |= I2C_OAR1_ADD0;
+  }
+  else
+  {
+    /* Reset the address bit0 for write */
+    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
+  }
+  /* Send the address */
+  I2Cx->DR = Address;
+}
+
+/**
+  * @brief  Enables or disables the specified I2C acknowledge feature.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C Acknowledgement.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the acknowledgement */
+    I2Cx->CR1 |= I2C_CR1_ACK;
+  }
+  else
+  {
+    /* Disable the acknowledgement */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
+  }
+}
+
+/**
+  * @brief  Configures the specified I2C own address2.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  Address: specifies the 7bit I2C own address2.
+  * @retval None.
+  */
+void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
+{
+  uint16_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Get the old register value */
+  tmpreg = I2Cx->OAR2;
+
+  /* Reset I2Cx Own address2 bit [7:1] */
+  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
+
+  /* Set I2Cx Own address2 */
+  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
+
+  /* Store the new register value */
+  I2Cx->OAR2 = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the specified I2C dual addressing mode.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C dual addressing mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable dual addressing mode */
+    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
+  }
+  else
+  {
+    /* Disable dual addressing mode */
+    I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C general call feature.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C General call.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable generall call */
+    I2Cx->CR1 |= I2C_CR1_ENGC;
+  }
+  else
+  {
+    /* Disable generall call */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C software reset.
+  * @note   When software reset is enabled, the I2C IOs are released (this can
+  *         be useful to recover from bus errors).  
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C software reset.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Peripheral under reset */
+    I2Cx->CR1 |= I2C_CR1_SWRST;
+  }
+  else
+  {
+    /* Peripheral not under reset */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C Clock stretching.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx Clock stretching.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState == DISABLE)
+  {
+    /* Enable the selected I2C Clock stretching */
+    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
+  }
+  else
+  {
+    /* Disable the selected I2C Clock stretching */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
+  }
+}
+
+/**
+  * @brief  Selects the specified I2C fast mode duty cycle.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
+  *          This parameter can be one of the following values:
+  *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
+  *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
+  * @retval None
+  */
+void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
+  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
+  {
+    /* I2C fast mode Tlow/Thigh=2 */
+    I2Cx->CCR &= I2C_DutyCycle_2;
+  }
+  else
+  {
+    /* I2C fast mode Tlow/Thigh=16/9 */
+    I2Cx->CCR |= I2C_DutyCycle_16_9;
+  }
+}
+
+/**
+  * @brief  Selects the specified I2C NACK position in master receiver mode.
+  * @note   This function is useful in I2C Master Receiver mode when the number
+  *         of data to be received is equal to 2. In this case, this function 
+  *         should be called (with parameter I2C_NACKPosition_Next) before data 
+  *         reception starts,as described in the 2-byte reception procedure 
+  *         recommended in Reference Manual in Section: Master receiver.                
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_NACKPosition: specifies the NACK position. 
+  *          This parameter can be one of the following values:
+  *            @arg I2C_NACKPosition_Next: indicates that the next byte will be the last
+  *                                        received byte.  
+  *            @arg I2C_NACKPosition_Current: indicates that current byte is the last 
+  *                                           received byte.
+  *            
+  * @note    This function configures the same bit (POS) as I2C_PECPositionConfig() 
+  *          but is intended to be used in I2C mode while I2C_PECPositionConfig() 
+  *          is intended to used in SMBUS mode. 
+  *            
+  * @retval None
+  */
+void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
+  
+  /* Check the input parameter */
+  if (I2C_NACKPosition == I2C_NACKPosition_Next)
+  {
+    /* Next byte in shift register is the last received byte */
+    I2Cx->CR1 |= I2C_NACKPosition_Next;
+  }
+  else
+  {
+    /* Current byte in shift register is the last received byte */
+    I2Cx->CR1 &= I2C_NACKPosition_Current;
+  }
+}
+
+/**
+  * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_SMBusAlert: specifies SMBAlert pin level. 
+  *          This parameter can be one of the following values:
+  *            @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
+  *            @arg I2C_SMBusAlert_High: SMBAlert pin driven high
+  * @retval None
+  */
+void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
+  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
+  {
+    /* Drive the SMBusAlert pin Low */
+    I2Cx->CR1 |= I2C_SMBusAlert_Low;
+  }
+  else
+  {
+    /* Drive the SMBusAlert pin High  */
+    I2Cx->CR1 &= I2C_SMBusAlert_High;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C ARP.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx ARP. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C ARP */
+    I2Cx->CR1 |= I2C_CR1_ENARP;
+  }
+  else
+  {
+    /* Disable the selected I2C ARP */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Group2 Data transfers functions
+ *  @brief   Data transfers functions 
+ *
+@verbatim   
+ ===============================================================================
+                  ##### Data transfers functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Sends a data byte through the I2Cx peripheral.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  Data: Byte to be transmitted..
+  * @retval None
+  */
+void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Write in the DR register the data to be sent */
+  I2Cx->DR = Data;
+}
+
+/**
+  * @brief  Returns the most recent received data by the I2Cx peripheral.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @retval The value of the received data.
+  */
+uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Return the data in the DR register */
+  return (uint8_t)I2Cx->DR;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Group3 PEC management functions
+ *  @brief   PEC management functions 
+ *
+@verbatim   
+ ===============================================================================
+                  ##### PEC management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified I2C PEC transfer.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C PEC transmission.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C PEC transmission */
+    I2Cx->CR1 |= I2C_CR1_PEC;
+  }
+  else
+  {
+    /* Disable the selected I2C PEC transmission */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
+  }
+}
+
+/**
+  * @brief  Selects the specified I2C PEC position.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_PECPosition: specifies the PEC position. 
+  *          This parameter can be one of the following values:
+  *            @arg I2C_PECPosition_Next: indicates that the next byte is PEC
+  *            @arg I2C_PECPosition_Current: indicates that current byte is PEC
+  *       
+  * @note    This function configures the same bit (POS) as I2C_NACKPositionConfig()
+  *          but is intended to be used in SMBUS mode while I2C_NACKPositionConfig() 
+  *          is intended to used in I2C mode.
+  *                
+  * @retval None
+  */
+void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
+  if (I2C_PECPosition == I2C_PECPosition_Next)
+  {
+    /* Next byte in shift register is PEC */
+    I2Cx->CR1 |= I2C_PECPosition_Next;
+  }
+  else
+  {
+    /* Current byte in shift register is PEC */
+    I2Cx->CR1 &= I2C_PECPosition_Current;
+  }
+}
+
+/**
+  * @brief  Enables or disables the PEC value calculation of the transferred bytes.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx PEC value calculation.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C PEC calculation */
+    I2Cx->CR1 |= I2C_CR1_ENPEC;
+  }
+  else
+  {
+    /* Disable the selected I2C PEC calculation */
+    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
+  }
+}
+
+/**
+  * @brief  Returns the PEC value for the specified I2C.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @retval The PEC value.
+  */
+uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Return the selected I2C PEC value */
+  return ((I2Cx->SR2) >> 8);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Group4 DMA transfers management functions
+ *  @brief   DMA transfers management functions 
+ *
+@verbatim   
+ ===============================================================================
+                ##### DMA transfers management functions #####
+ ===============================================================================  
+  This section provides functions allowing to configure the I2C DMA channels 
+  requests.
+  
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified I2C DMA requests.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C DMA transfer.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C DMA requests */
+    I2Cx->CR2 |= I2C_CR2_DMAEN;
+  }
+  else
+  {
+    /* Disable the selected I2C DMA requests */
+    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
+  }
+}
+
+/**
+  * @brief  Specifies that the next DMA transfer is the last one.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C DMA last transfer.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Next DMA transfer is the last transfer */
+    I2Cx->CR2 |= I2C_CR2_LAST;
+  }
+  else
+  {
+    /* Next DMA transfer is not the last transfer */
+    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Group5 Interrupts events and flags management functions
+ *  @brief   Interrupts, events and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+          ##### Interrupts, events and flags management functions #####
+ ===============================================================================
+    [..]
+    This section provides functions allowing to configure the I2C Interrupts 
+    sources and check or clear the flags or pending bits status.
+    The user should identify which mode will be used in his application to manage 
+    the communication: Polling mode, Interrupt mode or DMA mode. 
+
+
+                ##### I2C State Monitoring Functions #####                   
+ =============================================================================== 
+    [..]  
+    This I2C driver provides three different ways for I2C state monitoring
+    depending on the application requirements and constraints:
+         
+   
+     (#) Basic state monitoring (Using I2C_CheckEvent() function)
+     
+        It compares the status registers (SR1 and SR2) content to a given event
+        (can be the combination of one or more flags).
+        It returns SUCCESS if the current status includes the given flags 
+        and returns ERROR if one or more flags are missing in the current status.
+
+          (++) When to use
+             (+++) This function is suitable for most applications as well as for startup 
+               activity since the events are fully described in the product reference 
+               manual (RM0090).
+             (+++) It is also suitable for users who need to define their own events.
+
+          (++) Limitations
+               If an error occurs (ie. error flags are set besides to the monitored 
+               flags), the I2C_CheckEvent() function may return SUCCESS despite 
+               the communication hold or corrupted real state. 
+               In this case, it is advised to use error interrupts to monitor 
+               the error events and handle them in the interrupt IRQ handler.
+         
+     -@@- For error management, it is advised to use the following functions:
+        (+@@) I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
+        (+@@) I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
+              Where x is the peripheral instance (I2C1, I2C2 ...)
+        (+@@) I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
+              I2Cx_ER_IRQHandler() function in order to determine which error occurred.
+        (+@@) I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
+              and/or I2C_GenerateStop() in order to clear the error flag and source 
+              and return to correct  communication status.
+             
+ 
+     (#) Advanced state monitoring (Using the function I2C_GetLastEvent())
+
+        Using the function I2C_GetLastEvent() which returns the image of both status 
+        registers in a single word (uint32_t) (Status Register 2 value is shifted left 
+        by 16 bits and concatenated to Status Register 1).
+
+          (++) When to use
+             (+++) This function is suitable for the same applications above but it 
+               allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
+               function.
+             (+++) The returned value could be compared to events already defined in 
+               the library (stm32f4xx_i2c.h) or to custom values defined by user.
+               This function is suitable when multiple flags are monitored at the 
+               same time.
+             (+++) At the opposite of I2C_CheckEvent() function, this function allows 
+               user to choose when an event is accepted (when all events flags are 
+               set and no other flags are set or just when the needed flags are set 
+               like I2C_CheckEvent() function.
+
+          (++) Limitations
+             (+++) User may need to define his own events.
+             (+++) Same remark concerning the error management is applicable for this 
+               function if user decides to check only regular communication flags 
+               (and ignores error flags).
+      
+ 
+     (#) Flag-based state monitoring (Using the function I2C_GetFlagStatus())
+     
+      Using the function I2C_GetFlagStatus() which simply returns the status of 
+      one single flag (ie. I2C_FLAG_RXNE ...). 
+
+          (++) When to use
+             (+++) This function could be used for specific applications or in debug 
+               phase.
+             (+++) It is suitable when only one flag checking is needed (most I2C 
+               events are monitored through multiple flags).
+          (++) Limitations: 
+             (+++) When calling this function, the Status register is accessed. 
+               Some flags are cleared when the status register is accessed. 
+               So checking the status of one Flag, may clear other ones.
+             (+++) Function may need to be called twice or more in order to monitor 
+               one single event.
+ 
+   For detailed description of Events, please refer to section I2C_Events in 
+   stm32f4xx_i2c.h file.
+       
+@endverbatim
+  * @{
+  */
+   
+/**
+  * @brief  Reads the specified I2C register and returns its value.
+  * @param  I2C_Register: specifies the register to read.
+  *          This parameter can be one of the following values:
+  *            @arg I2C_Register_CR1:  CR1 register.
+  *            @arg I2C_Register_CR2:   CR2 register.
+  *            @arg I2C_Register_OAR1:  OAR1 register.
+  *            @arg I2C_Register_OAR2:  OAR2 register.
+  *            @arg I2C_Register_DR:    DR register.
+  *            @arg I2C_Register_SR1:   SR1 register.
+  *            @arg I2C_Register_SR2:   SR2 register.
+  *            @arg I2C_Register_CCR:   CCR register.
+  *            @arg I2C_Register_TRISE: TRISE register.
+  * @retval The value of the read register.
+  */
+uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_REGISTER(I2C_Register));
+
+  tmp = (uint32_t) I2Cx;
+  tmp += I2C_Register;
+
+  /* Return the selected register value */
+  return (*(__IO uint16_t *) tmp);
+}
+
+/**
+  * @brief  Enables or disables the specified I2C interrupts.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
+  *          This parameter can be any combination of the following values:
+  *            @arg I2C_IT_BUF: Buffer interrupt mask
+  *            @arg I2C_IT_EVT: Event interrupt mask
+  *            @arg I2C_IT_ERR: Error interrupt mask
+  * @param  NewState: new state of the specified I2C interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C interrupts */
+    I2Cx->CR2 |= I2C_IT;
+  }
+  else
+  {
+    /* Disable the selected I2C interrupts */
+    I2Cx->CR2 &= (uint16_t)~I2C_IT;
+  }
+}
+
+/*
+ ===============================================================================
+                          1. Basic state monitoring                    
+ ===============================================================================  
+ */
+
+/**
+  * @brief  Checks whether the last I2Cx Event is equal to the one passed
+  *         as parameter.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_EVENT: specifies the event to be checked. 
+  *          This parameter can be one of the following values:
+  *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
+  *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
+  *            @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED: EV1
+  *            @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED: EV1
+  *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
+  *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
+  *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF): EV2
+  *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
+  *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
+  *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF): EV3
+  *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
+  *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
+  *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
+  *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
+  *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6     
+  *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
+  *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
+  *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
+  *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
+  *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
+  *     
+  * @note   For detailed description of Events, please refer to section I2C_Events
+  *         in stm32f4xx_i2c.h file.
+  *    
+  * @retval An ErrorStatus enumeration value:
+  *           - SUCCESS: Last event is equal to the I2C_EVENT
+  *           - ERROR: Last event is different from the I2C_EVENT
+  */
+ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
+{
+  uint32_t lastevent = 0;
+  uint32_t flag1 = 0, flag2 = 0;
+  ErrorStatus status = ERROR;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_EVENT(I2C_EVENT));
+
+  /* Read the I2Cx status register */
+  flag1 = I2Cx->SR1;
+  flag2 = I2Cx->SR2;
+  flag2 = flag2 << 16;
+
+  /* Get the last event value from I2C status register */
+  lastevent = (flag1 | flag2) & FLAG_MASK;
+
+  /* Check whether the last event contains the I2C_EVENT */
+  if ((lastevent & I2C_EVENT) == I2C_EVENT)
+  {
+    /* SUCCESS: last event is equal to I2C_EVENT */
+    status = SUCCESS;
+  }
+  else
+  {
+    /* ERROR: last event is different from I2C_EVENT */
+    status = ERROR;
+  }
+  /* Return status */
+  return status;
+}
+
+/*
+ ===============================================================================
+                          2. Advanced state monitoring                   
+ ===============================================================================  
+ */
+
+/**
+  * @brief  Returns the last I2Cx Event.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  *     
+  * @note   For detailed description of Events, please refer to section I2C_Events
+  *         in stm32f4xx_i2c.h file.
+  *    
+  * @retval The last event
+  */
+uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
+{
+  uint32_t lastevent = 0;
+  uint32_t flag1 = 0, flag2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Read the I2Cx status register */
+  flag1 = I2Cx->SR1;
+  flag2 = I2Cx->SR2;
+  flag2 = flag2 << 16;
+
+  /* Get the last event value from I2C status register */
+  lastevent = (flag1 | flag2) & FLAG_MASK;
+
+  /* Return status */
+  return lastevent;
+}
+
+/*
+ ===============================================================================
+                          3. Flag-based state monitoring                   
+ ===============================================================================  
+ */
+
+/**
+  * @brief  Checks whether the specified I2C flag is set or not.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_FLAG: specifies the flag to check. 
+  *          This parameter can be one of the following values:
+  *            @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
+  *            @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
+  *            @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
+  *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
+  *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
+  *            @arg I2C_FLAG_BUSY: Bus busy flag
+  *            @arg I2C_FLAG_MSL: Master/Slave flag
+  *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
+  *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
+  *            @arg I2C_FLAG_PECERR: PEC error in reception flag
+  *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+  *            @arg I2C_FLAG_AF: Acknowledge failure flag
+  *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+  *            @arg I2C_FLAG_BERR: Bus error flag
+  *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
+  *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
+  *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
+  *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
+  *            @arg I2C_FLAG_BTF: Byte transfer finished flag
+  *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
+  *                                Address matched flag (Slave mode)"ENDAD"
+  *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
+  * @retval The new state of I2C_FLAG (SET or RESET).
+  */
+FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  __IO uint32_t i2creg = 0, i2cxbase = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
+
+  /* Get the I2Cx peripheral base address */
+  i2cxbase = (uint32_t)I2Cx;
+  
+  /* Read flag register index */
+  i2creg = I2C_FLAG >> 28;
+  
+  /* Get bit[23:0] of the flag */
+  I2C_FLAG &= FLAG_MASK;
+  
+  if(i2creg != 0)
+  {
+    /* Get the I2Cx SR1 register address */
+    i2cxbase += 0x14;
+  }
+  else
+  {
+    /* Flag in I2Cx SR2 Register */
+    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
+    /* Get the I2Cx SR2 register address */
+    i2cxbase += 0x18;
+  }
+  
+  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
+  {
+    /* I2C_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* I2C_FLAG is reset */
+    bitstatus = RESET;
+  }
+  
+  /* Return the I2C_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the I2Cx's pending flags.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_FLAG: specifies the flag to clear. 
+  *          This parameter can be any combination of the following values:
+  *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
+  *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
+  *            @arg I2C_FLAG_PECERR: PEC error in reception flag
+  *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+  *            @arg I2C_FLAG_AF: Acknowledge failure flag
+  *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+  *            @arg I2C_FLAG_BERR: Bus error flag
+  *   
+  * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
+  *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
+  *          to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
+  * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
+  *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
+  *          second byte of the address in DR register.
+  * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
+  *          operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
+  *          read/write to I2C_DR register (I2C_SendData()).
+  * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
+  *          I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
+  *          I2C_SR2 register ((void)(I2Cx->SR2)).
+  * @note   SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
+  *          register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
+  *          register (I2C_SendData()).
+  *  
+  * @retval None
+  */
+void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
+{
+  uint32_t flagpos = 0;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
+  /* Get the I2C flag position */
+  flagpos = I2C_FLAG & FLAG_MASK;
+  /* Clear the selected I2C flag */
+  I2Cx->SR1 = (uint16_t)~flagpos;
+}
+
+/**
+  * @brief  Checks whether the specified I2C interrupt has occurred or not.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_IT: specifies the interrupt source to check. 
+  *          This parameter can be one of the following values:
+  *            @arg I2C_IT_SMBALERT: SMBus Alert flag
+  *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
+  *            @arg I2C_IT_PECERR: PEC error in reception flag
+  *            @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
+  *            @arg I2C_IT_AF: Acknowledge failure flag
+  *            @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
+  *            @arg I2C_IT_BERR: Bus error flag
+  *            @arg I2C_IT_TXE: Data register empty flag (Transmitter)
+  *            @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
+  *            @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
+  *            @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
+  *            @arg I2C_IT_BTF: Byte transfer finished flag
+  *            @arg I2C_IT_ADDR: Address sent flag (Master mode) "ADSL"
+  *                              Address matched flag (Slave mode)"ENDAD"
+  *            @arg I2C_IT_SB: Start bit flag (Master mode)
+  * @retval The new state of I2C_IT (SET or RESET).
+  */
+ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_GET_IT(I2C_IT));
+
+  /* Check if the interrupt source is enabled or not */
+  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
+  
+  /* Get bit[23:0] of the flag */
+  I2C_IT &= FLAG_MASK;
+
+  /* Check the status of the specified I2C flag */
+  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
+  {
+    /* I2C_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* I2C_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the I2C_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the I2Cx's interrupt pending bits.
+  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
+  * @param  I2C_IT: specifies the interrupt pending bit to clear. 
+  *          This parameter can be any combination of the following values:
+  *            @arg I2C_IT_SMBALERT: SMBus Alert interrupt
+  *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
+  *            @arg I2C_IT_PECERR: PEC error in reception  interrupt
+  *            @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
+  *            @arg I2C_IT_AF: Acknowledge failure interrupt
+  *            @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
+  *            @arg I2C_IT_BERR: Bus error interrupt
+  * 
+  * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
+  *          to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
+  *          I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
+  * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
+  *          operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second 
+  *          byte of the address in I2C_DR register.
+  * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
+  *          operation to I2C_SR1 register (I2C_GetITStatus()) followed by a 
+  *          read/write to I2C_DR register (I2C_SendData()).
+  * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
+  *          I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to 
+  *          I2C_SR2 register ((void)(I2Cx->SR2)).
+  * @note   SB (Start Bit) is cleared by software sequence: a read operation to 
+  *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
+  *          I2C_DR register (I2C_SendData()).
+  * @retval None
+  */
+void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
+{
+  uint32_t flagpos = 0;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
+
+  /* Get the I2C flag position */
+  flagpos = I2C_IT & FLAG_MASK;
+
+  /* Clear the selected I2C flag */
+  I2Cx->SR1 = (uint16_t)~flagpos;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_iwdg.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_iwdg.c
new file mode 100644
index 0000000..08b31b9
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_iwdg.c
@@ -0,0 +1,266 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_iwdg.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Independent watchdog (IWDG) peripheral:           
+  *           + Prescaler and Counter configuration
+  *           + IWDG activation
+  *           + Flag management
+  *
+    @verbatim    
+ ===============================================================================
+                          ##### IWDG features #####
+ ===============================================================================
+    [..]  
+      The IWDG can be started by either software or hardware (configurable
+      through option byte).
+              
+      The IWDG is clocked by its own dedicated low-speed clock (LSI) and
+      thus stays active even if the main clock fails.
+      Once the IWDG is started, the LSI is forced ON and cannot be disabled
+      (LSI cannot be disabled too), and the counter starts counting down from 
+      the reset value of 0xFFF. When it reaches the end of count value (0x000)
+      a system reset is generated.
+      The IWDG counter should be reloaded at regular intervals to prevent
+      an MCU reset.
+                             
+      The IWDG is implemented in the VDD voltage domain that is still functional
+      in STOP and STANDBY mode (IWDG reset can wake-up from STANDBY).          
+              
+      IWDGRST flag in RCC_CSR register can be used to inform when a IWDG
+      reset occurs.
+              
+      Min-max timeout value @32KHz (LSI): ~125us / ~32.7s
+      The IWDG timeout may vary due to LSI frequency dispersion. STM32F4xx
+      devices provide the capability to measure the LSI frequency (LSI clock
+      connected internally to TIM5 CH4 input capture). The measured value
+      can be used to have an IWDG timeout with an acceptable accuracy. 
+      For more information, please refer to the STM32F4xx Reference manual
+            
+                     ##### How to use this driver #####
+ ===============================================================================
+    [..]
+      (#) Enable write access to IWDG_PR and IWDG_RLR registers using
+          IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable) function
+                 
+      (#) Configure the IWDG prescaler using IWDG_SetPrescaler() function
+              
+      (#) Configure the IWDG counter value using IWDG_SetReload() function.
+          This value will be loaded in the IWDG counter each time the counter
+          is reloaded, then the IWDG will start counting down from this value.
+              
+      (#) Start the IWDG using IWDG_Enable() function, when the IWDG is used
+          in software mode (no need to enable the LSI, it will be enabled
+          by hardware)
+               
+      (#) Then the application program must reload the IWDG counter at regular
+          intervals during normal operation to prevent an MCU reset, using
+          IWDG_ReloadCounter() function.      
+            
+    @endverbatim    
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_iwdg.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup IWDG 
+  * @brief IWDG driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* KR register bit mask */
+#define KR_KEY_RELOAD    ((uint16_t)0xAAAA)
+#define KR_KEY_ENABLE    ((uint16_t)0xCCCC)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup IWDG_Private_Functions
+  * @{
+  */
+
+/** @defgroup IWDG_Group1 Prescaler and Counter configuration functions
+ *  @brief   Prescaler and Counter configuration functions
+ *
+@verbatim   
+ ===============================================================================
+              ##### Prescaler and Counter configuration functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables write access to IWDG_PR and IWDG_RLR registers.
+  * @param  IWDG_WriteAccess: new state of write access to IWDG_PR and IWDG_RLR registers.
+  *          This parameter can be one of the following values:
+  *            @arg IWDG_WriteAccess_Enable: Enable write access to IWDG_PR and IWDG_RLR registers
+  *            @arg IWDG_WriteAccess_Disable: Disable write access to IWDG_PR and IWDG_RLR registers
+  * @retval None
+  */
+void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
+  IWDG->KR = IWDG_WriteAccess;
+}
+
+/**
+  * @brief  Sets IWDG Prescaler value.
+  * @param  IWDG_Prescaler: specifies the IWDG Prescaler value.
+  *          This parameter can be one of the following values:
+  *            @arg IWDG_Prescaler_4: IWDG prescaler set to 4
+  *            @arg IWDG_Prescaler_8: IWDG prescaler set to 8
+  *            @arg IWDG_Prescaler_16: IWDG prescaler set to 16
+  *            @arg IWDG_Prescaler_32: IWDG prescaler set to 32
+  *            @arg IWDG_Prescaler_64: IWDG prescaler set to 64
+  *            @arg IWDG_Prescaler_128: IWDG prescaler set to 128
+  *            @arg IWDG_Prescaler_256: IWDG prescaler set to 256
+  * @retval None
+  */
+void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
+  IWDG->PR = IWDG_Prescaler;
+}
+
+/**
+  * @brief  Sets IWDG Reload value.
+  * @param  Reload: specifies the IWDG Reload value.
+  *          This parameter must be a number between 0 and 0x0FFF.
+  * @retval None
+  */
+void IWDG_SetReload(uint16_t Reload)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_RELOAD(Reload));
+  IWDG->RLR = Reload;
+}
+
+/**
+  * @brief  Reloads IWDG counter with value defined in the reload register
+  *         (write access to IWDG_PR and IWDG_RLR registers disabled).
+  * @param  None
+  * @retval None
+  */
+void IWDG_ReloadCounter(void)
+{
+  IWDG->KR = KR_KEY_RELOAD;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Group2 IWDG activation function
+ *  @brief   IWDG activation function 
+ *
+@verbatim   
+ ===============================================================================
+                    ##### IWDG activation function #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables IWDG (write access to IWDG_PR and IWDG_RLR registers disabled).
+  * @param  None
+  * @retval None
+  */
+void IWDG_Enable(void)
+{
+  IWDG->KR = KR_KEY_ENABLE;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Group3 Flag management function 
+ *  @brief  Flag management function  
+ *
+@verbatim   
+ ===============================================================================
+                    ##### Flag management function #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Checks whether the specified IWDG flag is set or not.
+  * @param  IWDG_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg IWDG_FLAG_PVU: Prescaler Value Update on going
+  *            @arg IWDG_FLAG_RVU: Reload Value Update on going
+  * @retval The new state of IWDG_FLAG (SET or RESET).
+  */
+FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
+  if ((IWDG->SR & IWDG_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_ltdc.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_ltdc.c
new file mode 100644
index 0000000..d42b21b
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_ltdc.c
@@ -0,0 +1,1110 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_ltdc.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the LTDC controller (LTDC) peripheral:
+  *           + Initialization and configuration
+  *           + Interrupts and flags management
+  *           
+  *  @verbatim
+  
+ ===============================================================================
+                      ##### How to use this driver #####
+ ===============================================================================
+    [..]
+        (#) Enable LTDC clock using 
+            RCC_APB2PeriphResetCmd(RCC_APB2Periph_LTDC, ENABLE) function.
+        (#) Configures LTDC
+          (++) Configure the required Pixel clock following the panel datasheet
+          (++) Configure the Synchronous timings: VSYNC, HSYNC, Vertical and 
+              Horizontal back proch, active data area and the front proch 
+              timings 
+          (++) Configure the synchronous signals and clock polarity in the 
+              LTDC_GCR register
+        (#) Configures Layer1/2 parameters
+          (++) The Layer window horizontal and vertical position in the LTDC_LxWHPCR and 
+               LTDC_WVPCR registers. The layer window must be in the active data area.
+          (++) The pixel input format in the LTDC_LxPFCR register
+          (++) The color frame buffer start address in the LTDC_LxCFBAR register
+          (++) The line length and pitch of the color frame buffer in the 
+               LTDC_LxCFBLR register
+          (++) The number of lines of the color frame buffer in 
+               the LTDC_LxCFBLNR register
+          (++) if needed, load the CLUT with the RGB values and the address 
+               in the LTDC_LxCLUTWR register
+          (++) If needed, configure the default color and the blending factors 
+               respectively in the LTDC_LxDCCR and LTDC_LxBFCR registers 
+
+          (++) If needed, Dithering and color keying can be be enabled respectively 
+               in the LTDC_GCR and LTDC_LxCKCR registers. It can be also enabled 
+               on the fly.    
+        (#) Enable Layer1/2 and if needed the CLUT in the LTDC_LxCR register 
+  
+        (#) Reload the shadow registers to active register through 
+            the LTDC_SRCR register.
+          -@- All layer parameters can be be modified on the fly except the CLUT. 
+              The new configuration has to be either reloaded immediately 
+              or during vertical blanking period by configuring the LTDC_SRCR register.
+        (#) Call the LTDC_Cmd() to enable the LTDC controller.
+
+    @endverbatim
+  
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_ltdc.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup LTDC 
+  * @brief LTDC driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+#define GCR_MASK                     ((uint32_t)0x0FFE888F)  /* LTDC GCR Mask */
+
+
+/** @defgroup LTDC_Private_Functions
+  * @{
+  */
+
+/** @defgroup LTDC_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim
+ ===============================================================================
+            ##### Initialization and Configuration functions #####
+ ===============================================================================
+    [..]  This section provides functions allowing to:
+      (+) Initialize and configure the LTDC
+      (+) Enable or Disable Dither
+      (+) Define the position of the line interrupt
+      (+) reload layers registers with new parameters
+      (+) Initialize and configure layer1 and layer2
+      (+) Set and configure the color keying functionality
+      (+) Configure and Enables or disables CLUT 
+      
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the LTDC peripheral registers to their default reset
+  *         values.
+  * @param  None
+  * @retval None
+  */
+
+void LTDC_DeInit(void)
+{
+  /* Enable LTDC reset state */
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_LTDC, ENABLE);
+  /* Release LTDC from reset state */
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_LTDC, DISABLE);
+}
+
+/**
+  * @brief  Initializes the LTDC peripheral according to the specified parameters
+  *         in the LTDC_InitStruct.
+  * @note   This function can be used only when the LTDC is disabled.
+  * @param  LTDC_InitStruct: pointer to a LTDC_InitTypeDef structure that contains
+  *         the configuration information for the specified LTDC peripheral.
+  * @retval None
+  */
+
+void LTDC_Init(LTDC_InitTypeDef* LTDC_InitStruct)
+{
+  uint32_t horizontalsync = 0;
+  uint32_t accumulatedHBP = 0;
+  uint32_t accumulatedactiveW = 0;
+  uint32_t totalwidth = 0;
+  uint32_t backgreen = 0;
+  uint32_t backred = 0;
+
+  /* Check function parameters */
+  assert_param(IS_LTDC_HSYNC(LTDC_InitStruct->LTDC_HorizontalSync));
+  assert_param(IS_LTDC_VSYNC(LTDC_InitStruct->LTDC_VerticalSync));
+  assert_param(IS_LTDC_AHBP(LTDC_InitStruct->LTDC_AccumulatedHBP));
+  assert_param(IS_LTDC_AVBP(LTDC_InitStruct->LTDC_AccumulatedVBP));
+  assert_param(IS_LTDC_AAH(LTDC_InitStruct->LTDC_AccumulatedActiveH));
+  assert_param(IS_LTDC_AAW(LTDC_InitStruct->LTDC_AccumulatedActiveW));
+  assert_param(IS_LTDC_TOTALH(LTDC_InitStruct->LTDC_TotalHeigh));
+  assert_param(IS_LTDC_TOTALW(LTDC_InitStruct->LTDC_TotalWidth));
+  assert_param(IS_LTDC_HSPOL(LTDC_InitStruct->LTDC_HSPolarity));
+  assert_param(IS_LTDC_VSPOL(LTDC_InitStruct->LTDC_VSPolarity));
+  assert_param(IS_LTDC_DEPOL(LTDC_InitStruct->LTDC_DEPolarity));
+  assert_param(IS_LTDC_PCPOL(LTDC_InitStruct->LTDC_PCPolarity));
+  assert_param(IS_LTDC_BackBlueValue(LTDC_InitStruct->LTDC_BackgroundBlueValue));
+  assert_param(IS_LTDC_BackGreenValue(LTDC_InitStruct->LTDC_BackgroundGreenValue));
+  assert_param(IS_LTDC_BackRedValue(LTDC_InitStruct->LTDC_BackgroundRedValue));
+
+  /* Sets Synchronization size */
+  LTDC->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
+  horizontalsync = (LTDC_InitStruct->LTDC_HorizontalSync << 16);
+  LTDC->SSCR |= (horizontalsync | LTDC_InitStruct->LTDC_VerticalSync);
+
+  /* Sets Accumulated Back porch */
+  LTDC->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
+  accumulatedHBP = (LTDC_InitStruct->LTDC_AccumulatedHBP << 16);
+  LTDC->BPCR |= (accumulatedHBP | LTDC_InitStruct->LTDC_AccumulatedVBP);
+
+  /* Sets Accumulated Active Width */
+  LTDC->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
+  accumulatedactiveW = (LTDC_InitStruct->LTDC_AccumulatedActiveW << 16);
+  LTDC->AWCR |= (accumulatedactiveW | LTDC_InitStruct->LTDC_AccumulatedActiveH);
+
+  /* Sets Total Width */
+  LTDC->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
+  totalwidth = (LTDC_InitStruct->LTDC_TotalWidth << 16);
+  LTDC->TWCR |= (totalwidth | LTDC_InitStruct->LTDC_TotalHeigh);
+
+  LTDC->GCR &= (uint32_t)GCR_MASK;
+  LTDC->GCR |=  (uint32_t)(LTDC_InitStruct->LTDC_HSPolarity | LTDC_InitStruct->LTDC_VSPolarity | \
+                           LTDC_InitStruct->LTDC_DEPolarity | LTDC_InitStruct->LTDC_PCPolarity);
+
+  /* sets the background color value */
+  backgreen = (LTDC_InitStruct->LTDC_BackgroundGreenValue << 8);
+  backred = (LTDC_InitStruct->LTDC_BackgroundRedValue << 16);
+
+  LTDC->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
+  LTDC->BCCR |= (backred | backgreen | LTDC_InitStruct->LTDC_BackgroundBlueValue);
+}
+
+/**
+  * @brief  Fills each LTDC_InitStruct member with its default value.
+  * @param  LTDC_InitStruct: pointer to a LTDC_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+
+void LTDC_StructInit(LTDC_InitTypeDef* LTDC_InitStruct)
+{
+  /*--------------- Reset LTDC init structure parameters values ----------------*/
+  LTDC_InitStruct->LTDC_HSPolarity = LTDC_HSPolarity_AL;      /*!< Initialize the LTDC_HSPolarity member */ 
+  LTDC_InitStruct->LTDC_VSPolarity = LTDC_VSPolarity_AL;      /*!< Initialize the LTDC_VSPolarity member */
+  LTDC_InitStruct->LTDC_DEPolarity = LTDC_DEPolarity_AL;      /*!< Initialize the LTDC_DEPolarity member */
+  LTDC_InitStruct->LTDC_PCPolarity = LTDC_PCPolarity_IPC;     /*!< Initialize the LTDC_PCPolarity member */
+  LTDC_InitStruct->LTDC_HorizontalSync = 0x00;                /*!< Initialize the LTDC_HorizontalSync member */
+  LTDC_InitStruct->LTDC_VerticalSync = 0x00;                  /*!< Initialize the LTDC_VerticalSync member */
+  LTDC_InitStruct->LTDC_AccumulatedHBP = 0x00;                /*!< Initialize the LTDC_AccumulatedHBP member */
+  LTDC_InitStruct->LTDC_AccumulatedVBP = 0x00;                /*!< Initialize the LTDC_AccumulatedVBP member */
+  LTDC_InitStruct->LTDC_AccumulatedActiveW = 0x00;            /*!< Initialize the LTDC_AccumulatedActiveW member */
+  LTDC_InitStruct->LTDC_AccumulatedActiveH = 0x00;            /*!< Initialize the LTDC_AccumulatedActiveH member */
+  LTDC_InitStruct->LTDC_TotalWidth = 0x00;                    /*!< Initialize the LTDC_TotalWidth member */
+  LTDC_InitStruct->LTDC_TotalHeigh = 0x00;                    /*!< Initialize the LTDC_TotalHeigh member */
+  LTDC_InitStruct->LTDC_BackgroundRedValue = 0x00;            /*!< Initialize the LTDC_BackgroundRedValue member */
+  LTDC_InitStruct->LTDC_BackgroundGreenValue = 0x00;          /*!< Initialize the LTDC_BackgroundGreenValue member */
+  LTDC_InitStruct->LTDC_BackgroundBlueValue = 0x00;           /*!< Initialize the LTDC_BackgroundBlueValue member */
+}
+
+/**
+  * @brief  Enables or disables the LTDC Controller.
+  * @param  NewState: new state of the LTDC peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+
+void LTDC_Cmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable LTDC by setting LTDCEN bit */
+    LTDC->GCR |= (uint32_t)LTDC_GCR_LTDCEN;
+  }
+  else
+  {
+    /* Disable LTDC by clearing LTDCEN bit */
+    LTDC->GCR &= ~(uint32_t)LTDC_GCR_LTDCEN;
+  }
+}
+
+/**
+  * @brief  Enables or disables Dither.
+  * @param  NewState: new state of the Dither.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+
+void LTDC_DitherCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable Dither by setting DTEN bit */
+    LTDC->GCR |= (uint32_t)LTDC_GCR_DTEN;
+  }
+  else
+  {
+    /* Disable Dither by clearing DTEN bit */
+    LTDC->GCR &= ~(uint32_t)LTDC_GCR_DTEN;
+  }
+}
+
+/**
+  * @brief  Get the dither RGB width.
+  * @param  LTDC_RGB_InitStruct: pointer to a LTDC_RGBTypeDef structure that contains
+  *         the Dither RGB width.
+  * @retval None
+  */
+
+LTDC_RGBTypeDef LTDC_GetRGBWidth(void)
+{
+  LTDC_RGBTypeDef LTDC_RGB_InitStruct;
+
+  LTDC->GCR &= (uint32_t)GCR_MASK;
+
+  LTDC_RGB_InitStruct.LTDC_BlueWidth = (uint32_t)((LTDC->GCR >> 4) & 0x7);
+  LTDC_RGB_InitStruct.LTDC_GreenWidth = (uint32_t)((LTDC->GCR >> 8) & 0x7);
+  LTDC_RGB_InitStruct.LTDC_RedWidth = (uint32_t)((LTDC->GCR >> 12) & 0x7);
+
+  return LTDC_RGB_InitStruct;
+}
+
+/**
+  * @brief  Fills each LTDC_RGBStruct member with its default value.
+  * @param  LTDC_RGB_InitStruct: pointer to a LTDC_RGBTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+
+void LTDC_RGBStructInit(LTDC_RGBTypeDef* LTDC_RGB_InitStruct)
+{
+  LTDC_RGB_InitStruct->LTDC_BlueWidth = 0x02;
+  LTDC_RGB_InitStruct->LTDC_GreenWidth = 0x02;
+  LTDC_RGB_InitStruct->LTDC_RedWidth = 0x02;
+}
+
+
+/**
+  * @brief  Define the position of the line interrupt .
+  * @param  LTDC_LIPositionConfig: Line Interrupt Position.
+  * @retval None
+  */
+
+void LTDC_LIPConfig(uint32_t LTDC_LIPositionConfig)
+{
+  /* Check the parameters */
+  assert_param(IS_LTDC_LIPOS(LTDC_LIPositionConfig));
+
+  /* Sets the Line Interrupt position */
+  LTDC->LIPCR = (uint32_t)LTDC_LIPositionConfig;
+}
+
+/**
+  * @brief  reload layers registers with new parameters 
+  * @param  LTDC_Reload: specifies the type of reload.
+  *   This parameter can be one of the following values:
+  *     @arg LTDC_IMReload: Vertical blanking reload.
+  *     @arg LTDC_VBReload: Immediate reload.  
+  * @retval None
+  */
+
+void LTDC_ReloadConfig(uint32_t LTDC_Reload)
+{
+  /* Check the parameters */
+  assert_param(IS_LTDC_RELOAD(LTDC_Reload));
+
+  /* Sets the Reload type */
+  LTDC->SRCR = (uint32_t)LTDC_Reload;
+}
+
+
+/**
+  * @brief  Initializes the LTDC Layer according to the specified parameters
+  *         in the LTDC_LayerStruct.
+  * @note   This function can be used only when the LTDC is disabled.
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2    
+  * @param  LTDC_LayerStruct: pointer to a LTDC_LayerTypeDef structure that contains
+  *         the configuration information for the specified LTDC peripheral.
+  * @retval None
+  */
+
+void LTDC_LayerInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_Layer_InitTypeDef* LTDC_Layer_InitStruct)
+{
+
+  uint32_t whsppos = 0;
+  uint32_t wvsppos = 0;
+  uint32_t dcgreen = 0;
+  uint32_t dcred = 0;
+  uint32_t dcalpha = 0;
+  uint32_t cfbp = 0;
+
+/* Check the parameters */
+  assert_param(IS_LTDC_Pixelformat(LTDC_Layer_InitStruct->LTDC_PixelFormat));
+  assert_param(IS_LTDC_BlendingFactor1(LTDC_Layer_InitStruct->LTDC_BlendingFactor_1));
+  assert_param(IS_LTDC_BlendingFactor2(LTDC_Layer_InitStruct->LTDC_BlendingFactor_2));
+  assert_param(IS_LTDC_HCONFIGST(LTDC_Layer_InitStruct->LTDC_HorizontalStart));
+  assert_param(IS_LTDC_HCONFIGSP(LTDC_Layer_InitStruct->LTDC_HorizontalStop));
+  assert_param(IS_LTDC_VCONFIGST(LTDC_Layer_InitStruct->LTDC_VerticalStart));
+  assert_param(IS_LTDC_VCONFIGSP(LTDC_Layer_InitStruct->LTDC_VerticalStop));  
+  assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorBlue));
+  assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorGreen));
+  assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorRed));
+  assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorAlpha));
+  assert_param(IS_LTDC_CFBP(LTDC_Layer_InitStruct->LTDC_CFBPitch));
+  assert_param(IS_LTDC_CFBLL(LTDC_Layer_InitStruct->LTDC_CFBLineLength));
+  assert_param(IS_LTDC_CFBLNBR(LTDC_Layer_InitStruct->LTDC_CFBLineNumber));
+
+  /* Configures the horizontal start and stop position */
+  whsppos = LTDC_Layer_InitStruct->LTDC_HorizontalStop << 16;
+  LTDC_Layerx->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
+  LTDC_Layerx->WHPCR = (LTDC_Layer_InitStruct->LTDC_HorizontalStart | whsppos);
+
+  /* Configures the vertical start and stop position */
+  wvsppos = LTDC_Layer_InitStruct->LTDC_VerticalStop << 16;
+  LTDC_Layerx->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
+  LTDC_Layerx->WVPCR  = (LTDC_Layer_InitStruct->LTDC_VerticalStart | wvsppos);
+
+  /* Specifies the pixel format */
+  LTDC_Layerx->PFCR &= ~(LTDC_LxPFCR_PF);
+  LTDC_Layerx->PFCR = (LTDC_Layer_InitStruct->LTDC_PixelFormat);
+
+  /* Configures the default color values */
+  dcgreen = (LTDC_Layer_InitStruct->LTDC_DefaultColorGreen << 8);
+  dcred = (LTDC_Layer_InitStruct->LTDC_DefaultColorRed << 16);
+  dcalpha = (LTDC_Layer_InitStruct->LTDC_DefaultColorAlpha << 24);
+  LTDC_Layerx->DCCR &=  ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
+  LTDC_Layerx->DCCR = (LTDC_Layer_InitStruct->LTDC_DefaultColorBlue | dcgreen | \
+                        dcred | dcalpha);
+
+  /* Specifies the constant alpha value */      
+  LTDC_Layerx->CACR &= ~(LTDC_LxCACR_CONSTA);
+  LTDC_Layerx->CACR = (LTDC_Layer_InitStruct->LTDC_ConstantAlpha);
+
+  /* Specifies the blending factors */
+  LTDC_Layerx->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
+  LTDC_Layerx->BFCR = (LTDC_Layer_InitStruct->LTDC_BlendingFactor_1 | LTDC_Layer_InitStruct->LTDC_BlendingFactor_2);
+
+  /* Configures the color frame buffer start address */
+  LTDC_Layerx->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
+  LTDC_Layerx->CFBAR = (LTDC_Layer_InitStruct->LTDC_CFBStartAdress);
+
+  /* Configures the color frame buffer pitch in byte */
+  cfbp = (LTDC_Layer_InitStruct->LTDC_CFBPitch << 16);
+  LTDC_Layerx->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
+  LTDC_Layerx->CFBLR  = (LTDC_Layer_InitStruct->LTDC_CFBLineLength | cfbp);
+
+  /* Configures the frame buffer line number */
+  LTDC_Layerx->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
+  LTDC_Layerx->CFBLNR  = (LTDC_Layer_InitStruct->LTDC_CFBLineNumber);
+
+}
+
+/**
+  * @brief  Fills each LTDC_Layer_InitStruct member with its default value.
+  * @param  LTDC_Layer_InitStruct: pointer to a LTDC_LayerTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+
+void LTDC_LayerStructInit(LTDC_Layer_InitTypeDef * LTDC_Layer_InitStruct)
+{
+  /*--------------- Reset Layer structure parameters values -------------------*/
+
+  /*!< Initialize the horizontal limit member */
+  LTDC_Layer_InitStruct->LTDC_HorizontalStart = 0x00;
+  LTDC_Layer_InitStruct->LTDC_HorizontalStop = 0x00;
+
+  /*!< Initialize the vertical limit member */
+  LTDC_Layer_InitStruct->LTDC_VerticalStart = 0x00;
+  LTDC_Layer_InitStruct->LTDC_VerticalStop = 0x00;
+
+  /*!< Initialize the pixel format member */
+  LTDC_Layer_InitStruct->LTDC_PixelFormat = LTDC_Pixelformat_ARGB8888;
+
+  /*!< Initialize the constant alpha value */
+  LTDC_Layer_InitStruct->LTDC_ConstantAlpha = 0xFF;
+
+  /*!< Initialize the default color values */
+  LTDC_Layer_InitStruct->LTDC_DefaultColorBlue = 0x00;
+  LTDC_Layer_InitStruct->LTDC_DefaultColorGreen = 0x00;
+  LTDC_Layer_InitStruct->LTDC_DefaultColorRed = 0x00;
+  LTDC_Layer_InitStruct->LTDC_DefaultColorAlpha = 0x00;
+
+  /*!< Initialize the blending factors */
+  LTDC_Layer_InitStruct->LTDC_BlendingFactor_1 = LTDC_BlendingFactor1_PAxCA;
+  LTDC_Layer_InitStruct->LTDC_BlendingFactor_2 = LTDC_BlendingFactor2_PAxCA;
+
+  /*!< Initialize the frame buffer start address */
+  LTDC_Layer_InitStruct->LTDC_CFBStartAdress = 0x00;
+
+  /*!< Initialize the frame buffer pitch and line length */
+  LTDC_Layer_InitStruct->LTDC_CFBLineLength = 0x00;
+  LTDC_Layer_InitStruct->LTDC_CFBPitch = 0x00;
+
+  /*!< Initialize the frame buffer line number */
+  LTDC_Layer_InitStruct->LTDC_CFBLineNumber = 0x00;
+}
+
+
+/**
+  * @brief  Enables or disables the LTDC_Layer Controller.
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2
+  * @param  NewState: new state of the LTDC_Layer peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+
+void LTDC_LayerCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable LTDC_Layer by setting LEN bit */
+    LTDC_Layerx->CR |= (uint32_t)LTDC_LxCR_LEN;
+  }
+  else
+  {
+    /* Disable LTDC_Layer by clearing LEN bit */
+    LTDC_Layerx->CR &= ~(uint32_t)LTDC_LxCR_LEN;
+  }
+}
+
+
+/**
+  * @brief  Get the current position.
+  * @param  LTDC_Pos_InitStruct: pointer to a LTDC_PosTypeDef structure that contains
+  *         the current position.
+  * @retval None
+  */
+
+LTDC_PosTypeDef LTDC_GetPosStatus(void)
+{
+  LTDC_PosTypeDef LTDC_Pos_InitStruct;
+
+  LTDC->CPSR &= ~(LTDC_CPSR_CYPOS | LTDC_CPSR_CXPOS);
+
+  LTDC_Pos_InitStruct.LTDC_POSX = (uint32_t)(LTDC->CPSR >> 16);
+  LTDC_Pos_InitStruct.LTDC_POSY = (uint32_t)(LTDC->CPSR & 0xFFFF);
+
+  return LTDC_Pos_InitStruct;
+}
+
+/**
+  * @brief  Fills each LTDC_Pos_InitStruct member with its default value.
+  * @param  LTDC_Pos_InitStruct: pointer to a LTDC_PosTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+
+void LTDC_PosStructInit(LTDC_PosTypeDef* LTDC_Pos_InitStruct)
+{
+  LTDC_Pos_InitStruct->LTDC_POSX = 0x00;
+  LTDC_Pos_InitStruct->LTDC_POSY = 0x00;
+}
+
+/**
+  * @brief  Checks whether the specified LTDC's flag is set or not.
+  * @param  LTDC_CD: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg LTDC_CD_VDES: vertical data enable current status.
+  *     @arg LTDC_CD_HDES: horizontal data enable current status.
+  *     @arg LTDC_CD_VSYNC:  Vertical Synchronization current status.
+  *     @arg LTDC_CD_HSYNC:  Horizontal Synchronization current status.
+  * @retval The new state of LTDC_CD (SET or RESET).
+  */
+
+FlagStatus LTDC_GetCDStatus(uint32_t LTDC_CD)
+{
+  FlagStatus bitstatus;
+
+  /* Check the parameters */
+  assert_param(IS_LTDC_GET_CD(LTDC_CD));
+
+  if ((LTDC->CDSR & LTDC_CD) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Set and configure the color keying.
+  * @param  LTDC_colorkeying_InitStruct: pointer to a LTDC_ColorKeying_InitTypeDef 
+  *         structure that contains the color keying configuration.
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2   
+  * @retval None
+  */
+
+void LTDC_ColorKeyingConfig(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct, FunctionalState NewState)
+{ 
+  uint32_t ckgreen = 0;
+  uint32_t ckred = 0;
+
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_LTDC_CKEYING(LTDC_colorkeying_InitStruct->LTDC_ColorKeyBlue));
+  assert_param(IS_LTDC_CKEYING(LTDC_colorkeying_InitStruct->LTDC_ColorKeyGreen));
+  assert_param(IS_LTDC_CKEYING(LTDC_colorkeying_InitStruct->LTDC_ColorKeyRed));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable LTDC color keying by setting COLKEN bit */
+    LTDC_Layerx->CR |= (uint32_t)LTDC_LxCR_COLKEN;
+    
+    /* Sets the color keying values */
+    ckgreen = (LTDC_colorkeying_InitStruct->LTDC_ColorKeyGreen << 8);
+    ckred = (LTDC_colorkeying_InitStruct->LTDC_ColorKeyRed << 16);
+    LTDC_Layerx->CKCR  &= ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
+    LTDC_Layerx->CKCR |= (LTDC_colorkeying_InitStruct->LTDC_ColorKeyBlue | ckgreen | ckred);
+  }
+  else
+  {
+    /* Disable LTDC color keying by clearing COLKEN bit */
+    LTDC_Layerx->CR &= ~(uint32_t)LTDC_LxCR_COLKEN;
+  }
+  
+  /* Reload shadow register */
+  LTDC->SRCR = LTDC_IMReload;
+}
+
+/**
+  * @brief  Fills each LTDC_colorkeying_InitStruct member with its default value.
+  * @param  LTDC_colorkeying_InitStruct: pointer to a LTDC_ColorKeying_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+
+void LTDC_ColorKeyingStructInit(LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct)
+{
+  /*!< Initialize the color keying values */
+  LTDC_colorkeying_InitStruct->LTDC_ColorKeyBlue = 0x00;
+  LTDC_colorkeying_InitStruct->LTDC_ColorKeyGreen = 0x00;
+  LTDC_colorkeying_InitStruct->LTDC_ColorKeyRed = 0x00;
+}
+
+
+/**
+  * @brief  Enables or disables CLUT.
+  * @param  NewState: new state of CLUT.
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2  
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+
+void LTDC_CLUTCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable CLUT by setting CLUTEN bit */
+    LTDC_Layerx->CR |= (uint32_t)LTDC_LxCR_CLUTEN;
+  }
+  else
+  {
+    /* Disable CLUT by clearing CLUTEN bit */
+    LTDC_Layerx->CR &= ~(uint32_t)LTDC_LxCR_CLUTEN;
+  }
+  
+  /* Reload shadow register */
+  LTDC->SRCR = LTDC_IMReload;
+}
+
+/**
+  * @brief  configure the CLUT.
+  * @param  LTDC_CLUT_InitStruct: pointer to a LTDC_CLUT_InitTypeDef structure that contains
+  *         the CLUT configuration.
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2   
+  * @retval None
+  */
+
+void LTDC_CLUTInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct)
+{  
+  uint32_t green = 0;
+  uint32_t red = 0;
+  uint32_t clutadd = 0;
+
+  /* Check the parameters */
+  assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_CLUTAdress));
+  assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_RedValue));
+  assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_GreenValue));
+  assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_BlueValue));
+    
+  /* Specifies the CLUT address and RGB value */
+  green = (LTDC_CLUT_InitStruct->LTDC_GreenValue << 8);
+  red = (LTDC_CLUT_InitStruct->LTDC_RedValue << 16);
+  clutadd = (LTDC_CLUT_InitStruct->LTDC_CLUTAdress << 24);
+  LTDC_Layerx->CLUTWR  = (clutadd | LTDC_CLUT_InitStruct->LTDC_BlueValue | \
+                              green | red);
+}
+
+/**
+  * @brief  Fills each LTDC_CLUT_InitStruct member with its default value.
+  * @param  LTDC_CLUT_InitStruct: pointer to a LTDC_CLUT_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+
+void LTDC_CLUTStructInit(LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct)
+{
+  /*!< Initialize the CLUT adress and RGB values */
+  LTDC_CLUT_InitStruct->LTDC_CLUTAdress = 0x00;
+  LTDC_CLUT_InitStruct->LTDC_BlueValue = 0x00;
+  LTDC_CLUT_InitStruct->LTDC_GreenValue = 0x00;
+  LTDC_CLUT_InitStruct->LTDC_RedValue = 0x00;
+}
+
+
+/**
+  * @brief  reconfigure the layer position.
+  * @param  OffsetX: horizontal offset from start active width .
+  * @param  OffsetY: vertical offset from start active height.   
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2   
+  * @retval Reload of the shadow registers values must be applied after layer 
+  *         position reconfiguration.
+  */
+
+void LTDC_LayerPosition(LTDC_Layer_TypeDef* LTDC_Layerx, uint16_t OffsetX, uint16_t OffsetY)
+{
+  
+  uint32_t tempreg, temp;
+  uint32_t horizontal_start;
+  uint32_t horizontal_stop;
+  uint32_t vertical_start;
+  uint32_t vertical_stop;
+  
+  LTDC_Layerx->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
+  LTDC_Layerx->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
+  
+  /* Reconfigures the horizontal and vertical start position */
+  tempreg = LTDC->BPCR;
+  horizontal_start = (tempreg >> 16) + 1 + OffsetX;
+  vertical_start = (tempreg & 0xFFFF) + 1 + OffsetY;
+  
+  /* Reconfigures the horizontal and vertical stop position */
+  /* Get the number of byte per pixel */
+  
+  tempreg = LTDC_Layerx->PFCR;
+  
+  if (tempreg == LTDC_Pixelformat_ARGB8888)
+  {
+    temp = 4;
+  }
+  else if (tempreg == LTDC_Pixelformat_RGB888)
+  {
+    temp = 3;
+  }
+  else if ((tempreg == LTDC_Pixelformat_ARGB4444) || 
+          (tempreg == LTDC_Pixelformat_RGB565)    ||  
+          (tempreg == LTDC_Pixelformat_ARGB1555)  ||
+          (tempreg == LTDC_Pixelformat_AL88))
+  {
+    temp = 2;  
+  }
+  else
+  {
+    temp = 1;
+  }  
+    
+  tempreg = LTDC_Layerx->CFBLR;
+  horizontal_stop = (((tempreg & 0x1FFF) - 3)/temp) + horizontal_start - 1;
+  
+  tempreg = LTDC_Layerx->CFBLNR;
+  vertical_stop = (tempreg & 0x7FF) + vertical_start - 1;  
+  
+  LTDC_Layerx->WHPCR = horizontal_start | (horizontal_stop << 16);
+  LTDC_Layerx->WVPCR = vertical_start | (vertical_stop << 16);  
+}
+  
+/**
+  * @brief  reconfigure constant alpha.
+  * @param  ConstantAlpha: constant alpha value.
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2    
+  * @retval Reload of the shadow registers values must be applied after constant 
+  *         alpha reconfiguration.         
+  */
+
+void LTDC_LayerAlpha(LTDC_Layer_TypeDef* LTDC_Layerx, uint8_t ConstantAlpha)
+{  
+  /* reconfigure the constant alpha value */      
+  LTDC_Layerx->CACR = ConstantAlpha;
+}
+
+/**
+  * @brief  reconfigure layer address.
+  * @param  Address: The color frame buffer start address.
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2     
+  * @retval Reload of the shadow registers values must be applied after layer 
+  *         address reconfiguration.
+  */
+
+void LTDC_LayerAddress(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Address)
+{
+  /* Reconfigures the color frame buffer start address */
+  LTDC_Layerx->CFBAR = Address;
+}
+  
+/**
+  * @brief  reconfigure layer size.
+  * @param  Width: layer window width.
+  * @param  Height: layer window height.   
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2   
+  * @retval Reload of the shadow registers values must be applied after layer 
+  *         size reconfiguration.
+  */
+
+void LTDC_LayerSize(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Width, uint32_t Height)
+{
+
+  uint8_t temp;
+  uint32_t tempreg;
+  uint32_t horizontal_start;
+  uint32_t horizontal_stop;
+  uint32_t vertical_start;
+  uint32_t vertical_stop;  
+  
+  tempreg = LTDC_Layerx->PFCR;
+  
+  if (tempreg == LTDC_Pixelformat_ARGB8888)
+  {
+    temp = 4;
+  }
+  else if (tempreg == LTDC_Pixelformat_RGB888)
+  {
+    temp = 3;
+  }
+  else if ((tempreg == LTDC_Pixelformat_ARGB4444) || \
+          (tempreg == LTDC_Pixelformat_RGB565)    || \
+          (tempreg == LTDC_Pixelformat_ARGB1555)  || \
+          (tempreg == LTDC_Pixelformat_AL88))
+  {
+    temp = 2;  
+  }
+  else
+  {
+    temp = 1;
+  }
+
+  /* update horizontal and vertical stop */
+  tempreg = LTDC_Layerx->WHPCR;
+  horizontal_start = (tempreg & 0x1FFF);
+  horizontal_stop = Width + horizontal_start - 1;  
+
+  tempreg = LTDC_Layerx->WVPCR;
+  vertical_start = (tempreg & 0x1FFF);
+  vertical_stop = Height + vertical_start - 1;  
+  
+  LTDC_Layerx->WHPCR = horizontal_start | (horizontal_stop << 16);
+  LTDC_Layerx->WVPCR = vertical_start | (vertical_stop << 16);  
+
+  /* Reconfigures the color frame buffer pitch in byte */
+  LTDC_Layerx->CFBLR  = ((Width * temp) << 16) | ((Width * temp) + 3);  
+
+  /* Reconfigures the frame buffer line number */
+  LTDC_Layerx->CFBLNR  = Height;  
+  
+}
+
+/**
+  * @brief  reconfigure layer pixel format.
+  * @param  PixelFormat: reconfigure the pixel format, this parameter can be 
+  *         one of the following values:@ref LTDC_Pixelformat.   
+  * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
+  *         one of the following values: LTDC_Layer1, LTDC_Layer2   
+  * @retval Reload of the shadow registers values must be applied after layer 
+  *         pixel format reconfiguration.
+  */
+
+void LTDC_LayerPixelFormat(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t PixelFormat)
+{
+
+  uint8_t temp;
+  uint32_t tempreg;
+  
+  tempreg = LTDC_Layerx->PFCR;
+  
+  if (tempreg == LTDC_Pixelformat_ARGB8888)
+  {
+    temp = 4;
+  }
+  else if (tempreg == LTDC_Pixelformat_RGB888)
+  {
+    temp = 3;
+  }
+  else if ((tempreg == LTDC_Pixelformat_ARGB4444) || \
+          (tempreg == LTDC_Pixelformat_RGB565)    || \
+          (tempreg == LTDC_Pixelformat_ARGB1555)  || \
+          (tempreg == LTDC_Pixelformat_AL88))  
+  {
+    temp = 2;  
+  }
+  else
+  {
+    temp = 1;
+  }
+  
+  tempreg = (LTDC_Layerx->CFBLR >> 16);
+  tempreg = (tempreg / temp); 
+  
+  if (PixelFormat == LTDC_Pixelformat_ARGB8888)
+  {
+    temp = 4;
+  }
+  else if (PixelFormat == LTDC_Pixelformat_RGB888)
+  {
+    temp = 3;
+  }
+  else if ((PixelFormat == LTDC_Pixelformat_ARGB4444) || \
+          (PixelFormat == LTDC_Pixelformat_RGB565)    || \
+          (PixelFormat == LTDC_Pixelformat_ARGB1555)  || \
+          (PixelFormat == LTDC_Pixelformat_AL88))
+  {
+    temp = 2;  
+  }
+  else
+  {
+    temp = 1;
+  }
+  
+  /* Reconfigures the color frame buffer pitch in byte */
+  LTDC_Layerx->CFBLR  = ((tempreg * temp) << 16) | ((tempreg * temp) + 3);  
+
+  /* Reconfigures the color frame buffer start address */
+  LTDC_Layerx->PFCR = PixelFormat;
+    
+}
+    
+/**
+  * @}
+  */
+
+/** @defgroup LTDC_Group2 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim
+ ===============================================================================
+            ##### Interrupts and flags management functions #####
+ ===============================================================================
+
+    [..] This section provides functions allowing to configure the LTDC Interrupts 
+         and to get the status and clear flags and Interrupts pending bits.
+  
+    [..] The LTDC provides 4 Interrupts sources and 4 Flags
+    
+    *** Flags ***
+    =============
+    [..]
+      (+) LTDC_FLAG_LI:   Line Interrupt flag.
+      (+) LTDC_FLAG_FU:   FIFO Underrun Interrupt flag.
+      (+) LTDC_FLAG_TERR: Transfer Error Interrupt flag.
+      (+) LTDC_FLAG_RR:   Register Reload interrupt flag.
+      
+    *** Interrupts ***
+    ==================
+    [..]
+      (+) LTDC_IT_LI: Line Interrupt is generated when a programmed line 
+                      is reached. The line interrupt position is programmed in 
+                      the LTDC_LIPR register.
+      (+) LTDC_IT_FU: FIFO Underrun interrupt is generated when a pixel is requested 
+                      from an empty layer FIFO
+      (+) LTDC_IT_TERR: Transfer Error interrupt is generated when an AHB bus 
+                        error occurs during data transfer.
+      (+) LTDC_IT_RR: Register Reload interrupt is generated when the shadow 
+                      registers reload was performed during the vertical blanking 
+                      period.
+               
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified LTDC's interrupts.
+  * @param  LTDC_IT: specifies the LTDC interrupts sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg LTDC_IT_LI: Line Interrupt Enable.
+  *     @arg LTDC_IT_FU: FIFO Underrun Interrupt Enable.
+  *     @arg LTDC_IT_TERR: Transfer Error Interrupt Enable.
+  *     @arg LTDC_IT_RR: Register Reload interrupt enable.  
+  * @param NewState: new state of the specified LTDC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void LTDC_ITConfig(uint32_t LTDC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_LTDC_IT(LTDC_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    LTDC->IER |= LTDC_IT;
+  }
+  else
+  {
+    LTDC->IER &= (uint32_t)~LTDC_IT;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified LTDC's flag is set or not.
+  * @param  LTDC_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg LTDC_FLAG_LI:    Line Interrupt flag.
+  *     @arg LTDC_FLAG_FU:   FIFO Underrun Interrupt flag.
+  *     @arg LTDC_FLAG_TERR: Transfer Error Interrupt flag.
+  *     @arg LTDC_FLAG_RR:   Register Reload interrupt flag.
+  * @retval The new state of LTDC_FLAG (SET or RESET).
+  */
+FlagStatus LTDC_GetFlagStatus(uint32_t LTDC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_LTDC_FLAG(LTDC_FLAG));
+
+  if ((LTDC->ISR & LTDC_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the LTDC's pending flags.
+  * @param  LTDC_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg LTDC_FLAG_LI:    Line Interrupt flag.
+  *     @arg LTDC_FLAG_FU:   FIFO Underrun Interrupt flag.
+  *     @arg LTDC_FLAG_TERR: Transfer Error Interrupt flag.
+  *     @arg LTDC_FLAG_RR:   Register Reload interrupt flag.  
+  * @retval None
+  */
+void LTDC_ClearFlag(uint32_t LTDC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_LTDC_FLAG(LTDC_FLAG));
+
+  /* Clear the corresponding LTDC flag */
+  LTDC->ICR = (uint32_t)LTDC_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified LTDC's interrupt has occurred or not.
+  * @param  LTDC_IT: specifies the LTDC interrupts sources to check.
+  *   This parameter can be one of the following values:
+  *     @arg LTDC_IT_LI:    Line Interrupt Enable.
+  *     @arg LTDC_IT_FU:   FIFO Underrun Interrupt Enable.
+  *     @arg LTDC_IT_TERR: Transfer Error Interrupt Enable.
+  *     @arg LTDC_IT_RR:   Register Reload interrupt Enable.
+  * @retval The new state of the LTDC_IT (SET or RESET).
+  */
+ITStatus LTDC_GetITStatus(uint32_t LTDC_IT)
+{
+  ITStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_LTDC_IT(LTDC_IT));
+
+  if ((LTDC->ISR & LTDC_IT) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  if (((LTDC->IER & LTDC_IT) != (uint32_t)RESET) && (bitstatus != (uint32_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+
+/**
+  * @brief  Clears the LTDC's interrupt pending bits.
+  * @param  LTDC_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg LTDC_IT_LIE:    Line Interrupt.
+  *     @arg LTDC_IT_FUIE:   FIFO Underrun Interrupt.
+  *     @arg LTDC_IT_TERRIE: Transfer Error Interrupt.
+  *     @arg LTDC_IT_RRIE:   Register Reload interrupt.
+  * @retval None
+  */
+void LTDC_ClearITPendingBit(uint32_t LTDC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_LTDC_IT(LTDC_IT));
+
+  /* Clear the corresponding LTDC Interrupt */
+  LTDC->ICR = (uint32_t)LTDC_IT;
+}
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c
new file mode 100644
index 0000000..8fce4b1
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c
@@ -0,0 +1,939 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_pwr.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Power Controller (PWR) peripheral:           
+  *           + Backup Domain Access
+  *           + PVD configuration
+  *           + WakeUp pin configuration
+  *           + Main and Backup Regulators configuration
+  *           + FLASH Power Down configuration
+  *           + Low Power modes configuration
+  *           + Flags management
+  *               
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_pwr.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup PWR 
+  * @brief PWR driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* --------- PWR registers bit address in the alias region ---------- */
+#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
+
+/* --- CR Register ---*/
+
+/* Alias word address of DBP bit */
+#define CR_OFFSET                (PWR_OFFSET + 0x00)
+#define DBP_BitNumber            0x08
+#define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
+
+/* Alias word address of PVDE bit */
+#define PVDE_BitNumber           0x04
+#define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
+
+/* Alias word address of FPDS bit */
+#define FPDS_BitNumber           0x09
+#define CR_FPDS_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (FPDS_BitNumber * 4))
+
+/* Alias word address of PMODE bit */
+#define PMODE_BitNumber           0x0E
+#define CR_PMODE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PMODE_BitNumber * 4))
+
+/* Alias word address of ODEN bit */
+#define ODEN_BitNumber           0x10
+#define CR_ODEN_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (ODEN_BitNumber * 4))
+
+/* Alias word address of ODSWEN bit */
+#define ODSWEN_BitNumber         0x11
+#define CR_ODSWEN_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (ODSWEN_BitNumber * 4))
+
+/* Alias word address of MRLVDS bit */
+#define MRLVDS_BitNumber         0x0B
+#define CR_MRLVDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (MRLVDS_BitNumber * 4))
+
+/* Alias word address of LPLVDS bit */
+#define LPLVDS_BitNumber         0x0A
+#define CR_LPLVDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (LPLVDS_BitNumber * 4))
+
+/* --- CSR Register ---*/
+
+/* Alias word address of EWUP bit */
+#define CSR_OFFSET               (PWR_OFFSET + 0x04)
+#define EWUP_BitNumber           0x08
+#define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
+
+/* Alias word address of BRE bit */
+#define BRE_BitNumber            0x09
+#define CSR_BRE_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (BRE_BitNumber * 4))
+
+/* ------------------ PWR registers bit mask ------------------------ */
+
+/* CR register bit mask */
+#define CR_DS_MASK               ((uint32_t)0xFFFFF3FC)
+#define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
+#define CR_VOS_MASK              ((uint32_t)0xFFFF3FFF)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup PWR_Private_Functions
+  * @{
+  */
+
+/** @defgroup PWR_Group1 Backup Domain Access function 
+ *  @brief   Backup Domain Access function  
+ *
+@verbatim   
+ ===============================================================================
+                  ##### Backup Domain Access function #####
+ ===============================================================================  
+    [..]
+      After reset, the backup domain (RTC registers, RTC backup data 
+      registers and backup SRAM) is protected against possible unwanted 
+      write accesses. 
+      To enable access to the RTC Domain and RTC registers, proceed as follows:
+        (+) Enable the Power Controller (PWR) APB1 interface clock using the
+            RCC_APB1PeriphClockCmd() function.
+        (+) Enable access to RTC domain using the PWR_BackupAccessCmd() function.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
+  * @param  None
+  * @retval None
+  */
+void PWR_DeInit(void)
+{
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
+}
+
+/**
+  * @brief  Enables or disables access to the backup domain (RTC registers, RTC 
+  *         backup data registers and backup SRAM).
+  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
+  *         Backup Domain Access should be kept enabled.
+  * @param  NewState: new state of the access to the backup domain.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_BackupAccessCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Group2 PVD configuration functions
+ *  @brief   PVD configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+                    ##### PVD configuration functions #####
+ ===============================================================================  
+    [..]
+      (+) The PVD is used to monitor the VDD power supply by comparing it to a 
+          threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
+      (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower 
+          than the PVD threshold. This event is internally connected to the EXTI 
+          line16 and can generate an interrupt if enabled through the EXTI registers.
+      (+) The PVD is stopped in Standby mode.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
+  * @param  PWR_PVDLevel: specifies the PVD detection level
+  *          This parameter can be one of the following values:
+  *            @arg PWR_PVDLevel_0
+  *            @arg PWR_PVDLevel_1
+  *            @arg PWR_PVDLevel_2
+  *            @arg PWR_PVDLevel_3
+  *            @arg PWR_PVDLevel_4
+  *            @arg PWR_PVDLevel_5
+  *            @arg PWR_PVDLevel_6
+  *            @arg PWR_PVDLevel_7
+  * @note   Refer to the electrical characteristics of your device datasheet for
+  *         more details about the voltage threshold corresponding to each 
+  *         detection level.
+  * @retval None
+  */
+void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
+  
+  tmpreg = PWR->CR;
+  
+  /* Clear PLS[7:5] bits */
+  tmpreg &= CR_PLS_MASK;
+  
+  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
+  tmpreg |= PWR_PVDLevel;
+  
+  /* Store the new value */
+  PWR->CR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the Power Voltage Detector(PVD).
+  * @param  NewState: new state of the PVD.
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_PVDCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Group3 WakeUp pin configuration functions
+ *  @brief   WakeUp pin configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+                 ##### WakeUp pin configuration functions #####
+ ===============================================================================  
+    [..]
+      (+) WakeUp pin is used to wakeup the system from Standby mode. This pin is 
+          forced in input pull down configuration and is active on rising edges.
+      (+) There is only one WakeUp pin: WakeUp Pin 1 on PA.00.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the WakeUp Pin functionality.
+  * @param  NewState: new state of the WakeUp Pin functionality.
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_WakeUpPinCmd(FunctionalState NewState)
+{
+  /* Check the parameters */  
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Group4 Main and Backup Regulators configuration functions
+ *  @brief   Main and Backup Regulators configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+          ##### Main and Backup Regulators configuration functions #####
+ ===============================================================================  
+    [..]
+      (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
+          the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
+          retained even in Standby or VBAT mode when the low power backup regulator
+          is enabled. It can be considered as an internal EEPROM when VBAT is 
+          always present. You can use the PWR_BackupRegulatorCmd() function to 
+          enable the low power backup regulator and use the PWR_GetFlagStatus
+          (PWR_FLAG_BRR) to check if it is ready or not. 
+
+      (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
+          the backup SRAM is powered from VDD which replaces the VBAT power supply to 
+          save battery life.
+
+      (+) The backup SRAM is not mass erased by an tamper event. It is read 
+          protected to prevent confidential data, such as cryptographic private 
+          key, from being accessed. The backup SRAM can be erased only through 
+          the Flash interface when a protection level change from level 1 to 
+          level 0 is requested. 
+      -@- Refer to the description of Read protection (RDP) in the reference manual.
+
+      (+) The main internal regulator can be configured to have a tradeoff between 
+          performance and power consumption when the device does not operate at 
+          the maximum frequency. 
+      (+) For STM32F405xx/407xx and STM32F415xx/417xx  Devices, the regulator can be     
+          configured on the fly through PWR_MainRegulatorModeConfig() function which  
+          configure VOS bit in PWR_CR register:
+        (++) When this bit is set (Regulator voltage output Scale 1 mode selected) 
+             the System frequency can go up to 168 MHz. 
+        (++) When this bit is reset (Regulator voltage output Scale 2 mode selected) 
+             the System frequency can go up to 144 MHz.
+             
+       (+) For STM32F42xxx/43xxx Devices, the regulator can be configured through    
+           PWR_MainRegulatorModeConfig() function which configure VOS[1:0] bits in
+           PWR_CR register:  
+           which configure VOS[1:0] bits in PWR_CR register: 
+        (++) When VOS[1:0] = 11 (Regulator voltage output Scale 1 mode selected) 
+             the System frequency can go up to 168 MHz. 
+        (++) When VOS[1:0] = 10 (Regulator voltage output Scale 2 mode selected) 
+             the System frequency can go up to 144 MHz.  
+        (++) When VOS[1:0] = 01 (Regulator voltage output Scale 3 mode selected) 
+             the System frequency can go up to 120 MHz. 
+                          
+       (+) For STM32F42xxx/43xxx Devices, the scale can be modified only when the PLL 
+           is OFF and the HSI or HSE clock source is selected as system clock. 
+           The new value programmed is active only when the PLL is ON.
+           When the PLL is OFF, the voltage scale 3 is automatically selected. 
+        Refer to the datasheets for more details.
+        
+       (+) For STM32F42xxx/43xxx Devices, in Run mode: the main regulator has
+           2 operating modes available:
+        (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
+             voltage scaling (scale 1, scale 2 or scale 3)
+        (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
+            higher frequency than the normal mode for a given voltage scaling (scale 1,  
+            scale 2 or scale 3). This mode is enabled through PWR_OverDriveCmd() function and
+            PWR_OverDriveSWCmd() function, to enter or exit from Over-drive mode please follow 
+            the sequence described in Reference manual.
+             
+       (+) For STM32F42xxx/43xxx Devices, in Stop mode: the main regulator or low power regulator 
+           supplies a low power voltage to the 1.2V domain, thus preserving the content of registers 
+           and internal SRAM. 2 operating modes are available:
+         (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
+              available when the main regulator or the low power regulator is used in Scale 3 or 
+              low voltage mode.
+         (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is only
+              available when the main regulator or the low power regulator is in low voltage mode.
+              This mode is enabled through PWR_UnderDriveCmd() function.
+            
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the Backup Regulator.
+  * @param  NewState: new state of the Backup Regulator.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_BackupRegulatorCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the main internal regulator output voltage.
+  * @param  PWR_Regulator_Voltage: specifies the regulator output voltage to achieve
+  *         a tradeoff between performance and power consumption when the device does
+  *         not operate at the maximum frequency (refer to the datasheets for more details).
+  *          This parameter can be one of the following values:
+  *            @arg PWR_Regulator_Voltage_Scale1: Regulator voltage output Scale 1 mode, 
+  *                                                System frequency up to 168 MHz. 
+  *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
+  *                                                System frequency up to 144 MHz.    
+  *            @arg PWR_Regulator_Voltage_Scale3: Regulator voltage output Scale 3 mode, 
+  *                                                System frequency up to 120 MHz (only for STM32F42xxx/43xxx devices)
+  * @retval None
+  */
+void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
+{
+  uint32_t tmpreg = 0;
+	
+  /* Check the parameters */
+  assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
+
+  tmpreg = PWR->CR;
+  
+  /* Clear VOS[15:14] bits */
+  tmpreg &= CR_VOS_MASK;
+  
+  /* Set VOS[15:14] bits according to PWR_Regulator_Voltage value */
+  tmpreg |= PWR_Regulator_Voltage;
+  
+  /* Store the new value */
+  PWR->CR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the Over-Drive.
+  * 
+  * @note   This function can be used only for STM32F42xxx/STM3243xxx devices.
+  *         This mode allows the CPU and the core logic to operate at a higher frequency
+  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
+  * 
+  * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
+  *          critical tasks and when the system clock source is either HSI or HSE. 
+  *          During the Over-drive switch activation, no peripheral clocks should be enabled.   
+  *          The peripheral clocks must be enabled once the Over-drive mode is activated.
+  *            
+  * @param  NewState: new state of the Over Drive mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_OverDriveCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  /* Set/Reset the ODEN bit to enable/disable the Over Drive mode */
+  *(__IO uint32_t *) CR_ODEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the Over-Drive switching.
+  * 
+  * @note   This function can be used only for STM32F42xxx/STM3243xxx devices. 
+  *       
+  * @param  NewState: new state of the Over Drive switching mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_OverDriveSWCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* Set/Reset the ODSWEN bit to enable/disable the Over Drive switching mode */
+  *(__IO uint32_t *) CR_ODSWEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief   Enables or disables the Under-Drive mode.
+  * 
+  * @note   This function can be used only for STM32F42xxx/STM3243xxx devices.
+  * @note    This mode is enabled only with STOP low power mode.
+  *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
+  *          mode is only available when the main regulator or the low power regulator 
+  *          is in low voltage mode
+  *        
+  * @note   If the Under-drive mode was enabled, it is automatically disabled after 
+  *         exiting Stop mode. 
+  *         When the voltage regulator operates in Under-drive mode, an additional  
+  *         startup delay is induced when waking up from Stop mode.
+  *                    
+  * @param  NewState: new state of the Under Drive mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_UnderDriveCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the UDEN[1:0] bits to enable the Under Drive mode */
+    PWR->CR |= (uint32_t)PWR_CR_UDEN;
+  }
+  else
+  {
+    /* Reset the UDEN[1:0] bits to disable the Under Drive mode */
+    PWR->CR &= (uint32_t)(~PWR_CR_UDEN);
+  }
+}
+
+/**
+  * @brief Enables or disables the Main Regulator low voltage mode.
+  *
+  * @note  This mode is only available for STM32F401xx/STM32F411xx devices.
+  *
+  * @param  NewState: new state of the Under Drive mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_MainRegulatorLowVoltageCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)ENABLE;
+  }
+  else
+  {
+    *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;
+  }
+}
+
+/**
+  * @brief Enables or disables the Low Power Regulator low voltage mode.
+  *
+  * @note  This mode is only available for STM32F401xx/STM32F411xx devices.
+  *
+  * @param  NewState: new state of the Under Drive mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_LowRegulatorLowVoltageCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)ENABLE;
+  }
+  else
+  {
+    *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)DISABLE;
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Group5 FLASH Power Down configuration functions
+ *  @brief   FLASH Power Down configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+             ##### FLASH Power Down configuration functions #####
+ ===============================================================================  
+    [..]
+      (+) By setting the FPDS bit in the PWR_CR register by using the 
+          PWR_FlashPowerDownCmd() function, the Flash memory also enters power 
+          down mode when the device enters Stop mode. When the Flash memory 
+          is in power down mode, an additional startup delay is incurred when 
+          waking up from Stop mode.
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the Flash Power Down in STOP mode.
+  * @param  NewState: new state of the Flash power mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_FlashPowerDownCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Group6 Low Power modes configuration functions
+ *  @brief   Low Power modes configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Low Power modes configuration functions #####
+ ===============================================================================  
+    [..]
+      The devices feature 3 low-power modes:
+      (+) Sleep mode: Cortex-M4 core stopped, peripherals kept running.
+      (+) Stop mode: all clocks are stopped, regulator running, regulator 
+          in low power mode
+      (+) Standby mode: 1.2V domain powered off.
+   
+   *** Sleep mode ***
+   ==================
+    [..]
+      (+) Entry:
+        (++) The Sleep mode is entered by using the __WFI() or __WFE() functions.
+      (+) Exit:
+        (++) Any peripheral interrupt acknowledged by the nested vectored interrupt 
+             controller (NVIC) can wake up the device from Sleep mode.
+
+   *** Stop mode ***
+   =================
+    [..]
+      In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
+      and the HSE RC oscillators are disabled. Internal SRAM and register contents 
+      are preserved.
+      The voltage regulator can be configured either in normal or low-power mode.
+      To minimize the consumption In Stop mode, FLASH can be powered off before 
+      entering the Stop mode. It can be switched on again by software after exiting 
+      the Stop mode using the PWR_FlashPowerDownCmd() function. 
+   
+      (+) Entry:
+        (++) The Stop mode is entered using the PWR_EnterSTOPMode(PWR_MainRegulator_ON) 
+             function with:
+          (+++) Main regulator ON.
+          (+++) Low Power regulator ON.
+      (+) Exit:
+        (++) Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
+      
+   *** Standby mode ***
+   ====================
+    [..]
+      The Standby mode allows to achieve the lowest power consumption. It is based 
+      on the Cortex-M4 deepsleep mode, with the voltage regulator disabled. 
+      The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and 
+      the HSE oscillator are also switched off. SRAM and register contents are lost 
+      except for the RTC registers, RTC backup registers, backup SRAM and Standby 
+      circuitry.
+   
+      The voltage regulator is OFF.
+      
+      (+) Entry:
+        (++) The Standby mode is entered using the PWR_EnterSTANDBYMode() function.
+      (+) Exit:
+        (++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
+             tamper event, time-stamp event, external reset in NRST pin, IWDG reset.              
+
+   *** Auto-wakeup (AWU) from low-power mode ***
+   =============================================
+    [..]
+      The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
+      Wakeup event, a tamper event, a time-stamp event, or a comparator event, 
+      without depending on an external interrupt (Auto-wakeup mode).
+
+      (#) RTC auto-wakeup (AWU) from the Stop mode
+       
+        (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to:
+          (+++) Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt 
+                or Event modes) using the EXTI_Init() function.
+          (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
+          (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
+                and RTC_AlarmCmd() functions.
+        (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
+             is necessary to:
+          (+++) Configure the EXTI Line 21 to be sensitive to rising edges (Interrupt 
+                or Event modes) using the EXTI_Init() function.
+          (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
+                function
+          (+++) Configure the RTC to detect the tamper or time stamp event using the
+                RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
+                functions.
+        (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to:
+           (+++) Configure the EXTI Line 22 to be sensitive to rising edges (Interrupt 
+                 or Event modes) using the EXTI_Init() function.
+           (+++) Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
+           (+++) Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(), 
+                 RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
+
+      (#) RTC auto-wakeup (AWU) from the Standby mode
+   
+        (++) To wake up from the Standby mode with an RTC alarm event, it is necessary to:
+          (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
+          (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
+                and RTC_AlarmCmd() functions.
+        (++) To wake up from the Standby mode with an RTC Tamper or time stamp event, it 
+             is necessary to:
+          (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
+                function
+          (+++) Configure the RTC to detect the tamper or time stamp event using the
+                RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
+                functions.
+        (++) To wake up from the Standby mode with an RTC WakeUp event, it is necessary to:
+          (+++) Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
+          (+++) Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(), 
+                RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enters STOP mode.
+  *   
+  * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
+  * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
+  *         the HSI RC oscillator is selected as system clock.
+  * @note   When the voltage regulator operates in low power mode, an additional 
+  *         startup delay is incurred when waking up from Stop mode. 
+  *         By keeping the internal regulator ON during Stop mode, the consumption 
+  *         is higher although the startup time is reduced.
+  *     
+  * @param  PWR_Regulator: specifies the regulator state in STOP mode.
+  *          This parameter can be one of the following values:
+  *            @arg PWR_MainRegulator_ON: STOP mode with regulator ON
+  *            @arg PWR_LowPowerRegulator_ON: STOP mode with low power regulator ON
+  * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
+  *          This parameter can be one of the following values:
+  *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
+  *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
+  * @retval None
+  */
+void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
+  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
+  
+  /* Select the regulator state in STOP mode ---------------------------------*/
+  tmpreg = PWR->CR;
+  /* Clear PDDS and LPDS bits */
+  tmpreg &= CR_DS_MASK;
+  
+  /* Set LPDS, MRLVDS and LPLVDS bits according to PWR_Regulator value */
+  tmpreg |= PWR_Regulator;
+  
+  /* Store the new value */
+  PWR->CR = tmpreg;
+  
+  /* Set SLEEPDEEP bit of Cortex System Control Register */
+  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
+  
+  /* Select STOP mode entry --------------------------------------------------*/
+  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
+  {   
+    /* Request Wait For Interrupt */
+    __WFI();
+  }
+  else
+  {
+    /* Request Wait For Event */
+    __WFE();
+  }
+  /* Reset SLEEPDEEP bit of Cortex System Control Register */
+  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
+}
+
+/**
+  * @brief  Enters in Under-Drive STOP mode.
+  *  
+  * @note   This mode is only available for STM32F42xxx/STM3243xxx devices. 
+  * 
+  * @note    This mode can be selected only when the Under-Drive is already active 
+  *         
+  * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
+  * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
+  *         the HSI RC oscillator is selected as system clock.
+  * @note   When the voltage regulator operates in low power mode, an additional 
+  *         startup delay is incurred when waking up from Stop mode. 
+  *         By keeping the internal regulator ON during Stop mode, the consumption 
+  *         is higher although the startup time is reduced.
+  *     
+  * @param  PWR_Regulator: specifies the regulator state in STOP mode.
+  *          This parameter can be one of the following values:
+  *            @arg PWR_MainRegulator_UnderDrive_ON:  Main Regulator in under-drive mode 
+  *                 and Flash memory in power-down when the device is in Stop under-drive mode
+  *            @arg PWR_LowPowerRegulator_UnderDrive_ON:  Low Power Regulator in under-drive mode 
+  *                and Flash memory in power-down when the device is in Stop under-drive mode
+  * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
+  *          This parameter can be one of the following values:
+  *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
+  *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
+  * @retval None
+  */
+void PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_PWR_REGULATOR_UNDERDRIVE(PWR_Regulator));
+  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
+  
+  /* Select the regulator state in STOP mode ---------------------------------*/
+  tmpreg = PWR->CR;
+  /* Clear PDDS and LPDS bits */
+  tmpreg &= CR_DS_MASK;
+  
+  /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
+  tmpreg |= PWR_Regulator;
+  
+  /* Store the new value */
+  PWR->CR = tmpreg;
+  
+  /* Set SLEEPDEEP bit of Cortex System Control Register */
+  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
+  
+  /* Select STOP mode entry --------------------------------------------------*/
+  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
+  {   
+    /* Request Wait For Interrupt */
+    __WFI();
+  }
+  else
+  {
+    /* Request Wait For Event */
+    __WFE();
+  }
+  /* Reset SLEEPDEEP bit of Cortex System Control Register */
+  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
+}
+
+/**
+  * @brief  Enters STANDBY mode.
+  * @note   In Standby mode, all I/O pins are high impedance except for:
+  *          - Reset pad (still available) 
+  *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC 
+  *            Alarm out, or RTC clock calibration out.
+  *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
+  *          - WKUP pin 1 (PA0) if enabled.
+  * @note   The Wakeup flag (WUF) need to be cleared at application level before to call this function 
+  * @param  None
+  * @retval None
+  */
+void PWR_EnterSTANDBYMode(void)
+{
+  /* Select STANDBY mode */
+  PWR->CR |= PWR_CR_PDDS;
+  
+  /* Set SLEEPDEEP bit of Cortex System Control Register */
+  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
+  
+  /* This option is used to ensure that store operations are completed */
+#if defined ( __CC_ARM   )
+  __force_stores();
+#endif
+  /* Request Wait For Interrupt */
+  __WFI();
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Group7 Flags management functions
+ *  @brief   Flags management functions 
+ *
+@verbatim   
+ ===============================================================================
+                    ##### Flags management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Checks whether the specified PWR flag is set or not.
+  * @param  PWR_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
+  *                  was received from the WKUP pin or from the RTC alarm (Alarm A 
+  *                  or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
+  *                  An additional wakeup event is detected if the WKUP pin is enabled 
+  *                  (by setting the EWUP bit) when the WKUP pin level is already high.  
+  *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
+  *                  resumed from StandBy mode.    
+  *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
+  *                  by the PWR_PVDCmd() function. The PVD is stopped by Standby mode 
+  *                  For this reason, this bit is equal to 0 after Standby or reset
+  *                  until the PVDE bit is set.
+  *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
+  *                  when the device wakes up from Standby mode or by a system reset 
+  *                  or power reset.  
+  *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
+  *                 scaling output selection is ready.
+  *            @arg PWR_FLAG_ODRDY: This flag indicates that the Over-drive mode
+  *                 is ready (STM32F42xxx/43xxx devices) 
+  *            @arg PWR_FLAG_ODSWRDY: This flag indicates that the Over-drive mode
+  *                 switcching is ready (STM32F42xxx/43xxx devices) 
+  *            @arg PWR_FLAG_UDRDY: This flag indicates that the Under-drive mode
+  *                 is enabled in Stop mode (STM32F42xxx/43xxx devices)
+  * @retval The new state of PWR_FLAG (SET or RESET).
+  */
+FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
+  
+  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the PWR's pending flags.
+  * @param  PWR_FLAG: specifies the flag to clear.
+  *          This parameter can be one of the following values:
+  *            @arg PWR_FLAG_WU: Wake Up flag
+  *            @arg PWR_FLAG_SB: StandBy flag
+  *            @arg PWR_FLAG_UDRDY: Under-drive ready flag (STM32F42xxx/43xxx devices)
+  * @retval None
+  */
+void PWR_ClearFlag(uint32_t PWR_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
+  
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+  if (PWR_FLAG != PWR_FLAG_UDRDY)
+  {
+    PWR->CR |=  PWR_FLAG << 2;
+  }
+  else
+  {
+    PWR->CSR |= PWR_FLAG_UDRDY;
+  }
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+#if defined (STM32F40_41xxx) || defined (STM32F401xx) || defined (STM32F411xE) 
+  PWR->CR |=  PWR_FLAG << 2;
+#endif /* STM32F40_41xxx  || STM32F401xx || STM32F411xE */
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rcc.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rcc.c
new file mode 100644
index 0000000..24a01f6
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rcc.c
@@ -0,0 +1,2308 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_rcc.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Reset and clock control (RCC) peripheral:
+  *           + Internal/external clocks, PLL, CSS and MCO configuration
+  *           + System, AHB and APB busses clocks configuration
+  *           + Peripheral clocks configuration
+  *           + Interrupts and flags management
+  *
+ @verbatim                
+ ===============================================================================
+                      ##### RCC specific features #####
+ ===============================================================================
+    [..]  
+      After reset the device is running from Internal High Speed oscillator 
+      (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache 
+      and I-Cache are disabled, and all peripherals are off except internal
+      SRAM, Flash and JTAG.
+      (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
+          all peripherals mapped on these busses are running at HSI speed.
+      (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
+      (+) All GPIOs are in input floating state, except the JTAG pins which
+          are assigned to be used for debug purpose.
+    [..]          
+      Once the device started from reset, the user application has to:        
+      (+) Configure the clock source to be used to drive the System clock
+          (if the application needs higher frequency/performance)
+      (+) Configure the System clock frequency and Flash settings  
+      (+) Configure the AHB and APB busses prescalers
+      (+) Enable the clock for the peripheral(s) to be used
+      (+) Configure the clock source(s) for peripherals which clocks are not
+          derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)                                
+ @endverbatim    
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_rcc.h"
+#include "stm32f4xx_conf.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup RCC 
+  * @brief RCC driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ------------ RCC registers bit address in the alias region ----------- */
+#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
+/* --- CR Register ---*/
+/* Alias word address of HSION bit */
+#define CR_OFFSET                 (RCC_OFFSET + 0x00)
+#define HSION_BitNumber           0x00
+#define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
+/* Alias word address of CSSON bit */
+#define CSSON_BitNumber           0x13
+#define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
+/* Alias word address of PLLON bit */
+#define PLLON_BitNumber           0x18
+#define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
+/* Alias word address of PLLI2SON bit */
+#define PLLI2SON_BitNumber        0x1A
+#define CR_PLLI2SON_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLI2SON_BitNumber * 4))
+
+/* Alias word address of PLLSAION bit */
+#define PLLSAION_BitNumber        0x1C
+#define CR_PLLSAION_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLSAION_BitNumber * 4))
+
+/* --- CFGR Register ---*/
+/* Alias word address of I2SSRC bit */
+#define CFGR_OFFSET               (RCC_OFFSET + 0x08)
+#define I2SSRC_BitNumber          0x17
+#define CFGR_I2SSRC_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (I2SSRC_BitNumber * 4))
+
+/* --- BDCR Register ---*/
+/* Alias word address of RTCEN bit */
+#define BDCR_OFFSET               (RCC_OFFSET + 0x70)
+#define RTCEN_BitNumber           0x0F
+#define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
+/* Alias word address of BDRST bit */
+#define BDRST_BitNumber           0x10
+#define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
+
+/* --- CSR Register ---*/
+/* Alias word address of LSION bit */
+#define CSR_OFFSET                (RCC_OFFSET + 0x74)
+#define LSION_BitNumber           0x00
+#define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
+
+/* --- DCKCFGR Register ---*/
+/* Alias word address of TIMPRE bit */
+#define DCKCFGR_OFFSET            (RCC_OFFSET + 0x8C)
+#define TIMPRE_BitNumber          0x18
+#define DCKCFGR_TIMPRE_BB         (PERIPH_BB_BASE + (DCKCFGR_OFFSET * 32) + (TIMPRE_BitNumber * 4))
+/* ---------------------- RCC registers bit mask ------------------------ */
+/* CFGR register bit mask */
+#define CFGR_MCO2_RESET_MASK      ((uint32_t)0x07FFFFFF)
+#define CFGR_MCO1_RESET_MASK      ((uint32_t)0xF89FFFFF)
+
+/* RCC Flag Mask */
+#define FLAG_MASK                 ((uint8_t)0x1F)
+
+/* CR register byte 3 (Bits[23:16]) base address */
+#define CR_BYTE3_ADDRESS          ((uint32_t)0x40023802)
+
+/* CIR register byte 2 (Bits[15:8]) base address */
+#define CIR_BYTE2_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x01))
+
+/* CIR register byte 3 (Bits[23:16]) base address */
+#define CIR_BYTE3_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x02))
+
+/* BDCR register base address */
+#define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
+
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup RCC_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
+ *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
+ *
+@verbatim   
+ ===================================================================================
+ ##### Internal and  external clocks, PLL, CSS and MCO configuration functions #####
+ ===================================================================================  
+    [..]
+      This section provide functions allowing to configure the internal/external clocks,
+      PLLs, CSS and MCO pins.
+  
+      (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
+          the PLL as System clock source.
+
+      (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
+          clock source.
+
+      (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or
+          through the PLL as System clock source. Can be used also as RTC clock source.
+
+      (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
+
+      (#) PLL (clocked by HSI or HSE), featuring two different output clocks:
+        (++) The first output is used to generate the high speed system clock (up to 168 MHz)
+        (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),
+             the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).
+
+      (#) PLLI2S (clocked by HSI or HSE), used to generate an accurate clock to achieve 
+          high-quality audio performance on the I2S interface or SAI interface in case 
+          of STM32F429x/439x devices.
+     
+      (#) PLLSAI clocked by (HSI or HSE), used to generate an accurate clock to SAI 
+          interface and LCD TFT controller available only for STM32F42xxx/43xxx devices.
+  
+      (#) CSS (Clock security system), once enable and if a HSE clock failure occurs 
+         (HSE used directly or through PLL as System clock source), the System clock
+         is automatically switched to HSI and an interrupt is generated if enabled. 
+         The interrupt is linked to the Cortex-M4 NMI (Non-Maskable Interrupt) 
+         exception vector.   
+
+      (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL
+          clock (through a configurable prescaler) on PA8 pin.
+
+      (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S
+          clock (through a configurable prescaler) on PC9 pin.
+ @endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Resets the RCC clock configuration to the default reset state.
+  * @note   The default reset state of the clock configuration is given below:
+  *            - HSI ON and used as system clock source
+  *            - HSE, PLL and PLLI2S OFF
+  *            - AHB, APB1 and APB2 prescaler set to 1.
+  *            - CSS, MCO1 and MCO2 OFF
+  *            - All interrupts disabled
+  * @note   This function doesn't modify the configuration of the
+  *            - Peripheral clocks  
+  *            - LSI, LSE and RTC clocks 
+  * @param  None
+  * @retval None
+  */
+void RCC_DeInit(void)
+{
+  /* Set HSION bit */
+  RCC->CR |= (uint32_t)0x00000001;
+
+  /* Reset CFGR register */
+  RCC->CFGR = 0x00000000;
+
+  /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42/43xxx devices) bits */
+  RCC->CR &= (uint32_t)0xEAF6FFFF;
+
+  /* Reset PLLCFGR register */
+  RCC->PLLCFGR = 0x24003010;
+
+  /* Reset PLLI2SCFGR register */
+  RCC->PLLI2SCFGR = 0x20003000;
+
+  /* Reset PLLSAICFGR register, only available for STM32F42/43xxx devices */
+  RCC->PLLSAICFGR = 0x24003000;
+ 
+  /* Reset HSEBYP bit */
+  RCC->CR &= (uint32_t)0xFFFBFFFF;
+
+  /* Disable all interrupts */
+  RCC->CIR = 0x00000000;
+
+  /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx devices */
+  RCC->DCKCFGR = 0x00000000; 
+}
+
+/**
+  * @brief  Configures the External High Speed oscillator (HSE).
+  * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
+  *         software should wait on HSERDY flag to be set indicating that HSE clock
+  *         is stable and can be used to clock the PLL and/or system clock.
+  * @note   HSE state can not be changed if it is used directly or through the
+  *         PLL as system clock. In this case, you have to select another source
+  *         of the system clock then change the HSE state (ex. disable it).
+  * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.  
+  * @note   This function reset the CSSON bit, so if the Clock security system(CSS)
+  *         was previously enabled you have to enable it again after calling this
+  *         function.    
+  * @param  RCC_HSE: specifies the new state of the HSE.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
+  *                              6 HSE oscillator clock cycles.
+  *            @arg RCC_HSE_ON: turn ON the HSE oscillator
+  *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
+  * @retval None
+  */
+void RCC_HSEConfig(uint8_t RCC_HSE)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_HSE(RCC_HSE));
+
+  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
+  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
+
+  /* Set the new HSE configuration -------------------------------------------*/
+  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
+}
+
+/**
+  * @brief  Waits for HSE start-up.
+  * @note   This functions waits on HSERDY flag to be set and return SUCCESS if 
+  *         this flag is set, otherwise returns ERROR if the timeout is reached 
+  *         and this flag is not set. The timeout value is defined by the constant
+  *         HSE_STARTUP_TIMEOUT in stm32f4xx.h file. You can tailor it depending
+  *         on the HSE crystal used in your application. 
+  * @param  None
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: HSE oscillator is stable and ready to use
+  *          - ERROR: HSE oscillator not yet ready
+  */
+ErrorStatus RCC_WaitForHSEStartUp(void)
+{
+  __IO uint32_t startupcounter = 0;
+  ErrorStatus status = ERROR;
+  FlagStatus hsestatus = RESET;
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
+    startupcounter++;
+  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
+
+  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
+  {
+    status = SUCCESS;
+  }
+  else
+  {
+    status = ERROR;
+  }
+  return (status);
+}
+
+/**
+  * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
+  * @note   The calibration is used to compensate for the variations in voltage
+  *         and temperature that influence the frequency of the internal HSI RC.
+  * @param  HSICalibrationValue: specifies the calibration trimming value.
+  *         This parameter must be a number between 0 and 0x1F.
+  * @retval None
+  */
+void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
+
+  tmpreg = RCC->CR;
+
+  /* Clear HSITRIM[4:0] bits */
+  tmpreg &= ~RCC_CR_HSITRIM;
+
+  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
+  tmpreg |= (uint32_t)HSICalibrationValue << 3;
+
+  /* Store the new value */
+  RCC->CR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the Internal High Speed oscillator (HSI).
+  * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
+  *         It is used (enabled by hardware) as system clock source after startup
+  *         from Reset, wakeup from STOP and STANDBY mode, or in case of failure
+  *         of the HSE used directly or indirectly as system clock (if the Clock
+  *         Security System CSS is enabled).             
+  * @note   HSI can not be stopped if it is used as system clock source. In this case,
+  *         you have to select another source of the system clock then stop the HSI.  
+  * @note   After enabling the HSI, the application software should wait on HSIRDY
+  *         flag to be set indicating that HSI clock is stable and can be used as
+  *         system clock source.  
+  * @param  NewState: new state of the HSI.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
+  *         clock cycles.  
+  * @retval None
+  */
+void RCC_HSICmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the External Low Speed oscillator (LSE).
+  * @note   As the LSE is in the Backup domain and write access is denied to
+  *         this domain after reset, you have to enable write access using 
+  *         PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
+  *         (to be done once after reset).  
+  * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
+  *         software should wait on LSERDY flag to be set indicating that LSE clock
+  *         is stable and can be used to clock the RTC.
+  * @param  RCC_LSE: specifies the new state of the LSE.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
+  *                              6 LSE oscillator clock cycles.
+  *            @arg RCC_LSE_ON: turn ON the LSE oscillator
+  *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
+  * @retval None
+  */
+void RCC_LSEConfig(uint8_t RCC_LSE)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_LSE(RCC_LSE));
+
+  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
+  /* Reset LSEON bit */
+  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
+
+  /* Reset LSEBYP bit */
+  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
+
+  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
+  switch (RCC_LSE)
+  {
+    case RCC_LSE_ON:
+      /* Set LSEON bit */
+      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
+      break;
+    case RCC_LSE_Bypass:
+      /* Set LSEBYP and LSEON bits */
+      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
+      break;
+    default:
+      break;
+  }
+}
+
+/**
+  * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
+  * @note   After enabling the LSI, the application software should wait on 
+  *         LSIRDY flag to be set indicating that LSI clock is stable and can
+  *         be used to clock the IWDG and/or the RTC.
+  * @note   LSI can not be disabled if the IWDG is running.  
+  * @param  NewState: new state of the LSI.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
+  *         clock cycles. 
+  * @retval None
+  */
+void RCC_LSICmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the main PLL clock source, multiplication and division factors.
+  * @note   This function must be used only when the main PLL is disabled.
+  *  
+  * @param  RCC_PLLSource: specifies the PLL entry clock source.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_PLLSource_HSI: HSI oscillator clock selected as PLL clock entry
+  *            @arg RCC_PLLSource_HSE: HSE oscillator clock selected as PLL clock entry
+  * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
+  *  
+  * @param  PLLM: specifies the division factor for PLL VCO input clock
+  *          This parameter must be a number between 0 and 63.
+  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
+  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
+  *         of 2 MHz to limit PLL jitter.
+  *  
+  * @param  PLLN: specifies the multiplication factor for PLL VCO output clock
+  *          This parameter must be a number between 192 and 432.
+  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
+  *         output frequency is between 192 and 432 MHz.
+  *   
+  * @param  PLLP: specifies the division factor for main system clock (SYSCLK)
+  *          This parameter must be a number in the range {2, 4, 6, or 8}.
+  * @note   You have to set the PLLP parameter correctly to not exceed 168 MHz on
+  *         the System clock frequency.
+  *  
+  * @param  PLLQ: specifies the division factor for OTG FS, SDIO and RNG clocks
+  *          This parameter must be a number between 4 and 15.
+  * @note   If the USB OTG FS is used in your application, you have to set the
+  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
+  *         the SDIO and RNG need a frequency lower than or equal to 48 MHz to work
+  *         correctly.
+  *   
+  * @retval None
+  */
+void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
+  assert_param(IS_RCC_PLLM_VALUE(PLLM));
+  assert_param(IS_RCC_PLLN_VALUE(PLLN));
+  assert_param(IS_RCC_PLLP_VALUE(PLLP));
+  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
+
+  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
+                 (PLLQ << 24);
+}
+
+/**
+  * @brief  Enables or disables the main PLL.
+  * @note   After enabling the main PLL, the application software should wait on 
+  *         PLLRDY flag to be set indicating that PLL clock is stable and can
+  *         be used as system clock source.
+  * @note   The main PLL can not be disabled if it is used as system clock source
+  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
+  * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_PLLCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
+}
+
+#if defined (STM32F40_41xxx) || defined (STM32F401xx)
+/**
+  * @brief  Configures the PLLI2S clock multiplication and division factors.
+  *  
+  * @note   This function can be used only for STM32F405xx/407xx, STM32F415xx/417xx 
+  *         or STM32F401xx devices. 
+  *    
+  * @note   This function must be used only when the PLLI2S is disabled.
+  * @note   PLLI2S clock source is common with the main PLL (configured in 
+  *         RCC_PLLConfig function )  
+  *             
+  * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
+  *          This parameter must be a number between 192 and 432.
+  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
+  *         output frequency is between 192 and 432 MHz.
+  *    
+  * @param  PLLI2SR: specifies the division factor for I2S clock
+  *          This parameter must be a number between 2 and 7.
+  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
+  *         on the I2S clock frequency.
+  *   
+  * @retval None
+  */
+void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
+  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
+
+  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
+}
+
+#elif defined (STM32F411xE)
+/**
+  * @brief  Configures the PLLI2S clock multiplication and division factors.
+  *  
+  * @note   This function can be used only for STM32F411xE devices. 
+  *    
+  * @note   This function must be used only when the PLLI2S is disabled.
+  * @note   PLLI2S clock source is common with the main PLL (configured in 
+  *         RCC_PLLConfig function )  
+  *
+  * @param  PLLI2SM: specifies the division factor for PLLI2S VCO input clock
+  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
+  * @note   You have to set the PLLI2SM parameter correctly to ensure that the VCO input
+  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
+  *         of 2 MHz to limit PLLI2S jitter.
+  *
+  * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
+  *          This parameter must be a number between 192 and 432.
+  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
+  *         output frequency is between 192 and 432 MHz.
+  *    
+  * @param  PLLI2SR: specifies the division factor for I2S clock
+  *          This parameter must be a number between 2 and 7.
+  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
+  *         on the I2S clock frequency.
+  *   
+  * @retval None
+  */
+void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR, uint32_t PLLI2SM)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
+  assert_param(IS_RCC_PLLI2SM_VALUE(PLLI2SM));
+  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
+
+  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28) | PLLI2SM;
+}
+
+#elif defined (STM32F427_437xx) || defined (STM32F429_439xx)
+/**
+  * @brief  Configures the PLLI2S clock multiplication and division factors.
+  * 
+  * @note   This function can be used only for STM32F42xxx/43xxx devices 
+  *         
+  * @note   This function must be used only when the PLLI2S is disabled.
+  * @note   PLLI2S clock source is common with the main PLL (configured in 
+  *         RCC_PLLConfig function )  
+  *             
+  * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
+  *          This parameter must be a number between 192 and 432.
+  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
+  *         output frequency is between 192 and 432 MHz.
+  * 
+  * @param  PLLI2SQ: specifies the division factor for SAI1 clock
+  *          This parameter must be a number between 2 and 15.
+  *                 
+  * @param  PLLI2SR: specifies the division factor for I2S clock
+  *          This parameter must be a number between 2 and 7.
+  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
+  *         on the I2S clock frequency.
+  * @note   the PLLI2SR parameter is only available with STM32F42xxx/43xxx devices.  
+  *   
+  * @retval None
+  */
+void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SQ, uint32_t PLLI2SR)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
+  assert_param(IS_RCC_PLLI2SQ_VALUE(PLLI2SQ));
+  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
+
+  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SQ << 24) | (PLLI2SR << 28);
+}
+#else
+#endif /* STM32F40_41xxx || STM32F401xx */
+
+/**
+  * @brief  Enables or disables the PLLI2S. 
+  * @note   The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.  
+  * @param  NewState: new state of the PLLI2S. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_PLLI2SCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the PLLSAI clock multiplication and division factors.
+  *
+  * @note   This function can be used only for STM32F42xxx/43xxx devices 
+  *        
+  * @note   This function must be used only when the PLLSAI is disabled.
+  * @note   PLLSAI clock source is common with the main PLL (configured in 
+  *         RCC_PLLConfig function )  
+  *             
+  * @param  PLLSAIN: specifies the multiplication factor for PLLSAI VCO output clock
+  *          This parameter must be a number between 192 and 432.
+  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
+  *         output frequency is between 192 and 432 MHz.
+  *           
+  * @param  PLLSAIQ: specifies the division factor for SAI1 clock
+  *          This parameter must be a number between 2 and 15.
+  *            
+  * @param  PLLSAIR: specifies the division factor for LTDC clock
+  *          This parameter must be a number between 2 and 7.
+  *   
+  * @retval None
+  */
+void RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIN));
+  assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIR));
+
+  RCC->PLLSAICFGR = (PLLSAIN << 6) | (PLLSAIQ << 24) | (PLLSAIR << 28);
+}
+
+/**
+  * @brief  Enables or disables the PLLSAI. 
+  * 
+  * @note   This function can be used only for STM32F42xxx/43xxx devices 
+  *       
+  * @note   The PLLSAI is disabled by hardware when entering STOP and STANDBY modes.  
+  * @param  NewState: new state of the PLLSAI. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_PLLSAICmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_PLLSAION_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the Clock Security System.
+  * @note   If a failure is detected on the HSE oscillator clock, this oscillator
+  *         is automatically disabled and an interrupt is generated to inform the
+  *         software about the failure (Clock Security System Interrupt, CSSI),
+  *         allowing the MCU to perform rescue operations. The CSSI is linked to 
+  *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  
+  * @param  NewState: new state of the Clock Security System.
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Selects the clock source to output on MCO1 pin(PA8).
+  * @note   PA8 should be configured in alternate function mode.
+  * @param  RCC_MCO1Source: specifies the clock source to output.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_MCO1Source_HSI: HSI clock selected as MCO1 source
+  *            @arg RCC_MCO1Source_LSE: LSE clock selected as MCO1 source
+  *            @arg RCC_MCO1Source_HSE: HSE clock selected as MCO1 source
+  *            @arg RCC_MCO1Source_PLLCLK: main PLL clock selected as MCO1 source
+  * @param  RCC_MCO1Div: specifies the MCO1 prescaler.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_MCO1Div_1: no division applied to MCO1 clock
+  *            @arg RCC_MCO1Div_2: division by 2 applied to MCO1 clock
+  *            @arg RCC_MCO1Div_3: division by 3 applied to MCO1 clock
+  *            @arg RCC_MCO1Div_4: division by 4 applied to MCO1 clock
+  *            @arg RCC_MCO1Div_5: division by 5 applied to MCO1 clock
+  * @retval None
+  */
+void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
+  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
+
+  tmpreg = RCC->CFGR;
+
+  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
+  tmpreg &= CFGR_MCO1_RESET_MASK;
+
+  /* Select MCO1 clock source and prescaler */
+  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
+
+  /* Store the new value */
+  RCC->CFGR = tmpreg;  
+}
+
+/**
+  * @brief  Selects the clock source to output on MCO2 pin(PC9).
+  * @note   PC9 should be configured in alternate function mode.
+  * @param  RCC_MCO2Source: specifies the clock source to output.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_MCO2Source_SYSCLK: System clock (SYSCLK) selected as MCO2 source
+  *            @arg RCC_MCO2Source_PLLI2SCLK: PLLI2S clock selected as MCO2 source
+  *            @arg RCC_MCO2Source_HSE: HSE clock selected as MCO2 source
+  *            @arg RCC_MCO2Source_PLLCLK: main PLL clock selected as MCO2 source
+  * @param  RCC_MCO2Div: specifies the MCO2 prescaler.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_MCO2Div_1: no division applied to MCO2 clock
+  *            @arg RCC_MCO2Div_2: division by 2 applied to MCO2 clock
+  *            @arg RCC_MCO2Div_3: division by 3 applied to MCO2 clock
+  *            @arg RCC_MCO2Div_4: division by 4 applied to MCO2 clock
+  *            @arg RCC_MCO2Div_5: division by 5 applied to MCO2 clock
+  * @retval None
+  */
+void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
+  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
+  
+  tmpreg = RCC->CFGR;
+  
+  /* Clear MCO2 and MCO2PRE[2:0] bits */
+  tmpreg &= CFGR_MCO2_RESET_MASK;
+
+  /* Select MCO2 clock source and prescaler */
+  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
+
+  /* Store the new value */
+  RCC->CFGR = tmpreg;  
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Group2 System AHB and APB busses clocks configuration functions
+ *  @brief   System, AHB and APB busses clocks configuration functions
+ *
+@verbatim   
+ ===============================================================================
+      ##### System, AHB and APB busses clocks configuration functions #####
+ ===============================================================================  
+    [..]
+      This section provide functions allowing to configure the System, AHB, APB1 and 
+      APB2 busses clocks.
+  
+      (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
+          HSE and PLL.
+          The AHB clock (HCLK) is derived from System clock through configurable 
+          prescaler and used to clock the CPU, memory and peripherals mapped 
+          on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived 
+          from AHB clock through configurable prescalers and used to clock 
+          the peripherals mapped on these busses. You can use 
+          "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks.  
+
+      -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
+        (+@) I2S: the I2S clock can be derived either from a specific PLL (PLLI2S) or
+             from an external clock mapped on the I2S_CKIN pin. 
+             You have to use RCC_I2SCLKConfig() function to configure this clock. 
+        (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
+             divided by 2 to 31. You have to use RCC_RTCCLKConfig() and RCC_RTCCLKCmd()
+             functions to configure this clock. 
+        (+@) USB OTG FS, SDIO and RTC: USB OTG FS require a frequency equal to 48 MHz
+             to work correctly, while the SDIO require a frequency equal or lower than
+             to 48. This clock is derived of the main PLL through PLLQ divider.
+        (+@) IWDG clock which is always the LSI clock.
+       
+      (#) For STM32F405xx/407xx and STM32F415xx/417xx devices, the maximum frequency 
+         of the SYSCLK and HCLK is 168 MHz, PCLK2 84 MHz and PCLK1 42 MHz. Depending 
+         on the device voltage range, the maximum frequency should be adapted accordingly:
+ +-------------------------------------------------------------------------------------+     
+ | Latency       |                HCLK clock frequency (MHz)                           |
+ |               |---------------------------------------------------------------------|     
+ |               | voltage range  | voltage range  | voltage range   | voltage range   |
+ |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
+ |---------------|----------------|----------------|-----------------|-----------------|              
+ |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
+ |---------------|----------------|----------------|-----------------|-----------------|   
+ |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
+ |---------------|----------------|----------------|-----------------|-----------------|   
+ |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |5WS(6CPU cycle)|150< HCLK <= 168|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |7WS(8CPU cycle)|      NA        |      NA        |154 < HCLK <= 168|140 < HCLK <= 160|
+ +---------------|----------------|----------------|-----------------|-----------------+ 
+      (#) For STM32F42xxx/43xxx devices, the maximum frequency of the SYSCLK and HCLK is 180 MHz, 
+          PCLK2 90 MHz and PCLK1 45 MHz. Depending on the device voltage range, the maximum 
+          frequency should be adapted accordingly:
+ +-------------------------------------------------------------------------------------+     
+ | Latency       |                HCLK clock frequency (MHz)                           |
+ |               |---------------------------------------------------------------------|     
+ |               | voltage range  | voltage range  | voltage range   | voltage range   |
+ |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
+ |---------------|----------------|----------------|-----------------|-----------------|              
+ |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
+ |---------------|----------------|----------------|-----------------|-----------------|   
+ |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
+ |---------------|----------------|----------------|-----------------|-----------------|   
+ |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |5WS(6CPU cycle)|120< HCLK <= 180|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |7WS(8CPU cycle)|      NA        |168< HCLK <= 180|154 < HCLK <= 176|140 < HCLK <= 160|
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |8WS(9CPU cycle)|      NA        |      NA        |176 < HCLK <= 180|160 < HCLK <= 168|
+ +-------------------------------------------------------------------------------------+
+   
+      (#) For STM32F401xx devices, the maximum frequency of the SYSCLK and HCLK is 84 MHz, 
+          PCLK2 84 MHz and PCLK1 42 MHz. Depending on the device voltage range, the maximum 
+          frequency should be adapted accordingly:
+ +-------------------------------------------------------------------------------------+     
+ | Latency       |                HCLK clock frequency (MHz)                           |
+ |               |---------------------------------------------------------------------|     
+ |               | voltage range  | voltage range  | voltage range   | voltage range   |
+ |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
+ |---------------|----------------|----------------|-----------------|-----------------|              
+ |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
+ |---------------|----------------|----------------|-----------------|-----------------|   
+ |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
+ |---------------|----------------|----------------|-----------------|-----------------|   
+ |2WS(3CPU cycle)|60 < HCLK <= 84 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |3WS(4CPU cycle)|      NA        |72 < HCLK <= 84 |66 < HCLK <= 84  |60 < HCLK <= 80  |
+ |---------------|----------------|----------------|-----------------|-----------------| 
+ |4WS(5CPU cycle)|      NA        |      NA        |      NA         |80 < HCLK <= 84  | 
+ +-------------------------------------------------------------------------------------+
+
+      (#) For STM32F411xE devices, the maximum frequency of the SYSCLK and HCLK is 100 MHz, 
+          PCLK2 100 MHz and PCLK1 50 MHz. Depending on the device voltage range, the maximum 
+          frequency should be adapted accordingly:
+ +-------------------------------------------------------------------------------------+
+ | Latency       |                HCLK clock frequency (MHz)                           |
+ |               |---------------------------------------------------------------------|
+ |               | voltage range  | voltage range  | voltage range   | voltage range   |
+ |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 18   |0 < HCLK <= 16   |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |1WS(2CPU cycle)|30 < HCLK <= 64 |24 < HCLK <= 48 |18 < HCLK <= 36  |16 < HCLK <= 32  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |2WS(3CPU cycle)|64 < HCLK <= 90 |48 < HCLK <= 72 |36 < HCLK <= 54  |32 < HCLK <= 48  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |3WS(4CPU cycle)|90 < HCLK <= 100|72 < HCLK <= 96 |54 < HCLK <= 72  |48 < HCLK <= 64  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |4WS(5CPU cycle)|      NA        |96 < HCLK <= 100|72 < HCLK <= 90  |64 < HCLK <= 80  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |5WS(6CPU cycle)|      NA        |       NA       |90 < HCLK <= 100 |80 < HCLK <= 96  |
+ |---------------|----------------|----------------|-----------------|-----------------|
+ |6WS(7CPU cycle)|      NA        |       NA       |        NA       |96 < HCLK <= 100 |
+ +-------------------------------------------------------------------------------------+
+  
+      -@- On STM32F405xx/407xx and STM32F415xx/417xx devices: 
+           (++) when VOS = '0', the maximum value of fHCLK = 144MHz. 
+           (++) when VOS = '1', the maximum value of fHCLK = 168MHz. 
+          [..] 
+          On STM32F42xxx/43xxx devices:
+           (++) when VOS[1:0] = '0x01', the maximum value of fHCLK is 120MHz.
+           (++) when VOS[1:0] = '0x10', the maximum value of fHCLK is 144MHz.
+           (++) when VOS[1:0] = '0x11', the maximum value of f  is 168MHz 
+          [..]  
+          On STM32F401x devices:
+           (++) when VOS[1:0] = '0x01', the maximum value of fHCLK is 64MHz.
+           (++) when VOS[1:0] = '0x10', the maximum value of fHCLK is 84MHz.
+          On STM32F411xE devices:
+           (++) when VOS[1:0] = '0x01' the maximum value of fHCLK is 64MHz.
+           (++) when VOS[1:0] = '0x10' the maximum value of fHCLK is 84MHz.
+           (++) when VOS[1:0] = '0x11' the maximum value of fHCLK is 100MHz.
+
+       You can use PWR_MainRegulatorModeConfig() function to control VOS bits.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the system clock (SYSCLK).
+  * @note   The HSI is used (enabled by hardware) as system clock source after
+  *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
+  *         of failure of the HSE used directly or indirectly as system clock
+  *         (if the Clock Security System CSS is enabled).
+  * @note   A switch from one clock source to another occurs only if the target
+  *         clock source is ready (clock stable after startup delay or PLL locked). 
+  *         If a clock source which is not yet ready is selected, the switch will
+  *         occur when the clock source will be ready. 
+  *         You can use RCC_GetSYSCLKSource() function to know which clock is
+  *         currently used as system clock source. 
+  * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
+  *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
+  *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
+  * @retval None
+  */
+void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
+
+  tmpreg = RCC->CFGR;
+
+  /* Clear SW[1:0] bits */
+  tmpreg &= ~RCC_CFGR_SW;
+
+  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
+  tmpreg |= RCC_SYSCLKSource;
+
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+/**
+  * @brief  Returns the clock source used as system clock.
+  * @param  None
+  * @retval The clock source used as system clock. The returned value can be one
+  *         of the following:
+  *              - 0x00: HSI used as system clock
+  *              - 0x04: HSE used as system clock
+  *              - 0x08: PLL used as system clock
+  */
+uint8_t RCC_GetSYSCLKSource(void)
+{
+  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
+}
+
+/**
+  * @brief  Configures the AHB clock (HCLK).
+  * @note   Depending on the device voltage range, the software has to set correctly
+  *         these bits to ensure that HCLK not exceed the maximum allowed frequency
+  *         (for more details refer to section above
+  *           "CPU, AHB and APB busses clocks configuration functions")
+  * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
+  *         the system clock (SYSCLK).
+  *          This parameter can be one of the following values:
+  *            @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
+  *            @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
+  *            @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
+  *            @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
+  *            @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
+  *            @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
+  *            @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
+  *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
+  *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
+  * @retval None
+  */
+void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
+
+  tmpreg = RCC->CFGR;
+
+  /* Clear HPRE[3:0] bits */
+  tmpreg &= ~RCC_CFGR_HPRE;
+
+  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
+  tmpreg |= RCC_SYSCLK;
+
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+
+/**
+  * @brief  Configures the Low Speed APB clock (PCLK1).
+  * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
+  *         the AHB clock (HCLK).
+  *          This parameter can be one of the following values:
+  *            @arg RCC_HCLK_Div1:  APB1 clock = HCLK
+  *            @arg RCC_HCLK_Div2:  APB1 clock = HCLK/2
+  *            @arg RCC_HCLK_Div4:  APB1 clock = HCLK/4
+  *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
+  *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
+  * @retval None
+  */
+void RCC_PCLK1Config(uint32_t RCC_HCLK)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PCLK(RCC_HCLK));
+
+  tmpreg = RCC->CFGR;
+
+  /* Clear PPRE1[2:0] bits */
+  tmpreg &= ~RCC_CFGR_PPRE1;
+
+  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
+  tmpreg |= RCC_HCLK;
+
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+/**
+  * @brief  Configures the High Speed APB clock (PCLK2).
+  * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
+  *         the AHB clock (HCLK).
+  *          This parameter can be one of the following values:
+  *            @arg RCC_HCLK_Div1:  APB2 clock = HCLK
+  *            @arg RCC_HCLK_Div2:  APB2 clock = HCLK/2
+  *            @arg RCC_HCLK_Div4:  APB2 clock = HCLK/4
+  *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
+  *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
+  * @retval None
+  */
+void RCC_PCLK2Config(uint32_t RCC_HCLK)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PCLK(RCC_HCLK));
+
+  tmpreg = RCC->CFGR;
+
+  /* Clear PPRE2[2:0] bits */
+  tmpreg &= ~RCC_CFGR_PPRE2;
+
+  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
+  tmpreg |= RCC_HCLK << 3;
+
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+/**
+  * @brief  Returns the frequencies of different on chip clocks; SYSCLK, HCLK, 
+  *         PCLK1 and PCLK2.       
+  * 
+  * @note   The system frequency computed by this function is not the real 
+  *         frequency in the chip. It is calculated based on the predefined 
+  *         constant and the selected clock source:
+  * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
+  * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
+  * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**) 
+  *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
+  * @note     (*) HSI_VALUE is a constant defined in stm32f4xx.h file (default value
+  *               16 MHz) but the real value may vary depending on the variations
+  *               in voltage and temperature.
+  * @note     (**) HSE_VALUE is a constant defined in stm32f4xx.h file (default value
+  *                25 MHz), user has to ensure that HSE_VALUE is same as the real
+  *                frequency of the crystal used. Otherwise, this function may
+  *                have wrong result.
+  *                
+  * @note   The result of this function could be not correct when using fractional
+  *         value for HSE crystal.
+  *   
+  * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
+  *          the clocks frequencies.
+  *     
+  * @note   This function can be used by the user application to compute the 
+  *         baudrate for the communication peripherals or configure other parameters.
+  * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
+  *         must be called to update the structure's field. Otherwise, any
+  *         configuration based on this function will be incorrect.
+  *    
+  * @retval None
+  */
+void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
+{
+  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
+
+  /* Get SYSCLK source -------------------------------------------------------*/
+  tmp = RCC->CFGR & RCC_CFGR_SWS;
+
+  switch (tmp)
+  {
+    case 0x00:  /* HSI used as system clock source */
+      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
+      break;
+    case 0x04:  /* HSE used as system clock  source */
+      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
+      break;
+    case 0x08:  /* PLL used as system clock  source */
+
+      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
+         SYSCLK = PLL_VCO / PLLP
+         */    
+      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
+      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
+      
+      if (pllsource != 0)
+      {
+        /* HSE used as PLL clock source */
+        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
+      }
+      else
+      {
+        /* HSI used as PLL clock source */
+        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
+      }
+
+      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
+      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
+      break;
+    default:
+      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
+      break;
+  }
+  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
+
+  /* Get HCLK prescaler */
+  tmp = RCC->CFGR & RCC_CFGR_HPRE;
+  tmp = tmp >> 4;
+  presc = APBAHBPrescTable[tmp];
+  /* HCLK clock frequency */
+  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
+
+  /* Get PCLK1 prescaler */
+  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
+  tmp = tmp >> 10;
+  presc = APBAHBPrescTable[tmp];
+  /* PCLK1 clock frequency */
+  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
+
+  /* Get PCLK2 prescaler */
+  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
+  tmp = tmp >> 13;
+  presc = APBAHBPrescTable[tmp];
+  /* PCLK2 clock frequency */
+  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Group3 Peripheral clocks configuration functions
+ *  @brief   Peripheral clocks configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Peripheral clocks configuration functions #####
+ ===============================================================================  
+    [..] This section provide functions allowing to configure the Peripheral clocks. 
+  
+      (#) The RTC clock which is derived from the LSI, LSE or HSE clock divided 
+          by 2 to 31.
+     
+      (#) After restart from Reset or wakeup from STANDBY, all peripherals are off
+          except internal SRAM, Flash and JTAG. Before to start using a peripheral 
+          you have to enable its interface clock. You can do this using 
+          RCC_AHBPeriphClockCmd(), RCC_APB2PeriphClockCmd() and RCC_APB1PeriphClockCmd() functions.
+
+      (#) To reset the peripherals configuration (to the default state after device reset)
+          you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() and 
+          RCC_APB1PeriphResetCmd() functions.
+     
+      (#) To further reduce power consumption in SLEEP mode the peripheral clocks 
+          can be disabled prior to executing the WFI or WFE instructions. 
+          You can do this using RCC_AHBPeriphClockLPModeCmd(), 
+          RCC_APB2PeriphClockLPModeCmd() and RCC_APB1PeriphClockLPModeCmd() functions.  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the RTC clock (RTCCLK).
+  * @note   As the RTC clock configuration bits are in the Backup domain and write
+  *         access is denied to this domain after reset, you have to enable write
+  *         access using PWR_BackupAccessCmd(ENABLE) function before to configure
+  *         the RTC clock source (to be done once after reset).    
+  * @note   Once the RTC clock is configured it can't be changed unless the  
+  *         Backup domain is reset using RCC_BackupResetCmd() function, or by
+  *         a Power On Reset (POR).
+  *    
+  * @param  RCC_RTCCLKSource: specifies the RTC clock source.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
+  *            @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
+  *            @arg RCC_RTCCLKSource_HSE_Divx: HSE clock divided by x selected
+  *                                            as RTC clock, where x:[2,31]
+  *  
+  * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
+  *         work in STOP and STANDBY modes, and can be used as wakeup source.
+  *         However, when the HSE clock is used as RTC clock source, the RTC
+  *         cannot be used in STOP and STANDBY modes.    
+  * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
+  *         RTC clock source).
+  *  
+  * @retval None
+  */
+void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
+
+  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
+  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
+    tmpreg = RCC->CFGR;
+
+    /* Clear RTCPRE[4:0] bits */
+    tmpreg &= ~RCC_CFGR_RTCPRE;
+
+    /* Configure HSE division factor for RTC clock */
+    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
+
+    /* Store the new value */
+    RCC->CFGR = tmpreg;
+  }
+    
+  /* Select the RTC clock source */
+  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
+}
+
+/**
+  * @brief  Enables or disables the RTC clock.
+  * @note   This function must be used only after the RTC clock source was selected
+  *         using the RCC_RTCCLKConfig function.
+  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_RTCCLKCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Forces or releases the Backup domain reset.
+  * @note   This function resets the RTC peripheral (including the backup registers)
+  *         and the RTC clock source selection in RCC_CSR register.
+  * @note   The BKPSRAM is not affected by this reset.    
+  * @param  NewState: new state of the Backup domain reset.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_BackupResetCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the I2S clock source (I2SCLK).
+  * @note   This function must be called before enabling the I2S APB clock.
+  * @param  RCC_I2SCLKSource: specifies the I2S clock source.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_I2S2CLKSource_PLLI2S: PLLI2S clock used as I2S clock source
+  *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
+  *                                        used as I2S clock source
+  * @retval None
+  */
+void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
+
+  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
+}
+
+/**
+  * @brief  Configures the SAI clock Divider coming from PLLI2S.
+  * 
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *   
+  * @note   This function must be called before enabling the PLLI2S.
+  *              
+  * @param  RCC_PLLI2SDivQ: specifies the PLLI2S division factor for SAI1 clock .
+  *          This parameter must be a number between 1 and 32.
+  *          SAI1 clock frequency = f(PLLI2S_Q) / RCC_PLLI2SDivQ 
+  *              
+  * @retval None
+  */
+void RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ)  
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
+  
+  tmpreg = RCC->DCKCFGR;
+
+  /* Clear PLLI2SDIVQ[4:0] bits */
+  tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);
+
+  /* Set PLLI2SDIVQ values */
+  tmpreg |= (RCC_PLLI2SDivQ - 1);
+
+  /* Store the new value */
+  RCC->DCKCFGR = tmpreg;
+}
+
+/**
+  * @brief  Configures the SAI clock Divider coming from PLLSAI.
+  * 
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *        
+  * @note   This function must be called before enabling the PLLSAI.
+  *   
+  * @param  RCC_PLLSAIDivQ: specifies the PLLSAI division factor for SAI1 clock .
+  *          This parameter must be a number between 1 and 32.
+  *          SAI1 clock frequency = f(PLLSAI_Q) / RCC_PLLSAIDivQ  
+  *              
+  * @retval None
+  */
+void RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ)  
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
+  
+  tmpreg = RCC->DCKCFGR;
+
+  /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
+  tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);
+
+  /* Set PLLSAIDIVQ values */
+  tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
+
+  /* Store the new value */
+  RCC->DCKCFGR = tmpreg;
+}
+
+/**
+  * @brief  Configures SAI1BlockA clock source selection.
+  * 
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *       
+  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
+  *         the SAI clock.
+  * @param  RCC_SAIBlockACLKSource: specifies the SAI Block A clock source.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_SAIACLKSource_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
+  *                                           as SAI1 Block A clock 
+  *            @arg RCC_SAIACLKSource_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
+  *                                           as SAI1 Block A clock 
+  *            @arg RCC_SAIACLKSource_Ext: External clock mapped on the I2S_CKIN pin
+  *                                        used as SAI1 Block A clock
+  * @retval None
+  */
+void RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RCC_SAIACLK_SOURCE(RCC_SAIBlockACLKSource));
+  
+  tmpreg = RCC->DCKCFGR;
+
+  /* Clear RCC_DCKCFGR_SAI1ASRC[1:0] bits */
+  tmpreg &= ~RCC_DCKCFGR_SAI1ASRC;
+
+  /* Set SAI Block A source selection value */
+  tmpreg |= RCC_SAIBlockACLKSource;
+
+  /* Store the new value */
+  RCC->DCKCFGR = tmpreg;
+}
+
+/**
+  * @brief  Configures SAI1BlockB clock source selection.
+  * 
+  * @note   This function can be used only for STM32F42xxx/43xxx devices.
+  *       
+  * @note   This function must be called before enabling PLLSAI, PLLI2S and  
+  *         the SAI clock.
+  * @param  RCC_SAIBlockBCLKSource: specifies the SAI Block B clock source.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_SAIBCLKSource_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
+  *                                           as SAI1 Block B clock 
+  *            @arg RCC_SAIBCLKSource_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
+  *                                           as SAI1 Block B clock 
+  *            @arg RCC_SAIBCLKSource_Ext: External clock mapped on the I2S_CKIN pin
+  *                                        used as SAI1 Block B clock
+  * @retval None
+  */
+void RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RCC_SAIBCLK_SOURCE(RCC_SAIBlockBCLKSource));
+  
+  tmpreg = RCC->DCKCFGR;
+
+  /* Clear RCC_DCKCFGR_SAI1BSRC[1:0] bits */
+  tmpreg &= ~RCC_DCKCFGR_SAI1BSRC;
+
+  /* Set SAI Block B source selection value */
+  tmpreg |= RCC_SAIBlockBCLKSource;
+
+  /* Store the new value */
+  RCC->DCKCFGR = tmpreg;
+}
+
+
+/**
+  * @brief  Configures the LTDC clock Divider coming from PLLSAI.
+  * 
+  * @note   The LTDC peripheral is only available with STM32F429xx/439xx Devices.
+  *      
+  * @note   This function must be called before enabling the PLLSAI.
+  *   
+  * @param  RCC_PLLSAIDivR: specifies the PLLSAI division factor for LTDC clock .
+  *          This parameter must be a number between 2 and 16.
+  *          LTDC clock frequency = f(PLLSAI_R) / RCC_PLLSAIDivR  
+  *            
+  * @retval None
+  */
+void RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RCC_PLLSAI_DIVR_VALUE(RCC_PLLSAIDivR));
+  
+  tmpreg = RCC->DCKCFGR;
+
+  /* Clear PLLSAIDIVR[2:0] bits */
+  tmpreg &= ~RCC_DCKCFGR_PLLSAIDIVR;
+
+  /* Set PLLSAIDIVR values */
+  tmpreg |= RCC_PLLSAIDivR;
+
+  /* Store the new value */
+  RCC->DCKCFGR = tmpreg;
+}
+
+/**
+  * @brief  Configures the Timers clocks prescalers selection.
+  * 
+  * @note   This function can be used only for STM32F42xxx/43xxx and STM32F401xx/411xE devices. 
+  *   
+  * @param  RCC_TIMCLKPrescaler : specifies the Timers clocks prescalers selection
+  *         This parameter can be one of the following values:
+  *            @arg RCC_TIMPrescDesactivated: The Timers kernels clocks prescaler is 
+  *                 equal to HPRE if PPREx is corresponding to division by 1 or 2, 
+  *                 else it is equal to [(HPRE * PPREx) / 2] if PPREx is corresponding to 
+  *                 division by 4 or more.
+  *                   
+  *            @arg RCC_TIMPrescActivated: The Timers kernels clocks prescaler is 
+  *                 equal to HPRE if PPREx is corresponding to division by 1, 2 or 4, 
+  *                 else it is equal to [(HPRE * PPREx) / 4] if PPREx is corresponding 
+  *                 to division by 8 or more.
+  * @retval None
+  */
+void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));
+
+  *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
+  
+}
+
+/**
+  * @brief  Enables or disables the AHB1 peripheral clock.
+  * @note   After reset, the peripheral clock (used for registers read/write access)
+  *         is disabled and the application software has to enable this clock before 
+  *         using it.   
+  * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
+  *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
+  *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
+  *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
+  *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
+  *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
+  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
+  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
+  *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
+  *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
+  *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  
+  *            @arg RCC_AHB1Periph_CRC:         CRC clock
+  *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
+  *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
+  *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
+  *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
+  *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  
+  *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
+  *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
+  *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
+  *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
+  *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
+  *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
+
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->AHB1ENR |= RCC_AHB1Periph;
+  }
+  else
+  {
+    RCC->AHB1ENR &= ~RCC_AHB1Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the AHB2 peripheral clock.
+  * @note   After reset, the peripheral clock (used for registers read/write access)
+  *         is disabled and the application software has to enable this clock before 
+  *         using it. 
+  * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
+  *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
+  *            @arg RCC_AHB2Periph_HASH:   HASH clock
+  *            @arg RCC_AHB2Periph_RNG:    RNG clock
+  *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC->AHB2ENR |= RCC_AHB2Periph;
+  }
+  else
+  {
+    RCC->AHB2ENR &= ~RCC_AHB2Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the AHB3 peripheral clock.
+  * @note   After reset, the peripheral clock (used for registers read/write access)
+  *         is disabled and the application software has to enable this clock before 
+  *         using it. 
+  * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
+  *          This parameter must be: RCC_AHB3Periph_FSMC
+  *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC->AHB3ENR |= RCC_AHB3Periph;
+  }
+  else
+  {
+    RCC->AHB3ENR &= ~RCC_AHB3Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
+  * @note   After reset, the peripheral clock (used for registers read/write access)
+  *         is disabled and the application software has to enable this clock before 
+  *         using it. 
+  * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
+  *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
+  *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
+  *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
+  *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
+  *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
+  *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
+  *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
+  *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
+  *            @arg RCC_APB1Periph_WWDG:   WWDG clock
+  *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
+  *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
+  *            @arg RCC_APB1Periph_USART2: USART2 clock
+  *            @arg RCC_APB1Periph_USART3: USART3 clock
+  *            @arg RCC_APB1Periph_UART4:  UART4 clock
+  *            @arg RCC_APB1Periph_UART5:  UART5 clock
+  *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
+  *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
+  *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
+  *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
+  *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
+  *            @arg RCC_APB1Periph_PWR:    PWR clock
+  *            @arg RCC_APB1Periph_DAC:    DAC clock
+  *            @arg RCC_APB1Periph_UART7:  UART7 clock
+  *            @arg RCC_APB1Periph_UART8:  UART8 clock
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC->APB1ENR |= RCC_APB1Periph;
+  }
+  else
+  {
+    RCC->APB1ENR &= ~RCC_APB1Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
+  * @note   After reset, the peripheral clock (used for registers read/write access)
+  *         is disabled and the application software has to enable this clock before 
+  *         using it.
+  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
+  *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
+  *            @arg RCC_APB2Periph_USART1: USART1 clock
+  *            @arg RCC_APB2Periph_USART6: USART6 clock
+  *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
+  *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
+  *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
+  *            @arg RCC_APB2Periph_SDIO:   SDIO clock
+  *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
+  *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
+  *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
+  *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
+  *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
+  *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
+  *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
+  *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
+  *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
+  *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices) 
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC->APB2ENR |= RCC_APB2Periph;
+  }
+  else
+  {
+    RCC->APB2ENR &= ~RCC_APB2Periph;
+  }
+}
+
+/**
+  * @brief  Forces or releases AHB1 peripheral reset.
+  * @param  RCC_AHB1Periph: specifies the AHB1 peripheral to reset.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_AHB1Periph_GPIOA:   GPIOA clock
+  *            @arg RCC_AHB1Periph_GPIOB:   GPIOB clock 
+  *            @arg RCC_AHB1Periph_GPIOC:   GPIOC clock
+  *            @arg RCC_AHB1Periph_GPIOD:   GPIOD clock
+  *            @arg RCC_AHB1Periph_GPIOE:   GPIOE clock
+  *            @arg RCC_AHB1Periph_GPIOF:   GPIOF clock
+  *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
+  *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
+  *            @arg RCC_AHB1Periph_GPIOI:   GPIOI clock
+  *            @arg RCC_AHB1Periph_GPIOJ:   GPIOJ clock (STM32F42xxx/43xxx devices) 
+  *            @arg RCC_AHB1Periph_GPIOK:   GPIOK clock (STM32F42xxx/43xxxdevices)   
+  *            @arg RCC_AHB1Periph_CRC:     CRC clock
+  *            @arg RCC_AHB1Periph_DMA1:    DMA1 clock
+  *            @arg RCC_AHB1Periph_DMA2:    DMA2 clock
+  *            @arg RCC_AHB1Periph_DMA2D:   DMA2D clock (STM32F429xx/439xx devices)   
+  *            @arg RCC_AHB1Periph_ETH_MAC: Ethernet MAC clock
+  *            @arg RCC_AHB1Periph_OTG_HS:  USB OTG HS clock
+  *                  
+  * @param  NewState: new state of the specified peripheral reset.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC->AHB1RSTR |= RCC_AHB1Periph;
+  }
+  else
+  {
+    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
+  }
+}
+
+/**
+  * @brief  Forces or releases AHB2 peripheral reset.
+  * @param  RCC_AHB2Periph: specifies the AHB2 peripheral to reset.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
+  *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
+  *            @arg RCC_AHB2Periph_HASH:   HASH clock
+  *            @arg RCC_AHB2Periph_RNG:    RNG clock
+  *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
+  * @param  NewState: new state of the specified peripheral reset.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC->AHB2RSTR |= RCC_AHB2Periph;
+  }
+  else
+  {
+    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
+  }
+}
+
+/**
+  * @brief  Forces or releases AHB3 peripheral reset.
+  * @param  RCC_AHB3Periph: specifies the AHB3 peripheral to reset.
+  *          This parameter must be: RCC_AHB3Periph_FSMC
+  *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
+  * @param  NewState: new state of the specified peripheral reset.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC->AHB3RSTR |= RCC_AHB3Periph;
+  }
+  else
+  {
+    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
+  }
+}
+
+/**
+  * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
+  * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
+  *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
+  *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
+  *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
+  *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
+  *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
+  *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
+  *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
+  *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
+  *            @arg RCC_APB1Periph_WWDG:   WWDG clock
+  *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
+  *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
+  *            @arg RCC_APB1Periph_USART2: USART2 clock
+  *            @arg RCC_APB1Periph_USART3: USART3 clock
+  *            @arg RCC_APB1Periph_UART4:  UART4 clock
+  *            @arg RCC_APB1Periph_UART5:  UART5 clock
+  *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
+  *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
+  *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
+  *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
+  *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
+  *            @arg RCC_APB1Periph_PWR:    PWR clock
+  *            @arg RCC_APB1Periph_DAC:    DAC clock
+  *            @arg RCC_APB1Periph_UART7:  UART7 clock
+  *            @arg RCC_APB1Periph_UART8:  UART8 clock  
+  * @param  NewState: new state of the specified peripheral reset.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->APB1RSTR |= RCC_APB1Periph;
+  }
+  else
+  {
+    RCC->APB1RSTR &= ~RCC_APB1Periph;
+  }
+}
+
+/**
+  * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
+  * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
+  *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
+  *            @arg RCC_APB2Periph_USART1: USART1 clock
+  *            @arg RCC_APB2Periph_USART6: USART6 clock
+  *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
+  *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
+  *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
+  *            @arg RCC_APB2Periph_SDIO:   SDIO clock
+  *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
+  *            @arg RCC_APB2Periph_SPI4:   SPI4 clock  
+  *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
+  *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
+  *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
+  *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
+  *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
+  *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
+  *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
+  *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
+  * @param  NewState: new state of the specified peripheral reset.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->APB2RSTR |= RCC_APB2Periph;
+  }
+  else
+  {
+    RCC->APB2RSTR &= ~RCC_APB2Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the AHB1 peripheral clock during Low Power (Sleep) mode.
+  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
+  *         power consumption.
+  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
+  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
+  * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
+  *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
+  *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
+  *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
+  *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
+  *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
+  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
+  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
+  *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
+  *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
+  *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)   
+  *            @arg RCC_AHB1Periph_CRC:         CRC clock
+  *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
+  *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
+  *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
+  *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices) 
+  *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
+  *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
+  *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
+  *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
+  *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
+  *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->AHB1LPENR |= RCC_AHB1Periph;
+  }
+  else
+  {
+    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the AHB2 peripheral clock during Low Power (Sleep) mode.
+  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
+  *           power consumption.
+  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
+  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
+  * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
+  *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
+  *            @arg RCC_AHB2Periph_HASH:   HASH clock
+  *            @arg RCC_AHB2Periph_RNG:    RNG clock
+  *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock  
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->AHB2LPENR |= RCC_AHB2Periph;
+  }
+  else
+  {
+    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the AHB3 peripheral clock during Low Power (Sleep) mode.
+  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
+  *         power consumption.
+  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
+  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
+  * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
+  *          This parameter must be: RCC_AHB3Periph_FSMC
+  *                                  or RCC_AHB3Periph_FMC (STM32F429x/439x devices) 
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->AHB3LPENR |= RCC_AHB3Periph;
+  }
+  else
+  {
+    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the APB1 peripheral clock during Low Power (Sleep) mode.
+  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
+  *         power consumption.
+  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
+  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
+  * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
+  *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
+  *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
+  *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
+  *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
+  *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
+  *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
+  *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
+  *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
+  *            @arg RCC_APB1Periph_WWDG:   WWDG clock
+  *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
+  *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
+  *            @arg RCC_APB1Periph_USART2: USART2 clock
+  *            @arg RCC_APB1Periph_USART3: USART3 clock
+  *            @arg RCC_APB1Periph_UART4:  UART4 clock
+  *            @arg RCC_APB1Periph_UART5:  UART5 clock
+  *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
+  *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
+  *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
+  *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
+  *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
+  *            @arg RCC_APB1Periph_PWR:    PWR clock
+  *            @arg RCC_APB1Periph_DAC:    DAC clock
+  *            @arg RCC_APB1Periph_UART7:  UART7 clock
+  *            @arg RCC_APB1Periph_UART8:  UART8 clock
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->APB1LPENR |= RCC_APB1Periph;
+  }
+  else
+  {
+    RCC->APB1LPENR &= ~RCC_APB1Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the APB2 peripheral clock during Low Power (Sleep) mode.
+  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
+  *         power consumption.
+  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
+  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
+  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
+  *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
+  *            @arg RCC_APB2Periph_USART1: USART1 clock
+  *            @arg RCC_APB2Periph_USART6: USART6 clock
+  *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
+  *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
+  *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
+  *            @arg RCC_APB2Periph_SDIO:   SDIO clock
+  *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
+  *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
+  *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
+  *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
+  *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
+  *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
+  *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
+  *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
+  *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
+  *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
+  * @param  NewState: new state of the specified peripheral clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->APB2LPENR |= RCC_APB2Periph;
+  }
+  else
+  {
+    RCC->APB2LPENR &= ~RCC_APB2Periph;
+  }
+}
+
+/**
+  * @brief Configures the External Low Speed oscillator mode (LSE mode).
+  * @note This mode is only available for STM32F411xx devices.
+  * @param  Mode: specifies the LSE mode.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_LSE_LOWPOWER_MODE:  LSE oscillator in low power mode.
+  *            @arg RCC_LSE_HIGHDRIVE_MODE: LSE oscillator in High Drive mode.
+  * @retval None
+  */
+void RCC_LSEModeConfig(uint8_t Mode)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_LSE_MODE(Mode));
+  
+  if(Mode == RCC_LSE_HIGHDRIVE_MODE)
+  {
+    SET_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
+  }
+  else
+  {
+    CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Group4 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions 
+ *
+@verbatim   
+ ===============================================================================
+                ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified RCC interrupts.
+  * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *            @arg RCC_IT_LSERDY: LSE ready interrupt
+  *            @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *            @arg RCC_IT_HSERDY: HSE ready interrupt
+  *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
+  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt
+  *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)
+  * @param  NewState: new state of the specified RCC interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_IT(RCC_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
+    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
+  }
+  else
+  {
+    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
+    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified RCC flag is set or not.
+  * @param  RCC_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
+  *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
+  *            @arg RCC_FLAG_PLLRDY: main PLL clock ready
+  *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready
+  *            @arg RCC_FLAG_PLLSAIRDY: PLLSAI clock ready (only for STM32F42xxx/43xxx devices)
+  *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
+  *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
+  *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset
+  *            @arg RCC_FLAG_PINRST: Pin reset
+  *            @arg RCC_FLAG_PORRST: POR/PDR reset
+  *            @arg RCC_FLAG_SFTRST: Software reset
+  *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
+  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
+  *            @arg RCC_FLAG_LPWRRST: Low Power reset
+  * @retval The new state of RCC_FLAG (SET or RESET).
+  */
+FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
+{
+  uint32_t tmp = 0;
+  uint32_t statusreg = 0;
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_FLAG(RCC_FLAG));
+
+  /* Get the RCC register index */
+  tmp = RCC_FLAG >> 5;
+  if (tmp == 1)               /* The flag to check is in CR register */
+  {
+    statusreg = RCC->CR;
+  }
+  else if (tmp == 2)          /* The flag to check is in BDCR register */
+  {
+    statusreg = RCC->BDCR;
+  }
+  else                       /* The flag to check is in CSR register */
+  {
+    statusreg = RCC->CSR;
+  }
+
+  /* Get the flag position */
+  tmp = RCC_FLAG & FLAG_MASK;
+  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the RCC reset flags.
+  *         The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,  RCC_FLAG_SFTRST,
+  *         RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
+  * @param  None
+  * @retval None
+  */
+void RCC_ClearFlag(void)
+{
+  /* Set RMVF bit to clear the reset flags */
+  RCC->CSR |= RCC_CSR_RMVF;
+}
+
+/**
+  * @brief  Checks whether the specified RCC interrupt has occurred or not.
+  * @param  RCC_IT: specifies the RCC interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *            @arg RCC_IT_LSERDY: LSE ready interrupt
+  *            @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *            @arg RCC_IT_HSERDY: HSE ready interrupt
+  *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
+  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt           
+  *            @arg RCC_IT_PLLSAIRDY: PLLSAI clock ready interrupt (only for STM32F42xxx/43xxx devices)    
+  *            @arg RCC_IT_CSS: Clock Security System interrupt
+  * @retval The new state of RCC_IT (SET or RESET).
+  */
+ITStatus RCC_GetITStatus(uint8_t RCC_IT)
+{
+  ITStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_GET_IT(RCC_IT));
+
+  /* Check the status of the specified RCC interrupt */
+  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the RCC_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the RCC's interrupt pending bits.
+  * @param  RCC_IT: specifies the interrupt pending bit to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *            @arg RCC_IT_LSERDY: LSE ready interrupt
+  *            @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *            @arg RCC_IT_HSERDY: HSE ready interrupt
+  *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
+  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
+  *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)   
+  *            @arg RCC_IT_CSS: Clock Security System interrupt
+  * @retval None
+  */
+void RCC_ClearITPendingBit(uint8_t RCC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
+
+  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
+     pending bits */
+  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rng.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rng.c
new file mode 100644
index 0000000..7e271b2
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rng.c
@@ -0,0 +1,397 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_rng.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief This file provides firmware functions to manage the following 
+  *          functionalities of the Random Number Generator (RNG) peripheral:           
+  *           + Initialization and Configuration 
+  *           + Get 32 bit Random number      
+  *           + Interrupts and flags management       
+  *         
+@verbatim
+                                 
+ ===================================================================      
+                 ##### How to use this driver #####
+ ===================================================================          
+ [..]
+   (#) Enable The RNG controller clock using 
+       RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, ENABLE) function.
+                
+   (#) Activate the RNG peripheral using RNG_Cmd() function.
+            
+   (#) Wait until the 32 bit Random number Generator contains a valid  random data
+      (using polling/interrupt mode). For more details, refer to "Interrupts and 
+      flags management functions" module description.
+             
+   (#) Get the 32 bit Random number using RNG_GetRandomNumber() function
+            
+   (#) To get another 32 bit Random number, go to step 3.       
+         
+                
+@endverbatim
+  *         
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_rng.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup RNG 
+  * @brief RNG driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup RNG_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup RNG_Group1 Initialization and Configuration functions
+ *  @brief    Initialization and Configuration functions 
+ *
+@verbatim    
+ ===============================================================================
+             ##### Initialization and Configuration functions #####
+ ===============================================================================  
+ [..] This section provides functions allowing to 
+   (+) Initialize the RNG peripheral
+   (+) Enable or disable the RNG peripheral
+   
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  De-initializes the RNG peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void RNG_DeInit(void)
+{
+  /* Enable RNG reset state */
+  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, ENABLE);
+
+  /* Release RNG from reset state */
+  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, DISABLE);
+}
+
+/**
+  * @brief  Enables or disables the RNG peripheral.
+  * @param  NewState: new state of the RNG peripheral.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RNG_Cmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the RNG */
+    RNG->CR |= RNG_CR_RNGEN;
+  }
+  else
+  {
+    /* Disable the RNG */
+    RNG->CR &= ~RNG_CR_RNGEN;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup RNG_Group2 Get 32 bit Random number function
+ *  @brief    Get 32 bit Random number function 
+ *
+
+@verbatim    
+ ===============================================================================
+                 ##### Get 32 bit Random number function #####
+ ===============================================================================  
+ [..] This section provides a function allowing to get the 32 bit Random number  
+  
+   (@)  Before to call this function you have to wait till DRDY flag is set,
+        using RNG_GetFlagStatus(RNG_FLAG_DRDY) function. 
+   
+@endverbatim
+  * @{
+  */
+
+
+/**
+  * @brief  Returns a 32-bit random number.
+  *   
+  * @note   Before to call this function you have to wait till DRDY (data ready)
+  *         flag is set, using RNG_GetFlagStatus(RNG_FLAG_DRDY) function.
+  * @note   Each time the the Random number data is read (using RNG_GetRandomNumber()
+  *         function), the RNG_FLAG_DRDY flag is automatically cleared.
+  * @note   In the case of a seed error, the generation of random numbers is 
+  *         interrupted for as long as the SECS bit is '1'. If a number is 
+  *         available in the RNG_DR register, it must not be used because it may 
+  *         not have enough entropy. In this case, it is recommended to clear the 
+  *         SEIS bit(using RNG_ClearFlag(RNG_FLAG_SECS) function), then disable 
+  *         and enable the RNG peripheral (using RNG_Cmd() function) to 
+  *         reinitialize and restart the RNG.
+  * @note   In the case of a clock error, the RNG is no more able to generate 
+  *         random numbers because the PLL48CLK clock is not correct. User have 
+  *         to check that the clock controller is correctly configured to provide
+  *         the RNG clock and clear the CEIS bit (using RNG_ClearFlag(RNG_FLAG_CECS) 
+  *         function) . The clock error has no impact on the previously generated 
+  *         random numbers, and the RNG_DR register contents can be used.
+  *         
+  * @param  None
+  * @retval 32-bit random number.
+  */
+uint32_t RNG_GetRandomNumber(void)
+{
+  /* Return the 32 bit random number from the DR register */
+  return RNG->DR;
+}
+
+
+/**
+  * @}
+  */
+
+/** @defgroup RNG_Group3 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+ *
+@verbatim   
+ ===============================================================================
+             ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+ [..] This section provides functions allowing to configure the RNG Interrupts and 
+      to get the status and clear flags and Interrupts pending bits.
+  
+ [..] The RNG provides 3 Interrupts sources and 3 Flags:
+  
+ *** Flags : ***
+ ===============
+ [..] 
+    (#) RNG_FLAG_DRDY :  In the case of the RNG_DR register contains valid 
+        random data. it is cleared by reading the valid data(using 
+        RNG_GetRandomNumber() function).
+
+    (#) RNG_FLAG_CECS : In the case of a seed error detection. 
+      
+    (#) RNG_FLAG_SECS : In the case of a clock error detection.
+              
+ *** Interrupts ***
+ ==================
+ [..] If enabled, an RNG interrupt is pending :
+    
+   (#) In the case of the RNG_DR register contains valid random data. 
+       This interrupt source is cleared once the RNG_DR register has been read 
+       (using RNG_GetRandomNumber() function) until a new valid value is 
+       computed; or 
+   (#) In the case of a seed error : One of the following faulty sequences has 
+       been detected:
+       (++) More than 64 consecutive bits at the same value (0 or 1)
+       (++) More than 32 consecutive alternance of 0 and 1 (0101010101...01)
+       This interrupt source is cleared using RNG_ClearITPendingBit(RNG_IT_SEI)
+       function; or
+   (#) In the case of a clock error : the PLL48CLK (RNG peripheral clock source) 
+       was not correctly detected (fPLL48CLK< fHCLK/16). This interrupt source is
+       cleared using RNG_ClearITPendingBit(RNG_IT_CEI) function.
+       -@- note In this case, User have to check that the clock controller is 
+           correctly configured to provide the RNG clock. 
+
+ *** Managing the RNG controller events : ***
+ ============================================
+ [..] The user should identify which mode will be used in his application to manage 
+      the RNG controller events: Polling mode or Interrupt mode.
+  
+   (#) In the Polling Mode it is advised to use the following functions:
+       (++) RNG_GetFlagStatus() : to check if flags events occur. 
+       (++) RNG_ClearFlag()     : to clear the flags events.
+  
+       -@@- RNG_FLAG_DRDY can not be cleared by RNG_ClearFlag(). it is cleared only 
+            by reading the Random number data.      
+  
+   (#)  In the Interrupt Mode it is advised to use the following functions:
+        (++) RNG_ITConfig()       : to enable or disable the interrupt source.
+        (++) RNG_GetITStatus()    : to check if Interrupt occurs.
+        (++) RNG_ClearITPendingBit() : to clear the Interrupt pending Bit 
+             (corresponding Flag). 
+  
+@endverbatim
+  * @{
+  */ 
+
+/**
+  * @brief  Enables or disables the RNG interrupt.
+  * @note   The RNG provides 3 interrupt sources,
+  *           - Computed data is ready event (DRDY), and           
+  *           - Seed error Interrupt (SEI) and 
+  *           - Clock error Interrupt (CEI), 
+  *         all these interrupts sources are enabled by setting the IE bit in 
+  *         CR register. However, each interrupt have its specific status bit
+  *         (see RNG_GetITStatus() function) and clear bit except the DRDY event
+  *         (see RNG_ClearITPendingBit() function).
+  * @param  NewState: new state of the RNG interrupt.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RNG_ITConfig(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the RNG interrupt */
+    RNG->CR |= RNG_CR_IE;
+  }
+  else
+  {
+    /* Disable the RNG interrupt */
+    RNG->CR &= ~RNG_CR_IE;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified RNG flag is set or not.
+  * @param  RNG_FLAG: specifies the RNG flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg RNG_FLAG_DRDY: Data Ready flag.
+  *            @arg RNG_FLAG_CECS: Clock Error Current flag.
+  *            @arg RNG_FLAG_SECS: Seed Error Current flag.
+  * @retval The new state of RNG_FLAG (SET or RESET).
+  */
+FlagStatus RNG_GetFlagStatus(uint8_t RNG_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_RNG_GET_FLAG(RNG_FLAG));
+
+  /* Check the status of the specified RNG flag */
+  if ((RNG->SR & RNG_FLAG) != (uint8_t)RESET)
+  {
+    /* RNG_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* RNG_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the RNG_FLAG status */
+  return  bitstatus;
+}
+
+
+/**
+  * @brief  Clears the RNG flags.
+  * @param  RNG_FLAG: specifies the flag to clear. 
+  *          This parameter can be any combination of the following values:
+  *            @arg RNG_FLAG_CECS: Clock Error Current flag.
+  *            @arg RNG_FLAG_SECS: Seed Error Current flag.
+  * @note   RNG_FLAG_DRDY can not be cleared by RNG_ClearFlag() function. 
+  *         This flag is cleared only by reading the Random number data (using 
+  *         RNG_GetRandomNumber() function).                           
+  * @retval None
+  */
+void RNG_ClearFlag(uint8_t RNG_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_RNG_CLEAR_FLAG(RNG_FLAG));
+  /* Clear the selected RNG flags */
+  RNG->SR = ~(uint32_t)(((uint32_t)RNG_FLAG) << 4);
+}
+
+/**
+  * @brief  Checks whether the specified RNG interrupt has occurred or not.
+  * @param  RNG_IT: specifies the RNG interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg RNG_IT_CEI: Clock Error Interrupt.
+  *            @arg RNG_IT_SEI: Seed Error Interrupt.                   
+  * @retval The new state of RNG_IT (SET or RESET).
+  */
+ITStatus RNG_GetITStatus(uint8_t RNG_IT)
+{
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_RNG_GET_IT(RNG_IT));
+
+  /* Check the status of the specified RNG interrupt */
+  if ((RNG->SR & RNG_IT) != (uint8_t)RESET)
+  {
+    /* RNG_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* RNG_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the RNG_IT status */
+  return bitstatus;
+}
+
+
+/**
+  * @brief  Clears the RNG interrupt pending bit(s).
+  * @param  RNG_IT: specifies the RNG interrupt pending bit(s) to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg RNG_IT_CEI: Clock Error Interrupt.
+  *            @arg RNG_IT_SEI: Seed Error Interrupt.
+  * @retval None
+  */
+void RNG_ClearITPendingBit(uint8_t RNG_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_RNG_IT(RNG_IT));
+
+  /* Clear the selected RNG interrupt pending bit */
+  RNG->SR = (uint8_t)~RNG_IT;
+}
+/**
+  * @}
+  */ 
+  
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rtc.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rtc.c
new file mode 100644
index 0000000..a7ecb60
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rtc.c
@@ -0,0 +1,2761 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_rtc.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Real-Time Clock (RTC) peripheral:
+  *           + Initialization
+  *           + Calendar (Time and Date) configuration
+  *           + Alarms (Alarm A and Alarm B) configuration
+  *           + WakeUp Timer configuration
+  *           + Daylight Saving configuration
+  *           + Output pin Configuration
+  *           + Coarse digital Calibration configuration
+  *           + Smooth digital Calibration configuration
+  *           + TimeStamp configuration
+  *           + Tampers configuration
+  *           + Backup Data Registers configuration
+  *           + Shift control synchronisation    
+  *           + RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration
+  *           + Interrupts and flags management
+  *
+@verbatim
+
+ ===================================================================
+              ##### Backup Domain Operating Condition #####
+ ===================================================================
+ [..] The real-time clock (RTC), the RTC backup registers, and the backup 
+      SRAM (BKP SRAM) can be powered from the VBAT voltage when the main 
+      VDD supply is powered off.
+      To retain the content of the RTC backup registers, backup SRAM, and supply 
+      the RTC when VDD is turned off, VBAT pin can be connected to an optional 
+      standby voltage supplied by a battery or by another source.
+
+ [..] To allow the RTC to operate even when the main digital supply (VDD) is turned
+      off, the VBAT pin powers the following blocks:
+   (#) The RTC
+   (#) The LSE oscillator
+   (#) The backup SRAM when the low power backup regulator is enabled
+   (#) PC13 to PC15 I/Os, plus PI8 I/O (when available)
+  
+ [..] When the backup domain is supplied by VDD (analog switch connected to VDD),
+      the following functions are available:
+   (#) PC14 and PC15 can be used as either GPIO or LSE pins
+   (#) PC13 can be used as a GPIO or as the RTC_AF1 pin
+   (#) PI8 can be used as a GPIO or as the RTC_AF2 pin
+  
+ [..] When the backup domain is supplied by VBAT (analog switch connected to VBAT 
+      because VDD is not present), the following functions are available:
+   (#) PC14 and PC15 can be used as LSE pins only
+   (#) PC13 can be used as the RTC_AF1 pin 
+   (#) PI8 can be used as the RTC_AF2 pin
+  
+            
+                   ##### Backup Domain Reset #####
+ ===================================================================
+ [..] The backup domain reset sets all RTC registers and the RCC_BDCR register 
+      to their reset values. The BKPSRAM is not affected by this reset. The only
+      way of resetting the BKPSRAM is through the Flash interface by requesting 
+      a protection level change from 1 to 0.
+ [..] A backup domain reset is generated when one of the following events occurs:
+   (#) Software reset, triggered by setting the BDRST bit in the 
+       RCC Backup domain control register (RCC_BDCR). You can use the
+       RCC_BackupResetCmd().
+   (#) VDD or VBAT power on, if both supplies have previously been powered off.
+  
+
+                   ##### Backup Domain Access #####
+ ===================================================================
+ [..] After reset, the backup domain (RTC registers, RTC backup data 
+      registers and backup SRAM) is protected against possible unwanted write 
+      accesses. 
+ [..] To enable access to the RTC Domain and RTC registers, proceed as follows:
+   (+) Enable the Power Controller (PWR) APB1 interface clock using the
+       RCC_APB1PeriphClockCmd() function.
+   (+) Enable access to RTC domain using the PWR_BackupAccessCmd() function.
+   (+) Select the RTC clock source using the RCC_RTCCLKConfig() function.
+   (+) Enable RTC Clock using the RCC_RTCCLKCmd() function.
+  
+  
+                  ##### How to use RTC Driver #####
+ ===================================================================
+ [..] 
+   (+) Enable the RTC domain access (see description in the section above)
+   (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour 
+       format using the RTC_Init() function.
+  
+ *** Time and Date configuration ***
+ ===================================
+ [..] 
+   (+) To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
+       and RTC_SetDate() functions.
+   (+) To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate() functions.
+   (+) Use the RTC_DayLightSavingConfig() function to add or sub one
+       hour to the RTC Calendar.    
+  
+ *** Alarm configuration ***
+ ===========================
+ [..]
+   (+) To configure the RTC Alarm use the RTC_SetAlarm() function.
+   (+) Enable the selected RTC Alarm using the RTC_AlarmCmd() function
+   (+) To read the RTC Alarm, use the RTC_GetAlarm() function.
+   (+) To read the RTC alarm SubSecond, use the RTC_GetAlarmSubSecond() function.
+  
+ *** RTC Wakeup configuration ***
+ ================================
+ [..] 
+   (+) Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
+       function.
+   (+) Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() function  
+   (+) Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
+   (+) To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
+       function.
+  
+ *** Outputs configuration ***
+ =============================
+ [..] The RTC has 2 different outputs:
+   (+) AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
+       and WaKeUp signals. To output the selected RTC signal on RTC_AF1 pin, use the 
+       RTC_OutputConfig() function.                
+   (+) AFO_CALIB: this output is 512Hz signal or 1Hz. To output the RTC Clock on 
+       RTC_AF1 pin, use the RTC_CalibOutputCmd() function.
+  
+ *** Smooth digital Calibration configuration ***
+ ================================================    
+ [..]
+   (+) Configure the RTC Original Digital Calibration Value and the corresponding
+       calibration cycle period (32s,16s and 8s) using the RTC_SmoothCalibConfig() 
+       function.
+  
+ *** Coarse digital Calibration configuration ***
+ ================================================
+ [..]
+   (+) Configure the RTC Coarse Calibration Value and the corresponding
+       sign using the RTC_CoarseCalibConfig() function.
+   (+) Enable the RTC Coarse Calibration using the RTC_CoarseCalibCmd() function  
+  
+ *** TimeStamp configuration ***
+ ===============================
+ [..]
+   (+) Configure the RTC_AF1 trigger and enables the RTC TimeStamp using the RTC
+      _TimeStampCmd() function.
+   (+) To read the RTC TimeStamp Time and Date register, use the RTC_GetTimeStamp()
+       function.
+   (+) To read the RTC TimeStamp SubSecond register, use the 
+       RTC_GetTimeStampSubSecond() function.
+   (+) The TAMPER1 alternate function can be mapped either to RTC_AF1(PC13)
+       or RTC_AF2 (PI8) depending on the value of TAMP1INSEL bit in 
+       RTC_TAFCR register. You can use the  RTC_TamperPinSelection() function to
+       select the corresponding pin.     
+  
+ *** Tamper configuration ***
+ ============================
+ [..]
+   (+) Enable the RTC Tamper using the RTC_TamperCmd() function.
+   (+) Configure the Tamper filter count using RTC_TamperFilterConfig()
+       function. 
+   (+) Configure the RTC Tamper trigger Edge or Level according to the Tamper 
+       filter (if equal to 0 Edge else Level) value using the RTC_TamperConfig() 
+       function.
+   (+) Configure the Tamper sampling frequency using RTC_TamperSamplingFreqConfig()
+       function.
+   (+) Configure the Tamper precharge or discharge duration using 
+       RTC_TamperPinsPrechargeDuration() function.
+   (+) Enable the Tamper Pull-UP using RTC_TamperPullUpDisableCmd() function.
+   (+) Enable the Time stamp on Tamper detection event using  
+       TC_TSOnTamperDetecCmd() function.
+   (+) The TIMESTAMP alternate function can be mapped to either RTC_AF1 
+       or RTC_AF2 depending on the value of the TSINSEL bit in the RTC_TAFCR 
+       register. You can use the  RTC_TimeStampPinSelection() function to select 
+       the corresponding pin. 
+  
+ *** Backup Data Registers configuration ***
+ ===========================================
+ [..]
+   (+) To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
+       function.  
+   (+) To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
+       function.
+   
+
+                  ##### RTC and low power modes #####
+ ===================================================================
+ [..] The MCU can be woken up from a low power mode by an RTC alternate 
+      function.
+ [..] The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
+      RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
+      These RTC alternate functions can wake up the system from the Stop and 
+      Standby lowpower modes.
+ [..] The system can also wake up from low power modes without depending 
+      on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
+      or the RTC wakeup events.
+ [..] The RTC provides a programmable time base for waking up from the 
+      Stop or Standby mode at regular intervals.
+      Wakeup from STOP and Standby modes is possible only when the RTC clock source
+      is LSE or LSI.
+  
+
+          ##### Selection of RTC_AF1 alternate functions #####
+ ===================================================================
+ [..] The RTC_AF1 pin (PC13) can be used for the following purposes:
+   (+) AFO_ALARM output
+   (+) AFO_CALIB output
+   (+) AFI_TAMPER
+   (+) AFI_TIMESTAMP
+ 
+ [..]   
+   +-------------------------------------------------------------------------------------------------------------+
+   |     Pin         |AFO_ALARM |AFO_CALIB |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
+   |  configuration  | ENABLED  | ENABLED  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
+   |  and function   |          |          |           |              | selection  |  selection   |Configuration |
+   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
+   |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
+   |   output OD     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      0       |
+   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
+   |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
+   |   output PP     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      1       |
+   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
+   | Calibration out |          |          |           |              |    Don't   |     Don't    |              |
+   |   output PP     |     0    |    1     |Don't care | Don't care   |    care    |     care     |  Don't care  |
+   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
+   |  TAMPER input   |          |          |           |              |            |     Don't    |              |
+   |   floating      |     0    |    0     |     1     |      0       |      0     |     care     |  Don't care  |
+   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
+   |  TIMESTAMP and  |          |          |           |              |            |              |              |
+   |  TAMPER input   |     0    |    0     |     1     |      1       |      0     |      0       |  Don't care  |
+   |   floating      |          |          |           |              |            |              |              |
+   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
+   | TIMESTAMP input |          |          |           |              |    Don't   |              |              |
+   |    floating     |     0    |    0     |     0     |      1       |    care    |      0       |  Don't care  |
+   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
+   |  Standard GPIO  |     0    |    0     |     0     |      0       | Don't care |  Don't care  |  Don't care  |
+   +-------------------------------------------------------------------------------------------------------------+
+
+            
+        #####  Selection of RTC_AF2 alternate functions #####
+ ===================================================================
+ [..] The RTC_AF2 pin (PI8) can be used for the following purposes:
+   (+) AFI_TAMPER
+   (+) AFI_TIMESTAMP
+ [..]
+   +---------------------------------------------------------------------------------------+
+   |     Pin         |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
+   |  configuration  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
+   |  and function   |           |              | selection  |  selection   |Configuration |
+   |-----------------|-----------|--------------|------------|--------------|--------------|
+   |  TAMPER input   |           |              |            |     Don't    |              |
+   |   floating      |     1     |      0       |      1     |     care     |  Don't care  |
+   |-----------------|-----------|--------------|------------|--------------|--------------|
+   |  TIMESTAMP and  |           |              |            |              |              |
+   |  TAMPER input   |     1     |      1       |      1     |      1       |  Don't care  |
+   |   floating      |           |              |            |              |              |
+   |-----------------|-----------|--------------|------------|--------------|--------------|
+   | TIMESTAMP input |           |              |    Don't   |              |              |
+   |    floating     |     0     |      1       |    care    |      1       |  Don't care  |
+   |-----------------|-----------|--------------|------------|--------------|--------------|
+   |  Standard GPIO  |     0     |      0       | Don't care |  Don't care  |  Don't care  |
+   +---------------------------------------------------------------------------------------+   
+ 
+     
+@endverbatim
+  
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_rtc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup RTC 
+  * @brief RTC driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* Masks Definition */
+#define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
+#define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
+#define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
+#define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
+#define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
+                                            RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
+                                            RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
+                                            RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F | \
+                                            RTC_FLAG_RECALPF | RTC_FLAG_SHPF))
+
+#define INITMODE_TIMEOUT         ((uint32_t) 0x00010000)
+#define SYNCHRO_TIMEOUT          ((uint32_t) 0x00020000)
+#define RECALPF_TIMEOUT          ((uint32_t) 0x00020000)
+#define SHPF_TIMEOUT             ((uint32_t) 0x00001000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+static uint8_t RTC_ByteToBcd2(uint8_t Value);
+static uint8_t RTC_Bcd2ToByte(uint8_t Value);
+
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup RTC_Private_Functions
+  * @{
+  */ 
+
+/** @defgroup RTC_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+             ##### Initialization and Configuration functions #####
+ ===============================================================================
+ 
+ [..] This section provide functions allowing to initialize and configure the RTC
+      Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
+      Write protection, enter and exit the RTC initialization mode, RTC registers
+      synchronization check and reference clock detection enable.
+  
+   (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
+       split into 2 programmable prescalers to minimize power consumption.
+       (++) A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
+       (++) When both prescalers are used, it is recommended to configure the 
+            asynchronous prescaler to a high value to minimize consumption.
+
+   (#) All RTC registers are Write protected. Writing to the RTC registers
+       is enabled by writing a key into the Write Protection register, RTC_WPR.
+
+   (#) To Configure the RTC Calendar, user application should enter initialization
+       mode. In this mode, the calendar counter is stopped and its value can be 
+       updated. When the initialization sequence is complete, the calendar restarts 
+       counting after 4 RTCCLK cycles.
+
+   (#) To read the calendar through the shadow registers after Calendar initialization,
+       calendar update or after wakeup from low power modes the software must first 
+       clear the RSF flag. The software must then wait until it is set again before 
+       reading the calendar, which means that the calendar registers have been 
+       correctly copied into the RTC_TR and RTC_DR shadow registers.
+       The RTC_WaitForSynchro() function implements the above software sequence 
+       (RSF clear and RSF check).
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the RTC registers to their default reset values.
+  * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
+  *         registers.       
+  * @param  None
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC registers are deinitialized
+  *          - ERROR: RTC registers are not deinitialized
+  */
+ErrorStatus RTC_DeInit(void)
+{
+  __IO uint32_t wutcounter = 0x00;
+  uint32_t wutwfstatus = 0x00;
+  ErrorStatus status = ERROR;
+  
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Set Initialization mode */
+  if (RTC_EnterInitMode() == ERROR)
+  {
+    status = ERROR;
+  }  
+  else
+  {
+    /* Reset TR, DR and CR registers */
+    RTC->TR = (uint32_t)0x00000000;
+    RTC->DR = (uint32_t)0x00002101;
+    /* Reset All CR bits except CR[2:0] */
+    RTC->CR &= (uint32_t)0x00000007;
+  
+    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
+    do
+    {
+      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
+      wutcounter++;  
+    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
+    
+    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
+    {
+      status = ERROR;
+    }
+    else
+    {
+      /* Reset all RTC CR register bits */
+      RTC->CR &= (uint32_t)0x00000000;
+      RTC->WUTR = (uint32_t)0x0000FFFF;
+      RTC->PRER = (uint32_t)0x007F00FF;
+      RTC->CALIBR = (uint32_t)0x00000000;
+      RTC->ALRMAR = (uint32_t)0x00000000;        
+      RTC->ALRMBR = (uint32_t)0x00000000;
+      RTC->SHIFTR = (uint32_t)0x00000000;
+      RTC->CALR = (uint32_t)0x00000000;
+      RTC->ALRMASSR = (uint32_t)0x00000000;
+      RTC->ALRMBSSR = (uint32_t)0x00000000;
+      
+      /* Reset ISR register and exit initialization mode */
+      RTC->ISR = (uint32_t)0x00000000;
+      
+      /* Reset Tamper and alternate functions configuration register */
+      RTC->TAFCR = 0x00000000;
+  
+      if(RTC_WaitForSynchro() == ERROR)
+      {
+        status = ERROR;
+      }
+      else
+      {
+        status = SUCCESS;      
+      }
+    }
+  }
+  
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF;  
+  
+  return status;
+}
+
+/**
+  * @brief  Initializes the RTC registers according to the specified parameters 
+  *         in RTC_InitStruct.
+  * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
+  *         the configuration information for the RTC peripheral.
+  * @note   The RTC Prescaler register is write protected and can be written in 
+  *         initialization mode only.  
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC registers are initialized
+  *          - ERROR: RTC registers are not initialized  
+  */
+ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
+{
+  ErrorStatus status = ERROR;
+  
+  /* Check the parameters */
+  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
+  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
+  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Set Initialization mode */
+  if (RTC_EnterInitMode() == ERROR)
+  {
+    status = ERROR;
+  } 
+  else
+  {
+    /* Clear RTC CR FMT Bit */
+    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
+    /* Set RTC_CR register */
+    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
+  
+    /* Configure the RTC PRER */
+    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
+    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
+
+    /* Exit Initialization mode */
+    RTC_ExitInitMode();
+
+    status = SUCCESS;    
+  }
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+  
+  return status;
+}
+
+/**
+  * @brief  Fills each RTC_InitStruct member with its default value.
+  * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
+  *         initialized.
+  * @retval None
+  */
+void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
+{
+  /* Initialize the RTC_HourFormat member */
+  RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
+    
+  /* Initialize the RTC_AsynchPrediv member */
+  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
+
+  /* Initialize the RTC_SynchPrediv member */
+  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
+}
+
+/**
+  * @brief  Enables or disables the RTC registers write protection.
+  * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
+  *         RTC_TAFCR and RTC_BKPxR.
+  * @note   Writing a wrong key reactivates the write protection.
+  * @note   The protection mechanism is not affected by system reset.  
+  * @param  NewState: new state of the write protection.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RTC_WriteProtectionCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  if (NewState != DISABLE)
+  {
+    /* Enable the write protection for RTC registers */
+    RTC->WPR = 0xFF;   
+  }
+  else
+  {
+    /* Disable the write protection for RTC registers */
+    RTC->WPR = 0xCA;
+    RTC->WPR = 0x53;    
+  }
+}
+
+/**
+  * @brief  Enters the RTC Initialization mode.
+  * @note   The RTC Initialization mode is write protected, use the 
+  *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
+  * @param  None
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC is in Init mode
+  *          - ERROR: RTC is not in Init mode  
+  */
+ErrorStatus RTC_EnterInitMode(void)
+{
+  __IO uint32_t initcounter = 0x00;
+  ErrorStatus status = ERROR;
+  uint32_t initstatus = 0x00;
+     
+  /* Check if the Initialization mode is set */
+  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
+  {
+    /* Set the Initialization mode */
+    RTC->ISR = (uint32_t)RTC_INIT_MASK;
+    
+    /* Wait till RTC is in INIT state and if Time out is reached exit */
+    do
+    {
+      initstatus = RTC->ISR & RTC_ISR_INITF;
+      initcounter++;  
+    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
+    
+    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
+    {
+      status = SUCCESS;
+    }
+    else
+    {
+      status = ERROR;
+    }        
+  }
+  else
+  {
+    status = SUCCESS;  
+  } 
+    
+  return (status);  
+}
+
+/**
+  * @brief  Exits the RTC Initialization mode.
+  * @note   When the initialization sequence is complete, the calendar restarts 
+  *         counting after 4 RTCCLK cycles.  
+  * @note   The RTC Initialization mode is write protected, use the 
+  *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
+  * @param  None
+  * @retval None
+  */
+void RTC_ExitInitMode(void)
+{ 
+  /* Exit Initialization mode */
+  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
+}
+
+/**
+  * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
+  *         synchronized with RTC APB clock.
+  * @note   The RTC Resynchronization mode is write protected, use the 
+  *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
+  * @note   To read the calendar through the shadow registers after Calendar 
+  *         initialization, calendar update or after wakeup from low power modes 
+  *         the software must first clear the RSF flag. 
+  *         The software must then wait until it is set again before reading 
+  *         the calendar, which means that the calendar registers have been 
+  *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
+  * @param  None
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC registers are synchronised
+  *          - ERROR: RTC registers are not synchronised
+  */
+ErrorStatus RTC_WaitForSynchro(void)
+{
+  __IO uint32_t synchrocounter = 0;
+  ErrorStatus status = ERROR;
+  uint32_t synchrostatus = 0x00;
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+    
+  /* Clear RSF flag */
+  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
+    
+  /* Wait the registers to be synchronised */
+  do
+  {
+    synchrostatus = RTC->ISR & RTC_ISR_RSF;
+    synchrocounter++;  
+  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
+    
+  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
+  {
+    status = SUCCESS;
+  }
+  else
+  {
+    status = ERROR;
+  }        
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+    
+  return (status); 
+}
+
+/**
+  * @brief  Enables or disables the RTC reference clock detection.
+  * @param  NewState: new state of the RTC reference clock.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC reference clock detection is enabled
+  *          - ERROR: RTC reference clock detection is disabled  
+  */
+ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
+{ 
+  ErrorStatus status = ERROR;
+  
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+    
+  /* Set Initialization mode */
+  if (RTC_EnterInitMode() == ERROR)
+  {
+    status = ERROR;
+  } 
+  else
+  {  
+    if (NewState != DISABLE)
+    {
+      /* Enable the RTC reference clock detection */
+      RTC->CR |= RTC_CR_REFCKON;   
+    }
+    else
+    {
+      /* Disable the RTC reference clock detection */
+      RTC->CR &= ~RTC_CR_REFCKON;    
+    }
+    /* Exit Initialization mode */
+    RTC_ExitInitMode();
+    
+    status = SUCCESS;
+  }
+  
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF;  
+  
+  return status; 
+}
+
+/**
+  * @brief  Enables or Disables the Bypass Shadow feature.
+  * @note   When the Bypass Shadow is enabled the calendar value are taken 
+  *         directly from the Calendar counter.
+  * @param  NewState: new state of the Bypass Shadow feature.
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+*/
+void RTC_BypassShadowCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+  
+  if (NewState != DISABLE)
+  {
+    /* Set the BYPSHAD bit */
+    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
+  }
+  else
+  {
+    /* Reset the BYPSHAD bit */
+    RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
+  }
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group2 Time and Date configuration functions
+ *  @brief   Time and Date configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+                 ##### Time and Date configuration functions #####
+ ===============================================================================  
+ 
+ [..] This section provide functions allowing to program and read the RTC Calendar
+      (Time and Date).
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Set the RTC current time.
+  * @param  RTC_Format: specifies the format of the entered parameters.
+  *          This parameter can be  one of the following values:
+  *            @arg RTC_Format_BIN:  Binary data format 
+  *            @arg RTC_Format_BCD:  BCD data format
+  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
+  *                        the time configuration information for the RTC.     
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC Time register is configured
+  *          - ERROR: RTC Time register is not configured
+  */
+ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
+{
+  uint32_t tmpreg = 0;
+  ErrorStatus status = ERROR;
+    
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(RTC_Format));
+  
+  if (RTC_Format == RTC_Format_BIN)
+  {
+    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
+    {
+      assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
+      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
+    } 
+    else
+    {
+      RTC_TimeStruct->RTC_H12 = 0x00;
+      assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
+    }
+    assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
+    assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
+  }
+  else
+  {
+    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
+    {
+      tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
+      assert_param(IS_RTC_HOUR12(tmpreg));
+      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
+    } 
+    else
+    {
+      RTC_TimeStruct->RTC_H12 = 0x00;
+      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
+    }
+    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
+    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
+  }
+  
+  /* Check the input parameters format */
+  if (RTC_Format != RTC_Format_BIN)
+  {
+    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
+             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
+             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
+             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
+  }  
+  else
+  {
+    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
+                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
+                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
+                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
+  }  
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Set Initialization mode */
+  if (RTC_EnterInitMode() == ERROR)
+  {
+    status = ERROR;
+  } 
+  else
+  {
+    /* Set the RTC_TR register */
+    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
+
+    /* Exit Initialization mode */
+    RTC_ExitInitMode(); 
+
+    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
+    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
+    {
+    if(RTC_WaitForSynchro() == ERROR)
+    {
+      status = ERROR;
+    }
+    else
+    {
+      status = SUCCESS;
+    }
+  }
+    else
+    {
+      status = SUCCESS;
+    }
+  }
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+    
+  return status;
+}
+
+/**
+  * @brief  Fills each RTC_TimeStruct member with its default value
+  *         (Time = 00h:00min:00sec).
+  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
+  *         initialized.
+  * @retval None
+  */
+void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
+{
+  /* Time = 00h:00min:00sec */
+  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
+  RTC_TimeStruct->RTC_Hours = 0;
+  RTC_TimeStruct->RTC_Minutes = 0;
+  RTC_TimeStruct->RTC_Seconds = 0; 
+}
+
+/**
+  * @brief  Get the RTC current Time.
+  * @param  RTC_Format: specifies the format of the returned parameters.
+  *          This parameter can be  one of the following values:
+  *            @arg RTC_Format_BIN:  Binary data format 
+  *            @arg RTC_Format_BCD:  BCD data format
+  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
+  *                        contain the returned current time configuration.     
+  * @retval None
+  */
+void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(RTC_Format));
+
+  /* Get the RTC_TR register */
+  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
+  
+  /* Fill the structure fields with the read parameters */
+  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
+  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
+  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
+  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
+
+  /* Check the input parameters format */
+  if (RTC_Format == RTC_Format_BIN)
+  {
+    /* Convert the structure parameters to Binary format */
+    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
+    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
+    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
+  }
+}
+
+/**
+  * @brief  Gets the RTC current Calendar Sub seconds value.
+  * @note   This function freeze the Time and Date registers after reading the 
+  *         SSR register.
+  * @param  None
+  * @retval RTC current Calendar Sub seconds value.
+  */
+uint32_t RTC_GetSubSecond(void)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Get sub seconds values from the correspondent registers*/
+  tmpreg = (uint32_t)(RTC->SSR);
+  
+  /* Read DR register to unfroze calendar registers */
+  (void) (RTC->DR);
+  
+  return (tmpreg);
+}
+
+/**
+  * @brief  Set the RTC current date.
+  * @param  RTC_Format: specifies the format of the entered parameters.
+  *          This parameter can be  one of the following values:
+  *            @arg RTC_Format_BIN:  Binary data format 
+  *            @arg RTC_Format_BCD:  BCD data format
+  * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
+  *                         the date configuration information for the RTC.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC Date register is configured
+  *          - ERROR: RTC Date register is not configured
+  */
+ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
+{
+  uint32_t tmpreg = 0;
+  ErrorStatus status = ERROR;
+  
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(RTC_Format));
+
+  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
+  {
+    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
+  }  
+  if (RTC_Format == RTC_Format_BIN)
+  {
+    assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
+    assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
+    assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
+  }
+  else
+  {
+    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
+    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
+    assert_param(IS_RTC_MONTH(tmpreg));
+    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
+    assert_param(IS_RTC_DATE(tmpreg));
+  }
+  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
+
+  /* Check the input parameters format */
+  if (RTC_Format != RTC_Format_BIN)
+  {
+    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
+              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
+              ((uint32_t)RTC_DateStruct->RTC_Date) | \
+              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
+  }  
+  else
+  {
+    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
+              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
+              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
+              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
+  }
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Set Initialization mode */
+  if (RTC_EnterInitMode() == ERROR)
+  {
+    status = ERROR;
+  } 
+  else
+  {
+    /* Set the RTC_DR register */
+    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
+
+    /* Exit Initialization mode */
+    RTC_ExitInitMode(); 
+
+    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
+    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
+    {
+    if(RTC_WaitForSynchro() == ERROR)
+    {
+      status = ERROR;
+    }
+    else
+    {
+      status = SUCCESS;
+    }
+  }
+    else
+    {
+      status = SUCCESS;
+    }
+  }
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF;   
+  
+  return status;
+}
+
+/**
+  * @brief  Fills each RTC_DateStruct member with its default value
+  *         (Monday, January 01 xx00).
+  * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
+  *         initialized.
+  * @retval None
+  */
+void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
+{
+  /* Monday, January 01 xx00 */
+  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
+  RTC_DateStruct->RTC_Date = 1;
+  RTC_DateStruct->RTC_Month = RTC_Month_January;
+  RTC_DateStruct->RTC_Year = 0;
+}
+
+/**
+  * @brief  Get the RTC current date. 
+  * @param  RTC_Format: specifies the format of the returned parameters.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_Format_BIN: Binary data format 
+  *            @arg RTC_Format_BCD: BCD data format
+  * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
+  *                        contain the returned current date configuration.     
+  * @retval None
+  */
+void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(RTC_Format));
+  
+  /* Get the RTC_TR register */
+  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
+
+  /* Fill the structure fields with the read parameters */
+  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
+  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
+  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
+  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
+
+  /* Check the input parameters format */
+  if (RTC_Format == RTC_Format_BIN)
+  {
+    /* Convert the structure parameters to Binary format */
+    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
+    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
+    RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group3 Alarms configuration functions
+ *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+         ##### Alarms A and B configuration functions #####
+ ===============================================================================  
+ 
+ [..] This section provide functions allowing to program and read the RTC Alarms.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Set the specified RTC Alarm.
+  * @note   The Alarm register can only be written when the corresponding Alarm
+  *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
+  * @param  RTC_Format: specifies the format of the returned parameters.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_Format_BIN: Binary data format 
+  *            @arg RTC_Format_BCD: BCD data format
+  * @param  RTC_Alarm: specifies the alarm to be configured.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_Alarm_A: to select Alarm A
+  *            @arg RTC_Alarm_B: to select Alarm B  
+  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
+  *                          contains the alarm configuration parameters.     
+  * @retval None
+  */
+void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(RTC_Format));
+  assert_param(IS_RTC_ALARM(RTC_Alarm));
+  assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
+  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
+
+  if (RTC_Format == RTC_Format_BIN)
+  {
+    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
+    {
+      assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
+      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
+    } 
+    else
+    {
+      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
+      assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
+    }
+    assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
+    assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
+    
+    if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
+    }
+    else
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
+    }
+  }
+  else
+  {
+    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
+    {
+      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
+      assert_param(IS_RTC_HOUR12(tmpreg));
+      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
+    } 
+    else
+    {
+      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
+      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
+    }
+    
+    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
+    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
+    
+    if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
+    {
+      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
+    }
+    else
+    {
+      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
+    }    
+  }
+
+  /* Check the input parameters format */
+  if (RTC_Format != RTC_Format_BIN)
+  {
+    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
+              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
+              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
+              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
+              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
+              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
+              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
+  }  
+  else
+  {
+    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
+              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
+              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
+              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
+              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
+              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
+              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
+  } 
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Configure the Alarm register */
+  if (RTC_Alarm == RTC_Alarm_A)
+  {
+    RTC->ALRMAR = (uint32_t)tmpreg;
+  }
+  else
+  {
+    RTC->ALRMBR = (uint32_t)tmpreg;
+  }
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF;   
+}
+
+/**
+  * @brief  Fills each RTC_AlarmStruct member with its default value
+  *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
+  *         all fields are masked).
+  * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
+  *         will be initialized.
+  * @retval None
+  */
+void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
+{
+  /* Alarm Time Settings : Time = 00h:00mn:00sec */
+  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
+  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
+  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
+  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
+
+  /* Alarm Date Settings : Date = 1st day of the month */
+  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
+  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
+
+  /* Alarm Masks Settings : Mask =  all fields are not masked */
+  RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
+}
+
+/**
+  * @brief  Get the RTC Alarm value and masks.
+  * @param  RTC_Format: specifies the format of the output parameters.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_Format_BIN: Binary data format 
+  *            @arg RTC_Format_BCD: BCD data format
+  * @param  RTC_Alarm: specifies the alarm to be read.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_Alarm_A: to select Alarm A
+  *            @arg RTC_Alarm_B: to select Alarm B  
+  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
+  *                          contains the output alarm configuration values.     
+  * @retval None
+  */
+void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(RTC_Format));
+  assert_param(IS_RTC_ALARM(RTC_Alarm)); 
+
+  /* Get the RTC_ALRMxR register */
+  if (RTC_Alarm == RTC_Alarm_A)
+  {
+    tmpreg = (uint32_t)(RTC->ALRMAR);
+  }
+  else
+  {
+    tmpreg = (uint32_t)(RTC->ALRMBR);
+  }
+
+  /* Fill the structure with the read parameters */
+  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
+                                                     RTC_ALRMAR_HU)) >> 16);
+  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
+                                                     RTC_ALRMAR_MNU)) >> 8);
+  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
+                                                     RTC_ALRMAR_SU));
+  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
+  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
+  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
+  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
+
+  if (RTC_Format == RTC_Format_BIN)
+  {
+    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
+                                                        RTC_AlarmTime.RTC_Hours);
+    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
+                                                        RTC_AlarmTime.RTC_Minutes);
+    RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
+                                                        RTC_AlarmTime.RTC_Seconds);
+    RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
+  }  
+}
+
+/**
+  * @brief  Enables or disables the specified RTC Alarm.
+  * @param  RTC_Alarm: specifies the alarm to be configured.
+  *          This parameter can be any combination of the following values:
+  *            @arg RTC_Alarm_A: to select Alarm A
+  *            @arg RTC_Alarm_B: to select Alarm B  
+  * @param  NewState: new state of the specified alarm.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC Alarm is enabled/disabled
+  *          - ERROR: RTC Alarm is not enabled/disabled  
+  */
+ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
+{
+  __IO uint32_t alarmcounter = 0x00;
+  uint32_t alarmstatus = 0x00;
+  ErrorStatus status = ERROR;
+    
+  /* Check the parameters */
+  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Configure the Alarm state */
+  if (NewState != DISABLE)
+  {
+    RTC->CR |= (uint32_t)RTC_Alarm;
+
+    status = SUCCESS;    
+  }
+  else
+  { 
+    /* Disable the Alarm in RTC_CR register */
+    RTC->CR &= (uint32_t)~RTC_Alarm;
+   
+    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
+    do
+    {
+      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
+      alarmcounter++;  
+    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
+    
+    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
+    {
+      status = ERROR;
+    } 
+    else
+    {
+      status = SUCCESS;
+    }        
+  } 
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+  
+  return status;
+}
+
+/**
+  * @brief  Configure the RTC AlarmA/B Sub seconds value and mask.*
+  * @note   This function is performed only when the Alarm is disabled. 
+  * @param  RTC_Alarm: specifies the alarm to be configured.
+  *   This parameter can be one of the following values:
+  *     @arg RTC_Alarm_A: to select Alarm A
+  *     @arg RTC_Alarm_B: to select Alarm B
+  * @param  RTC_AlarmSubSecondValue: specifies the Sub seconds value.
+  *   This parameter can be a value from 0 to 0x00007FFF.
+  * @param  RTC_AlarmSubSecondMask:  specifies the Sub seconds Mask.
+  *   This parameter can be any combination of the following values:
+  *     @arg RTC_AlarmSubSecondMask_All    : All Alarm SS fields are masked.
+  *                                          There is no comparison on sub seconds for Alarm.
+  *     @arg RTC_AlarmSubSecondMask_SS14_1 : SS[14:1] are don't care in Alarm comparison.
+  *                                          Only SS[0] is compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_2 : SS[14:2] are don't care in Alarm comparison.
+  *                                          Only SS[1:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_3 : SS[14:3] are don't care in Alarm comparison.
+  *                                          Only SS[2:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_4 : SS[14:4] are don't care in Alarm comparison.
+  *                                          Only SS[3:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_5 : SS[14:5] are don't care in Alarm comparison.
+  *                                          Only SS[4:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_6 : SS[14:6] are don't care in Alarm comparison.
+  *                                          Only SS[5:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_7 : SS[14:7] are don't care in Alarm comparison.
+  *                                          Only SS[6:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_8 : SS[14:8] are don't care in Alarm comparison.
+  *                                          Only SS[7:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_9 : SS[14:9] are don't care in Alarm comparison.
+  *                                          Only SS[8:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_10: SS[14:10] are don't care in Alarm comparison.
+  *                                          Only SS[9:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_11: SS[14:11] are don't care in Alarm comparison.
+  *                                          Only SS[10:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_12: SS[14:12] are don't care in Alarm comparison.
+  *                                          Only SS[11:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14_13: SS[14:13] are don't care in Alarm comparison.
+  *                                          Only SS[12:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_SS14   : SS[14] is don't care in Alarm comparison.
+  *                                          Only SS[13:0] are compared
+  *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
+  *                                          to activate alarm
+  * @retval None
+  */
+void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_ALARM(RTC_Alarm));
+  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
+  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
+  
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+  
+  /* Configure the Alarm A or Alarm B Sub Second registers */
+  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
+  
+  if (RTC_Alarm == RTC_Alarm_A)
+  {
+    /* Configure the Alarm A Sub Second register */
+    RTC->ALRMASSR = tmpreg;
+  }
+  else
+  {
+    /* Configure the Alarm B Sub Second register */
+    RTC->ALRMBSSR = tmpreg;
+  }
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF;
+
+}
+
+/**
+  * @brief  Gets the RTC Alarm Sub seconds value.
+  * @param  RTC_Alarm: specifies the alarm to be read.
+  *   This parameter can be one of the following values:
+  *     @arg RTC_Alarm_A: to select Alarm A
+  *     @arg RTC_Alarm_B: to select Alarm B
+  * @param  None
+  * @retval RTC Alarm Sub seconds value.
+  */
+uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Get the RTC_ALRMxR register */
+  if (RTC_Alarm == RTC_Alarm_A)
+  {
+    tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
+  }
+  else
+  {
+    tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
+  } 
+  
+  return (tmpreg);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group4 WakeUp Timer configuration functions
+ *  @brief   WakeUp Timer configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+                 ##### WakeUp Timer configuration functions #####
+ ===============================================================================  
+
+ [..] This section provide functions allowing to program and read the RTC WakeUp.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the RTC Wakeup clock source.
+  * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
+  *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).      
+  * @param  RTC_WakeUpClock: Wakeup Clock source.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_WakeUpClock_RTCCLK_Div16: RTC Wakeup Counter Clock = RTCCLK/16
+  *            @arg RTC_WakeUpClock_RTCCLK_Div8: RTC Wakeup Counter Clock = RTCCLK/8
+  *            @arg RTC_WakeUpClock_RTCCLK_Div4: RTC Wakeup Counter Clock = RTCCLK/4
+  *            @arg RTC_WakeUpClock_RTCCLK_Div2: RTC Wakeup Counter Clock = RTCCLK/2
+  *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
+  *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
+  * @retval None
+  */
+void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Clear the Wakeup Timer clock source bits in CR register */
+  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
+
+  /* Configure the clock source */
+  RTC->CR |= (uint32_t)RTC_WakeUpClock;
+  
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+}
+
+/**
+  * @brief  Configures the RTC Wakeup counter.
+  * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
+  *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).        
+  * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
+  *          This parameter can be a value from 0x0000 to 0xFFFF. 
+  * @retval None
+  */
+void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
+  
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+  
+  /* Configure the Wakeup Timer counter */
+  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
+  
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+}
+
+/**
+  * @brief  Returns the RTC WakeUp timer counter value.
+  * @param  None
+  * @retval The RTC WakeUp Counter value.
+  */
+uint32_t RTC_GetWakeUpCounter(void)
+{
+  /* Get the counter value */
+  return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
+}
+
+/**
+  * @brief  Enables or Disables the RTC WakeUp timer.
+  * @param  NewState: new state of the WakeUp timer.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
+{
+  __IO uint32_t wutcounter = 0x00;
+  uint32_t wutwfstatus = 0x00;
+  ErrorStatus status = ERROR;
+  
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the Wakeup Timer */
+    RTC->CR |= (uint32_t)RTC_CR_WUTE;
+    status = SUCCESS;    
+  }
+  else
+  {
+    /* Disable the Wakeup Timer */
+    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
+    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
+    do
+    {
+      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
+      wutcounter++;  
+    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
+    
+    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
+    {
+      status = ERROR;
+    }
+    else
+    {
+      status = SUCCESS;
+    }    
+  }
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+  
+  return status;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group5 Daylight Saving configuration functions
+ *  @brief   Daylight Saving configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Daylight Saving configuration functions #####
+ ===============================================================================  
+
+ [..] This section provide functions allowing to configure the RTC DayLight Saving.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Adds or substract one hour from the current time.
+  * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
+  *          This parameter can be one of the following values:
+  *            @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
+  *            @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
+  * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
+  *                            in CR register to store the operation.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
+  *            @arg RTC_StoreOperation_Set: BCK Bit Set
+  * @retval None
+  */
+void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
+  assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Clear the bits to be configured */
+  RTC->CR &= (uint32_t)~(RTC_CR_BCK);
+
+  /* Configure the RTC_CR register */
+  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+}
+
+/**
+  * @brief  Returns the RTC Day Light Saving stored operation.
+  * @param  None
+  * @retval RTC Day Light Saving stored operation.
+  *          - RTC_StoreOperation_Reset
+  *          - RTC_StoreOperation_Set       
+  */
+uint32_t RTC_GetStoreOperation(void)
+{
+  return (RTC->CR & RTC_CR_BCK);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group6 Output pin Configuration function
+ *  @brief   Output pin Configuration function 
+ *
+@verbatim   
+ ===============================================================================
+                 ##### Output pin Configuration function #####
+ ===============================================================================  
+
+ [..] This section provide functions allowing to configure the RTC Output source.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the RTC output source (AFO_ALARM).
+  * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
+  *          This parameter can be one of the following values:
+  *            @arg RTC_Output_Disable: No output selected
+  *            @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
+  *            @arg RTC_Output_AlarmB: signal of AlarmB mapped to output
+  *            @arg RTC_Output_WakeUp: signal of WakeUp mapped to output
+  * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
+  *          This parameter can be one of the following:
+  *            @arg RTC_OutputPolarity_High: The output pin is high when the 
+  *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
+  *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
+  *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
+  * @retval None
+  */
+void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_OUTPUT(RTC_Output));
+  assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Clear the bits to be configured */
+  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
+
+  /* Configure the output selection and polarity */
+  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group7 Digital Calibration configuration functions
+ *  @brief   Coarse Calibration configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Digital Calibration configuration functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the Coarse calibration parameters.
+  * @param  RTC_CalibSign: specifies the sign of the coarse calibration value.
+  *          This parameter can be  one of the following values:
+  *            @arg RTC_CalibSign_Positive: The value sign is positive 
+  *            @arg RTC_CalibSign_Negative: The value sign is negative
+  * @param  Value: value of coarse calibration expressed in ppm (coded on 5 bits).
+  *    
+  * @note   This Calibration value should be between 0 and 63 when using negative
+  *         sign with a 2-ppm step.
+  *           
+  * @note   This Calibration value should be between 0 and 126 when using positive
+  *         sign with a 4-ppm step.
+  *           
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC Coarse calibration are initialized
+  *          - ERROR: RTC Coarse calibration are not initialized     
+  */
+ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
+{
+  ErrorStatus status = ERROR;
+   
+  /* Check the parameters */
+  assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
+  assert_param(IS_RTC_CALIB_VALUE(Value)); 
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Set Initialization mode */
+  if (RTC_EnterInitMode() == ERROR)
+  {
+    status = ERROR;
+  } 
+  else
+  {
+    /* Set the coarse calibration value */
+    RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
+    /* Exit Initialization mode */
+    RTC_ExitInitMode();
+    
+    status = SUCCESS;
+  } 
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+  
+  return status;
+}
+
+/**
+  * @brief  Enables or disables the Coarse calibration process.
+  * @param  NewState: new state of the Coarse calibration.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC Coarse calibration are enabled/disabled
+  *          - ERROR: RTC Coarse calibration are not enabled/disabled    
+  */
+ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
+{
+  ErrorStatus status = ERROR;
+  
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+  
+  /* Set Initialization mode */
+  if (RTC_EnterInitMode() == ERROR)
+  {
+    status =  ERROR;
+  }
+  else
+  {
+    if (NewState != DISABLE)
+    {
+      /* Enable the Coarse Calibration */
+      RTC->CR |= (uint32_t)RTC_CR_DCE;
+    }
+    else
+    { 
+      /* Disable the Coarse Calibration */
+      RTC->CR &= (uint32_t)~RTC_CR_DCE;
+    }
+    /* Exit Initialization mode */
+    RTC_ExitInitMode();
+    
+    status = SUCCESS;
+  } 
+  
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+  
+  return status;
+}
+
+/**
+  * @brief  Enables or disables the RTC clock to be output through the relative pin.
+  * @param  NewState: new state of the digital calibration Output.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RTC_CalibOutputCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the RTC clock output */
+    RTC->CR |= (uint32_t)RTC_CR_COE;
+  }
+  else
+  { 
+    /* Disable the RTC clock output */
+    RTC->CR &= (uint32_t)~RTC_CR_COE;
+  }
+  
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+}
+
+/**
+  * @brief  Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
+  * @param  RTC_CalibOutput : Select the Calibration output Selection .
+  *   This parameter can be one of the following values:
+  *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
+  *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
+  * @retval None
+*/
+void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+  
+  /*clear flags before configuration */
+  RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
+
+  /* Configure the RTC_CR register */
+  RTC->CR |= (uint32_t)RTC_CalibOutput;
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF;
+}
+
+/**
+  * @brief  Configures the Smooth Calibration Settings.
+  * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
+  *   This parameter can be can be one of the following values:
+  *     @arg RTC_SmoothCalibPeriod_32sec : The smooth calibration period is 32s.
+  *     @arg RTC_SmoothCalibPeriod_16sec : The smooth calibration period is 16s.
+  *     @arg RTC_SmoothCalibPeriod_8sec  : The smooth calibartion period is 8s.
+  * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
+  *   This parameter can be one of the following values:
+  *     @arg RTC_SmoothCalibPlusPulses_Set  : Add one RTCCLK puls every 2**11 pulses.
+  *     @arg RTC_SmoothCalibPlusPulses_Reset: No RTCCLK pulses are added.
+  * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
+  *   This parameter can be one any value from 0 to 0x000001FF.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC Calib registers are configured
+  *          - ERROR: RTC Calib registers are not configured
+*/
+ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
+                                  uint32_t RTC_SmoothCalibPlusPulses,
+                                  uint32_t RTC_SmouthCalibMinusPulsesValue)
+{
+  ErrorStatus status = ERROR;
+  uint32_t recalpfcount = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
+  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
+  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+  
+  /* check if a calibration is pending*/
+  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
+  {
+    /* wait until the Calibration is completed*/
+    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
+    {
+      recalpfcount++;
+    }
+  }
+
+  /* check if the calibration pending is completed or if there is no calibration operation at all*/
+  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
+  {
+    /* Configure the Smooth calibration settings */
+    RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
+
+    status = SUCCESS;
+  }
+  else
+  {
+    status = ERROR;
+  }
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF;
+  
+  return (ErrorStatus)(status);
+}
+
+/**
+  * @}
+  */
+
+
+/** @defgroup RTC_Group8 TimeStamp configuration functions
+ *  @brief   TimeStamp configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+                 ##### TimeStamp configuration functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or Disables the RTC TimeStamp functionality with the 
+  *         specified time stamp pin stimulating edge.
+  * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
+  *         activated.
+  *          This parameter can be one of the following:
+  *            @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
+  *                                    edge of the related pin.
+  *            @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
+  *                                     falling edge of the related pin.
+  * @param  NewState: new state of the TimeStamp.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* Get the RTC_CR register and clear the bits to be configured */
+  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
+
+  /* Get the new configuration */
+  if (NewState != DISABLE)
+  {
+    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
+  }
+  else
+  {
+    tmpreg |= (uint32_t)(RTC_TimeStampEdge);
+  }
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  /* Configure the Time Stamp TSEDGE and Enable bits */
+  RTC->CR = (uint32_t)tmpreg;
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+}
+
+/**
+  * @brief  Get the RTC TimeStamp value and masks.
+  * @param  RTC_Format: specifies the format of the output parameters.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_Format_BIN: Binary data format 
+  *            @arg RTC_Format_BCD: BCD data format
+  * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
+  *                             contains the TimeStamp time values. 
+  * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
+  *                             contains the TimeStamp date values.     
+  * @retval None
+  */
+void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
+                                      RTC_DateTypeDef* RTC_StampDateStruct)
+{
+  uint32_t tmptime = 0, tmpdate = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(RTC_Format));
+
+  /* Get the TimeStamp time and date registers values */
+  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
+  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
+
+  /* Fill the Time structure fields with the read parameters */
+  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
+  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
+  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
+  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
+
+  /* Fill the Date structure fields with the read parameters */
+  RTC_StampDateStruct->RTC_Year = 0;
+  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
+  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
+  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
+
+  /* Check the input parameters format */
+  if (RTC_Format == RTC_Format_BIN)
+  {
+    /* Convert the Time structure parameters to Binary format */
+    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
+    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
+    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
+
+    /* Convert the Date structure parameters to Binary format */
+    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
+    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
+    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
+  }
+}
+
+/**
+  * @brief  Get the RTC timestamp Sub seconds value.
+  * @param  None
+  * @retval RTC current timestamp Sub seconds value.
+  */
+uint32_t RTC_GetTimeStampSubSecond(void)
+{
+  /* Get timestamp sub seconds values from the correspondent registers */
+  return (uint32_t)(RTC->TSSSR);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group9 Tampers configuration functions
+ *  @brief   Tampers configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+                 ##### Tampers configuration functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the select Tamper pin edge.
+  * @param  RTC_Tamper: Selected tamper pin.
+  *          This parameter can be RTC_Tamper_1.
+  * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
+  *         stimulates tamper event. 
+  *   This parameter can be one of the following values:
+  *     @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
+  *     @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.
+  *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
+  *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
+  * @retval None
+  */
+void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
+  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
+ 
+  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
+  {  
+    /* Configure the RTC_TAFCR register */
+    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
+  }
+  else
+  { 
+    /* Configure the RTC_TAFCR register */
+    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
+  }  
+}
+
+/**
+  * @brief  Enables or Disables the Tamper detection.
+  * @param  RTC_Tamper: Selected tamper pin.
+  *          This parameter can be RTC_Tamper_1.
+  * @param  NewState: new state of the tamper pin.
+  *          This parameter can be: ENABLE or DISABLE.                   
+  * @retval None
+  */
+void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_TAMPER(RTC_Tamper));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected Tamper pin */
+    RTC->TAFCR |= (uint32_t)RTC_Tamper;
+  }
+  else
+  {
+    /* Disable the selected Tamper pin */
+    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
+  }  
+}
+
+/**
+  * @brief  Configures the Tampers Filter.
+  * @param  RTC_TamperFilter: Specifies the tampers filter.
+  *   This parameter can be one of the following values:
+  *     @arg RTC_TamperFilter_Disable: Tamper filter is disabled.
+  *     @arg RTC_TamperFilter_2Sample: Tamper is activated after 2 consecutive 
+  *                                    samples at the active level 
+  *     @arg RTC_TamperFilter_4Sample: Tamper is activated after 4 consecutive 
+  *                                    samples at the active level
+  *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
+  *                                    samples at the active level 
+  * @retval None
+  */
+void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
+   
+  /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
+  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
+
+  /* Configure the RTC_TAFCR register */
+  RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
+}
+
+/**
+  * @brief  Configures the Tampers Sampling Frequency.
+  * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
+  *   This parameter can be one of the following values:
+  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div32768: Each of the tamper inputs are sampled
+  *                                           with a frequency =  RTCCLK / 32768
+  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div16384: Each of the tamper inputs are sampled
+  *                                           with a frequency =  RTCCLK / 16384
+  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div8192: Each of the tamper inputs are sampled
+  *                                           with a frequency =  RTCCLK / 8192
+  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div4096: Each of the tamper inputs are sampled
+  *                                           with a frequency =  RTCCLK / 4096
+  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div2048: Each of the tamper inputs are sampled
+  *                                           with a frequency =  RTCCLK / 2048
+  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div1024: Each of the tamper inputs are sampled
+  *                                           with a frequency =  RTCCLK / 1024
+  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div512: Each of the tamper inputs are sampled
+  *                                           with a frequency =  RTCCLK / 512  
+  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
+  *                                           with a frequency =  RTCCLK / 256  
+  * @retval None
+  */
+void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
+ 
+  /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
+  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
+
+  /* Configure the RTC_TAFCR register */
+  RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
+}
+
+/**
+  * @brief  Configures the Tampers Pins input Precharge Duration.
+  * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
+  *         Precharge Duration.
+  *   This parameter can be one of the following values:
+  *     @arg RTC_TamperPrechargeDuration_1RTCCLK: Tamper pins are precharged before sampling during 1 RTCCLK cycle
+  *     @arg RTC_TamperPrechargeDuration_2RTCCLK: Tamper pins are precharged before sampling during 2 RTCCLK cycle
+  *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are precharged before sampling during 4 RTCCLK cycle    
+  *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are precharged before sampling during 8 RTCCLK cycle
+  * @retval None
+  */
+void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
+   
+  /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
+  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
+
+  /* Configure the RTC_TAFCR register */
+  RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
+}
+
+/**
+  * @brief  Enables or Disables the TimeStamp on Tamper Detection Event.
+  * @note   The timestamp is valid even the TSE bit in tamper control register 
+  *         is reset.   
+  * @param  NewState: new state of the timestamp on tamper event.
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+   
+  if (NewState != DISABLE)
+  {
+    /* Save timestamp on tamper detection event */
+    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
+  }
+  else
+  {
+    /* Tamper detection does not cause a timestamp to be saved */
+    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
+  }
+}
+
+/**
+  * @brief  Enables or Disables the Precharge of Tamper pin.
+  * @param  NewState: new state of tamper pull up.
+  *   This parameter can be: ENABLE or DISABLE.                   
+  * @retval None
+  */
+void RTC_TamperPullUpCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+ if (NewState != DISABLE)
+  {
+    /* Enable precharge of the selected Tamper pin */
+    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
+  }
+  else
+  {
+    /* Disable precharge of the selected Tamper pin */
+    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
+  } 
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group10 Backup Data Registers configuration functions
+ *  @brief   Backup Data Registers configuration functions  
+ *
+@verbatim   
+ ===============================================================================
+             ##### Backup Data Registers configuration functions ##### 
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Writes a data in a specified RTC Backup data register.
+  * @param  RTC_BKP_DR: RTC Backup data Register number.
+  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
+  *                          specify the register.
+  * @param  Data: Data to be written in the specified RTC Backup data register.                     
+  * @retval None
+  */
+void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
+{
+  __IO uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RTC_BKP(RTC_BKP_DR));
+
+  tmp = RTC_BASE + 0x50;
+  tmp += (RTC_BKP_DR * 4);
+
+  /* Write the specified register */
+  *(__IO uint32_t *)tmp = (uint32_t)Data;
+}
+
+/**
+  * @brief  Reads data from the specified RTC Backup data Register.
+  * @param  RTC_BKP_DR: RTC Backup data Register number.
+  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
+  *                          specify the register.                   
+  * @retval None
+  */
+uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
+{
+  __IO uint32_t tmp = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RTC_BKP(RTC_BKP_DR));
+
+  tmp = RTC_BASE + 0x50;
+  tmp += (RTC_BKP_DR * 4);
+  
+  /* Read the specified register */
+  return (*(__IO uint32_t *)tmp);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group11 RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions
+ *  @brief   RTC Tamper and TimeStamp Pins Selection and Output Type Config 
+ *           configuration functions  
+ *
+@verbatim   
+ ==================================================================================================
+ ##### RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions ##### 
+ ==================================================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Selects the RTC Tamper Pin.
+  * @param  RTC_TamperPin: specifies the RTC Tamper Pin.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_TamperPin_PC13: PC13 is selected as RTC Tamper Pin.
+  *            @arg RTC_TamperPin_PI8: PI8 is selected as RTC Tamper Pin.    
+  * @retval None
+  */
+void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
+  
+  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
+  RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
+}
+
+/**
+  * @brief  Selects the RTC TimeStamp Pin.
+  * @param  RTC_TimeStampPin: specifies the RTC TimeStamp Pin.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
+  *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
+  * @retval None
+  */
+void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
+  
+  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
+  RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
+}
+
+/**
+  * @brief  Configures the RTC Output Pin mode. 
+  * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
+  *                                    Open Drain mode.
+  *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
+  *                                    Push Pull mode.    
+  * @retval None
+  */
+void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
+  
+  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
+  RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group12 Shift control synchronisation functions
+ *  @brief   Shift control synchronisation functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Shift control synchronisation functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the Synchronization Shift Control Settings.
+  * @note   When REFCKON is set, firmware must not write to Shift control register 
+  * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
+  *   This parameter can be one of the following values :
+  *     @arg RTC_ShiftAdd1S_Set  : Add one second to the clock calendar. 
+  *     @arg RTC_ShiftAdd1S_Reset: No effect.
+  * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
+  *         This parameter can be one any value from 0 to 0x7FFF.
+  * @retval An ErrorStatus enumeration value:
+  *          - SUCCESS: RTC Shift registers are configured
+  *          - ERROR: RTC Shift registers are not configured
+*/
+ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
+{
+  ErrorStatus status = ERROR;
+  uint32_t shpfcount = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
+  assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+  
+  /* Check if a Shift is pending*/
+  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
+  {
+    /* Wait until the shift is completed*/
+    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
+    {
+      shpfcount++;
+    }
+  }
+
+  /* Check if the Shift pending is completed or if there is no Shift operation at all*/
+  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
+  {
+    /* check if the reference clock detection is disabled */
+    if((RTC->CR & RTC_CR_REFCKON) == RESET)
+    {
+      /* Configure the Shift settings */
+      RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
+    
+      if(RTC_WaitForSynchro() == ERROR)
+      {
+        status = ERROR;
+      }
+      else
+      {
+        status = SUCCESS;
+      }
+    }
+    else
+    {
+      status = ERROR;
+    }
+  }
+  else
+  {
+    status = ERROR;
+  }
+
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF;
+  
+  return (ErrorStatus)(status);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Group13 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions  
+ *
+@verbatim   
+ ===============================================================================
+              ##### Interrupts and flags management functions #####
+ ===============================================================================  
+ [..] All RTC interrupts are connected to the EXTI controller.
+ 
+   (+) To enable the RTC Alarm interrupt, the following sequence is required:
+       (++) Configure and enable the EXTI Line 17 in interrupt mode and select 
+            the rising edge sensitivity using the EXTI_Init() function.
+       (++) Configure and enable the RTC_Alarm IRQ channel in the NVIC using the 
+            NVIC_Init() function.
+       (++) Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B) using
+            the RTC_SetAlarm() and RTC_AlarmCmd() functions.
+
+   (+) To enable the RTC Wakeup interrupt, the following sequence is required:
+       (++) Configure and enable the EXTI Line 22 in interrupt mode and select the
+            rising edge sensitivity using the EXTI_Init() function.
+       (++) Configure and enable the RTC_WKUP IRQ channel in the NVIC using the 
+            NVIC_Init() function.
+       (++) Configure the RTC to generate the RTC wakeup timer event using the 
+            RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() 
+            functions.
+
+   (+) To enable the RTC Tamper interrupt, the following sequence is required:
+       (++) Configure and enable the EXTI Line 21 in interrupt mode and select 
+            the rising edge sensitivity using the EXTI_Init() function.
+       (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the
+            NVIC_Init() function.
+       (++) Configure the RTC to detect the RTC tamper event using the 
+            RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
+
+   (+) To enable the RTC TimeStamp interrupt, the following sequence is required:
+       (++) Configure and enable the EXTI Line 21 in interrupt mode and select the
+            rising edge sensitivity using the EXTI_Init() function.
+       (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the 
+            NVIC_Init() function.
+       (++) Configure the RTC to detect the RTC time stamp event using the 
+            RTC_TimeStampCmd() functions.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified RTC interrupts.
+  * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
+  *          This parameter can be any combination of the following values:
+  *            @arg RTC_IT_TS:  Time Stamp interrupt mask
+  *            @arg RTC_IT_WUT:  WakeUp Timer interrupt mask
+  *            @arg RTC_IT_ALRB:  Alarm B interrupt mask
+  *            @arg RTC_IT_ALRA:  Alarm A interrupt mask
+  *            @arg RTC_IT_TAMP: Tamper event interrupt mask
+  * @param  NewState: new state of the specified RTC interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* Disable the write protection for RTC registers */
+  RTC->WPR = 0xCA;
+  RTC->WPR = 0x53;
+
+  if (NewState != DISABLE)
+  {
+    /* Configure the Interrupts in the RTC_CR register */
+    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
+    /* Configure the Tamper Interrupt in the RTC_TAFCR */
+    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
+  }
+  else
+  {
+    /* Configure the Interrupts in the RTC_CR register */
+    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
+    /* Configure the Tamper Interrupt in the RTC_TAFCR */
+    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
+  }
+  /* Enable the write protection for RTC registers */
+  RTC->WPR = 0xFF; 
+}
+
+/**
+  * @brief  Checks whether the specified RTC flag is set or not.
+  * @param  RTC_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_FLAG_RECALPF: RECALPF event flag.
+  *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
+  *            @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
+  *            @arg RTC_FLAG_TSF: Time Stamp event flag
+  *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
+  *            @arg RTC_FLAG_ALRBF: Alarm B flag
+  *            @arg RTC_FLAG_ALRAF: Alarm A flag
+  *            @arg RTC_FLAG_INITF: Initialization mode flag
+  *            @arg RTC_FLAG_RSF: Registers Synchronized flag
+  *            @arg RTC_FLAG_INITS: Registers Configured flag
+  *            @arg RTC_FLAG_SHPF: Shift operation pending flag.
+  *            @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag
+  *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
+  *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
+  * @retval The new state of RTC_FLAG (SET or RESET).
+  */
+FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
+  
+  /* Get all the flags */
+  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
+  
+  /* Return the status of the flag */
+  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the RTC's pending flags.
+  * @param  RTC_FLAG: specifies the RTC flag to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
+  *            @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
+  *            @arg RTC_FLAG_TSF: Time Stamp event flag
+  *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
+  *            @arg RTC_FLAG_ALRBF: Alarm B flag
+  *            @arg RTC_FLAG_ALRAF: Alarm A flag
+  *            @arg RTC_FLAG_RSF: Registers Synchronized flag
+  * @retval None
+  */
+void RTC_ClearFlag(uint32_t RTC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
+
+  /* Clear the Flags in the RTC_ISR register */
+  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
+}
+
+/**
+  * @brief  Checks whether the specified RTC interrupt has occurred or not.
+  * @param  RTC_IT: specifies the RTC interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_IT_TS: Time Stamp interrupt 
+  *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
+  *            @arg RTC_IT_ALRB: Alarm B interrupt 
+  *            @arg RTC_IT_ALRA: Alarm A interrupt 
+  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
+  * @retval The new state of RTC_IT (SET or RESET).
+  */
+ITStatus RTC_GetITStatus(uint32_t RTC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t tmpreg = 0, enablestatus = 0;
+ 
+  /* Check the parameters */
+  assert_param(IS_RTC_GET_IT(RTC_IT));
+  
+  /* Get the TAMPER Interrupt enable bit and pending bit */
+  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
+ 
+  /* Get the Interrupt enable Status */
+  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
+  
+  /* Get the Interrupt pending bit */
+  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
+  
+  /* Get the status of the Interrupt */
+  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the RTC's interrupt pending bits.
+  * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg RTC_IT_TS: Time Stamp interrupt 
+  *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
+  *            @arg RTC_IT_ALRB: Alarm B interrupt 
+  *            @arg RTC_IT_ALRA: Alarm A interrupt 
+  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
+  * @retval None
+  */
+void RTC_ClearITPendingBit(uint32_t RTC_IT)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_CLEAR_IT(RTC_IT));
+
+  /* Get the RTC_ISR Interrupt pending bits mask */
+  tmpreg = (uint32_t)(RTC_IT >> 4);
+
+  /* Clear the interrupt pending bits in the RTC_ISR register */
+  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @brief  Converts a 2 digit decimal to BCD format.
+  * @param  Value: Byte to be converted.
+  * @retval Converted byte
+  */
+static uint8_t RTC_ByteToBcd2(uint8_t Value)
+{
+  uint8_t bcdhigh = 0;
+  
+  while (Value >= 10)
+  {
+    bcdhigh++;
+    Value -= 10;
+  }
+  
+  return  ((uint8_t)(bcdhigh << 4) | Value);
+}
+
+/**
+  * @brief  Convert from 2 digit BCD to Binary.
+  * @param  Value: BCD value to be converted.
+  * @retval Converted word
+  */
+static uint8_t RTC_Bcd2ToByte(uint8_t Value)
+{
+  uint8_t tmp = 0;
+  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
+  return (tmp + (Value & (uint8_t)0x0F));
+}
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sai.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sai.c
new file mode 100644
index 0000000..f02739d
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sai.c
@@ -0,0 +1,1079 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_sai.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014  
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Serial Audio Interface (SAI):
+  *           + Initialization and Configuration
+  *           + Data transfers functions
+  *           + DMA transfers management
+  *           + Interrupts and flags management 
+  *           
+  @verbatim
+ ===============================================================================
+                     ##### How to use this driver #####
+ ===============================================================================
+    [..] 
+    
+       (#) Enable peripheral clock using the following functions 
+           RCC_APB2PeriphClockCmd(RCC_APB2Periph_SAI1, ENABLE) for SAI1
+  
+       (#) For each SAI Block A/B enable SCK, SD, FS and MCLK GPIO clocks 
+           using RCC_AHB1PeriphClockCmd() function.
+  
+       (#) Peripherals alternate function: 
+           (++) Connect the pin to the desired peripherals' Alternate 
+                Function (AF) using GPIO_PinAFConfig() function.
+           (++) Configure the desired pin in alternate function by:
+                GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
+           (++) Select the type, pull-up/pull-down and output speed via 
+                GPIO_PuPd, GPIO_OType and GPIO_Speed members
+           (++) Call GPIO_Init() function
+           -@@- If an external clock source is used then the I2S CKIN pin should be 
+               also configured in Alternate function Push-pull pull-up mode.
+                
+      (#) The SAI clock can be generated from different clock source :
+          PLL I2S, PLL SAI or external clock source.
+          (++) The PLL I2S is configured using the following functions RCC_PLLI2SConfig(), 
+               RCC_PLLI2SCmd(ENABLE), RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY) and 
+               RCC_SAIPLLI2SClkDivConfig() or;
+              
+          (++) The PLL SAI is configured using the following functions RCC_PLLSAIConfig(), 
+               RCC_PLLSAICmd(ENABLE), RCC_GetFlagStatus(RCC_FLAG_PLLSAIRDY) and 
+               RCC_SAIPLLSAIClkDivConfig()or;          
+              
+          (++) External clock source is configured using the function 
+               RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly the 
+               define constant I2S_EXTERNAL_CLOCK_VAL in the stm32f4xx_conf.h file.      
+                
+      (#) Each SAI Block A or B has its own clock generator to make these two blocks 
+          completely independent. The Clock generator is configured using RCC_SAIBlockACLKConfig() and 
+          RCC_SAIBlockBCLKConfig() functions.
+                  
+      (#) Each SAI Block A or B can be configured separetely : 
+          (++) Program the Master clock divider, Audio mode, Protocol, Data Length, Clock Strobing Edge, 
+               Synchronous mode, Output drive and FIFO Thresold using SAI_Init() function.   
+               In case of master mode, program the Master clock divider (MCKDIV) using 
+               the following formula :  
+               (+++) MCLK_x = SAI_CK_x / (MCKDIV * 2) with MCLK_x = 256 * FS
+               (+++) FS = SAI_CK_x / (MCKDIV * 2) * 256
+               (+++) MCKDIV = SAI_CK_x / FS * 512
+         (++) Program the Frame Length, Frame active Length, FS Definition, FS Polarity, 
+              FS Offset using SAI_FrameInit() function.    
+         (++) Program the Slot First Bit Offset, Slot Size, Slot Number, Slot Active 
+              using SAI_SlotInit() function. 
+                   
+      (#) Enable the NVIC and the corresponding interrupt using the function 
+          SAI_ITConfig() if you need to use interrupt mode. 
+  
+      (#) When using the DMA mode 
+          (++) Configure the DMA using DMA_Init() function
+          (++) Active the needed channel Request using SAI_DMACmd() function
+   
+      (#) Enable the SAI using the SAI_Cmd() function.
+   
+      (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
+  
+      (#) The SAI has some specific functions which can be useful depending 
+          on the audio protocol selected.  
+          (++) Enable Mute mode when the audio block is a transmitter using SAI_MuteModeCmd()
+               function and configure the value transmitted during mute using SAI_MuteValueConfig().  
+          (++) Detect the Mute mode when audio block is a receiver using SAI_MuteFrameCounterConfig().             
+          (++) Enable the MONO mode without any data preprocessing in memory when the number
+               of slot is equal to 2 using SAI_MonoModeConfig() function.
+          (++) Enable data companding algorithm (U law and A law) using SAI_CompandingModeConfig().
+          (++) Choose the behavior of the SD line in output when an inactive slot is sent 
+               on the data line using SAI_TRIStateConfig() function.   
+  [..]               
+   (@)    In master TX mode: enabling the audio block immediately generates the bit clock 
+          for the external slaves even if there is no data in the FIFO, However FS signal 
+          generation is conditioned by the presence of data in the FIFO.
+                 
+   (@)    In master RX mode: enabling the audio block immediately generates the bit clock 
+          and FS signal for the external slaves. 
+                
+   (@)    It is mandatory to respect the following conditions in order to avoid bad SAI behavior: 
+            (+@)  First bit Offset <= (SLOT size - Data size)
+            (+@)  Data size <= SLOT size
+            (+@)  Number of SLOT x SLOT size = Frame length
+            (+@)  The number of slots should be even when bit FSDEF in the SAI_xFRCR is set.    
+  
+    @endverbatim  
+
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_sai.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup SAI 
+  * @brief SAI driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* *SAI registers Masks */
+#define CR1_CLEAR_MASK            ((uint32_t)0xFF07C010)
+#define FRCR_CLEAR_MASK           ((uint32_t)0xFFF88000)
+#define SLOTR_CLEAR_MASK          ((uint32_t)0x0000F020)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup SAI_Private_Functions
+  * @{
+  */
+
+/** @defgroup SAI_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+            ##### Initialization and Configuration functions #####
+ ===============================================================================  
+  [..]
+  This section provides a set of functions allowing to initialize the SAI Audio 
+  Block Mode, Audio Protocol, Data size, Synchronization between audio block, 
+  Master clock Divider, Fifo threshold, Frame configuration, slot configuration,
+  Tristate mode, Companding mode and Mute mode.  
+  [..] 
+  The SAI_Init(), SAI_FrameInit() and SAI_SlotInit() functions follows the SAI Block
+  configuration procedures for Master mode and Slave mode (details for these procedures 
+  are available in reference manual(RM0090).
+  
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitialize the SAIx peripheral registers to their default reset values.
+  * @param  SAIx: To select the SAIx peripheral, where x can be the different instances 
+  *                     
+  * @retval None
+  */
+void SAI_DeInit(SAI_TypeDef* SAIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_PERIPH(SAIx));
+
+  /* Enable SAI1 reset state */
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, ENABLE);
+  /* Release SAI1 from reset state */
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, DISABLE);  
+}
+
+/**
+  * @brief  Initializes the SAI Block x peripheral according to the specified 
+  *         parameters in the SAI_InitStruct.
+  *         
+  * @note   SAI clock is generated from a specific output of the PLLSAI or a specific  
+  *         output of the PLLI2S or from an alternate function bypassing the PLL I2S.
+  *        
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  SAI_InitStruct: pointer to a SAI_InitTypeDef structure that
+  *         contains the configuration information for the specified SAI Block peripheral.             
+  * @retval None
+  */
+void SAI_Init(SAI_Block_TypeDef* SAI_Block_x, SAI_InitTypeDef* SAI_InitStruct)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  
+  /* Check the SAI Block parameters */
+  assert_param(IS_SAI_BLOCK_MODE(SAI_InitStruct->SAI_AudioMode));
+  assert_param(IS_SAI_BLOCK_PROTOCOL(SAI_InitStruct->SAI_Protocol));
+  assert_param(IS_SAI_BLOCK_DATASIZE(SAI_InitStruct->SAI_DataSize));
+  assert_param(IS_SAI_BLOCK_FIRST_BIT(SAI_InitStruct->SAI_FirstBit));
+  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(SAI_InitStruct->SAI_ClockStrobing));
+  assert_param(IS_SAI_BLOCK_SYNCHRO(SAI_InitStruct->SAI_Synchro));
+  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(SAI_InitStruct->SAI_OUTDRIV));
+  assert_param(IS_SAI_BLOCK_NODIVIDER(SAI_InitStruct->SAI_NoDivider));
+  assert_param(IS_SAI_BLOCK_MASTER_DIVIDER(SAI_InitStruct->SAI_MasterDivider));
+  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(SAI_InitStruct->SAI_FIFOThreshold));
+
+  /* SAI Block_x CR1 Configuration */
+  /* Get the SAI Block_x CR1 value */
+  tmpreg = SAI_Block_x->CR1;
+  /* Clear MODE, PRTCFG, DS, LSBFIRST, CKSTR, SYNCEN, OUTDRIV, NODIV, and MCKDIV bits */
+  tmpreg &= CR1_CLEAR_MASK;
+  /* Configure SAI_Block_x: Audio mode, Protocol, Data Size, first transmitted bit, Clock strobing 
+     edge, Synchronization mode, Output drive, Master Divider and FIFO level */  
+  /* Set MODE bits according to SAI_AudioMode value       */
+  /* Set PRTCFG bits according to SAI_Protocol value      */
+  /* Set DS bits according to SAI_DataSize value          */
+  /* Set LSBFIRST bit according to SAI_FirstBit value     */
+  /* Set CKSTR bit according to SAI_ClockStrobing value   */
+  /* Set SYNCEN bit according to SAI_Synchro value        */
+  /* Set OUTDRIV bit according to SAI_OUTDRIV value       */
+  /* Set NODIV bit according to SAI_NoDivider value       */
+  /* Set MCKDIV bits according to SAI_MasterDivider value */
+  tmpreg |= (uint32_t)(SAI_InitStruct->SAI_AudioMode     | SAI_InitStruct->SAI_Protocol  |
+                       SAI_InitStruct->SAI_DataSize      | SAI_InitStruct->SAI_FirstBit  |  
+                       SAI_InitStruct->SAI_ClockStrobing | SAI_InitStruct->SAI_Synchro   |  
+                       SAI_InitStruct->SAI_OUTDRIV       | SAI_InitStruct->SAI_NoDivider | 
+                       (uint32_t)((SAI_InitStruct->SAI_MasterDivider) << 20));
+  /* Write to SAI_Block_x CR1 */
+  SAI_Block_x->CR1 = tmpreg;
+  
+  /* SAI Block_x CR2 Configuration */
+  /* Get the SAIBlock_x CR2 value */
+  tmpreg = SAI_Block_x->CR2;
+  /* Clear FTH bits */
+  tmpreg &= ~(SAI_xCR2_FTH);
+  /* Configure the FIFO Level */
+  /* Set FTH bits according to SAI_FIFOThreshold value */ 
+  tmpreg |= (uint32_t)(SAI_InitStruct->SAI_FIFOThreshold);
+  /* Write to SAI_Block_x CR2 */
+  SAI_Block_x->CR2 = tmpreg;
+}
+
+/**
+  * @brief  Initializes the SAI Block Audio frame according to the specified 
+  *         parameters in the SAI_FrameInitStruct.
+  *         
+  * @note   this function has no meaning if the AC'97 or SPDIF audio protocol 
+  *         are selected. 
+  *               
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  SAI_FrameInitStruct: pointer to an SAI_FrameInitTypeDef structure that
+  *         contains the configuration of audio frame for a specified SAI Block                       
+  * @retval None
+  */
+void SAI_FrameInit(SAI_Block_TypeDef* SAI_Block_x, SAI_FrameInitTypeDef* SAI_FrameInitStruct)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  
+  /* Check the SAI Block frame parameters */
+  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(SAI_FrameInitStruct->SAI_FrameLength));
+  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(SAI_FrameInitStruct->SAI_ActiveFrameLength));
+  assert_param(IS_SAI_BLOCK_FS_DEFINITION(SAI_FrameInitStruct->SAI_FSDefinition));
+  assert_param(IS_SAI_BLOCK_FS_POLARITY(SAI_FrameInitStruct->SAI_FSPolarity));
+  assert_param(IS_SAI_BLOCK_FS_OFFSET(SAI_FrameInitStruct->SAI_FSOffset));
+
+  /* SAI Block_x FRCR Configuration */
+  /* Get the SAI Block_x FRCR value */
+  tmpreg = SAI_Block_x->FRCR;
+  /* Clear FRL, FSALL, FSDEF, FSPOL, FSOFF bits */
+  tmpreg &= FRCR_CLEAR_MASK;
+  /* Configure SAI_Block_x Frame: Frame Length, Active Frame Length, Frame Synchronization
+     Definition, Frame Synchronization Polarity and Frame Synchronization Polarity */
+  /* Set FRL bits according to SAI_FrameLength value         */
+  /* Set FSALL bits according to SAI_ActiveFrameLength value */
+  /* Set FSDEF bit according to SAI_FSDefinition value       */
+  /* Set FSPOL bit according to SAI_FSPolarity value         */
+  /* Set FSOFF bit according to SAI_FSOffset value           */
+  tmpreg |= (uint32_t)((uint32_t)(SAI_FrameInitStruct->SAI_FrameLength - 1)  | 
+                       SAI_FrameInitStruct->SAI_FSOffset     | 
+                       SAI_FrameInitStruct->SAI_FSDefinition |    
+                       SAI_FrameInitStruct->SAI_FSPolarity   |                        
+                       (uint32_t)((SAI_FrameInitStruct->SAI_ActiveFrameLength - 1) << 8));
+                       
+  /* Write to SAI_Block_x FRCR */
+  SAI_Block_x->FRCR = tmpreg;
+}
+
+/**
+  * @brief  Initializes the SAI Block audio Slot according to the specified 
+  *         parameters in the SAI_SlotInitStruct.
+  *         
+  * @note   this function has no meaning if the AC'97 or SPDIF audio protocol 
+  *         are selected.
+  *               
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  SAI_SlotInitStruct: pointer to an SAI_SlotInitTypeDef structure that
+  *         contains the configuration of audio slot for a specified SAI Block                      
+  * @retval None
+  */
+void SAI_SlotInit(SAI_Block_TypeDef* SAI_Block_x, SAI_SlotInitTypeDef* SAI_SlotInitStruct)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  
+  /* Check the SAI Block Slot parameters */
+  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(SAI_SlotInitStruct->SAI_FirstBitOffset));
+  assert_param(IS_SAI_BLOCK_SLOT_SIZE(SAI_SlotInitStruct->SAI_SlotSize));
+  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(SAI_SlotInitStruct->SAI_SlotNumber));
+  assert_param(IS_SAI_SLOT_ACTIVE(SAI_SlotInitStruct->SAI_SlotActive));
+
+  /* SAI Block_x SLOTR Configuration */
+  /* Get the SAI Block_x SLOTR value */
+  tmpreg = SAI_Block_x->SLOTR;
+  /* Clear FBOFF, SLOTSZ, NBSLOT, SLOTEN bits */
+  tmpreg &= SLOTR_CLEAR_MASK;
+  /* Configure SAI_Block_x Slot: First bit offset, Slot size, Number of Slot in  
+     audio frame and slots activated in audio frame */
+  /* Set FBOFF bits according to SAI_FirstBitOffset value  */
+  /* Set SLOTSZ bits according to SAI_SlotSize value       */
+  /* Set NBSLOT bits according to SAI_SlotNumber value     */
+  /* Set SLOTEN bits according to SAI_SlotActive value     */
+  tmpreg |= (uint32_t)(SAI_SlotInitStruct->SAI_FirstBitOffset | 
+                       SAI_SlotInitStruct->SAI_SlotSize       | 
+                       SAI_SlotInitStruct->SAI_SlotActive     |    
+                       (uint32_t)((SAI_SlotInitStruct->SAI_SlotNumber - 1) <<  8));
+                       
+  /* Write to SAI_Block_x SLOTR */
+  SAI_Block_x->SLOTR = tmpreg;
+}
+
+/**
+  * @brief  Fills each SAI_InitStruct member with its default value.
+  * @param  SAI_InitStruct: pointer to a SAI_InitTypeDef structure which will 
+  *         be initialized.  
+  * @retval None
+  */
+void SAI_StructInit(SAI_InitTypeDef* SAI_InitStruct)
+{
+  /* Reset SAI init structure parameters values */
+  /* Initialize the SAI_AudioMode member */
+  SAI_InitStruct->SAI_AudioMode = SAI_Mode_MasterTx;
+  /* Initialize the SAI_Protocol member */
+  SAI_InitStruct->SAI_Protocol = SAI_Free_Protocol;
+  /* Initialize the SAI_DataSize member */
+  SAI_InitStruct->SAI_DataSize = SAI_DataSize_8b;
+  /* Initialize the SAI_FirstBit member */
+  SAI_InitStruct->SAI_FirstBit = SAI_FirstBit_MSB;
+  /* Initialize the SAI_ClockStrobing member */
+  SAI_InitStruct->SAI_ClockStrobing = SAI_ClockStrobing_FallingEdge;
+  /* Initialize the SAI_Synchro member */
+  SAI_InitStruct->SAI_Synchro = SAI_Asynchronous;
+  /* Initialize the SAI_OUTDRIV member */
+  SAI_InitStruct->SAI_OUTDRIV = SAI_OutputDrive_Disabled;
+  /* Initialize the SAI_NoDivider member */
+  SAI_InitStruct->SAI_NoDivider = SAI_MasterDivider_Enabled;
+  /* Initialize the SAI_MasterDivider member */
+  SAI_InitStruct->SAI_MasterDivider = 0;
+  /* Initialize the SAI_FIFOThreshold member */
+  SAI_InitStruct->SAI_FIFOThreshold = SAI_Threshold_FIFOEmpty;
+}
+
+/**
+  * @brief  Fills each SAI_FrameInitStruct member with its default value.
+  * @param  SAI_FrameInitStruct: pointer to a SAI_FrameInitTypeDef structure 
+  *         which will be initialized.                     
+  * @retval None
+  */
+void SAI_FrameStructInit(SAI_FrameInitTypeDef* SAI_FrameInitStruct)
+{
+  /* Reset SAI Frame init structure parameters values */
+  /* Initialize the SAI_FrameLength member */
+  SAI_FrameInitStruct->SAI_FrameLength = 8;
+  /* Initialize the SAI_ActiveFrameLength member */
+  SAI_FrameInitStruct->SAI_ActiveFrameLength = 1;
+  /* Initialize the SAI_FSDefinition member */
+  SAI_FrameInitStruct->SAI_FSDefinition = SAI_FS_StartFrame;
+  /* Initialize the SAI_FSPolarity member */
+  SAI_FrameInitStruct->SAI_FSPolarity = SAI_FS_ActiveLow;
+  /* Initialize the SAI_FSOffset member */
+  SAI_FrameInitStruct->SAI_FSOffset = SAI_FS_FirstBit;
+}
+
+/**
+  * @brief  Fills each SAI_SlotInitStruct member with its default value.
+  * @param  SAI_SlotInitStruct: pointer to a SAI_SlotInitTypeDef structure 
+  *         which will be initialized.                     
+  * @retval None
+  */
+void SAI_SlotStructInit(SAI_SlotInitTypeDef* SAI_SlotInitStruct)
+{
+  /* Reset SAI Slot init structure parameters values */
+  /* Initialize the SAI_FirstBitOffset member */
+  SAI_SlotInitStruct->SAI_FirstBitOffset = 0;
+  /* Initialize the SAI_SlotSize member */
+  SAI_SlotInitStruct->SAI_SlotSize = SAI_SlotSize_DataSize;
+  /* Initialize the SAI_SlotNumber member */
+  SAI_SlotInitStruct->SAI_SlotNumber = 1;
+  /* Initialize the SAI_SlotActive member */
+  SAI_SlotInitStruct->SAI_SlotActive = SAI_Slot_NotActive;
+
+}
+
+/**
+  * @brief  Enables or disables the specified SAI Block peripheral.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  NewState: new state of the SAI_Block_x peripheral. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SAI_Cmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SAI peripheral */
+    SAI_Block_x->CR1 |= SAI_xCR1_SAIEN;
+  }
+  else
+  {
+    /* Disable the selected SAI peripheral */
+    SAI_Block_x->CR1 &= ~(SAI_xCR1_SAIEN);
+  }
+}
+
+/**
+  * @brief  Configures the mono mode for the selected SAI block.
+  * 
+  * @note  This function has a meaning only when the number of slot is equal to 2. 
+  *      
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  SAI_MonoMode: specifies the SAI block mono mode.
+  *          This parameter can be one of the following values:
+  *            @arg SAI_MonoMode : Set mono audio mode
+  *            @arg SAI_StreoMode : Set streo audio mode                       
+  * @retval None
+  */
+void SAI_MonoModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_Mono_StreoMode)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_SAI_BLOCK_MONO_STREO_MODE(SAI_MonoMode));
+  /* Clear MONO bit */
+  SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
+  /* Set new Mono Mode value */
+  SAI_Block_x->CR1 |= SAI_MonoMode;
+}
+
+/**
+  * @brief  Configures the TRIState managment on data line for the selected SAI block.
+  * 
+  * @note  This function has a meaning only when the SAI block is configured in transmitter 
+  *      
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  SAI_TRIState: specifies the SAI block TRIState management.
+  *          This parameter can be one of the following values:
+  *            @arg SAI_Output_NotReleased : SD output line is still drived by the SAI.
+  *            @arg SAI_Output_Released : SD output line is released (HI-Z)                       
+  * @retval None
+  */
+void SAI_TRIStateConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_TRIState)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(SAI_TRIState));
+  /* Clear MONO bit */
+  SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
+  /* Set new Mono Mode value */
+  SAI_Block_x->CR1 |= SAI_MonoMode;  
+  
+}
+
+/**
+  * @brief  Configures the companding mode for the selected SAI block.
+  * 
+  * @note  The data expansion or data compression are determined by the state of
+  *        SAI block selected (transmitter or receiver). 
+
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.              
+  * @param  SAI_CompandingMode: specifies the SAI block companding mode.
+  *          This parameter can be one of the following values:
+  *            @arg SAI_NoCompanding : no companding algorithm set
+  *            @arg SAI_ULaw_1CPL_Companding : Set U law (algorithm 1's complement representation)
+  *            @arg SAI_ALaw_1CPL_Companding : Set A law (algorithm 1's complement repesentation)  
+  *            @arg SAI_ULaw_2CPL_Companding : Set U law (algorithm 2's complement representation)
+  *            @arg SAI_ALaw_2CPL_Companding : Set A law (algorithm 2's complement repesentation)  
+  * @retval None
+  */
+void SAI_CompandingModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_CompandingMode)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(SAI_CompandingMode));
+  /* Clear Companding Mode bits */
+  SAI_Block_x->CR2 &= ~(SAI_xCR2_COMP);
+  /* Set new Companding Mode value */
+  SAI_Block_x->CR2 |= SAI_CompandingMode;
+}
+
+/**
+  * @brief  Enables or disables the Mute mode for the selected SAI block.
+  *    
+  * @note   This function has a meaning only when the audio block is transmitter
+  * @note   Mute mode is applied for an entire frame for all the valid slot
+  *         It becomes active at the end of an audio frame when set somewhere in a frame. 
+  *         Mute mode exit occurs at the end of the frame in which the bit MUTE has been set.
+  *
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  NewState: new state of the SAIx block. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SAI_MuteModeCmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SAI block mute mode */
+    SAI_Block_x->CR2 |= SAI_xCR2_MUTE;
+  }
+  else
+  {
+    /* Disable the selected SAI SS output */
+    SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTE);
+  }
+}
+
+/**
+  * @brief  Configure the mute value for the selected SAI block.
+  *    
+  * @note   This function has a meaning only when the audio block is transmitter
+  * @note   the configuration last value sent during mute mode has only a meaning 
+  *          when the number of slot is lower or equal to 2 and if the MUTE bit is set.
+  *           
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  SAI_MuteValue: specifies the SAI block mute value.
+  *          This parameter can be one of the following values:
+  *            @arg SAI_ZeroValue : bit value 0 is sent during Mute Mode
+  *            @arg SAI_LastSentValue : Last value is sent during Mute Mode  
+  * @retval None
+  */
+void SAI_MuteValueConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteValue)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_SAI_BLOCK_MUTE_VALUE(SAI_MuteValue));
+  
+  /* Clear Mute value bits */
+  SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTEVAL);
+  /* Set new Mute value */
+  SAI_Block_x->CR2 |= SAI_MuteValue;
+}
+
+/**
+  * @brief  Enables or disables the Mute mode for the selected SAI block. 
+  *
+  * @note   This function has a meaning only when the audio block is Receiver
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  SAI_MuteCounter: specifies the SAI block mute value.
+  *         This parameter can be a number between 0 and 63.  
+ 
+  * @retval None
+  */
+void SAI_MuteFrameCounterConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteCounter)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_SAI_BLOCK_MUTE_COUNTER(SAI_MuteCounter));
+  
+  /* Clear Mute value bits */
+  SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTECNT);
+  /* Set new Mute value */
+  SAI_Block_x->CR2 |= (SAI_MuteCounter << 7);
+}
+
+/**
+  * @brief  Reinitialize the FIFO pointer
+  *   
+  * @note   The FIFO pointers can be reinitialized at anytime The data present 
+  *         into the FIFO, if it is not empty, will be lost. 
+  * 
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  * @param  NewState: new state of the selected SAI TI communication mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SAI_FlushFIFO(SAI_Block_TypeDef* SAI_Block_x)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+
+  /* FIFO flush */
+  SAI_Block_x->CR2 |= SAI_xCR2_FFLUSH;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Group2 Data transfers functions
+ *  @brief   Data transfers functions
+ *
+@verbatim   
+ ===============================================================================
+                       ##### Data transfers functions #####
+ ===============================================================================  
+  [..]
+  This section provides a set of functions allowing to manage the SAI data transfers.
+  [..]
+  In reception, data are received and then stored into an internal FIFO while 
+  In transmission, data are first stored into an internal FIFO before being 
+  transmitted.
+  [..]
+  The read access of the SAI_xDR register can be done using the SAI_ReceiveData()
+  function and returns the Rx buffered value. Whereas a write access to the SAI_DR 
+  can be done using SAI_SendData() function and stores the written data into 
+  Tx buffer.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Returns the most recent received data by the SAI block x peripheral. 
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
+  *         
+  * @retval The value of the received data.
+  */
+uint32_t SAI_ReceiveData(SAI_Block_TypeDef* SAI_Block_x)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  
+  /* Return the data in the DR register */
+  return SAI_Block_x->DR;
+}
+
+/**
+  * @brief  Transmits a Data through the SAI block x peripheral.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  *        
+  * @param  Data: Data to be transmitted.
+  * @retval None
+  */
+void SAI_SendData(SAI_Block_TypeDef* SAI_Block_x, uint32_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  
+  /* Write in the DR register the data to be sent */
+  SAI_Block_x->DR = Data;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Group3 DMA transfers management functions
+ *  @brief   DMA transfers management functions
+  *
+@verbatim   
+ ===============================================================================
+                  ##### DMA transfers management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the SAI Block x DMA interface.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
+  * @param  NewState: new state of the selected SAI block DMA transfer request.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SAI block mute mode */
+    SAI_Block_x->CR1 |= SAI_xCR1_DMAEN;
+  }
+  else
+  {
+    /* Disable the selected SAI SS output */
+    SAI_Block_x->CR1 &= ~(SAI_xCR1_DMAEN);
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SAI_Group4 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+  *
+@verbatim   
+ ===============================================================================
+            ##### Interrupts and flags management functions #####
+ ===============================================================================  
+  [..]
+  This section provides a set of functions allowing to configure the SAI Interrupts 
+  sources and check or clear the flags or pending bits status.
+  The user should identify which mode will be used in his application to manage 
+  the communication: Polling mode, Interrupt mode or DMA mode. 
+    
+  *** Polling Mode ***
+  ====================
+  [..]
+  In Polling Mode, the SAI communication can be managed by 7 flags:
+     (#) SAI_FLAG_FREQ : to indicate if there is a FIFO Request to write or to read.
+     (#) SAI_FLAG_MUTEDET : to indicate if a MUTE frame detected
+     (#) SAI_FLAG_OVRUDR : to indicate if an Overrun or Underrun error occur
+     (#) SAI_FLAG_AFSDET : to indicate if there is the detection of a audio frame 
+                          synchronisation (FS) earlier than expected
+     (#) SAI_FLAG_LFSDET : to indicate if there is the detection of a audio frame 
+                          synchronisation (FS) later than expected              
+     (#) SAI_FLAG_CNRDY : to indicate if  the codec is not ready to communicate during 
+                         the reception of the TAG 0 (slot0) of the AC97 audio frame 
+     (#) SAI_FLAG_WCKCFG: to indicate if wrong clock configuration in master mode 
+                         error occurs.
+  [..]
+  In this Mode it is advised to use the following functions:
+     (+) FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);
+     (+) void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);
+
+  *** Interrupt Mode ***
+  ======================
+  [..]
+  In Interrupt Mode, the SAI communication can be managed by 7 interrupt sources
+  and 7 pending bits: 
+  (+) Pending Bits:
+     (##) SAI_IT_FREQ : to indicate if there is a FIFO Request to write or to read.
+     (##) SAI_IT_MUTEDET : to indicate if a MUTE frame detected.
+     (##) SAI_IT_OVRUDR : to indicate if an Overrun or Underrun error occur.
+     (##) SAI_IT_AFSDET : to indicate if there is the detection of a audio frame 
+                          synchronisation (FS) earlier than expected.
+     (##) SAI_IT_LFSDET : to indicate if there is the detection of a audio frame 
+                          synchronisation (FS) later than expected.              
+     (##) SAI_IT_CNRDY : to indicate if  the codec is not ready to communicate during 
+                         the reception of the TAG 0 (slot0) of the AC97 audio frame. 
+     (##) SAI_IT_WCKCFG: to indicate if wrong clock configuration in master mode 
+                         error occurs.
+
+  (+) Interrupt Source:
+     (##) SAI_IT_FREQ : specifies the interrupt source for FIFO Request.
+     (##) SAI_IT_MUTEDET : specifies the interrupt source for MUTE frame detected.
+     (##) SAI_IT_OVRUDR : specifies the interrupt source for overrun or underrun error.
+     (##) SAI_IT_AFSDET : specifies the interrupt source for anticipated frame synchronization
+                          detection interrupt.
+     (##) SAI_IT_LFSDET : specifies the interrupt source for late frame synchronization
+                          detection interrupt.             
+     (##) SAI_IT_CNRDY : specifies the interrupt source for codec not ready interrupt
+     (##) SAI_IT_WCKCFG: specifies the interrupt source for wrong clock configuration
+                         interrupt.
+  [..]                     
+  In this Mode it is advised to use the following functions:
+     (+) void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState);
+     (+) ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);
+     (+) void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);
+
+  *** DMA Mode ***
+  ================
+  [..]
+  In DMA Mode, each SAI audio block has an independent DMA interface in order to 
+  read or to write into the SAI_xDR register (to hit the internal FIFO). 
+  There is one DMA channel by audio block following basic DMA request/acknowledge 
+  protocol.
+  [..]
+  In this Mode it is advised to use the following function:
+    (+) void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState);
+  [..]
+  This section provides also functions allowing to
+   (+) Check the SAI Block enable status
+   (+)Check the FIFO status 
+   
+  *** SAI Block Enable status ***
+  ===============================
+  [..]
+  After disabling a SAI Block, it is recommended to check (or wait until) the SAI Block 
+  is effectively disabled. If a Block is disabled while an audio frame transfer is ongoing
+  the current frame will be transferred and the block will be effectively disabled only at 
+  the end of audio frame. 
+  To monitor this state it is possible to use the following function:
+    (+) FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x); 
+ 
+  *** SAI Block FIFO status ***
+  =============================
+  [..]
+  It is possible to monitor the FIFO status when a transfer is ongoing using the following 
+  function:
+    (+) uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x);
+    
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified SAI Block interrupts.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
+  * @param  SAI_IT: specifies the SAI interrupt source to be enabled or disabled. 
+  *          This parameter can be one of the following values:
+  *            @arg SAI_IT_FREQ: FIFO Request interrupt mask
+  *            @arg SAI_IT_MUTEDET: MUTE detection interrupt mask
+  *            @arg SAI_IT_OVRUDR: overrun/underrun interrupt mask
+  *            @arg SAI_IT_AFSDET: anticipated frame synchronization detection 
+  *                                interrupt mask  
+  *            @arg SAI_IT_LFSDET: late frame synchronization detection interrupt 
+  *                                mask
+  *            @arg SAI_IT_CNRDY: codec not ready interrupt mask
+  *            @arg SAI_IT_WCKCFG: wrong clock configuration interrupt mask      
+  * @param  NewState: new state of the specified SAI interrupt.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SAI Block interrupt */
+    SAI_Block_x->IMR |= SAI_IT;
+  }
+  else
+  {
+    /* Disable the selected SAI Block interrupt */
+    SAI_Block_x->IMR &= ~(SAI_IT);
+  }
+}
+
+/**
+  * @brief  Checks whether the specified SAI block x flag is set or not.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
+  * @param  SAI_FLAG: specifies the SAI block flag to check. 
+  *          This parameter can be one of the following values:
+  *            @arg SAI_FLAG_FREQ: FIFO Request flag.  
+  *            @arg SAI_FLAG_MUTEDET: MUTE detection flag.  
+  *            @arg SAI_FLAG_OVRUDR: overrun/underrun flag.
+  *            @arg SAI_FLAG_WCKCFG: wrong clock configuration flag.            
+  *            @arg SAI_FLAG_CNRDY: codec not ready flag. 
+  *            @arg SAI_FLAG_AFSDET: anticipated frame synchronization detection flag.
+  *            @arg SAI_FLAG_LFSDET: late frame synchronization detection flag.
+  * @retval The new state of SAI_FLAG (SET or RESET).
+  */
+FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_SAI_BLOCK_GET_FLAG(SAI_FLAG));
+  
+  /* Check the status of the specified SAI flag */
+  if ((SAI_Block_x->SR & SAI_FLAG) != (uint32_t)RESET)
+  {
+    /* SAI_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SAI_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SAI_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the specified SAI Block x flag.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
+  * @param  SAI_FLAG: specifies the SAI block flag to check. 
+  *          This parameter can be one of the following values: 
+  *            @arg SAI_FLAG_MUTEDET: MUTE detection flag.  
+  *            @arg SAI_FLAG_OVRUDR: overrun/underrun flag.
+  *            @arg SAI_FLAG_WCKCFG: wrong clock configuration flag.            
+  *            @arg SAI_FLAG_CNRDY: codec not ready flag. 
+  *            @arg SAI_FLAG_AFSDET: anticipated frame synchronization detection flag.
+  *            @arg SAI_FLAG_LFSDET: late frame synchronization detection flag. 
+  *  
+  * @note    FREQ (FIFO Request) flag is cleared : 
+  *          - When the audio block is transmitter and the FIFO is full or the FIFO   
+  *            has one data (one buffer mode) depending the bit FTH in the
+  *            SAI_xCR2 register.
+  *          - When the audio block is receiver and the FIFO is not empty           
+  *  
+  * @retval None
+  */
+void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_SAI_BLOCK_CLEAR_FLAG(SAI_FLAG));
+    
+  /* Clear the selected SAI Block flag */
+  SAI_Block_x->CLRFR |= SAI_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified SAI Block x interrupt has occurred or not.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
+  * @param  SAI_IT: specifies the SAI interrupt source to be enabled or disabled. 
+  *          This parameter can be one of the following values:
+  *            @arg SAI_IT_FREQ: FIFO Request interrupt 
+  *            @arg SAI_IT_MUTEDET: MUTE detection interrupt 
+  *            @arg SAI_IT_OVRUDR: overrun/underrun interrupt 
+  *            @arg SAI_IT_AFSDET: anticipated frame synchronization detection interrupt                                    
+  *            @arg SAI_IT_LFSDET: late frame synchronization detection interrupt                                
+  *            @arg SAI_IT_CNRDY: codec not ready interrupt 
+  *            @arg SAI_IT_WCKCFG: wrong clock configuration interrupt 
+  *                
+  * @retval The new state of SAI_IT (SET or RESET).
+  */
+ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t  enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
+  
+  /* Get the SAI_IT enable bit status */
+  enablestatus = (SAI_Block_x->IMR & SAI_IT) ;
+
+  /* Check the status of the specified SAI interrupt */
+  if (((SAI_Block_x->SR & SAI_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
+  {
+    /* SAI_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SAI_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SAI_IT status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SAI Block x interrupt pending bit.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
+  * @param  SAI_IT: specifies the SAI Block interrupt pending bit to clear. 
+  *          This parameter can be one of the following values:  
+  *            @arg SAI_IT_MUTEDET: MUTE detection interrupt.  
+  *            @arg SAI_IT_OVRUDR: overrun/underrun interrupt.
+  *            @arg SAI_IT_WCKCFG: wrong clock configuration interrupt.            
+  *            @arg SAI_IT_CNRDY: codec not ready interrupt. 
+  *            @arg SAI_IT_AFSDET: anticipated frame synchronization detection interrupt.
+  *            @arg SAI_IT_LFSDET: late frame synchronization detection interrupt. 
+  *  
+  * @note    FREQ (FIFO Request) flag is cleared : 
+  *          - When the audio block is transmitter and the FIFO is full or the FIFO   
+  *            has one data (one buffer mode) depending the bit FTH in the
+  *            SAI_xCR2 register.
+  *          - When the audio block is receiver and the FIFO is not empty  
+  *            
+  * @retval None
+  */
+void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
+
+  /* Clear the selected SAI Block x interrupt pending bit */
+  SAI_Block_x->CLRFR |= SAI_IT; 
+}
+
+/**
+  * @brief  Returns the status of EN bit for the specified SAI Block x.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  *   
+  * @note    After disabling a SAI Block, it is recommended to check (or wait until) 
+  *          the SAI Block is effectively disabled. If a Block is disabled while
+  *          an audio frame transfer is ongoing, the current frame will be 
+  *          transferred and the block will be effectively disabled only at 
+  *          the end of audio frame.  
+  *      
+  * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
+  */
+FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x)
+{
+  FunctionalState state = DISABLE;
+
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  if ((SAI_Block_x->CR1 & (uint32_t)SAI_xCR1_SAIEN) != 0)
+  {
+    /* The selected SAI Block x EN bit is set (audio frame transfer is ongoing) */
+    state = ENABLE;
+  }
+  else
+  {
+    /* The selected SAI Block x EN bit is cleared (SAI Block is disabled and 
+        all transfers are complete) */
+    state = DISABLE;
+  }
+  return state;
+}
+
+/**
+  * @brief  Returns the current SAI Block x FIFO filled level.
+  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
+  *   
+  * @retval The FIFO filling state.
+  *           - SAI_FIFOStatus_Empty: when FIFO is empty  
+  *           - SAI_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
+  *                                               and not empty.
+  *           - SAI_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
+  *           - SAI_FIFOStatus_HalfFull: if more than 1 half-full.
+  *           - SAI_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
+  *           - SAI_FIFOStatus_Full: when FIFO is full
+  */
+uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x)
+{
+  uint32_t tmpreg = 0;
+ 
+  /* Check the parameters */
+  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
+  
+  /* Get the FIFO level bits */
+  tmpreg = (uint32_t)((SAI_Block_x->SR & SAI_xSR_FLVL));
+  
+  return tmpreg;
+}
+
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sdio.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sdio.c
new file mode 100644
index 0000000..0a08406
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sdio.c
@@ -0,0 +1,1011 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_sdio.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Secure digital input/output interface (SDIO) 
+  *          peripheral:
+  *           + Initialization and Configuration
+  *           + Command path state machine (CPSM) management
+  *           + Data path state machine (DPSM) management
+  *           + SDIO IO Cards mode management
+  *           + CE-ATA mode management
+  *           + DMA transfers management
+  *           + Interrupts and flags management
+  *
+@verbatim
+
+ ===================================================================
+                 ##### How to use this driver #####
+ ===================================================================
+ [..]
+   (#) The SDIO clock (SDIOCLK = 48 MHz) is coming from a specific output of PLL 
+       (PLL48CLK). Before to start working with SDIO peripheral make sure that the
+       PLL is well configured.
+       The SDIO peripheral uses two clock signals:
+       (++) SDIO adapter clock (SDIOCLK = 48 MHz)
+       (++) APB2 bus clock (PCLK2)
+       
+       -@@- PCLK2 and SDIO_CK clock frequencies must respect the following condition:
+           Frequency(PCLK2) >= (3 / 8 x Frequency(SDIO_CK))
+  
+   (#) Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SDIO, ENABLE).
+  
+   (#) According to the SDIO mode, enable the GPIO clocks using 
+       RCC_AHB1PeriphClockCmd() function. 
+       The I/O can be one of the following configurations:
+       (++) 1-bit data length: SDIO_CMD, SDIO_CK and D0.
+       (++) 4-bit data length: SDIO_CMD, SDIO_CK and D[3:0].
+       (++) 8-bit data length: SDIO_CMD, SDIO_CK and D[7:0].      
+  
+   (#) Peripheral alternate function: 
+       (++) Connect the pin to the desired peripherals' Alternate Function (AF) 
+           using GPIO_PinAFConfig() function
+       (++) Configure the desired pin in alternate function by: 
+           GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
+       (++) Select the type, pull-up/pull-down and output speed via GPIO_PuPd, 
+           GPIO_OType and GPIO_Speed members
+       (++) Call GPIO_Init() function
+  
+   (#) Program the Clock Edge, Clock Bypass, Clock Power Save, Bus Wide, 
+       hardware, flow control and the Clock Divider using the SDIO_Init()
+       function.
+  
+   (#) Enable the Power ON State using the SDIO_SetPowerState(SDIO_PowerState_ON) 
+       function.
+                
+   (#) Enable the clock using the SDIO_ClockCmd() function.
+  
+   (#) Enable the NVIC and the corresponding interrupt using the function 
+       SDIO_ITConfig() if you need to use interrupt mode. 
+  
+   (#) When using the DMA mode 
+       (++) Configure the DMA using DMA_Init() function
+       (++) Active the needed channel Request using SDIO_DMACmd() function
+  
+   (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
+  
+   (#) To control the CPSM (Command Path State Machine) and send 
+       commands to the card use the SDIO_SendCommand(), 
+       SDIO_GetCommandResponse() and SDIO_GetResponse() functions. First, user has
+       to fill the command structure (pointer to SDIO_CmdInitTypeDef) according 
+       to the selected command to be sent.
+       The parameters that should be filled are:
+       (++) Command Argument
+       (++) Command Index
+       (++) Command Response type
+       (++) Command Wait
+       (++) CPSM Status (Enable or Disable).
+  
+       -@@- To check if the command is well received, read the SDIO_CMDRESP
+           register using the SDIO_GetCommandResponse().
+           The SDIO responses registers (SDIO_RESP1 to SDIO_RESP2), use the
+           SDIO_GetResponse() function.
+  
+   (#) To control the DPSM (Data Path State Machine) and send/receive 
+       data to/from the card use the SDIO_DataConfig(), SDIO_GetDataCounter(), 
+       SDIO_ReadData(), SDIO_WriteData() and SDIO_GetFIFOCount() functions.
+  
+ *** Read Operations ***
+ =======================
+ [..]
+   (#) First, user has to fill the data structure (pointer to
+       SDIO_DataInitTypeDef) according to the selected data type to be received.
+       The parameters that should be filled are:
+       (++) Data TimeOut
+       (++) Data Length
+       (++) Data Block size
+       (++) Data Transfer direction: should be from card (To SDIO)
+       (++) Data Transfer mode
+       (++) DPSM Status (Enable or Disable)
+                                     
+   (#) Configure the SDIO resources to receive the data from the card
+       according to selected transfer mode (Refer to Step 8, 9 and 10).
+  
+   (#)  Send the selected Read command (refer to step 11).
+                    
+   (#) Use the SDIO flags/interrupts to check the transfer status.
+  
+ *** Write Operations ***
+ ========================
+ [..]
+   (#) First, user has to fill the data structure (pointer to
+       SDIO_DataInitTypeDef) according to the selected data type to be received.
+       The parameters that should be filled are:
+       (++) Data TimeOut
+       (++) Data Length
+       (++) Data Block size
+       (++) Data Transfer direction:  should be to card (To CARD)
+       (++) Data Transfer mode
+       (++) DPSM Status (Enable or Disable)
+  
+   (#) Configure the SDIO resources to send the data to the card according to 
+       selected transfer mode (Refer to Step 8, 9 and 10).
+                     
+   (#) Send the selected Write command (refer to step 11).
+                    
+   (#) Use the SDIO flags/interrupts to check the transfer status.
+  
+  
+@endverbatim
+  *
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_sdio.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup SDIO 
+  * @brief SDIO driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* ------------ SDIO registers bit address in the alias region ----------- */
+#define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
+
+/* --- CLKCR Register ---*/
+/* Alias word address of CLKEN bit */
+#define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
+#define CLKEN_BitNumber           0x08
+#define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
+
+/* --- CMD Register ---*/
+/* Alias word address of SDIOSUSPEND bit */
+#define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
+#define SDIOSUSPEND_BitNumber     0x0B
+#define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
+
+/* Alias word address of ENCMDCOMPL bit */
+#define ENCMDCOMPL_BitNumber      0x0C
+#define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
+
+/* Alias word address of NIEN bit */
+#define NIEN_BitNumber            0x0D
+#define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
+
+/* Alias word address of ATACMD bit */
+#define ATACMD_BitNumber          0x0E
+#define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
+
+/* --- DCTRL Register ---*/
+/* Alias word address of DMAEN bit */
+#define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
+#define DMAEN_BitNumber           0x03
+#define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
+
+/* Alias word address of RWSTART bit */
+#define RWSTART_BitNumber         0x08
+#define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
+
+/* Alias word address of RWSTOP bit */
+#define RWSTOP_BitNumber          0x09
+#define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
+
+/* Alias word address of RWMOD bit */
+#define RWMOD_BitNumber           0x0A
+#define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
+
+/* Alias word address of SDIOEN bit */
+#define SDIOEN_BitNumber          0x0B
+#define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
+
+/* ---------------------- SDIO registers bit mask ------------------------ */
+/* --- CLKCR Register ---*/
+/* CLKCR register clear mask */
+#define CLKCR_CLEAR_MASK         ((uint32_t)0xFFFF8100) 
+
+/* --- PWRCTRL Register ---*/
+/* SDIO PWRCTRL Mask */
+#define PWR_PWRCTRL_MASK         ((uint32_t)0xFFFFFFFC)
+
+/* --- DCTRL Register ---*/
+/* SDIO DCTRL Clear Mask */
+#define DCTRL_CLEAR_MASK         ((uint32_t)0xFFFFFF08)
+
+/* --- CMD Register ---*/
+/* CMD Register clear mask */
+#define CMD_CLEAR_MASK           ((uint32_t)0xFFFFF800)
+
+/* SDIO RESP Registers Address */
+#define SDIO_RESP_ADDR           ((uint32_t)(SDIO_BASE + 0x14))
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup SDIO_Private_Functions
+  * @{
+  */
+
+/** @defgroup SDIO_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Initialization and Configuration functions #####
+ ===============================================================================
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void SDIO_DeInit(void)
+{
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);
+}
+
+/**
+  * @brief  Initializes the SDIO peripheral according to the specified 
+  *         parameters in the SDIO_InitStruct.
+  * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
+  *         that contains the configuration information for the SDIO peripheral.
+  * @retval None
+  */
+void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
+{
+  uint32_t tmpreg = 0;
+    
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));
+  assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));
+  assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));
+  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
+  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
+   
+/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
+  /* Get the SDIO CLKCR value */
+  tmpreg = SDIO->CLKCR;
+  
+  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
+  tmpreg &= CLKCR_CLEAR_MASK;
+  
+  /* Set CLKDIV bits according to SDIO_ClockDiv value */
+  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
+  /* Set BYPASS bit according to SDIO_ClockBypass value */
+  /* Set WIDBUS bits according to SDIO_BusWide value */
+  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
+  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
+  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
+             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
+             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
+  
+  /* Write to SDIO CLKCR */
+  SDIO->CLKCR = tmpreg;
+}
+
+/**
+  * @brief  Fills each SDIO_InitStruct member with its default value.
+  * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
+  *         will be initialized.
+  * @retval None
+  */
+void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
+{
+  /* SDIO_InitStruct members default value */
+  SDIO_InitStruct->SDIO_ClockDiv = 0x00;
+  SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
+  SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
+  SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
+  SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
+  SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
+}
+
+/**
+  * @brief  Enables or disables the SDIO Clock.
+  * @param  NewState: new state of the SDIO Clock. 
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_ClockCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Sets the power status of the controller.
+  * @param  SDIO_PowerState: new state of the Power state. 
+  *          This parameter can be one of the following values:
+  *            @arg SDIO_PowerState_OFF: SDIO Power OFF
+  *            @arg SDIO_PowerState_ON: SDIO Power ON
+  * @retval None
+  */
+void SDIO_SetPowerState(uint32_t SDIO_PowerState)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
+  
+  SDIO->POWER = SDIO_PowerState;
+}
+
+/**
+  * @brief  Gets the power status of the controller.
+  * @param  None
+  * @retval Power status of the controller. The returned value can be one of the 
+  *         following values:
+  *            - 0x00: Power OFF
+  *            - 0x02: Power UP
+  *            - 0x03: Power ON 
+  */
+uint32_t SDIO_GetPowerState(void)
+{
+  return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Group2 Command path state machine (CPSM) management functions
+ *  @brief   Command path state machine (CPSM) management functions 
+ *
+@verbatim   
+ ===============================================================================
+        ##### Command path state machine (CPSM) management functions #####
+ ===============================================================================  
+
+  This section provide functions allowing to program and read the Command path 
+  state machine (CPSM).
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Initializes the SDIO Command according to the specified 
+  *         parameters in the SDIO_CmdInitStruct and send the command.
+  * @param  SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
+  *         structure that contains the configuration information for the SDIO 
+  *         command.
+  * @retval None
+  */
+void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));
+  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));
+  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
+  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
+  
+/*---------------------------- SDIO ARG Configuration ------------------------*/
+  /* Set the SDIO Argument value */
+  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
+  
+/*---------------------------- SDIO CMD Configuration ------------------------*/  
+  /* Get the SDIO CMD value */
+  tmpreg = SDIO->CMD;
+  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
+  tmpreg &= CMD_CLEAR_MASK;
+  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
+  /* Set WAITRESP bits according to SDIO_Response value */
+  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
+  /* Set CPSMEN bits according to SDIO_CPSM value */
+  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
+           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
+  
+  /* Write to SDIO CMD */
+  SDIO->CMD = tmpreg;
+}
+
+/**
+  * @brief  Fills each SDIO_CmdInitStruct member with its default value.
+  * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
+  *         structure which will be initialized.
+  * @retval None
+  */
+void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
+{
+  /* SDIO_CmdInitStruct members default value */
+  SDIO_CmdInitStruct->SDIO_Argument = 0x00;
+  SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
+  SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
+  SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
+  SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
+}
+
+/**
+  * @brief  Returns command index of last command for which response received.
+  * @param  None
+  * @retval Returns the command index of the last command response received.
+  */
+uint8_t SDIO_GetCommandResponse(void)
+{
+  return (uint8_t)(SDIO->RESPCMD);
+}
+
+/**
+  * @brief  Returns response received from the card for the last command.
+  * @param  SDIO_RESP: Specifies the SDIO response register. 
+  *          This parameter can be one of the following values:
+  *            @arg SDIO_RESP1: Response Register 1
+  *            @arg SDIO_RESP2: Response Register 2
+  *            @arg SDIO_RESP3: Response Register 3
+  *            @arg SDIO_RESP4: Response Register 4
+  * @retval The Corresponding response register value.
+  */
+uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SDIO_RESP(SDIO_RESP));
+
+  tmp = SDIO_RESP_ADDR + SDIO_RESP;
+  
+  return (*(__IO uint32_t *) tmp); 
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Group3 Data path state machine (DPSM) management functions
+ *  @brief   Data path state machine (DPSM) management functions
+ *
+@verbatim   
+ ===============================================================================
+         ##### Data path state machine (DPSM) management functions #####
+ ===============================================================================  
+
+  This section provide functions allowing to program and read the Data path 
+  state machine (DPSM).
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Initializes the SDIO data path according to the specified 
+  *         parameters in the SDIO_DataInitStruct.
+  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
+  *         that contains the configuration information for the SDIO command.
+  * @retval None
+  */
+void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
+{
+  uint32_t tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));
+  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));
+  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));
+  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
+  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));
+
+/*---------------------------- SDIO DTIMER Configuration ---------------------*/
+  /* Set the SDIO Data TimeOut value */
+  SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
+
+/*---------------------------- SDIO DLEN Configuration -----------------------*/
+  /* Set the SDIO DataLength value */
+  SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
+
+/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
+  /* Get the SDIO DCTRL value */
+  tmpreg = SDIO->DCTRL;
+  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
+  tmpreg &= DCTRL_CLEAR_MASK;
+  /* Set DEN bit according to SDIO_DPSM value */
+  /* Set DTMODE bit according to SDIO_TransferMode value */
+  /* Set DTDIR bit according to SDIO_TransferDir value */
+  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
+  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
+           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
+
+  /* Write to SDIO DCTRL */
+  SDIO->DCTRL = tmpreg;
+}
+
+/**
+  * @brief  Fills each SDIO_DataInitStruct member with its default value.
+  * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure 
+  *         which will be initialized.
+  * @retval None
+  */
+void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
+{
+  /* SDIO_DataInitStruct members default value */
+  SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
+  SDIO_DataInitStruct->SDIO_DataLength = 0x00;
+  SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
+  SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
+  SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
+  SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
+}
+
+/**
+  * @brief  Returns number of remaining data bytes to be transferred.
+  * @param  None
+  * @retval Number of remaining data bytes to be transferred
+  */
+uint32_t SDIO_GetDataCounter(void)
+{ 
+  return SDIO->DCOUNT;
+}
+
+/**
+  * @brief  Read one data word from Rx FIFO.
+  * @param  None
+  * @retval Data received
+  */
+uint32_t SDIO_ReadData(void)
+{ 
+  return SDIO->FIFO;
+}
+
+/**
+  * @brief  Write one data word to Tx FIFO.
+  * @param  Data: 32-bit data word to write.
+  * @retval None
+  */
+void SDIO_WriteData(uint32_t Data)
+{ 
+  SDIO->FIFO = Data;
+}
+
+/**
+  * @brief  Returns the number of words left to be written to or read from FIFO.	
+  * @param  None
+  * @retval Remaining number of words.
+  */
+uint32_t SDIO_GetFIFOCount(void)
+{ 
+  return SDIO->FIFOCNT;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Group4 SDIO IO Cards mode management functions
+ *  @brief   SDIO IO Cards mode management functions
+ *
+@verbatim   
+ ===============================================================================
+               ##### SDIO IO Cards mode management functions #####
+ ===============================================================================  
+
+  This section provide functions allowing to program and read the SDIO IO Cards.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Starts the SD I/O Read Wait operation.	
+  * @param  NewState: new state of the Start SDIO Read Wait operation. 
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_StartSDIOReadWait(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
+}
+
+/**
+  * @brief  Stops the SD I/O Read Wait operation.	
+  * @param  NewState: new state of the Stop SDIO Read Wait operation. 
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_StopSDIOReadWait(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
+}
+
+/**
+  * @brief  Sets one of the two options of inserting read wait interval.
+  * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.
+  *          This parameter can be:
+  *            @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
+  *            @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
+  * @retval None
+  */
+void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
+  
+  *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
+}
+
+/**
+  * @brief  Enables or disables the SD I/O Mode Operation.
+  * @param  NewState: new state of SDIO specific operation. 
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_SetSDIOOperation(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the SD I/O Mode suspend command sending.
+  * @param  NewState: new state of the SD I/O Mode suspend command.
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Group5 CE-ATA mode management functions
+ *  @brief   CE-ATA mode management functions
+ *
+@verbatim   
+ ===============================================================================
+                  ##### CE-ATA mode management functions #####
+ ===============================================================================  
+
+  This section provide functions allowing to program and read the CE-ATA card.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the command completion signal.
+  * @param  NewState: new state of command completion signal. 
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_CommandCompletionCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the CE-ATA interrupt.
+  * @param  NewState: new state of CE-ATA interrupt. 
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_CEATAITCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
+}
+
+/**
+  * @brief  Sends CE-ATA command (CMD61).
+  * @param  NewState: new state of CE-ATA command. 
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_SendCEATACmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Group6 DMA transfers management functions
+ *  @brief   DMA transfers management functions
+ *
+@verbatim   
+ ===============================================================================
+                  ##### DMA transfers management functions #####
+ ===============================================================================  
+
+  This section provide functions allowing to program SDIO DMA transfer.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the SDIO DMA request.
+  * @param  NewState: new state of the selected SDIO DMA request.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_DMACmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Group7 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions  
+ *
+@verbatim   
+ ===============================================================================
+              ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the SDIO interrupts.
+  * @param  SDIO_IT: specifies the SDIO interrupt sources to be enabled or disabled.
+  *          This parameter can be one or a combination of the following values:
+  *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
+  *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
+  *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
+  *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
+  *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
+  *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
+  *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
+  *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
+  *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
+  *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
+  *                                   bus mode interrupt
+  *            @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
+  *            @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
+  *            @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
+  *            @arg SDIO_IT_RXACT:    Data receive in progress interrupt
+  *            @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
+  *            @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
+  *            @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
+  *            @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
+  *            @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
+  *            @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
+  *            @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
+  *            @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
+  *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
+  *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
+  * @param  NewState: new state of the specified SDIO interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None 
+  */
+void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_IT(SDIO_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the SDIO interrupts */
+    SDIO->MASK |= SDIO_IT;
+  }
+  else
+  {
+    /* Disable the SDIO interrupts */
+    SDIO->MASK &= ~SDIO_IT;
+  } 
+}
+
+/**
+  * @brief  Checks whether the specified SDIO flag is set or not.
+  * @param  SDIO_FLAG: specifies the flag to check. 
+  *          This parameter can be one of the following values:
+  *            @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
+  *            @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
+  *            @arg SDIO_FLAG_CTIMEOUT: Command response timeout
+  *            @arg SDIO_FLAG_DTIMEOUT: Data timeout
+  *            @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
+  *            @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
+  *            @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
+  *            @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
+  *            @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
+  *            @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide bus mode.
+  *            @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
+  *            @arg SDIO_FLAG_CMDACT:   Command transfer in progress
+  *            @arg SDIO_FLAG_TXACT:    Data transmit in progress
+  *            @arg SDIO_FLAG_RXACT:    Data receive in progress
+  *            @arg SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty
+  *            @arg SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full
+  *            @arg SDIO_FLAG_TXFIFOF:  Transmit FIFO full
+  *            @arg SDIO_FLAG_RXFIFOF:  Receive FIFO full
+  *            @arg SDIO_FLAG_TXFIFOE:  Transmit FIFO empty
+  *            @arg SDIO_FLAG_RXFIFOE:  Receive FIFO empty
+  *            @arg SDIO_FLAG_TXDAVL:   Data available in transmit FIFO
+  *            @arg SDIO_FLAG_RXDAVL:   Data available in receive FIFO
+  *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
+  *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
+  * @retval The new state of SDIO_FLAG (SET or RESET).
+  */
+FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
+{ 
+  FlagStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
+  
+  if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SDIO's pending flags.
+  * @param  SDIO_FLAG: specifies the flag to clear.  
+  *          This parameter can be one or a combination of the following values:
+  *            @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
+  *            @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
+  *            @arg SDIO_FLAG_CTIMEOUT: Command response timeout
+  *            @arg SDIO_FLAG_DTIMEOUT: Data timeout
+  *            @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
+  *            @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
+  *            @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
+  *            @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
+  *            @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
+  *            @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide bus mode
+  *            @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
+  *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
+  *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
+  * @retval None
+  */
+void SDIO_ClearFlag(uint32_t SDIO_FLAG)
+{ 
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
+   
+  SDIO->ICR = SDIO_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified SDIO interrupt has occurred or not.
+  * @param  SDIO_IT: specifies the SDIO interrupt source to check. 
+  *          This parameter can be one of the following values:
+  *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
+  *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
+  *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
+  *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
+  *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
+  *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
+  *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
+  *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
+  *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
+  *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
+  *                                   bus mode interrupt
+  *            @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
+  *            @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
+  *            @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
+  *            @arg SDIO_IT_RXACT:    Data receive in progress interrupt
+  *            @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
+  *            @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
+  *            @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
+  *            @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
+  *            @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
+  *            @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
+  *            @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
+  *            @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
+  *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
+  *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
+  * @retval The new state of SDIO_IT (SET or RESET).
+  */
+ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
+{ 
+  ITStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_GET_IT(SDIO_IT));
+  if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SDIO's interrupt pending bits.
+  * @param  SDIO_IT: specifies the interrupt pending bit to clear. 
+  *          This parameter can be one or a combination of the following values:
+  *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
+  *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
+  *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
+  *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
+  *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
+  *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
+  *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
+  *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
+  *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIO_DCOUNT, is zero) interrupt
+  *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
+  *                                   bus mode interrupt
+  *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
+  *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61
+  * @retval None
+  */
+void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
+{ 
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
+   
+  SDIO->ICR = SDIO_IT;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_spi.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_spi.c
new file mode 100644
index 0000000..f250aad
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_spi.c
@@ -0,0 +1,1319 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_spi.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Serial peripheral interface (SPI):
+  *           + Initialization and Configuration
+  *           + Data transfers functions
+  *           + Hardware CRC Calculation
+  *           + DMA transfers management
+  *           + Interrupts and flags management 
+  *           
+@verbatim
+
+ ===================================================================
+                  ##### How to use this driver #####
+ ===================================================================
+ [..]
+   (#) Enable peripheral clock using the following functions 
+       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE) for SPI1
+       RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE) for SPI2
+       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI3
+       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI4
+       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI5
+       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI6.
+  
+   (#) Enable SCK, MOSI, MISO and NSS GPIO clocks using RCC_AHB1PeriphClockCmd()
+       function. In I2S mode, if an external clock source is used then the I2S 
+       CKIN pin GPIO clock should also be enabled.
+  
+   (#) Peripherals alternate function: 
+       (++) Connect the pin to the desired peripherals' Alternate Function (AF) 
+            using GPIO_PinAFConfig() function
+       (++) Configure the desired pin in alternate function by: 
+            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
+       (++) Select the type, pull-up/pull-down and output speed via GPIO_PuPd, 
+            GPIO_OType and GPIO_Speed members
+       (++) Call GPIO_Init() function In I2S mode, if an external clock source is 
+            used then the I2S CKIN pin should be also configured in Alternate 
+            function Push-pull pull-up mode. 
+          
+   (#) Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
+       Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
+       function.
+       In I2S mode, program the Mode, Standard, Data Format, MCLK Output, Audio 
+       frequency and Polarity using I2S_Init() function. For I2S mode, make sure 
+       that either:
+       (++) I2S PLL is configured using the functions 
+            RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S), RCC_PLLI2SCmd(ENABLE) and 
+            RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY); or 
+       (++) External clock source is configured using the function 
+            RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly 
+            the define constant I2S_EXTERNAL_CLOCK_VAL in the stm32f4xx_conf.h file. 
+  
+   (#) Enable the NVIC and the corresponding interrupt using the function 
+       SPI_ITConfig() if you need to use interrupt mode. 
+  
+   (#) When using the DMA mode 
+       (++) Configure the DMA using DMA_Init() function
+       (++) Active the needed channel Request using SPI_I2S_DMACmd() function
+   
+   (#) Enable the SPI using the SPI_Cmd() function or enable the I2S using
+       I2S_Cmd().
+   
+   (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
+  
+   (#) Optionally, you can enable/configure the following parameters without
+       re-initialization (i.e there is no need to call again SPI_Init() function):
+       (++) When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
+            is programmed as Data direction parameter using the SPI_Init() function
+            it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
+            using the SPI_BiDirectionalLineConfig() function.
+       (++) When SPI_NSS_Soft is selected as Slave Select Management parameter 
+            using the SPI_Init() function it can be possible to manage the 
+            NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
+       (++) Reconfigure the data size using the SPI_DataSizeConfig() function  
+       (++) Enable or disable the SS output using the SPI_SSOutputCmd() function  
+            
+    (#) To use the CRC Hardware calculation feature refer to the Peripheral 
+        CRC hardware Calculation subsection.
+     
+  
+ [..] It is possible to use SPI in I2S full duplex mode, in this case, each SPI 
+      peripheral is able to manage sending and receiving data simultaneously
+      using two data lines. Each SPI peripheral has an extended block called I2Sxext
+      (ie. I2S2ext for SPI2 and I2S3ext for SPI3).
+      The extension block is not a full SPI IP, it is used only as I2S slave to
+      implement full duplex mode. The extension block uses the same clock sources
+      as its master.          
+      To configure I2S full duplex you have to:
+              
+      (#) Configure SPIx in I2S mode (I2S_Init() function) as described above. 
+             
+      (#) Call the I2S_FullDuplexConfig() function using the same strucutre passed to  
+          I2S_Init() function.
+              
+      (#) Call I2S_Cmd() for SPIx then for its extended block.
+            
+      (#) To configure interrupts or DMA requests and to get/clear flag status, 
+          use I2Sxext instance for the extension block.
+               
+ [..] Functions that can be called with I2Sxext instances are: I2S_Cmd(), 
+      I2S_FullDuplexConfig(), SPI_I2S_ReceiveData(), SPI_I2S_SendData(), 
+      SPI_I2S_DMACmd(), SPI_I2S_ITConfig(), SPI_I2S_GetFlagStatus(), 
+      SPI_I2S_ClearFlag(), SPI_I2S_GetITStatus() and SPI_I2S_ClearITPendingBit().
+                   
+      Example: To use SPI3 in Full duplex mode (SPI3 is Master Tx, I2S3ext is Slave Rx):
+              
+      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);   
+      I2S_StructInit(&I2SInitStruct);
+      I2SInitStruct.Mode = I2S_Mode_MasterTx;     
+      I2S_Init(SPI3, &I2SInitStruct);
+      I2S_FullDuplexConfig(SPI3ext, &I2SInitStruct)
+      I2S_Cmd(SPI3, ENABLE);
+      I2S_Cmd(SPI3ext, ENABLE);
+      ...
+      while (SPI_I2S_GetFlagStatus(SPI2, SPI_FLAG_TXE) == RESET)
+      {}
+      SPI_I2S_SendData(SPI3, txdata[i]);
+      ...  
+      while (SPI_I2S_GetFlagStatus(I2S3ext, SPI_FLAG_RXNE) == RESET)
+      {}
+      rxdata[i] = SPI_I2S_ReceiveData(I2S3ext);
+      ...          
+                
+ [..]       
+   (@) In I2S mode: if an external clock is used as source clock for the I2S,  
+       then the define I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should 
+       be enabled and set to the value of the source clock frequency (in Hz).
+   
+   (@) In SPI mode: To use the SPI TI mode, call the function SPI_TIModeCmd() 
+       just after calling the function SPI_Init().
+  
+@endverbatim  
+  *                                  
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_spi.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup SPI 
+  * @brief SPI driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* SPI registers Masks */
+#define CR1_CLEAR_MASK            ((uint16_t)0x3040)
+#define I2SCFGR_CLEAR_MASK        ((uint16_t)0xF040)
+
+/* RCC PLLs masks */
+#define PLLCFGR_PPLR_MASK         ((uint32_t)0x70000000)
+#define PLLCFGR_PPLN_MASK         ((uint32_t)0x00007FC0)
+
+#define SPI_CR2_FRF               ((uint16_t)0x0010)
+#define SPI_SR_TIFRFE             ((uint16_t)0x0100)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup SPI_Private_Functions
+  * @{
+  */
+
+/** @defgroup SPI_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+             ##### Initialization and Configuration functions ##### 
+ ===============================================================================  
+ [..] This section provides a set of functions allowing to initialize the SPI 
+      Direction, SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS 
+      Management, SPI Baud Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
+  
+ [..] The SPI_Init() function follows the SPI configuration procedures for Master 
+      mode and Slave mode (details for these procedures are available in reference 
+      manual (RM0090)).
+  
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  De-initialize the SPIx peripheral registers to their default reset values.
+  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
+  *         in SPI mode or 2 or 3 in I2S mode.   
+  *         
+  * @note   The extended I2S blocks (ie. I2S2ext and I2S3ext blocks) are de-initialized
+  *         when the relative I2S peripheral is de-initialized (the extended block's clock
+  *         is managed by the I2S peripheral clock).
+  *             
+  * @retval None
+  */
+void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+
+  if (SPIx == SPI1)
+  {
+    /* Enable SPI1 reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
+    /* Release SPI1 from reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
+  }
+  else if (SPIx == SPI2)
+  {
+    /* Enable SPI2 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
+    /* Release SPI2 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
+  }
+  else if (SPIx == SPI3)
+  {
+    /* Enable SPI3 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
+    /* Release SPI3 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
+  }
+  else if (SPIx == SPI4)
+  {
+    /* Enable SPI4 reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
+    /* Release SPI4 from reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
+  }
+  else if (SPIx == SPI5)
+  {
+    /* Enable SPI5 reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, ENABLE);
+    /* Release SPI5 from reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
+  }
+  else 
+  {
+    if (SPIx == SPI6)
+    {
+      /* Enable SPI6 reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
+      /* Release SPI6 from reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the SPIx peripheral according to the specified 
+  *         parameters in the SPI_InitStruct.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
+  *         contains the configuration information for the specified SPI peripheral.
+  * @retval None
+  */
+void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
+{
+  uint16_t tmpreg = 0;
+  
+  /* check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Check the SPI parameters */
+  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
+  assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
+  assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
+  assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
+  assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
+  assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
+  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
+  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
+  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
+
+/*---------------------------- SPIx CR1 Configuration ------------------------*/
+  /* Get the SPIx CR1 value */
+  tmpreg = SPIx->CR1;
+  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
+  tmpreg &= CR1_CLEAR_MASK;
+  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
+     master/salve mode, CPOL and CPHA */
+  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
+  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
+  /* Set LSBFirst bit according to SPI_FirstBit value */
+  /* Set BR bits according to SPI_BaudRatePrescaler value */
+  /* Set CPOL bit according to SPI_CPOL value */
+  /* Set CPHA bit according to SPI_CPHA value */
+  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
+                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
+                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
+                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
+  /* Write to SPIx CR1 */
+  SPIx->CR1 = tmpreg;
+
+  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
+  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
+/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
+  /* Write to SPIx CRCPOLY */
+  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
+}
+
+/**
+  * @brief  Initializes the SPIx peripheral according to the specified 
+  *         parameters in the I2S_InitStruct.
+  * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral (configured in I2S mode).
+  * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
+  *         contains the configuration information for the specified SPI peripheral
+  *         configured in I2S mode.
+  *           
+  * @note   The function calculates the optimal prescaler needed to obtain the most 
+  *         accurate audio frequency (depending on the I2S clock source, the PLL values 
+  *         and the product configuration). But in case the prescaler value is greater 
+  *         than 511, the default value (0x02) will be configured instead.    
+  * 
+  * @note   if an external clock is used as source clock for the I2S, then the define
+  *         I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should be enabled and set
+  *         to the value of the the source clock frequency (in Hz).
+  *  
+  * @retval None
+  */
+void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
+{
+  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
+  uint32_t tmp = 0, i2sclk = 0;
+#ifndef I2S_EXTERNAL_CLOCK_VAL
+  uint32_t pllm = 0, plln = 0, pllr = 0;
+#endif /* I2S_EXTERNAL_CLOCK_VAL */
+  
+  /* Check the I2S parameters */
+  assert_param(IS_SPI_23_PERIPH(SPIx));
+  assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
+  assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
+  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
+  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
+  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
+  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
+
+/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
+  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
+  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
+  SPIx->I2SPR = 0x0002;
+  
+  /* Get the I2SCFGR register value */
+  tmpreg = SPIx->I2SCFGR;
+  
+  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
+  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
+  {
+    i2sodd = (uint16_t)0;
+    i2sdiv = (uint16_t)2;   
+  }
+  /* If the requested audio frequency is not the default, compute the prescaler */
+  else
+  {
+    /* Check the frame length (For the Prescaler computing) *******************/
+    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
+    {
+      /* Packet length is 16 bits */
+      packetlength = 1;
+    }
+    else
+    {
+      /* Packet length is 32 bits */
+      packetlength = 2;
+    }
+
+    /* Get I2S source Clock frequency  ****************************************/
+      
+    /* If an external I2S clock has to be used, this define should be set  
+       in the project configuration or in the stm32f4xx_conf.h file */
+  #ifdef I2S_EXTERNAL_CLOCK_VAL     
+    /* Set external clock as I2S clock source */
+    if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
+    {
+      RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
+    }
+    
+    /* Set the I2S clock to the external clock  value */
+    i2sclk = I2S_EXTERNAL_CLOCK_VAL;
+
+  #else /* There is no define for External I2S clock source */
+    /* Set PLLI2S as I2S clock source */
+    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
+    {
+      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
+    }    
+    
+    /* Get the PLLI2SN value */
+    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
+                      (RCC_PLLI2SCFGR_PLLI2SN >> 6));
+    
+    /* Get the PLLI2SR value */
+    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
+                      (RCC_PLLI2SCFGR_PLLI2SR >> 28));
+    
+    /* Get the PLLM value */
+    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
+
+    if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)
+    {
+      /* Get the I2S source clock value */
+      i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
+    }
+    else
+    { /* Get the I2S source clock value */
+      i2sclk = (uint32_t)(((HSI_VALUE / pllm) * plln) / pllr);
+    }
+  #endif /* I2S_EXTERNAL_CLOCK_VAL */
+    
+    /* Compute the Real divider depending on the MCLK output state, with a floating point */
+    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
+    {
+      /* MCLK output is enabled */
+      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
+    }
+    else
+    {
+      /* MCLK output is disabled */
+      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
+    }
+    
+    /* Remove the flatting point */
+    tmp = tmp / 10;  
+      
+    /* Check the parity of the divider */
+    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
+   
+    /* Compute the i2sdiv prescaler */
+    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
+   
+    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
+    i2sodd = (uint16_t) (i2sodd << 8);
+  }
+
+  /* Test if the divider is 1 or 0 or greater than 0xFF */
+  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
+  {
+    /* Set the default values */
+    i2sdiv = 2;
+    i2sodd = 0;
+  }
+
+  /* Write to SPIx I2SPR register the computed value */
+  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
+ 
+  /* Configure the I2S with the SPI_InitStruct values */
+  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
+                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
+                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
+ 
+  /* Write to SPIx I2SCFGR */  
+  SPIx->I2SCFGR = tmpreg;
+}
+
+/**
+  * @brief  Fills each SPI_InitStruct member with its default value.
+  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
+{
+/*--------------- Reset SPI init structure parameters values -----------------*/
+  /* Initialize the SPI_Direction member */
+  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
+  /* initialize the SPI_Mode member */
+  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
+  /* initialize the SPI_DataSize member */
+  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
+  /* Initialize the SPI_CPOL member */
+  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
+  /* Initialize the SPI_CPHA member */
+  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
+  /* Initialize the SPI_NSS member */
+  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
+  /* Initialize the SPI_BaudRatePrescaler member */
+  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
+  /* Initialize the SPI_FirstBit member */
+  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
+  /* Initialize the SPI_CRCPolynomial member */
+  SPI_InitStruct->SPI_CRCPolynomial = 7;
+}
+
+/**
+  * @brief  Fills each I2S_InitStruct member with its default value.
+  * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
+{
+/*--------------- Reset I2S init structure parameters values -----------------*/
+  /* Initialize the I2S_Mode member */
+  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
+  
+  /* Initialize the I2S_Standard member */
+  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
+  
+  /* Initialize the I2S_DataFormat member */
+  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
+  
+  /* Initialize the I2S_MCLKOutput member */
+  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
+  
+  /* Initialize the I2S_AudioFreq member */
+  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
+  
+  /* Initialize the I2S_CPOL member */
+  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
+}
+
+/**
+  * @brief  Enables or disables the specified SPI peripheral.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx peripheral. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI peripheral */
+    SPIx->CR1 |= SPI_CR1_SPE;
+  }
+  else
+  {
+    /* Disable the selected SPI peripheral */
+    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
+  * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral (or I2Sxext 
+  *         for full duplex mode).
+  * @param  NewState: new state of the SPIx peripheral. 
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI peripheral (in I2S mode) */
+    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
+  }
+  else
+  {
+    /* Disable the selected SPI peripheral in I2S mode */
+    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
+  }
+}
+
+/**
+  * @brief  Configures the data size for the selected SPI.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @param  SPI_DataSize: specifies the SPI data size.
+  *          This parameter can be one of the following values:
+  *            @arg SPI_DataSize_16b: Set data frame format to 16bit
+  *            @arg SPI_DataSize_8b: Set data frame format to 8bit
+  * @retval None
+  */
+void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
+  /* Clear DFF bit */
+  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
+  /* Set new DFF bit value */
+  SPIx->CR1 |= SPI_DataSize;
+}
+
+/**
+  * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
+  *          This parameter can be one of the following values:
+  *            @arg SPI_Direction_Tx: Selects Tx transmission direction
+  *            @arg SPI_Direction_Rx: Selects Rx receive direction
+  * @retval None
+  */
+void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_DIRECTION(SPI_Direction));
+  if (SPI_Direction == SPI_Direction_Tx)
+  {
+    /* Set the Tx only mode */
+    SPIx->CR1 |= SPI_Direction_Tx;
+  }
+  else
+  {
+    /* Set the Rx only mode */
+    SPIx->CR1 &= SPI_Direction_Rx;
+  }
+}
+
+/**
+  * @brief  Configures internally by software the NSS pin for the selected SPI.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
+  *          This parameter can be one of the following values:
+  *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
+  *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
+  * @retval None
+  */
+void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
+  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
+  {
+    /* Set NSS pin internally by software */
+    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
+  }
+  else
+  {
+    /* Reset NSS pin internally by software */
+    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the SS output for the selected SPI.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx SS output. 
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI SS output */
+    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
+  }
+  else
+  {
+    /* Disable the selected SPI SS output */
+    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
+  }
+}
+
+/**
+  * @brief  Enables or disables the SPIx/I2Sx DMA interface.
+  *   
+  * @note   This function can be called only after the SPI_Init() function has 
+  *         been called. 
+  * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
+  *         are not taken into consideration and are configured by hardware
+  *         respectively to the TI mode requirements.  
+  * 
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 
+  * @param  NewState: new state of the selected SPI TI communication mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the TI mode for the selected SPI peripheral */
+    SPIx->CR2 |= SPI_CR2_FRF;
+  }
+  else
+  {
+    /* Disable the TI mode for the selected SPI peripheral */
+    SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
+  }
+}
+
+/**
+  * @brief  Configures the full duplex mode for the I2Sx peripheral using its
+  *         extension I2Sxext according to the specified parameters in the 
+  *         I2S_InitStruct.
+  * @param  I2Sxext: where x can be  2 or 3 to select the I2S peripheral extension block.
+  * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
+  *         contains the configuration information for the specified I2S peripheral
+  *         extension.
+  * 
+  * @note   The structure pointed by I2S_InitStruct parameter should be the same
+  *         used for the master I2S peripheral. In this case, if the master is 
+  *         configured as transmitter, the slave will be receiver and vice versa.
+  *         Or you can force a different mode by modifying the field I2S_Mode to the
+  *         value I2S_SlaveRx or I2S_SlaveTx indepedently of the master configuration.    
+  *         
+  * @note   The I2S full duplex extension can be configured in slave mode only.    
+  *  
+  * @retval None
+  */
+void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
+{
+  uint16_t tmpreg = 0, tmp = 0;
+  
+  /* Check the I2S parameters */
+  assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
+  assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
+  assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
+  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
+  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
+
+/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
+  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
+  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
+  I2Sxext->I2SPR = 0x0002;
+  
+  /* Get the I2SCFGR register value */
+  tmpreg = I2Sxext->I2SCFGR;
+  
+  /* Get the mode to be configured for the extended I2S */
+  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
+  {
+    tmp = I2S_Mode_SlaveRx;
+  }
+  else
+  {
+    if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
+    {
+      tmp = I2S_Mode_SlaveTx;
+    }
+  }
+
+ 
+  /* Configure the I2S with the SPI_InitStruct values */
+  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
+                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
+                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
+ 
+  /* Write to SPIx I2SCFGR */  
+  I2Sxext->I2SCFGR = tmpreg;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Group2 Data transfers functions
+ *  @brief   Data transfers functions
+ *
+@verbatim   
+ ===============================================================================
+                      ##### Data transfers functions #####
+ ===============================================================================  
+
+ [..] This section provides a set of functions allowing to manage the SPI data 
+      transfers. In reception, data are received and then stored into an internal 
+      Rx buffer while. In transmission, data are first stored into an internal Tx 
+      buffer before being transmitted.
+
+ [..] The read access of the SPI_DR register can be done using the SPI_I2S_ReceiveData()
+      function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
+      can be done using SPI_I2S_SendData() function and stores the written data into 
+      Tx buffer.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
+  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
+  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
+  * @retval The value of the received data.
+  */
+uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
+  
+  /* Return the data in the DR register */
+  return SPIx->DR;
+}
+
+/**
+  * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
+  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
+  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.     
+  * @param  Data: Data to be transmitted.
+  * @retval None
+  */
+void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
+  
+  /* Write in the DR register the data to be sent */
+  SPIx->DR = Data;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Group3 Hardware CRC Calculation functions
+ *  @brief   Hardware CRC Calculation functions
+ *
+@verbatim   
+ ===============================================================================
+                 ##### Hardware CRC Calculation functions #####
+ ===============================================================================  
+
+ [..] This section provides a set of functions allowing to manage the SPI CRC hardware 
+      calculation
+
+ [..] SPI communication using CRC is possible through the following procedure:
+   (#) Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
+       Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
+       function.
+   (#) Enable the CRC calculation using the SPI_CalculateCRC() function.
+   (#) Enable the SPI using the SPI_Cmd() function
+   (#) Before writing the last data to the TX buffer, set the CRCNext bit using the 
+       SPI_TransmitCRC() function to indicate that after transmission of the last 
+       data, the CRC should be transmitted.
+   (#) After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
+        bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
+        value. 
+        If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
+        can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
+
+ [..]
+   (@) It is advised not to read the calculated CRC values during the communication.
+
+   (@) When the SPI is in slave mode, be careful to enable CRC calculation only 
+       when the clock is stable, that is, when the clock is in the steady state. 
+       If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
+       to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
+       the value of the SPE bit.
+
+   (@) With high bitrate frequencies, be careful when transmitting the CRC.
+       As the number of used CPU cycles has to be as low as possible in the CRC 
+       transfer phase, it is forbidden to call software functions in the CRC 
+       transmission sequence to avoid errors in the last data and CRC reception. 
+       In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
+       of the last data.
+
+   (@) For high bit rate frequencies, it is advised to use the DMA mode to avoid the
+       degradation of the SPI speed performance due to CPU accesses impacting the 
+       SPI bandwidth.
+
+   (@) When the STM32F4xx is configured as slave and the NSS hardware mode is 
+       used, the NSS pin needs to be kept low between the data phase and the CRC 
+       phase.
+
+   (@) When the SPI is configured in slave mode with the CRC feature enabled, CRC
+       calculation takes place even if a high level is applied on the NSS pin. 
+       This may happen for example in case of a multi-slave environment where the 
+       communication master addresses slaves alternately.
+
+   (@) Between a slave de-selection (high level on NSS) and a new slave selection 
+       (low level on NSS), the CRC value should be cleared on both master and slave
+       sides in order to resynchronize the master and slave for their respective 
+       CRC calculation.
+
+   (@) To clear the CRC, follow the procedure below:
+       (#@) Disable SPI using the SPI_Cmd() function
+       (#@) Disable the CRC calculation using the SPI_CalculateCRC() function.
+       (#@) Enable the CRC calculation using the SPI_CalculateCRC() function.
+       (#@) Enable SPI using the SPI_Cmd() function.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the CRC value calculation of the transferred bytes.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx CRC value calculation.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI CRC calculation */
+    SPIx->CR1 |= SPI_CR1_CRCEN;
+  }
+  else
+  {
+    /* Disable the selected SPI CRC calculation */
+    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
+  }
+}
+
+/**
+  * @brief  Transmit the SPIx CRC value.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @retval None
+  */
+void SPI_TransmitCRC(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Enable the selected SPI CRC transmission */
+  SPIx->CR1 |= SPI_CR1_CRCNEXT;
+}
+
+/**
+  * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @param  SPI_CRC: specifies the CRC register to be read.
+  *          This parameter can be one of the following values:
+  *            @arg SPI_CRC_Tx: Selects Tx CRC register
+  *            @arg SPI_CRC_Rx: Selects Rx CRC register
+  * @retval The selected CRC register value..
+  */
+uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
+{
+  uint16_t crcreg = 0;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_CRC(SPI_CRC));
+  if (SPI_CRC != SPI_CRC_Rx)
+  {
+    /* Get the Tx CRC register */
+    crcreg = SPIx->TXCRCR;
+  }
+  else
+  {
+    /* Get the Rx CRC register */
+    crcreg = SPIx->RXCRCR;
+  }
+  /* Return the selected CRC register */
+  return crcreg;
+}
+
+/**
+  * @brief  Returns the CRC Polynomial register value for the specified SPI.
+  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
+  * @retval The CRC Polynomial register value.
+  */
+uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Return the CRC polynomial register */
+  return SPIx->CRCPR;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Group4 DMA transfers management functions
+ *  @brief   DMA transfers management functions
+  *
+@verbatim   
+ ===============================================================================
+                   ##### DMA transfers management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the SPIx/I2Sx DMA interface.
+  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
+  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
+  * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
+  *          This parameter can be any combination of the following values:
+  *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
+  *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
+  * @param  NewState: new state of the selected SPI DMA transfer request.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI DMA requests */
+    SPIx->CR2 |= SPI_I2S_DMAReq;
+  }
+  else
+  {
+    /* Disable the selected SPI DMA requests */
+    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Group5 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions
+  *
+@verbatim   
+ ===============================================================================
+            ##### Interrupts and flags management functions #####
+ ===============================================================================  
+ 
+ [..] This section provides a set of functions allowing to configure the SPI Interrupts 
+      sources and check or clear the flags or pending bits status.
+      The user should identify which mode will be used in his application to manage 
+      the communication: Polling mode, Interrupt mode or DMA mode. 
+    
+ *** Polling Mode ***
+ ====================
+[..] In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
+  (#) SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
+  (#) SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
+  (#) SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
+  (#) SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
+  (#) SPI_FLAG_MODF : to indicate if a Mode Fault error occur
+  (#) SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
+  (#) I2S_FLAG_TIFRFE: to indicate a Frame Format error occurs.
+  (#) I2S_FLAG_UDR: to indicate an Underrun error occurs.
+  (#) I2S_FLAG_CHSIDE: to indicate Channel Side.
+
+  (@) Do not use the BSY flag to handle each data transmission or reception. It is
+      better to use the TXE and RXNE flags instead.
+
+ [..] In this Mode it is advised to use the following functions:
+   (+) FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
+   (+) void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
+
+ *** Interrupt Mode ***
+ ======================
+ [..] In Interrupt Mode, the SPI communication can be managed by 3 interrupt sources
+      and 7 pending bits: 
+   (+) Pending Bits:
+       (##) SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
+       (##) SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
+       (##) SPI_IT_CRCERR : to indicate if a CRC Calculation error occur (available in SPI mode only)            
+       (##) SPI_IT_MODF : to indicate if a Mode Fault error occur (available in SPI mode only)
+       (##) SPI_I2S_IT_OVR : to indicate if an Overrun error occur
+       (##) I2S_IT_UDR : to indicate an Underrun Error occurs (available in I2S mode only).
+       (##) I2S_FLAG_TIFRFE : to indicate a Frame Format error occurs (available in TI mode only).
+
+   (+) Interrupt Source:
+       (##) SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
+            interrupt.  
+       (##) SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
+            empty interrupt.
+       (##) SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
+
+ [..] In this Mode it is advised to use the following functions:
+   (+) void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
+   (+) ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
+   (+) void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
+
+ *** DMA Mode ***
+ ================
+ [..] In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
+   (#) SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request
+   (#) SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request
+
+ [..] In this Mode it is advised to use the following function:
+   (+) void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState 
+       NewState);
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified SPI/I2S interrupts.
+  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
+  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
+  * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
+  *          This parameter can be one of the following values:
+  *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
+  *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
+  *            @arg SPI_I2S_IT_ERR: Error interrupt mask
+  * @param  NewState: new state of the specified SPI interrupt.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
+{
+  uint16_t itpos = 0, itmask = 0 ;
+  
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
+
+  /* Get the SPI IT index */
+  itpos = SPI_I2S_IT >> 4;
+
+  /* Set the IT mask */
+  itmask = (uint16_t)1 << (uint16_t)itpos;
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI interrupt */
+    SPIx->CR2 |= itmask;
+  }
+  else
+  {
+    /* Disable the selected SPI interrupt */
+    SPIx->CR2 &= (uint16_t)~itmask;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified SPIx/I2Sx flag is set or not.
+  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
+  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
+  * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
+  *          This parameter can be one of the following values:
+  *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
+  *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
+  *            @arg SPI_I2S_FLAG_BSY: Busy flag.
+  *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
+  *            @arg SPI_FLAG_MODF: Mode Fault flag.
+  *            @arg SPI_FLAG_CRCERR: CRC Error flag.
+  *            @arg SPI_I2S_FLAG_TIFRFE: Format Error.
+  *            @arg I2S_FLAG_UDR: Underrun Error flag.
+  *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
+  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
+  */
+FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
+  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
+  
+  /* Check the status of the specified SPI flag */
+  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
+  {
+    /* SPI_I2S_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SPI_I2S_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SPI_I2S_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the SPIx CRC Error (CRCERR) flag.
+  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
+  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
+  * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
+  *          This function clears only CRCERR flag.
+  *            @arg SPI_FLAG_CRCERR: CRC Error flag.  
+  *  
+  * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
+  *          operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
+  *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
+  * @note   UDR (UnderRun error) flag is cleared by a read operation to 
+  *          SPI_SR register (SPI_I2S_GetFlagStatus()).   
+  * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
+  *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
+  *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
+  *  
+  * @retval None
+  */
+void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
+  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
+    
+  /* Clear the selected SPI CRC Error (CRCERR) flag */
+  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified SPIx/I2Sx interrupt has occurred or not.
+  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
+  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
+  * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
+  *          This parameter can be one of the following values:
+  *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
+  *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
+  *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
+  *            @arg SPI_IT_MODF: Mode Fault interrupt.
+  *            @arg SPI_IT_CRCERR: CRC Error interrupt.
+  *            @arg I2S_IT_UDR: Underrun interrupt.  
+  *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
+  * @retval The new state of SPI_I2S_IT (SET or RESET).
+  */
+ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint16_t itpos = 0, itmask = 0, enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
+  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
+
+  /* Get the SPI_I2S_IT index */
+  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
+
+  /* Get the SPI_I2S_IT IT mask */
+  itmask = SPI_I2S_IT >> 4;
+
+  /* Set the IT mask */
+  itmask = 0x01 << itmask;
+
+  /* Get the SPI_I2S_IT enable bit status */
+  enablestatus = (SPIx->CR2 & itmask) ;
+
+  /* Check the status of the specified SPI interrupt */
+  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
+  {
+    /* SPI_I2S_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SPI_I2S_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SPI_I2S_IT status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
+  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
+  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
+  * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
+  *         This function clears only CRCERR interrupt pending bit.   
+  *            @arg SPI_IT_CRCERR: CRC Error interrupt.
+  *   
+  * @note   OVR (OverRun Error) interrupt pending bit is cleared by software 
+  *          sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
+  *          followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
+  * @note   UDR (UnderRun Error) interrupt pending bit is cleared by a read 
+  *          operation to SPI_SR register (SPI_I2S_GetITStatus()).   
+  * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
+  *          a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
+  *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
+  *          the SPI).
+  * @retval None
+  */
+void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
+{
+  uint16_t itpos = 0;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
+  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
+
+  /* Get the SPI_I2S IT index */
+  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
+
+  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
+  SPIx->SR = (uint16_t)~itpos;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/**
+  * @}
+  */ 
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_syscfg.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_syscfg.c
new file mode 100644
index 0000000..edc46f9
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_syscfg.c
@@ -0,0 +1,240 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_syscfg.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the SYSCFG peripheral.
+  *
+ @verbatim
+    
+ ===============================================================================
+                     ##### How to use this driver #####
+ ===============================================================================
+    [..] This driver provides functions for:
+            
+       (#) Remapping the memory accessible in the code area using SYSCFG_MemoryRemapConfig()
+            
+       (#) Swapping the internal flash Bank1 and Bank2 this features is only visible for 
+           STM32F42xxx/43xxx devices Devices. 
+                
+       (#) Manage the EXTI lines connection to the GPIOs using SYSCFG_EXTILineConfig()
+              
+       (#) Select the ETHERNET media interface (RMII/RII) using SYSCFG_ETH_MediaInterfaceConfig()
+  
+       -@- SYSCFG APB clock must be enabled to get write access to SYSCFG registers,
+           using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
+                   
+ @endverbatim      
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_syscfg.h"
+#include "stm32f4xx_rcc.h"
+#include "stm32f4xx_conf.h"
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup SYSCFG 
+  * @brief SYSCFG driver modules
+  * @{
+  */ 
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ------------ RCC registers bit address in the alias region ----------- */
+#define SYSCFG_OFFSET             (SYSCFG_BASE - PERIPH_BASE)
+/* ---  MEMRMP Register ---*/ 
+/* Alias word address of UFB_MODE bit */ 
+#define MEMRMP_OFFSET             SYSCFG_OFFSET 
+#define UFB_MODE_BitNumber        ((uint8_t)0x8) 
+#define UFB_MODE_BB               (PERIPH_BB_BASE + (MEMRMP_OFFSET * 32) + (UFB_MODE_BitNumber * 4)) 
+
+
+/* ---  PMC Register ---*/ 
+/* Alias word address of MII_RMII_SEL bit */ 
+#define PMC_OFFSET                (SYSCFG_OFFSET + 0x04) 
+#define MII_RMII_SEL_BitNumber    ((uint8_t)0x17) 
+#define PMC_MII_RMII_SEL_BB       (PERIPH_BB_BASE + (PMC_OFFSET * 32) + (MII_RMII_SEL_BitNumber * 4)) 
+
+/* ---  CMPCR Register ---*/ 
+/* Alias word address of CMP_PD bit */ 
+#define CMPCR_OFFSET              (SYSCFG_OFFSET + 0x20) 
+#define CMP_PD_BitNumber          ((uint8_t)0x00) 
+#define CMPCR_CMP_PD_BB           (PERIPH_BB_BASE + (CMPCR_OFFSET * 32) + (CMP_PD_BitNumber * 4)) 
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup SYSCFG_Private_Functions
+  * @{
+  */ 
+
+/**
+  * @brief  Deinitializes the Alternate Functions (remap and EXTI configuration)
+  *   registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void SYSCFG_DeInit(void)
+{
+   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
+   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
+}
+
+/**
+  * @brief  Changes the mapping of the specified pin.
+  * @param  SYSCFG_Memory: selects the memory remapping.
+  *         This parameter can be one of the following values:
+  *            @arg SYSCFG_MemoryRemap_Flash:       Main Flash memory mapped at 0x00000000  
+  *            @arg SYSCFG_MemoryRemap_SystemFlash: System Flash memory mapped at 0x00000000
+  *            @arg SYSCFG_MemoryRemap_FSMC:        FSMC (Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000 for STM32F405xx/407xx and STM32F415xx/417xx devices. 
+  *            @arg SYSCFG_MemoryRemap_FMC:         FMC (Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000 for STM32F42xxx/43xxx devices.  
+  *            @arg SYSCFG_MemoryRemap_SRAM:        Embedded SRAM (112kB) mapped at 0x00000000
+  *            @arg SYSCFG_MemoryRemap_SDRAM:       FMC (External SDRAM)  mapped at 0x00000000 for STM32F42xxx/43xxx devices.            
+  * @retval None
+  */
+void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
+{
+  /* Check the parameters */
+  assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));
+
+  SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
+}
+
+/**
+  * @brief  Enables or disables the Interal FLASH Bank Swapping.
+  *   
+  * @note   This function can be used only for STM32F42xxx/43xxx devices. 
+  *
+  * @param  NewState: new state of Interal FLASH Bank swapping.
+  *          This parameter can be one of the following values:
+  *            @arg ENABLE: Flash Bank2 mapped at 0x08000000 (and aliased @0x00000000) 
+  *                         and Flash Bank1 mapped at 0x08100000 (and aliased at 0x00100000)   
+  *            @arg DISABLE:(the default state) Flash Bank1 mapped at 0x08000000 (and aliased @0x0000 0000) 
+                            and Flash Bank2 mapped at 0x08100000 (and aliased at 0x00100000)  
+  * @retval None
+  */
+void SYSCFG_MemorySwappingBank(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) UFB_MODE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Selects the GPIO pin used as EXTI Line.
+  * @param  EXTI_PortSourceGPIOx : selects the GPIO port to be used as source for
+  *          EXTI lines where x can be (A..K) for STM32F42xxx/43xxx devices, (A..I) 
+  *          for STM32F405xx/407xx and STM32F415xx/417xx devices or (A, B, C, D and H)
+  *          for STM32401xx devices.  
+  *            
+  * @param  EXTI_PinSourcex: specifies the EXTI line to be configured.
+  *           This parameter can be EXTI_PinSourcex where x can be (0..15, except
+  *           for EXTI_PortSourceGPIOI x can be (0..11) for STM32F405xx/407xx
+  *           and STM32F405xx/407xx devices and for EXTI_PortSourceGPIOK x can   
+  *           be (0..7) for STM32F42xxx/43xxx devices. 
+  *             
+  * @retval None
+  */
+void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
+{
+  uint32_t tmp = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
+  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
+
+  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
+  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
+  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
+}
+
+/**
+  * @brief  Selects the ETHERNET media interface 
+  * @param  SYSCFG_ETH_MediaInterface: specifies the Media Interface mode. 
+  *          This parameter can be one of the following values: 
+  *            @arg SYSCFG_ETH_MediaInterface_MII: MII mode selected
+  *            @arg SYSCFG_ETH_MediaInterface_RMII: RMII mode selected 
+  * @retval None 
+  */
+void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
+{ 
+  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
+  /* Configure MII_RMII selection bit */ 
+  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
+}
+
+/**
+  * @brief  Enables or disables the I/O Compensation Cell.
+  * @note   The I/O compensation cell can be used only when the device supply
+  *         voltage ranges from 2.4 to 3.6 V.  
+  * @param  NewState: new state of the I/O Compensation Cell.
+  *          This parameter can be one of the following values:
+  *            @arg ENABLE: I/O compensation cell enabled  
+  *            @arg DISABLE: I/O compensation cell power-down mode  
+  * @retval None
+  */
+void SYSCFG_CompensationCellCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CMPCR_CMP_PD_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Checks whether the I/O Compensation Cell ready flag is set or not.
+  * @param  None
+  * @retval The new state of the I/O Compensation Cell ready flag (SET or RESET)
+  */
+FlagStatus SYSCFG_GetCompensationCellStatus(void)
+{
+  FlagStatus bitstatus = RESET;
+    
+  if ((SYSCFG->CMPCR & SYSCFG_CMPCR_READY ) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/   
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_tim.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_tim.c
new file mode 100644
index 0000000..7ac3e4f
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_tim.c
@@ -0,0 +1,3365 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_tim.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the TIM peripheral:
+  *            + TimeBase management
+  *            + Output Compare management
+  *            + Input Capture management
+  *            + Advanced-control timers (TIM1 and TIM8) specific features  
+  *            + Interrupts, DMA and flags management
+  *            + Clocks management
+  *            + Synchronization management
+  *            + Specific interface management
+  *            + Specific remapping management      
+  *              
+  @verbatim   
+ ===============================================================================
+                   #####  How to use this driver #####
+ ===============================================================================
+    [..]
+    This driver provides functions to configure and program the TIM 
+    of all STM32F4xx devices.
+    These functions are split in 9 groups: 
+     
+      (#) TIM TimeBase management: this group includes all needed functions 
+          to configure the TM Timebase unit:
+        (++) Set/Get Prescaler
+        (++) Set/Get Autoreload  
+        (++) Counter modes configuration
+        (++) Set Clock division  
+        (++) Select the One Pulse mode
+        (++) Update Request Configuration
+        (++) Update Disable Configuration
+        (++) Auto-Preload Configuration 
+        (++) Enable/Disable the counter     
+                   
+      (#) TIM Output Compare management: this group includes all needed 
+          functions to configure the Capture/Compare unit used in Output 
+          compare mode: 
+        (++) Configure each channel, independently, in Output Compare mode
+        (++) Select the output compare modes
+        (++) Select the Polarities of each channel
+        (++) Set/Get the Capture/Compare register values
+        (++) Select the Output Compare Fast mode 
+        (++) Select the Output Compare Forced mode  
+        (++) Output Compare-Preload Configuration 
+        (++) Clear Output Compare Reference
+        (++) Select the OCREF Clear signal
+        (++) Enable/Disable the Capture/Compare Channels    
+                     
+      (#) TIM Input Capture management: this group includes all needed 
+          functions to configure the Capture/Compare unit used in 
+          Input Capture mode:
+        (++) Configure each channel in input capture mode
+        (++) Configure Channel1/2 in PWM Input mode
+        (++) Set the Input Capture Prescaler
+        (++) Get the Capture/Compare values      
+                     
+      (#) Advanced-control timers (TIM1 and TIM8) specific features
+        (++) Configures the Break input, dead time, Lock level, the OSSI,
+             the OSSR State and the AOE(automatic output enable)
+        (++) Enable/Disable the TIM peripheral Main Outputs
+        (++) Select the Commutation event
+        (++) Set/Reset the Capture Compare Preload Control bit
+                                
+      (#) TIM interrupts, DMA and flags management
+        (++) Enable/Disable interrupt sources
+        (++) Get flags status
+        (++) Clear flags/ Pending bits
+        (++) Enable/Disable DMA requests 
+        (++) Configure DMA burst mode
+        (++) Select CaptureCompare DMA request  
+                
+      (#) TIM clocks management: this group includes all needed functions 
+          to configure the clock controller unit:
+        (++) Select internal/External clock
+        (++) Select the external clock mode: ETR(Mode1/Mode2), TIx or ITRx
+           
+      (#) TIM synchronization management: this group includes all needed 
+          functions to configure the Synchronization unit:
+        (++) Select Input Trigger  
+        (++) Select Output Trigger  
+        (++) Select Master Slave Mode 
+        (++) ETR Configuration when used as external trigger   
+       
+      (#) TIM specific interface management, this group includes all 
+          needed functions to use the specific TIM interface:
+        (++) Encoder Interface Configuration
+        (++) Select Hall Sensor   
+           
+      (#) TIM specific remapping management includes the Remapping 
+          configuration of specific timers               
+     
+  @endverbatim    
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_tim.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup TIM 
+  * @brief TIM driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* ---------------------- TIM registers bit mask ------------------------ */
+#define SMCR_ETR_MASK      ((uint16_t)0x00FF) 
+#define CCMR_OFFSET        ((uint16_t)0x0018)
+#define CCER_CCE_SET       ((uint16_t)0x0001)  
+#define	CCER_CCNE_SET      ((uint16_t)0x0004) 
+#define CCMR_OC13M_MASK    ((uint16_t)0xFF8F)
+#define CCMR_OC24M_MASK    ((uint16_t)0x8FFF) 
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup TIM_Private_Functions
+  * @{
+  */
+
+/** @defgroup TIM_Group1 TimeBase management functions
+ *  @brief   TimeBase management functions 
+ *
+@verbatim   
+ ===============================================================================
+                     ##### TimeBase management functions #####
+ ===============================================================================  
+  
+     
+            ##### TIM Driver: how to use it in Timing(Time base) Mode #####
+ ===============================================================================
+    [..] 
+    To use the Timer in Timing(Time base) mode, the following steps are mandatory:
+       
+      (#) Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
+                    
+      (#) Fill the TIM_TimeBaseInitStruct with the desired parameters.
+       
+      (#) Call TIM_TimeBaseInit(TIMx, &TIM_TimeBaseInitStruct) to configure the Time Base unit
+          with the corresponding configuration
+          
+      (#) Enable the NVIC if you need to generate the update interrupt. 
+          
+      (#) Enable the corresponding interrupt using the function TIM_ITConfig(TIMx, TIM_IT_Update) 
+       
+      (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
+             
+       -@- All other functions can be used separately to modify, if needed,
+           a specific feature of the Timer. 
+
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @retval None
+
+  */
+void TIM_DeInit(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
+ 
+  if (TIMx == TIM1)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
+  } 
+  else if (TIMx == TIM2) 
+  {     
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
+  }  
+  else if (TIMx == TIM3)
+  { 
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
+  }  
+  else if (TIMx == TIM4)
+  { 
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
+  }  
+  else if (TIMx == TIM5)
+  {      
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
+  }  
+  else if (TIMx == TIM6)  
+  {    
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
+  }  
+  else if (TIMx == TIM7)
+  {      
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
+  }  
+  else if (TIMx == TIM8)
+  {      
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
+  }  
+  else if (TIMx == TIM9)
+  {      
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
+   }  
+  else if (TIMx == TIM10)
+  {      
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
+  }  
+  else if (TIMx == TIM11) 
+  {     
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
+  }  
+  else if (TIMx == TIM12)
+  {      
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
+  }  
+  else if (TIMx == TIM13) 
+  {       
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
+  }  
+  else
+  { 
+    if (TIMx == TIM14) 
+    {     
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
+    }   
+  }
+}
+
+/**
+  * @brief  Initializes the TIMx Time Base Unit peripheral according to 
+  *         the specified parameters in the TIM_TimeBaseInitStruct.
+  * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
+  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
+  *         that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
+{
+  uint16_t tmpcr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
+  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
+  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
+
+  tmpcr1 = TIMx->CR1;  
+
+  if((TIMx == TIM1) || (TIMx == TIM8)||
+     (TIMx == TIM2) || (TIMx == TIM3)||
+     (TIMx == TIM4) || (TIMx == TIM5)) 
+  {
+    /* Select the Counter Mode */
+    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
+    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
+  }
+ 
+  if((TIMx != TIM6) && (TIMx != TIM7))
+  {
+    /* Set the clock division */
+    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
+    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
+  }
+
+  TIMx->CR1 = tmpcr1;
+
+  /* Set the Autoreload value */
+  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
+ 
+  /* Set the Prescaler value */
+  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
+    
+  if ((TIMx == TIM1) || (TIMx == TIM8))  
+  {
+    /* Set the Repetition Counter value */
+    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
+  }
+
+  /* Generate an update event to reload the Prescaler 
+     and the repetition counter(only for TIM1 and TIM8) value immediatly */
+  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
+}
+
+/**
+  * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
+  * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
+  *         structure which will be initialized.
+  * @retval None
+  */
+void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
+{
+  /* Set the default configuration */
+  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
+  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
+  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
+  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
+  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
+}
+
+/**
+  * @brief  Configures the TIMx Prescaler.
+  * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
+  * @param  Prescaler: specifies the Prescaler Register value
+  * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
+  *          This parameter can be one of the following values:
+  *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
+  *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
+  * @retval None
+  */
+void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
+  /* Set the Prescaler value */
+  TIMx->PSC = Prescaler;
+  /* Set or reset the UG Bit */
+  TIMx->EGR = TIM_PSCReloadMode;
+}
+
+/**
+  * @brief  Specifies the TIMx Counter Mode to be used.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_CounterMode: specifies the Counter Mode to be used
+  *          This parameter can be one of the following values:
+  *            @arg TIM_CounterMode_Up: TIM Up Counting Mode
+  *            @arg TIM_CounterMode_Down: TIM Down Counting Mode
+  *            @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
+  *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
+  *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
+  * @retval None
+  */
+void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
+{
+  uint16_t tmpcr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
+
+  tmpcr1 = TIMx->CR1;
+
+  /* Reset the CMS and DIR Bits */
+  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
+
+  /* Set the Counter Mode */
+  tmpcr1 |= TIM_CounterMode;
+
+  /* Write to TIMx CR1 register */
+  TIMx->CR1 = tmpcr1;
+}
+
+/**
+  * @brief  Sets the TIMx Counter Register value
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  Counter: specifies the Counter register new value.
+  * @retval None
+  */
+void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
+{
+  /* Check the parameters */
+   assert_param(IS_TIM_ALL_PERIPH(TIMx));
+
+  /* Set the Counter Register value */
+  TIMx->CNT = Counter;
+}
+
+/**
+  * @brief  Sets the TIMx Autoreload Register value
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  Autoreload: specifies the Autoreload register new value.
+  * @retval None
+  */
+void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  
+  /* Set the Autoreload Register value */
+  TIMx->ARR = Autoreload;
+}
+
+/**
+  * @brief  Gets the TIMx Counter value.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @retval Counter Register value
+  */
+uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+
+  /* Get the Counter Register value */
+  return TIMx->CNT;
+}
+
+/**
+  * @brief  Gets the TIMx Prescaler value.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @retval Prescaler Register value.
+  */
+uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+
+  /* Get the Prescaler Register value */
+  return TIMx->PSC;
+}
+
+/**
+  * @brief  Enables or Disables the TIMx Update event.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  NewState: new state of the TIMx UDIS bit
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the Update Disable Bit */
+    TIMx->CR1 |= TIM_CR1_UDIS;
+  }
+  else
+  {
+    /* Reset the Update Disable Bit */
+    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
+  }
+}
+
+/**
+  * @brief  Configures the TIMx Update Request Interrupt source.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  TIM_UpdateSource: specifies the Update source.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_UpdateSource_Global: Source of update is the counter
+  *                 overflow/underflow or the setting of UG bit, or an update
+  *                 generation through the slave mode controller.
+  *            @arg TIM_UpdateSource_Regular: Source of update is counter overflow/underflow.
+  * @retval None
+  */
+void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
+
+  if (TIM_UpdateSource != TIM_UpdateSource_Global)
+  {
+    /* Set the URS Bit */
+    TIMx->CR1 |= TIM_CR1_URS;
+  }
+  else
+  {
+    /* Reset the URS Bit */
+    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
+  }
+}
+
+/**
+  * @brief  Enables or disables TIMx peripheral Preload register on ARR.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  NewState: new state of the TIMx peripheral Preload register
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the ARR Preload Bit */
+    TIMx->CR1 |= TIM_CR1_ARPE;
+  }
+  else
+  {
+    /* Reset the ARR Preload Bit */
+    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
+  }
+}
+
+/**
+  * @brief  Selects the TIMx's One Pulse Mode.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  TIM_OPMode: specifies the OPM Mode to be used.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OPMode_Single
+  *            @arg TIM_OPMode_Repetitive
+  * @retval None
+  */
+void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
+
+  /* Reset the OPM Bit */
+  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
+
+  /* Configure the OPM Mode */
+  TIMx->CR1 |= TIM_OPMode;
+}
+
+/**
+  * @brief  Sets the TIMx Clock Division value.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_CKD: specifies the clock division value.
+  *          This parameter can be one of the following value:
+  *            @arg TIM_CKD_DIV1: TDTS = Tck_tim
+  *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
+  *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
+  * @retval None
+  */
+void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
+
+  /* Reset the CKD Bits */
+  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
+
+  /* Set the CKD value */
+  TIMx->CR1 |= TIM_CKD;
+}
+
+/**
+  * @brief  Enables or disables the specified TIM peripheral.
+  * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
+  * @param  NewState: new state of the TIMx peripheral.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the TIM Counter */
+    TIMx->CR1 |= TIM_CR1_CEN;
+  }
+  else
+  {
+    /* Disable the TIM Counter */
+    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Group2 Output Compare management functions
+ *  @brief    Output Compare management functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Output Compare management functions #####
+ ===============================================================================  
+   
+      
+        ##### TIM Driver: how to use it in Output Compare Mode #####
+ ===============================================================================
+    [..] 
+    To use the Timer in Output Compare mode, the following steps are mandatory:
+       
+      (#) Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) 
+          function
+       
+      (#) Configure the TIM pins by configuring the corresponding GPIO pins
+       
+      (#) Configure the Time base unit as described in the first part of this driver, 
+        (++) if needed, else the Timer will run with the default configuration:
+            Autoreload value = 0xFFFF
+        (++) Prescaler value = 0x0000
+        (++) Counter mode = Up counting
+        (++) Clock Division = TIM_CKD_DIV1
+          
+      (#) Fill the TIM_OCInitStruct with the desired parameters including:
+        (++) The TIM Output Compare mode: TIM_OCMode
+        (++) TIM Output State: TIM_OutputState
+        (++) TIM Pulse value: TIM_Pulse
+        (++) TIM Output Compare Polarity : TIM_OCPolarity
+       
+      (#) Call TIM_OCxInit(TIMx, &TIM_OCInitStruct) to configure the desired 
+          channel with the corresponding configuration
+       
+      (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
+       
+      -@- All other functions can be used separately to modify, if needed,
+          a specific feature of the Timer. 
+          
+      -@- In case of PWM mode, this function is mandatory:
+          TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE); 
+              
+      -@- If the corresponding interrupt or DMA request are needed, the user should:
+        (+@) Enable the NVIC (or the DMA) to use the TIM interrupts (or DMA requests). 
+        (+@) Enable the corresponding interrupt (or DMA request) using the function 
+             TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx))   
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Initializes the TIMx Channel1 according to the specified parameters in
+  *         the TIM_OCInitStruct.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
+  *         the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
+
+  /* Disable the Channel 1: Reset the CC1E Bit */
+  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
+  
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx->CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx->CR2;
+  
+  /* Get the TIMx CCMR1 register value */
+  tmpccmrx = TIMx->CCMR1;
+    
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
+  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
+  /* Select the Output Compare Mode */
+  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
+  
+  /* Reset the Output Polarity level */
+  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
+  /* Set the Output Compare Polarity */
+  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
+  
+  /* Set the Output State */
+  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
+    
+  if((TIMx == TIM1) || (TIMx == TIM8))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
+    
+    /* Reset the Output N Polarity level */
+    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
+    /* Set the Output N Polarity */
+    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
+    /* Reset the Output N State */
+    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
+    
+    /* Set the Output N State */
+    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
+    /* Reset the Output Compare and Output Compare N IDLE State */
+    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
+    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
+    /* Set the Output Idle state */
+    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
+    /* Set the Output N Idle state */
+    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
+  }
+  /* Write to TIMx CR2 */
+  TIMx->CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmrx;
+  
+  /* Set the Capture Compare Register value */
+  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
+  
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel2 according to the specified parameters 
+  *         in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
+  *         the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
+
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
+  
+  /* Get the TIMx CCER register value */  
+  tmpccer = TIMx->CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx->CR2;
+  
+  /* Get the TIMx CCMR1 register value */
+  tmpccmrx = TIMx->CCMR1;
+    
+  /* Reset the Output Compare mode and Capture/Compare selection Bits */
+  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
+  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
+  
+  /* Reset the Output Polarity level */
+  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
+  /* Set the Output Compare Polarity */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
+  
+  /* Set the Output State */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
+    
+  if((TIMx == TIM1) || (TIMx == TIM8))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
+    
+    /* Reset the Output N Polarity level */
+    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
+    /* Set the Output N Polarity */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
+    /* Reset the Output N State */
+    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
+    
+    /* Set the Output N State */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
+    /* Reset the Output Compare and Output Compare N IDLE State */
+    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
+    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
+    /* Set the Output Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
+    /* Set the Output N Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
+  }
+  /* Write to TIMx CR2 */
+  TIMx->CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmrx;
+  
+  /* Set the Capture Compare Register value */
+  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
+  
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel3 according to the specified parameters
+  *         in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
+  *         the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
+
+  /* Disable the Channel 3: Reset the CC2E Bit */
+  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
+  
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx->CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx->CR2;
+  
+  /* Get the TIMx CCMR2 register value */
+  tmpccmrx = TIMx->CCMR2;
+    
+  /* Reset the Output Compare mode and Capture/Compare selection Bits */
+  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
+  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
+  
+  /* Reset the Output Polarity level */
+  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
+  /* Set the Output Compare Polarity */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
+  
+  /* Set the Output State */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
+    
+  if((TIMx == TIM1) || (TIMx == TIM8))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
+    
+    /* Reset the Output N Polarity level */
+    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
+    /* Set the Output N Polarity */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
+    /* Reset the Output N State */
+    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
+    
+    /* Set the Output N State */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
+    /* Reset the Output Compare and Output Compare N IDLE State */
+    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
+    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
+    /* Set the Output Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
+    /* Set the Output N Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
+  }
+  /* Write to TIMx CR2 */
+  TIMx->CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR2 */
+  TIMx->CCMR2 = tmpccmrx;
+  
+  /* Set the Capture Compare Register value */
+  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
+  
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel4 according to the specified parameters
+  *         in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
+  *         the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
+
+  /* Disable the Channel 4: Reset the CC4E Bit */
+  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
+  
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx->CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx->CR2;
+  
+  /* Get the TIMx CCMR2 register value */
+  tmpccmrx = TIMx->CCMR2;
+    
+  /* Reset the Output Compare mode and Capture/Compare selection Bits */
+  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
+  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
+  
+  /* Reset the Output Polarity level */
+  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
+  /* Set the Output Compare Polarity */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
+  
+  /* Set the Output State */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
+  
+  if((TIMx == TIM1) || (TIMx == TIM8))
+  {
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
+    /* Reset the Output Compare IDLE State */
+    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
+    /* Set the Output Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
+  }
+  /* Write to TIMx CR2 */
+  TIMx->CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR2 */  
+  TIMx->CCMR2 = tmpccmrx;
+    
+  /* Set the Capture Compare Register value */
+  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
+  
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Fills each TIM_OCInitStruct member with its default value.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  /* Set the default configuration */
+  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
+  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
+  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
+  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
+  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
+  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
+  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
+  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
+}
+
+/**
+  * @brief  Selects the TIM Output Compare Mode.
+  * @note   This function disables the selected channel before changing the Output
+  *         Compare Mode. If needed, user has to enable this channel using
+  *         TIM_CCxCmd() and TIM_CCxNCmd() functions.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_Channel: specifies the TIM Channel
+  *          This parameter can be one of the following values:
+  *            @arg TIM_Channel_1: TIM Channel 1
+  *            @arg TIM_Channel_2: TIM Channel 2
+  *            @arg TIM_Channel_3: TIM Channel 3
+  *            @arg TIM_Channel_4: TIM Channel 4
+  * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
+  *           This parameter can be one of the following values:
+  *            @arg TIM_OCMode_Timing
+  *            @arg TIM_OCMode_Active
+  *            @arg TIM_OCMode_Toggle
+  *            @arg TIM_OCMode_PWM1
+  *            @arg TIM_OCMode_PWM2
+  *            @arg TIM_ForcedAction_Active
+  *            @arg TIM_ForcedAction_InActive
+  * @retval None
+  */
+void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
+{
+  uint32_t tmp = 0;
+  uint16_t tmp1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_OCM(TIM_OCMode));
+
+  tmp = (uint32_t) TIMx;
+  tmp += CCMR_OFFSET;
+
+  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
+
+  /* Disable the Channel: Reset the CCxE Bit */
+  TIMx->CCER &= (uint16_t) ~tmp1;
+
+  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
+  {
+    tmp += (TIM_Channel>>1);
+
+    /* Reset the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
+   
+    /* Configure the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp |= TIM_OCMode;
+  }
+  else
+  {
+    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
+
+    /* Reset the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
+    
+    /* Configure the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
+  }
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare1 Register value
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  Compare1: specifies the Capture Compare1 register new value.
+  * @retval None
+  */
+void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+
+  /* Set the Capture Compare1 Register value */
+  TIMx->CCR1 = Compare1;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare2 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  Compare2: specifies the Capture Compare2 register new value.
+  * @retval None
+  */
+void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+
+  /* Set the Capture Compare2 Register value */
+  TIMx->CCR2 = Compare2;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare3 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  Compare3: specifies the Capture Compare3 register new value.
+  * @retval None
+  */
+void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+
+  /* Set the Capture Compare3 Register value */
+  TIMx->CCR3 = Compare3;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare4 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  Compare4: specifies the Capture Compare4 register new value.
+  * @retval None
+  */
+void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+
+  /* Set the Capture Compare4 Register value */
+  TIMx->CCR4 = Compare4;
+}
+
+/**
+  * @brief  Forces the TIMx output 1 waveform to active or inactive level.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
+  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
+  * @retval None
+  */
+void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Reset the OC1M Bits */
+  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
+
+  /* Configure The Forced output Mode */
+  tmpccmr1 |= TIM_ForcedAction;
+
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Forces the TIMx output 2 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
+  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
+  * @retval None
+  */
+void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Reset the OC2M Bits */
+  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
+
+  /* Configure The Forced output Mode */
+  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
+
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Forces the TIMx output 3 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
+  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
+  * @retval None
+  */
+void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+
+  tmpccmr2 = TIMx->CCMR2;
+
+  /* Reset the OC1M Bits */
+  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
+
+  /* Configure The Forced output Mode */
+  tmpccmr2 |= TIM_ForcedAction;
+
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Forces the TIMx output 4 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
+  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
+  * @retval None
+  */
+void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr2 = TIMx->CCMR2;
+
+  /* Reset the OC2M Bits */
+  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
+
+  /* Configure The Forced output Mode */
+  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
+
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCPreload_Enable
+  *            @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Reset the OC1PE Bit */
+  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
+
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr1 |= TIM_OCPreload;
+
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCPreload_Enable
+  *            @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Reset the OC2PE Bit */
+  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
+
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
+
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCPreload_Enable
+  *            @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+
+  tmpccmr2 = TIMx->CCMR2;
+
+  /* Reset the OC3PE Bit */
+  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
+
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr2 |= TIM_OCPreload;
+
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCPreload_Enable
+  *            @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+
+  tmpccmr2 = TIMx->CCMR2;
+
+  /* Reset the OC4PE Bit */
+  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
+
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
+
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 1 Fast feature.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Reset the OC1FE Bit */
+  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
+
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr1 |= TIM_OCFast;
+
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 2 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Reset the OC2FE Bit */
+  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
+
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
+
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 3 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr2 = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+
+  /* Get the TIMx CCMR2 register value */
+  tmpccmr2 = TIMx->CCMR2;
+
+  /* Reset the OC3FE Bit */
+  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
+
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr2 |= TIM_OCFast;
+
+  /* Write to TIMx CCMR2 */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 4 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+
+  /* Get the TIMx CCMR2 register value */
+  tmpccmr2 = TIMx->CCMR2;
+
+  /* Reset the OC4FE Bit */
+  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
+
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
+
+  /* Write to TIMx CCMR2 */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF1 signal on an external event
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCClear_Enable: TIM Output clear enable
+  *            @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Reset the OC1CE Bit */
+  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
+
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr1 |= TIM_OCClear;
+
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF2 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCClear_Enable: TIM Output clear enable
+  *            @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Reset the OC2CE Bit */
+  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
+
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
+
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF3 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCClear_Enable: TIM Output clear enable
+  *            @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+
+  tmpccmr2 = TIMx->CCMR2;
+
+  /* Reset the OC3CE Bit */
+  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
+
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr2 |= TIM_OCClear;
+
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF4 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCClear_Enable: TIM Output clear enable
+  *            @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+
+  tmpccmr2 = TIMx->CCMR2;
+
+  /* Reset the OC4CE Bit */
+  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
+
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
+
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Configures the TIMx channel 1 polarity.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC1 Polarity
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCPolarity_High: Output Compare active high
+  *            @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+
+  tmpccer = TIMx->CCER;
+
+  /* Set or Reset the CC1P Bit */
+  tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
+  tmpccer |= TIM_OCPolarity;
+
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx Channel 1N polarity.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_OCNPolarity: specifies the OC1N Polarity
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCNPolarity_High: Output Compare active high
+  *            @arg TIM_OCNPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+   
+  tmpccer = TIMx->CCER;
+
+  /* Set or Reset the CC1NP Bit */
+  tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
+  tmpccer |= TIM_OCNPolarity;
+
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx channel 2 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_OCPolarity: specifies the OC2 Polarity
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCPolarity_High: Output Compare active high
+  *            @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+
+  tmpccer = TIMx->CCER;
+
+  /* Set or Reset the CC2P Bit */
+  tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
+  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
+
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx Channel 2N polarity.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_OCNPolarity: specifies the OC2N Polarity
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCNPolarity_High: Output Compare active high
+  *            @arg TIM_OCNPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
+{
+  uint16_t tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+  
+  tmpccer = TIMx->CCER;
+
+  /* Set or Reset the CC2NP Bit */
+  tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
+  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
+
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx channel 3 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC3 Polarity
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCPolarity_High: Output Compare active high
+  *            @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+
+  tmpccer = TIMx->CCER;
+
+  /* Set or Reset the CC3P Bit */
+  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
+  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
+
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx Channel 3N polarity.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_OCNPolarity: specifies the OC3N Polarity
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCNPolarity_High: Output Compare active high
+  *            @arg TIM_OCNPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
+{
+  uint16_t tmpccer = 0;
+ 
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+    
+  tmpccer = TIMx->CCER;
+
+  /* Set or Reset the CC3NP Bit */
+  tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
+  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
+
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx channel 4 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC4 Polarity
+  *          This parameter can be one of the following values:
+  *            @arg TIM_OCPolarity_High: Output Compare active high
+  *            @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+
+  tmpccer = TIMx->CCER;
+
+  /* Set or Reset the CC4P Bit */
+  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
+  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
+
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Enables or disables the TIM Capture Compare Channel x.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_Channel: specifies the TIM Channel
+  *          This parameter can be one of the following values:
+  *            @arg TIM_Channel_1: TIM Channel 1
+  *            @arg TIM_Channel_2: TIM Channel 2
+  *            @arg TIM_Channel_3: TIM Channel 3
+  *            @arg TIM_Channel_4: TIM Channel 4
+  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
+  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
+  * @retval None
+  */
+void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
+{
+  uint16_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
+  assert_param(IS_TIM_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_CCX(TIM_CCx));
+
+  tmp = CCER_CCE_SET << TIM_Channel;
+
+  /* Reset the CCxE Bit */
+  TIMx->CCER &= (uint16_t)~ tmp;
+
+  /* Set or reset the CCxE Bit */ 
+  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
+}
+
+/**
+  * @brief  Enables or disables the TIM Capture Compare Channel xN.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_Channel: specifies the TIM Channel
+  *          This parameter can be one of the following values:
+  *            @arg TIM_Channel_1: TIM Channel 1
+  *            @arg TIM_Channel_2: TIM Channel 2
+  *            @arg TIM_Channel_3: TIM Channel 3
+  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
+  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
+  * @retval None
+  */
+void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
+{
+  uint16_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_CCXN(TIM_CCxN));
+
+  tmp = CCER_CCNE_SET << TIM_Channel;
+
+  /* Reset the CCxNE Bit */
+  TIMx->CCER &= (uint16_t) ~tmp;
+
+  /* Set or reset the CCxNE Bit */ 
+  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
+}
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Group3 Input Capture management functions
+ *  @brief    Input Capture management functions 
+ *
+@verbatim   
+ ===============================================================================
+                  ##### Input Capture management functions #####
+ ===============================================================================  
+         
+            ##### TIM Driver: how to use it in Input Capture Mode #####
+ ===============================================================================
+    [..]    
+    To use the Timer in Input Capture mode, the following steps are mandatory:
+       
+      (#) Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) 
+          function
+       
+      (#) Configure the TIM pins by configuring the corresponding GPIO pins
+       
+      (#) Configure the Time base unit as described in the first part of this driver,
+          if needed, else the Timer will run with the default configuration:
+        (++) Autoreload value = 0xFFFF
+        (++) Prescaler value = 0x0000
+        (++) Counter mode = Up counting
+        (++) Clock Division = TIM_CKD_DIV1
+          
+      (#) Fill the TIM_ICInitStruct with the desired parameters including:
+        (++) TIM Channel: TIM_Channel
+        (++) TIM Input Capture polarity: TIM_ICPolarity
+        (++) TIM Input Capture selection: TIM_ICSelection
+        (++) TIM Input Capture Prescaler: TIM_ICPrescaler
+        (++) TIM Input CApture filter value: TIM_ICFilter
+       
+      (#) Call TIM_ICInit(TIMx, &TIM_ICInitStruct) to configure the desired channel 
+          with the corresponding configuration and to measure only frequency 
+          or duty cycle of the input signal, or, Call TIM_PWMIConfig(TIMx, &TIM_ICInitStruct) 
+          to configure the desired channels with the corresponding configuration 
+          and to measure the frequency and the duty cycle of the input signal
+          
+      (#) Enable the NVIC or the DMA to read the measured frequency. 
+          
+      (#) Enable the corresponding interrupt (or DMA request) to read the Captured 
+          value, using the function TIM_ITConfig(TIMx, TIM_IT_CCx) 
+          (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)) 
+       
+      (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
+       
+      (#) Use TIM_GetCapturex(TIMx); to read the captured value.
+       
+      -@- All other functions can be used separately to modify, if needed,
+          a specific feature of the Timer. 
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Initializes the TIM peripheral according to the specified parameters
+  *         in the TIM_ICInitStruct.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
+  *         the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
+  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
+  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
+  
+  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
+  {
+    /* TI1 Configuration */
+    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
+               TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
+  {
+    /* TI2 Configuration */
+    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
+               TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
+  {
+    /* TI3 Configuration */
+    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
+               TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+  else
+  {
+    /* TI4 Configuration */
+    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
+               TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+}
+
+/**
+  * @brief  Fills each TIM_ICInitStruct member with its default value.
+  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  /* Set the default configuration */
+  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
+  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
+  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
+  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
+  TIM_ICInitStruct->TIM_ICFilter = 0x00;
+}
+
+/**
+  * @brief  Configures the TIM peripheral according to the specified parameters
+  *         in the TIM_ICInitStruct to measure an external PWM signal.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5,8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
+  *         the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
+  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+
+  /* Select the Opposite Input Polarity */
+  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
+  {
+    icoppositepolarity = TIM_ICPolarity_Falling;
+  }
+  else
+  {
+    icoppositepolarity = TIM_ICPolarity_Rising;
+  }
+  /* Select the Opposite Input */
+  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
+  {
+    icoppositeselection = TIM_ICSelection_IndirectTI;
+  }
+  else
+  {
+    icoppositeselection = TIM_ICSelection_DirectTI;
+  }
+  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
+  {
+    /* TI1 Configuration */
+    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+    /* TI2 Configuration */
+    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+  else
+  { 
+    /* TI2 Configuration */
+    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+    /* TI1 Configuration */
+    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 1 value.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @retval Capture Compare 1 Register value.
+  */
+uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+
+  /* Get the Capture 1 Register value */
+  return TIMx->CCR1;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 2 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @retval Capture Compare 2 Register value.
+  */
+uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+
+  /* Get the Capture 2 Register value */
+  return TIMx->CCR2;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 3 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @retval Capture Compare 3 Register value.
+  */
+uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
+
+  /* Get the Capture 3 Register value */
+  return TIMx->CCR3;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 4 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @retval Capture Compare 4 Register value.
+  */
+uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+
+  /* Get the Capture 4 Register value */
+  return TIMx->CCR4;
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 1 prescaler.
+  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPSC_DIV1: no prescaler
+  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+
+  /* Reset the IC1PSC Bits */
+  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
+
+  /* Set the IC1PSC value */
+  TIMx->CCMR1 |= TIM_ICPSC;
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 2 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPSC_DIV1: no prescaler
+  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+
+  /* Reset the IC2PSC Bits */
+  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
+
+  /* Set the IC2PSC value */
+  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 3 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPSC_DIV1: no prescaler
+  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+
+  /* Reset the IC3PSC Bits */
+  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
+
+  /* Set the IC3PSC value */
+  TIMx->CCMR2 |= TIM_ICPSC;
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 4 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPSC_DIV1: no prescaler
+  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{  
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+
+  /* Reset the IC4PSC Bits */
+  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
+
+  /* Set the IC4PSC value */
+  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
+}
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Group4 Advanced-control timers (TIM1 and TIM8) specific features
+ *  @brief   Advanced-control timers (TIM1 and TIM8) specific features
+ *
+@verbatim   
+ ===============================================================================
+      ##### Advanced-control timers (TIM1 and TIM8) specific features #####
+ ===============================================================================  
+        
+             ##### TIM Driver: how to use the Break feature #####
+ ===============================================================================
+    [..] 
+    After configuring the Timer channel(s) in the appropriate Output Compare mode: 
+                         
+      (#) Fill the TIM_BDTRInitStruct with the desired parameters for the Timer
+          Break Polarity, dead time, Lock level, the OSSI/OSSR State and the 
+          AOE(automatic output enable).
+               
+      (#) Call TIM_BDTRConfig(TIMx, &TIM_BDTRInitStruct) to configure the Timer
+          
+      (#) Enable the Main Output using TIM_CtrlPWMOutputs(TIM1, ENABLE) 
+          
+      (#) Once the break even occurs, the Timer's output signals are put in reset
+          state or in a known state (according to the configuration made in
+          TIM_BDTRConfig() function).
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
+  *         and the AOE(automatic output enable).
+  * @param  TIMx: where x can be  1 or 8 to select the TIM 
+  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
+  *         contains the BDTR Register configuration  information for the TIM peripheral.
+  * @retval None
+  */
+void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
+  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
+  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
+  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
+  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
+  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
+
+  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
+     the OSSI State, the dead time value and the Automatic Output Enable Bit */
+  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
+             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
+             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
+             TIM_BDTRInitStruct->TIM_AutomaticOutput;
+}
+
+/**
+  * @brief  Fills each TIM_BDTRInitStruct member with its default value.
+  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
+  *         will be initialized.
+  * @retval None
+  */
+void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
+{
+  /* Set the default configuration */
+  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
+  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
+  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
+  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
+  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
+  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
+  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
+}
+
+/**
+  * @brief  Enables or disables the TIM peripheral Main Outputs.
+  * @param  TIMx: where x can be 1 or 8 to select the TIMx peripheral.
+  * @param  NewState: new state of the TIM peripheral Main Outputs.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the TIM Main Output */
+    TIMx->BDTR |= TIM_BDTR_MOE;
+  }
+  else
+  {
+    /* Disable the TIM Main Output */
+    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
+  }  
+}
+
+/**
+  * @brief  Selects the TIM peripheral Commutation event.
+  * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
+  * @param  NewState: new state of the Commutation event.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the COM Bit */
+    TIMx->CR2 |= TIM_CR2_CCUS;
+  }
+  else
+  {
+    /* Reset the COM Bit */
+    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
+  }
+}
+
+/**
+  * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
+  * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
+  * @param  NewState: new state of the Capture Compare Preload Control bit
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the CCPC Bit */
+    TIMx->CR2 |= TIM_CR2_CCPC;
+  }
+  else
+  {
+    /* Reset the CCPC Bit */
+    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Group5 Interrupts DMA and flags management functions
+ *  @brief    Interrupts, DMA and flags management functions 
+ *
+@verbatim   
+ ===============================================================================
+          ##### Interrupts, DMA and flags management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified TIM interrupts.
+  * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
+  * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
+  *          This parameter can be any combination of the following values:
+  *            @arg TIM_IT_Update: TIM update Interrupt source
+  *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+  *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+  *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+  *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+  *            @arg TIM_IT_COM: TIM Commutation Interrupt source
+  *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
+  *            @arg TIM_IT_Break: TIM Break Interrupt source
+  *  
+  * @note   For TIM6 and TIM7 only the parameter TIM_IT_Update can be used
+  * @note   For TIM9 and TIM12 only one of the following parameters can be used: TIM_IT_Update,
+  *          TIM_IT_CC1, TIM_IT_CC2 or TIM_IT_Trigger. 
+  * @note   For TIM10, TIM11, TIM13 and TIM14 only one of the following parameters can
+  *          be used: TIM_IT_Update or TIM_IT_CC1   
+  * @note   TIM_IT_COM and TIM_IT_Break can be used only with TIM1 and TIM8 
+  *        
+  * @param  NewState: new state of the TIM interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
+{  
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_IT(TIM_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the Interrupt sources */
+    TIMx->DIER |= TIM_IT;
+  }
+  else
+  {
+    /* Disable the Interrupt sources */
+    TIMx->DIER &= (uint16_t)~TIM_IT;
+  }
+}
+
+/**
+  * @brief  Configures the TIMx event to be generate by software.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  TIM_EventSource: specifies the event source.
+  *          This parameter can be one or more of the following values:	   
+  *            @arg TIM_EventSource_Update: Timer update Event source
+  *            @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
+  *            @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
+  *            @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
+  *            @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
+  *            @arg TIM_EventSource_COM: Timer COM event source  
+  *            @arg TIM_EventSource_Trigger: Timer Trigger Event source
+  *            @arg TIM_EventSource_Break: Timer Break event source
+  * 
+  * @note   TIM6 and TIM7 can only generate an update event. 
+  * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
+  *        
+  * @retval None
+  */
+void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
+{ 
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
+ 
+  /* Set the event sources */
+  TIMx->EGR = TIM_EventSource;
+}
+
+/**
+  * @brief  Checks whether the specified TIM flag is set or not.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  TIM_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_FLAG_Update: TIM update Flag
+  *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
+  *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
+  *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
+  *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
+  *            @arg TIM_FLAG_COM: TIM Commutation Flag
+  *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
+  *            @arg TIM_FLAG_Break: TIM Break Flag
+  *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
+  *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
+  *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
+  *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
+  *
+  * @note   TIM6 and TIM7 can have only one update flag. 
+  * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
+  *
+  * @retval The new state of TIM_FLAG (SET or RESET).
+  */
+FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
+{ 
+  ITStatus bitstatus = RESET;  
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
+
+  
+  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the TIMx's pending flags.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  TIM_FLAG: specifies the flag bit to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg TIM_FLAG_Update: TIM update Flag
+  *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
+  *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
+  *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
+  *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
+  *            @arg TIM_FLAG_COM: TIM Commutation Flag
+  *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
+  *            @arg TIM_FLAG_Break: TIM Break Flag
+  *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
+  *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
+  *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
+  *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
+  *
+  * @note   TIM6 and TIM7 can have only one update flag. 
+  * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.
+  *    
+  * @retval None
+  */
+void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
+{  
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+   
+  /* Clear the flags */
+  TIMx->SR = (uint16_t)~TIM_FLAG;
+}
+
+/**
+  * @brief  Checks whether the TIM interrupt has occurred or not.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  TIM_IT: specifies the TIM interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_IT_Update: TIM update Interrupt source
+  *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+  *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+  *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+  *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+  *            @arg TIM_IT_COM: TIM Commutation Interrupt source
+  *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
+  *            @arg TIM_IT_Break: TIM Break Interrupt source
+  *
+  * @note   TIM6 and TIM7 can generate only an update interrupt.
+  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
+  *     
+  * @retval The new state of the TIM_IT(SET or RESET).
+  */
+ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
+{
+  ITStatus bitstatus = RESET;  
+  uint16_t itstatus = 0x0, itenable = 0x0;
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_GET_IT(TIM_IT));
+   
+  itstatus = TIMx->SR & TIM_IT;
+  
+  itenable = TIMx->DIER & TIM_IT;
+  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the TIMx's interrupt pending bits.
+  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
+  * @param  TIM_IT: specifies the pending bit to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg TIM_IT_Update: TIM1 update Interrupt source
+  *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+  *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+  *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+  *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+  *            @arg TIM_IT_COM: TIM Commutation Interrupt source
+  *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
+  *            @arg TIM_IT_Break: TIM Break Interrupt source
+  *
+  * @note   TIM6 and TIM7 can generate only an update interrupt.
+  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
+  *      
+  * @retval None
+  */
+void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+
+  /* Clear the IT pending Bit */
+  TIMx->SR = (uint16_t)~TIM_IT;
+}
+
+/**
+  * @brief  Configures the TIMx's DMA interface.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_DMABase: DMA Base address.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_DMABase_CR1  
+  *            @arg TIM_DMABase_CR2
+  *            @arg TIM_DMABase_SMCR
+  *            @arg TIM_DMABase_DIER
+  *            @arg TIM1_DMABase_SR
+  *            @arg TIM_DMABase_EGR
+  *            @arg TIM_DMABase_CCMR1
+  *            @arg TIM_DMABase_CCMR2
+  *            @arg TIM_DMABase_CCER
+  *            @arg TIM_DMABase_CNT   
+  *            @arg TIM_DMABase_PSC   
+  *            @arg TIM_DMABase_ARR
+  *            @arg TIM_DMABase_RCR
+  *            @arg TIM_DMABase_CCR1
+  *            @arg TIM_DMABase_CCR2
+  *            @arg TIM_DMABase_CCR3  
+  *            @arg TIM_DMABase_CCR4
+  *            @arg TIM_DMABase_BDTR
+  *            @arg TIM_DMABase_DCR
+  * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
+  *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
+  * @retval None
+  */
+void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
+  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
+
+  /* Set the DMA Base and the DMA Burst Length */
+  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
+}
+
+/**
+  * @brief  Enables or disables the TIMx's DMA Requests.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
+  * @param  TIM_DMASource: specifies the DMA Request sources.
+  *          This parameter can be any combination of the following values:
+  *            @arg TIM_DMA_Update: TIM update Interrupt source
+  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
+  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
+  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
+  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
+  *            @arg TIM_DMA_COM: TIM Commutation DMA source
+  *            @arg TIM_DMA_Trigger: TIM Trigger DMA source
+  * @param  NewState: new state of the DMA Request sources.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
+  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA sources */
+    TIMx->DIER |= TIM_DMASource; 
+  }
+  else
+  {
+    /* Disable the DMA sources */
+    TIMx->DIER &= (uint16_t)~TIM_DMASource;
+  }
+}
+
+/**
+  * @brief  Selects the TIMx peripheral Capture Compare DMA source.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  NewState: new state of the Capture Compare DMA source
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the CCDS Bit */
+    TIMx->CR2 |= TIM_CR2_CCDS;
+  }
+  else
+  {
+    /* Reset the CCDS Bit */
+    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Group6 Clocks management functions
+ *  @brief    Clocks management functions
+ *
+@verbatim   
+ ===============================================================================
+                  ##### Clocks management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the TIMx internal Clock
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @retval None
+  */
+void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+
+  /* Disable slave mode to clock the prescaler directly with the internal clock */
+  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
+}
+
+/**
+  * @brief  Configures the TIMx Internal Trigger as External Clock
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_InputTriggerSource: Trigger source.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_TS_ITR0: Internal Trigger 0
+  *            @arg TIM_TS_ITR1: Internal Trigger 1
+  *            @arg TIM_TS_ITR2: Internal Trigger 2
+  *            @arg TIM_TS_ITR3: Internal Trigger 3
+  * @retval None
+  */
+void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
+
+  /* Select the Internal Trigger */
+  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
+
+  /* Select the External clock mode1 */
+  TIMx->SMCR |= TIM_SlaveMode_External1;
+}
+
+/**
+  * @brief  Configures the TIMx Trigger as External Clock
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
+  *         to select the TIM peripheral.
+  * @param  TIM_TIxExternalCLKSource: Trigger source.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
+  *            @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
+  *            @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
+  * @param  TIM_ICPolarity: specifies the TIx Polarity.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPolarity_Rising
+  *            @arg TIM_ICPolarity_Falling
+  * @param  ICFilter: specifies the filter value.
+  *          This parameter must be a value between 0x0 and 0xF.
+  * @retval None
+  */
+void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
+                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
+  assert_param(IS_TIM_IC_FILTER(ICFilter));
+
+  /* Configure the Timer Input Clock Source */
+  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
+  {
+    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
+  }
+  else
+  {
+    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
+  }
+  /* Select the Trigger source */
+  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
+  /* Select the External clock mode1 */
+  TIMx->SMCR |= TIM_SlaveMode_External1;
+}
+
+/**
+  * @brief  Configures the External clock Mode1
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
+  *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
+  *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
+  *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
+  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
+  *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
+  * @param  ExtTRGFilter: External Trigger Filter.
+  *          This parameter must be a value between 0x00 and 0x0F
+  * @retval None
+  */
+void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
+                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
+{
+  uint16_t tmpsmcr = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+  /* Configure the ETR Clock source */
+  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
+  
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx->SMCR;
+
+  /* Reset the SMS Bits */
+  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
+
+  /* Select the External clock mode1 */
+  tmpsmcr |= TIM_SlaveMode_External1;
+
+  /* Select the Trigger selection : ETRF */
+  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
+  tmpsmcr |= TIM_TS_ETRF;
+
+  /* Write to TIMx SMCR */
+  TIMx->SMCR = tmpsmcr;
+}
+
+/**
+  * @brief  Configures the External clock Mode2
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
+  *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
+  *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
+  *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
+  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
+  *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
+  * @param  ExtTRGFilter: External Trigger Filter.
+  *          This parameter must be a value between 0x00 and 0x0F
+  * @retval None
+  */
+void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
+                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+
+  /* Configure the ETR Clock source */
+  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
+
+  /* Enable the External clock mode2 */
+  TIMx->SMCR |= TIM_SMCR_ECE;
+}
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Group7 Synchronization management functions
+ *  @brief    Synchronization management functions 
+ *
+@verbatim   
+ ===============================================================================
+                ##### Synchronization management functions #####
+ ===============================================================================  
+                         
+          ##### TIM Driver: how to use it in synchronization Mode #####
+ ===============================================================================
+    [..] 
+    
+    *** Case of two/several Timers ***
+    ==================================
+    [..]
+      (#) Configure the Master Timers using the following functions:
+        (++) void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource); 
+        (++) void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);  
+      (#) Configure the Slave Timers using the following functions: 
+        (++) void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
+        (++) void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
+          
+    *** Case of Timers and external trigger(ETR pin) ***
+    ====================================================
+    [..]           
+      (#) Configure the External trigger using this function:
+        (++) void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                               uint16_t ExtTRGFilter);
+      (#) Configure the Slave Timers using the following functions: 
+        (++) void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
+        (++) void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Selects the Input Trigger source
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
+  *         to select the TIM peripheral.
+  * @param  TIM_InputTriggerSource: The Input Trigger source.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_TS_ITR0: Internal Trigger 0
+  *            @arg TIM_TS_ITR1: Internal Trigger 1
+  *            @arg TIM_TS_ITR2: Internal Trigger 2
+  *            @arg TIM_TS_ITR3: Internal Trigger 3
+  *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
+  *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
+  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
+  *            @arg TIM_TS_ETRF: External Trigger input
+  * @retval None
+  */
+void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
+{
+  uint16_t tmpsmcr = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
+  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
+
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx->SMCR;
+
+  /* Reset the TS Bits */
+  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
+
+  /* Set the Input Trigger source */
+  tmpsmcr |= TIM_InputTriggerSource;
+
+  /* Write to TIMx SMCR */
+  TIMx->SMCR = tmpsmcr;
+}
+
+/**
+  * @brief  Selects the TIMx Trigger Output Mode.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
+  *     
+  * @param  TIM_TRGOSource: specifies the Trigger Output source.
+  *   This parameter can be one of the following values:
+  *
+  *  - For all TIMx
+  *            @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output(TRGO)
+  *            @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output(TRGO)
+  *            @arg TIM_TRGOSource_Update: The update event is selected as the trigger output(TRGO)
+  *
+  *  - For all TIMx except TIM6 and TIM7
+  *            @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
+  *                                     is to be set, as soon as a capture or compare match occurs(TRGO)
+  *            @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output(TRGO)
+  *            @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output(TRGO)
+  *            @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output(TRGO)
+  *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output(TRGO)
+  *
+  * @retval None
+  */
+void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
+  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
+
+  /* Reset the MMS Bits */
+  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
+  /* Select the TRGO source */
+  TIMx->CR2 |=  TIM_TRGOSource;
+}
+
+/**
+  * @brief  Selects the TIMx Slave Mode.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
+  * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal(TRGI) reinitialize 
+  *                                      the counter and triggers an update of the registers
+  *            @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high
+  *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI
+  *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter
+  * @retval None
+  */
+void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
+
+  /* Reset the SMS Bits */
+  TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
+
+  /* Select the Slave Mode */
+  TIMx->SMCR |= TIM_SlaveMode;
+}
+
+/**
+  * @brief  Sets or Resets the TIMx Master/Slave Mode.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
+  * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
+  *                                             and its slaves (through TRGO)
+  *            @arg TIM_MasterSlaveMode_Disable: No action
+  * @retval None
+  */
+void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
+
+  /* Reset the MSM Bit */
+  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
+  
+  /* Set or Reset the MSM Bit */
+  TIMx->SMCR |= TIM_MasterSlaveMode;
+}
+
+/**
+  * @brief  Configures the TIMx External Trigger (ETR).
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
+  *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
+  *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
+  *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
+  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
+  *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
+  * @param  ExtTRGFilter: External Trigger Filter.
+  *          This parameter must be a value between 0x00 and 0x0F
+  * @retval None
+  */
+void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
+                   uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
+{
+  uint16_t tmpsmcr = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+
+  tmpsmcr = TIMx->SMCR;
+
+  /* Reset the ETR Bits */
+  tmpsmcr &= SMCR_ETR_MASK;
+
+  /* Set the Prescaler, the Filter value and the Polarity */
+  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
+
+  /* Write to TIMx SMCR */
+  TIMx->SMCR = tmpsmcr;
+}
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Group8 Specific interface management functions
+ *  @brief    Specific interface management functions 
+ *
+@verbatim   
+ ===============================================================================
+            ##### Specific interface management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the TIMx Encoder Interface.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
+  *            @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
+  *            @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
+  *                                       on the level of the other input.
+  * @param  TIM_IC1Polarity: specifies the IC1 Polarity
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPolarity_Falling: IC Falling edge.
+  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
+  * @param  TIM_IC2Polarity: specifies the IC2 Polarity
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPolarity_Falling: IC Falling edge.
+  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
+  * @retval None
+  */
+void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
+                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
+{
+  uint16_t tmpsmcr = 0;
+  uint16_t tmpccmr1 = 0;
+  uint16_t tmpccer = 0;
+    
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
+  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
+  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
+
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx->SMCR;
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx->CCER;
+
+  /* Set the encoder Mode */
+  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
+  tmpsmcr |= TIM_EncoderMode;
+
+  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
+  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
+  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
+
+  /* Set the TI1 and the TI2 Polarities */
+  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
+  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
+
+  /* Write to TIMx SMCR */
+  TIMx->SMCR = tmpsmcr;
+
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmr1;
+
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Enables or disables the TIMx's Hall sensor interface.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  NewState: new state of the TIMx Hall sensor interface.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the TI1S Bit */
+    TIMx->CR2 |= TIM_CR2_TI1S;
+  }
+  else
+  {
+    /* Reset the TI1S Bit */
+    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
+  }
+}
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Group9 Specific remapping management function
+ *  @brief   Specific remapping management function
+ *
+@verbatim   
+ ===============================================================================
+              ##### Specific remapping management function #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the TIM2, TIM5 and TIM11 Remapping input capabilities.
+  * @param  TIMx: where x can be 2, 5 or 11 to select the TIM peripheral.
+  * @param  TIM_Remap: specifies the TIM input remapping source.
+  *          This parameter can be one of the following values:
+  *            @arg TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)
+  *            @arg TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trogger output.
+  *            @arg TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF. 
+  *            @arg TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF. 
+  *            @arg TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)
+  *            @arg TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.
+  *            @arg TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.
+  *            @arg TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.
+  *            @arg TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default) 
+  *            @arg TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
+  *                                 (HSE divided by a programmable prescaler)  
+  * @retval None
+  */
+void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
+{
+ /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_REMAP(TIM_Remap));
+
+  /* Set the Timer remapping configuration */
+  TIMx->OR =  TIM_Remap;
+}
+/**
+  * @}
+  */
+
+/**
+  * @brief  Configure the TI1 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
+  *         to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPolarity_Rising
+  *            @arg TIM_ICPolarity_Falling
+  *            @arg TIM_ICPolarity_BothEdge  
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
+  *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
+  *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *          This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr1 = 0, tmpccer = 0;
+
+  /* Disable the Channel 1: Reset the CC1E Bit */
+  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
+  tmpccmr1 = TIMx->CCMR1;
+  tmpccer = TIMx->CCER;
+
+  /* Select the Input and set the filter */
+  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
+  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
+
+  /* Select the Polarity and set the CC1E Bit */
+  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
+  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
+
+  /* Write to TIMx CCMR1 and CCER registers */
+  TIMx->CCMR1 = tmpccmr1;
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configure the TI2 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
+  *         peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPolarity_Rising
+  *            @arg TIM_ICPolarity_Falling
+  *            @arg TIM_ICPolarity_BothEdge   
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
+  *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
+  *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *          This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
+
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
+  tmpccmr1 = TIMx->CCMR1;
+  tmpccer = TIMx->CCER;
+  tmp = (uint16_t)(TIM_ICPolarity << 4);
+
+  /* Select the Input and set the filter */
+  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
+  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
+  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
+
+  /* Select the Polarity and set the CC2E Bit */
+  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
+  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
+
+  /* Write to TIMx CCMR1 and CCER registers */
+  TIMx->CCMR1 = tmpccmr1 ;
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configure the TI3 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPolarity_Rising
+  *            @arg TIM_ICPolarity_Falling
+  *            @arg TIM_ICPolarity_BothEdge         
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
+  *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
+  *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *          This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
+
+  /* Disable the Channel 3: Reset the CC3E Bit */
+  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
+  tmpccmr2 = TIMx->CCMR2;
+  tmpccer = TIMx->CCER;
+  tmp = (uint16_t)(TIM_ICPolarity << 8);
+
+  /* Select the Input and set the filter */
+  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
+  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
+
+  /* Select the Polarity and set the CC3E Bit */
+  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
+  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
+
+  /* Write to TIMx CCMR2 and CCER registers */
+  TIMx->CCMR2 = tmpccmr2;
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configure the TI4 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICPolarity_Rising
+  *            @arg TIM_ICPolarity_Falling
+  *            @arg TIM_ICPolarity_BothEdge     
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *          This parameter can be one of the following values:
+  *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
+  *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
+  *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *          This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
+
+  /* Disable the Channel 4: Reset the CC4E Bit */
+  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
+  tmpccmr2 = TIMx->CCMR2;
+  tmpccer = TIMx->CCER;
+  tmp = (uint16_t)(TIM_ICPolarity << 12);
+
+  /* Select the Input and set the filter */
+  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
+  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
+  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
+
+  /* Select the Polarity and set the CC4E Bit */
+  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
+  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
+
+  /* Write to TIMx CCMR2 and CCER registers */
+  TIMx->CCMR2 = tmpccmr2;
+  TIMx->CCER = tmpccer ;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c
new file mode 100644
index 0000000..e18c0ea
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c
@@ -0,0 +1,1487 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_usart.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Universal synchronous asynchronous receiver
+  *          transmitter (USART):           
+  *           + Initialization and Configuration
+  *           + Data transfers
+  *           + Multi-Processor Communication
+  *           + LIN mode
+  *           + Half-duplex mode
+  *           + Smartcard mode
+  *           + IrDA mode
+  *           + DMA transfers management
+  *           + Interrupts and flags management 
+  *           
+  @verbatim       
+ ===============================================================================
+                        ##### How to use this driver #####
+ ===============================================================================
+    [..]
+      (#) Enable peripheral clock using the following functions
+          RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
+          RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, 
+          UART4 or UART5.
+  
+      (#) According to the USART mode, enable the GPIO clocks using 
+          RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
+          or/and SCLK). 
+  
+      (#) Peripheral's alternate function: 
+        (++) Connect the pin to the desired peripherals' Alternate 
+            Function (AF) using GPIO_PinAFConfig() function
+        (++) Configure the desired pin in alternate function by:
+            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
+        (++) Select the type, pull-up/pull-down and output speed via 
+            GPIO_PuPd, GPIO_OType and GPIO_Speed members
+        (++) Call GPIO_Init() function
+          
+      (#) Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
+          flow control and Mode(Receiver/Transmitter) using the USART_Init()
+          function.
+  
+      (#) For synchronous mode, enable the clock and program the polarity,
+          phase and last bit using the USART_ClockInit() function.
+  
+      (#) Enable the NVIC and the corresponding interrupt using the function 
+         USART_ITConfig() if you need to use interrupt mode. 
+  
+      (#) When using the DMA mode 
+        (++) Configure the DMA using DMA_Init() function
+        (++) Active the needed channel Request using USART_DMACmd() function
+   
+      (#) Enable the USART using the USART_Cmd() function.
+   
+      (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
+    
+      -@- Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
+          for more details
+    
+    [..]        
+    In order to reach higher communication baudrates, it is possible to
+    enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
+    This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
+    and before calling the function USART_Init().
+            
+    @endverbatim        
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_usart.h"
+#include "stm32f4xx_rcc.h"
+#include "stm32f4xx_conf.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup USART 
+  * @brief USART driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
+#define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
+                                              USART_CR1_PS | USART_CR1_TE | \
+                                              USART_CR1_RE))
+
+/*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
+#define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
+                                              USART_CR2_CPHA | USART_CR2_LBCL))
+
+/*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
+#define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
+
+/*!< USART Interrupts mask */
+#define IT_MASK                   ((uint16_t)0x001F)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup USART_Private_Functions
+  * @{
+  */
+
+/** @defgroup USART_Group1 Initialization and Configuration functions
+ *  @brief   Initialization and Configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+            ##### Initialization and Configuration functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides a set of functions allowing to initialize the USART 
+    in asynchronous and in synchronous modes.
+      (+) For the asynchronous mode only these parameters can be configured: 
+        (++) Baud Rate
+        (++) Word Length 
+        (++) Stop Bit
+        (++) Parity: If the parity is enabled, then the MSB bit of the data written
+             in the data register is transmitted but is changed by the parity bit.
+             Depending on the frame length defined by the M bit (8-bits or 9-bits),
+             the possible USART frame formats are as listed in the following table:
+   +-------------------------------------------------------------+     
+   |   M bit |  PCE bit  |            USART frame                |
+   |---------------------|---------------------------------------|             
+   |    0    |    0      |    | SB | 8 bit data | STB |          |
+   |---------|-----------|---------------------------------------|  
+   |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
+   |---------|-----------|---------------------------------------|  
+   |    1    |    0      |    | SB | 9 bit data | STB |          |
+   |---------|-----------|---------------------------------------|  
+   |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
+   +-------------------------------------------------------------+            
+        (++) Hardware flow control
+        (++) Receiver/transmitter modes
+
+    [..]
+    The USART_Init() function follows the USART  asynchronous configuration 
+    procedure (details for the procedure are available in reference manual (RM0090)).
+
+     (+) For the synchronous mode in addition to the asynchronous mode parameters these 
+         parameters should be also configured:
+        (++) USART Clock Enabled
+        (++) USART polarity
+        (++) USART phase
+        (++) USART LastBit
+  
+    [..]
+    These parameters can be configured using the USART_ClockInit() function.
+
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @retval None
+  */
+void USART_DeInit(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+
+  if (USARTx == USART1)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
+  }
+  else if (USARTx == USART2)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
+  }
+  else if (USARTx == USART3)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
+  }    
+  else if (USARTx == UART4)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
+  }
+  else if (USARTx == UART5)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
+  }  
+  else if (USARTx == USART6)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
+  }
+  else if (USARTx == UART7)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, DISABLE);
+  }     
+  else
+  {
+    if (USARTx == UART8)
+    { 
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the USARTx peripheral according to the specified
+  *         parameters in the USART_InitStruct .
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
+  *         the configuration information for the specified USART peripheral.
+  * @retval None
+  */
+void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
+{
+  uint32_t tmpreg = 0x00, apbclock = 0x00;
+  uint32_t integerdivider = 0x00;
+  uint32_t fractionaldivider = 0x00;
+  RCC_ClocksTypeDef RCC_ClocksStatus;
+
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
+  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
+  assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
+  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
+  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
+  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
+
+  /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
+  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
+  {
+    assert_param(IS_USART_1236_PERIPH(USARTx));
+  }
+
+/*---------------------------- USART CR2 Configuration -----------------------*/
+  tmpreg = USARTx->CR2;
+
+  /* Clear STOP[13:12] bits */
+  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
+
+  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
+      Set STOP[13:12] bits according to USART_StopBits value */
+  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
+  
+  /* Write to USART CR2 */
+  USARTx->CR2 = (uint16_t)tmpreg;
+
+/*---------------------------- USART CR1 Configuration -----------------------*/
+  tmpreg = USARTx->CR1;
+
+  /* Clear M, PCE, PS, TE and RE bits */
+  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
+
+  /* Configure the USART Word Length, Parity and mode: 
+     Set the M bits according to USART_WordLength value 
+     Set PCE and PS bits according to USART_Parity value
+     Set TE and RE bits according to USART_Mode value */
+  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
+            USART_InitStruct->USART_Mode;
+
+  /* Write to USART CR1 */
+  USARTx->CR1 = (uint16_t)tmpreg;
+
+/*---------------------------- USART CR3 Configuration -----------------------*/  
+  tmpreg = USARTx->CR3;
+
+  /* Clear CTSE and RTSE bits */
+  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
+
+  /* Configure the USART HFC : 
+      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
+  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
+
+  /* Write to USART CR3 */
+  USARTx->CR3 = (uint16_t)tmpreg;
+
+/*---------------------------- USART BRR Configuration -----------------------*/
+  /* Configure the USART Baud Rate */
+  RCC_GetClocksFreq(&RCC_ClocksStatus);
+
+  if ((USARTx == USART1) || (USARTx == USART6))
+  {
+    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
+  }
+  else
+  {
+    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
+  }
+  
+  /* Determine the integer part */
+  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
+  {
+    /* Integer part computing in case Oversampling mode is 8 Samples */
+    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
+  }
+  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
+  {
+    /* Integer part computing in case Oversampling mode is 16 Samples */
+    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
+  }
+  tmpreg = (integerdivider / 100) << 4;
+
+  /* Determine the fractional part */
+  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
+
+  /* Implement the fractional part in the register */
+  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
+  {
+    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
+  }
+  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
+  {
+    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
+  }
+  
+  /* Write to USART BRR register */
+  USARTx->BRR = (uint16_t)tmpreg;
+}
+
+/**
+  * @brief  Fills each USART_InitStruct member with its default value.
+  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
+{
+  /* USART_InitStruct members default value */
+  USART_InitStruct->USART_BaudRate = 9600;
+  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
+  USART_InitStruct->USART_StopBits = USART_StopBits_1;
+  USART_InitStruct->USART_Parity = USART_Parity_No ;
+  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
+  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
+}
+
+/**
+  * @brief  Initializes the USARTx peripheral Clock according to the 
+  *         specified parameters in the USART_ClockInitStruct .
+  * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
+  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
+  *         contains the configuration information for the specified  USART peripheral.
+  * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
+  * @retval None
+  */
+void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
+{
+  uint32_t tmpreg = 0x00;
+  /* Check the parameters */
+  assert_param(IS_USART_1236_PERIPH(USARTx));
+  assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
+  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
+  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
+  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
+  
+/*---------------------------- USART CR2 Configuration -----------------------*/
+  tmpreg = USARTx->CR2;
+  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
+  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
+  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
+  /* Set CLKEN bit according to USART_Clock value */
+  /* Set CPOL bit according to USART_CPOL value */
+  /* Set CPHA bit according to USART_CPHA value */
+  /* Set LBCL bit according to USART_LastBit value */
+  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
+                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
+  /* Write to USART CR2 */
+  USARTx->CR2 = (uint16_t)tmpreg;
+}
+
+/**
+  * @brief  Fills each USART_ClockInitStruct member with its default value.
+  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
+  *         which will be initialized.
+  * @retval None
+  */
+void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
+{
+  /* USART_ClockInitStruct members default value */
+  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
+  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
+  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
+  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
+}
+
+/**
+  * @brief  Enables or disables the specified USART peripheral.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  NewState: new state of the USARTx peripheral.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected USART by setting the UE bit in the CR1 register */
+    USARTx->CR1 |= USART_CR1_UE;
+  }
+  else
+  {
+    /* Disable the selected USART by clearing the UE bit in the CR1 register */
+    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
+  }
+}
+
+/**
+  * @brief  Sets the system clock prescaler.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_Prescaler: specifies the prescaler clock. 
+  * @note   The function is used for IrDA mode with UART4 and UART5.   
+  * @retval None
+  */
+void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
+{ 
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  
+  /* Clear the USART prescaler */
+  USARTx->GTPR &= USART_GTPR_GT;
+  /* Set the USART prescaler */
+  USARTx->GTPR |= USART_Prescaler;
+}
+
+/**
+  * @brief  Enables or disables the USART's 8x oversampling mode.
+  * @note   This function has to be called before calling USART_Init() function
+  *         in order to have correct baudrate Divider value.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  NewState: new state of the USART 8x oversampling mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
+    USARTx->CR1 |= USART_CR1_OVER8;
+  }
+  else
+  {
+    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
+    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
+  }
+}  
+
+/**
+  * @brief  Enables or disables the USART's one bit sampling method.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  NewState: new state of the USART one bit sampling method.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
+    USARTx->CR3 |= USART_CR3_ONEBIT;
+  }
+  else
+  {
+    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
+    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Group2 Data transfers functions
+ *  @brief   Data transfers functions 
+ *
+@verbatim   
+ ===============================================================================
+                      ##### Data transfers functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides a set of functions allowing to manage the USART data 
+    transfers.
+    [..]
+    During an USART reception, data shifts in least significant bit first through 
+    the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
+    between the internal bus and the received shift register.
+    [..]
+    When a transmission is taking place, a write instruction to the USART_DR register 
+    stores the data in the TDR register and which is copied in the shift register 
+    at the end of the current transmission.
+    [..]
+    The read access of the USART_DR register can be done using the USART_ReceiveData()
+    function and returns the RDR buffered value. Whereas a write access to the USART_DR 
+    can be done using USART_SendData() function and stores the written data into 
+    TDR buffer.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Transmits single data through the USARTx peripheral.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  Data: the data to transmit.
+  * @retval None
+  */
+void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_DATA(Data)); 
+    
+  /* Transmit Data */
+  USARTx->DR = (Data & (uint16_t)0x01FF);
+}
+
+/**
+  * @brief  Returns the most recent received data by the USARTx peripheral.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @retval The received data.
+  */
+uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  
+  /* Receive Data */
+  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Group3 MultiProcessor Communication functions
+ *  @brief   Multi-Processor Communication functions 
+ *
+@verbatim   
+ ===============================================================================
+              ##### Multi-Processor Communication functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides a set of functions allowing to manage the USART 
+    multiprocessor communication.
+    [..]
+    For instance one of the USARTs can be the master, its TX output is connected 
+    to the RX input of the other USART. The others are slaves, their respective 
+    TX outputs are logically ANDed together and connected to the RX input of the 
+    master.
+    [..]
+    USART multiprocessor communication is possible through the following procedure:
+      (#) Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode 
+          transmitter or Mode receiver and hardware flow control values using 
+          the USART_Init() function.
+      (#) Configures the USART address using the USART_SetAddress() function.
+      (#) Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
+          using USART_WakeUpConfig() function only for the slaves.
+      (#) Enable the USART using the USART_Cmd() function.
+      (#) Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
+    [..]
+    The USART Slave exit from mute mode when receive the wake up condition.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Sets the address of the USART node.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_Address: Indicates the address of the USART node.
+  * @retval None
+  */
+void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_ADDRESS(USART_Address)); 
+    
+  /* Clear the USART address */
+  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
+  /* Set the USART address node */
+  USARTx->CR2 |= USART_Address;
+}
+
+/**
+  * @brief  Determines if the USART is in mute mode or not.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  NewState: new state of the USART mute mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
+    USARTx->CR1 |= USART_CR1_RWU;
+  }
+  else
+  {
+    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
+    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
+  }
+}
+/**
+  * @brief  Selects the USART WakeUp method.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_WakeUp: specifies the USART wakeup method.
+  *          This parameter can be one of the following values:
+  *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
+  *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
+  * @retval None
+  */
+void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_WAKEUP(USART_WakeUp));
+  
+  USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
+  USARTx->CR1 |= USART_WakeUp;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Group4 LIN mode functions
+ *  @brief   LIN mode functions 
+ *
+@verbatim   
+ ===============================================================================
+                        ##### LIN mode functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides a set of functions allowing to manage the USART LIN 
+    Mode communication.
+    [..]
+    In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
+    the LIN standard.
+    [..]
+    Only this LIN Feature is supported by the USART IP:
+      (+) LIN Master Synchronous Break send capability and LIN slave break detection
+          capability :  13-bit break generation and 10/11 bit break detection
+
+    [..]
+    USART LIN Master transmitter communication is possible through the following 
+    procedure:
+      (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
+        Mode transmitter or Mode receiver and hardware flow control values using 
+        the USART_Init() function.
+      (#) Enable the USART using the USART_Cmd() function.
+      (#) Enable the LIN mode using the USART_LINCmd() function.
+      (#) Send the break character using USART_SendBreak() function.
+    [..]
+    USART LIN Master receiver communication is possible through the following procedure:
+      (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
+          Mode transmitter or Mode receiver and hardware flow control values using 
+          the USART_Init() function.
+      (#) Enable the USART using the USART_Cmd() function.
+      (#) Configures the break detection length using the USART_LINBreakDetectLengthConfig()
+          function.
+      (#) Enable the LIN mode using the USART_LINCmd() function.
+
+      -@- In LIN mode, the following bits must be kept cleared:
+       (+@) CLKEN in the USART_CR2 register,
+       (+@) STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Sets the USART LIN Break detection length.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
+  *          This parameter can be one of the following values:
+  *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
+  *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
+  * @retval None
+  */
+void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
+  
+  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
+  USARTx->CR2 |= USART_LINBreakDetectLength;  
+}
+
+/**
+  * @brief  Enables or disables the USART's LIN mode.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  NewState: new state of the USART LIN mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
+    USARTx->CR2 |= USART_CR2_LINEN;
+  }
+  else
+  {
+    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
+    USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
+  }
+}
+
+/**
+  * @brief  Transmits break characters.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @retval None
+  */
+void USART_SendBreak(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  
+  /* Send break characters */
+  USARTx->CR1 |= USART_CR1_SBK;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Group5 Halfduplex mode function
+ *  @brief   Half-duplex mode function 
+ *
+@verbatim   
+ ===============================================================================
+                    ##### Half-duplex mode function #####
+ ===============================================================================  
+    [..]
+    This subsection provides a set of functions allowing to manage the USART 
+    Half-duplex communication.
+    [..]
+    The USART can be configured to follow a single-wire half-duplex protocol where 
+    the TX and RX lines are internally connected.
+    [..]
+    USART Half duplex communication is possible through the following procedure:
+      (#) Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
+          or Mode receiver and hardware flow control values using the USART_Init()
+          function.
+      (#) Configures the USART address using the USART_SetAddress() function.
+      (#) Enable the USART using the USART_Cmd() function.
+      (#) Enable the half duplex mode using USART_HalfDuplexCmd() function.
+
+
+    -@- The RX pin is no longer used
+    -@- In Half-duplex mode the following bits must be kept cleared:
+      (+@) LINEN and CLKEN bits in the USART_CR2 register.
+      (+@) SCEN and IREN bits in the USART_CR3 register.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the USART's Half Duplex communication.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  NewState: new state of the USART Communication.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
+    USARTx->CR3 |= USART_CR3_HDSEL;
+  }
+  else
+  {
+    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
+    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
+  }
+}
+
+/**
+  * @}
+  */
+
+
+/** @defgroup USART_Group6 Smartcard mode functions
+ *  @brief   Smartcard mode functions 
+ *
+@verbatim   
+ ===============================================================================
+                              ##### Smartcard mode functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides a set of functions allowing to manage the USART 
+    Smartcard communication.
+    [..]
+    The Smartcard interface is designed to support asynchronous protocol Smartcards as
+    defined in the ISO 7816-3 standard.
+    [..]
+    The USART can provide a clock to the smartcard through the SCLK output.
+    In smartcard mode, SCLK is not associated to the communication but is simply derived 
+    from the internal peripheral input clock through a 5-bit prescaler.
+    [..]
+    Smartcard communication is possible through the following procedure:
+      (#) Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
+      (#) Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
+      (#) Program the USART clock using the USART_ClockInit() function as following:
+        (++) USART Clock enabled
+        (++) USART CPOL Low
+        (++) USART CPHA on first edge
+        (++) USART Last Bit Clock Enabled
+      (#) Program the Smartcard interface using the USART_Init() function as following:
+        (++) Word Length = 9 Bits
+        (++) 1.5 Stop Bit
+        (++) Even parity
+        (++) BaudRate = 12096 baud
+        (++) Hardware flow control disabled (RTS and CTS signals)
+        (++) Tx and Rx enabled
+      (#) POptionally you can enable the parity error interrupt using the USART_ITConfig()
+          function
+      (#) PEnable the USART using the USART_Cmd() function.
+      (#) PEnable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
+      (#) PEnable the Smartcard interface using the USART_SmartCardCmd() function.
+
+    Please refer to the ISO 7816-3 specification for more details.
+
+      -@- It is also possible to choose 0.5 stop bit for receiving but it is recommended 
+          to use 1.5 stop bits for both transmitting and receiving to avoid switching 
+          between the two configurations.
+      -@- In smartcard mode, the following bits must be kept cleared:
+        (+@) LINEN bit in the USART_CR2 register.
+        (+@) HDSEL and IREN bits in the USART_CR3 register.
+      -@- Smartcard mode is available on USART peripherals only (not available on UART4 
+          and UART5 peripherals).
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Sets the specified USART guard time.
+  * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_GuardTime: specifies the guard time.   
+  * @retval None
+  */
+void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
+{    
+  /* Check the parameters */
+  assert_param(IS_USART_1236_PERIPH(USARTx));
+  
+  /* Clear the USART Guard time */
+  USARTx->GTPR &= USART_GTPR_PSC;
+  /* Set the USART guard time */
+  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
+}
+
+/**
+  * @brief  Enables or disables the USART's Smart Card mode.
+  * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
+  *         UART peripheral.
+  * @param  NewState: new state of the Smart Card mode.
+  *          This parameter can be: ENABLE or DISABLE.      
+  * @retval None
+  */
+void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_1236_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
+    USARTx->CR3 |= USART_CR3_SCEN;
+  }
+  else
+  {
+    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
+    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
+  }
+}
+
+/**
+  * @brief  Enables or disables NACK transmission.
+  * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
+  *         UART peripheral.
+  * @param  NewState: new state of the NACK transmission.
+  *          This parameter can be: ENABLE or DISABLE.  
+  * @retval None
+  */
+void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_1236_PERIPH(USARTx)); 
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
+    USARTx->CR3 |= USART_CR3_NACK;
+  }
+  else
+  {
+    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
+    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Group7 IrDA mode functions
+ *  @brief   IrDA mode functions 
+ *
+@verbatim   
+ ===============================================================================
+                        ##### IrDA mode functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides a set of functions allowing to manage the USART 
+    IrDA communication.
+    [..]
+    IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
+    on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
+    is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
+    While receiving data, transmission should be avoided as the data to be transmitted
+    could be corrupted.
+    [..]
+    IrDA communication is possible through the following procedure:
+      (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
+          modes and hardware flow control values using the USART_Init() function.
+      (#) Enable the USART using the USART_Cmd() function.
+      (#) Configures the IrDA pulse width by configuring the prescaler using  
+          the USART_SetPrescaler() function.
+      (#) Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
+          using the USART_IrDAConfig() function.
+      (#) Enable the IrDA using the USART_IrDACmd() function.
+
+      -@- A pulse of width less than two and greater than one PSC period(s) may or may
+          not be rejected.
+      -@- The receiver set up time should be managed by software. The IrDA physical layer
+          specification specifies a minimum of 10 ms delay between transmission and 
+          reception (IrDA is a half duplex protocol).
+      -@- In IrDA mode, the following bits must be kept cleared:
+        (+@) LINEN, STOP and CLKEN bits in the USART_CR2 register.
+        (+@) SCEN and HDSEL bits in the USART_CR3 register.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Configures the USART's IrDA interface.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_IrDAMode: specifies the IrDA mode.
+  *          This parameter can be one of the following values:
+  *            @arg USART_IrDAMode_LowPower
+  *            @arg USART_IrDAMode_Normal
+  * @retval None
+  */
+void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
+    
+  USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
+  USARTx->CR3 |= USART_IrDAMode;
+}
+
+/**
+  * @brief  Enables or disables the USART's IrDA interface.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  NewState: new state of the IrDA mode.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  if (NewState != DISABLE)
+  {
+    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
+    USARTx->CR3 |= USART_CR3_IREN;
+  }
+  else
+  {
+    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
+    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
+  }
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Group8 DMA transfers management functions
+ *  @brief   DMA transfers management functions
+ *
+@verbatim   
+ ===============================================================================
+              ##### DMA transfers management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+  
+/**
+  * @brief  Enables or disables the USART's DMA interface.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_DMAReq: specifies the DMA request.
+  *          This parameter can be any combination of the following values:
+  *            @arg USART_DMAReq_Tx: USART DMA transmit request
+  *            @arg USART_DMAReq_Rx: USART DMA receive request
+  * @param  NewState: new state of the DMA Request sources.
+  *          This parameter can be: ENABLE or DISABLE.   
+  * @retval None
+  */
+void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
+       DMAR bits in the USART CR3 register */
+    USARTx->CR3 |= USART_DMAReq;
+  }
+  else
+  {
+    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
+       DMAR bits in the USART CR3 register */
+    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
+  }
+}
+
+/**
+  * @}
+  */
+  
+/** @defgroup USART_Group9 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions 
+ *
+@verbatim   
+ ===============================================================================
+            ##### Interrupts and flags management functions #####
+ ===============================================================================  
+    [..]
+    This subsection provides a set of functions allowing to configure the USART 
+    Interrupts sources, DMA channels requests and check or clear the flags or 
+    pending bits status.
+    The user should identify which mode will be used in his application to manage 
+    the communication: Polling mode, Interrupt mode or DMA mode. 
+    
+    *** Polling Mode ***
+    ====================
+    [..]
+    In Polling Mode, the SPI communication can be managed by 10 flags:
+      (#) USART_FLAG_TXE : to indicate the status of the transmit buffer register
+      (#) USART_FLAG_RXNE : to indicate the status of the receive buffer register
+      (#) USART_FLAG_TC : to indicate the status of the transmit operation
+      (#) USART_FLAG_IDLE : to indicate the status of the Idle Line             
+      (#) USART_FLAG_CTS : to indicate the status of the nCTS input
+      (#) USART_FLAG_LBD : to indicate the status of the LIN break detection
+      (#) USART_FLAG_NE : to indicate if a noise error occur
+      (#) USART_FLAG_FE : to indicate if a frame error occur
+      (#) USART_FLAG_PE : to indicate if a parity error occur
+      (#) USART_FLAG_ORE : to indicate if an Overrun error occur
+    [..]
+    In this Mode it is advised to use the following functions:
+      (+) FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
+      (+) void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
+
+    *** Interrupt Mode ***
+    ======================
+    [..]
+    In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
+    and 10 pending bits: 
+
+      (#) Pending Bits:
+
+        (##) USART_IT_TXE : to indicate the status of the transmit buffer register
+        (##) USART_IT_RXNE : to indicate the status of the receive buffer register
+        (##) USART_IT_TC : to indicate the status of the transmit operation
+        (##) USART_IT_IDLE : to indicate the status of the Idle Line             
+        (##) USART_IT_CTS : to indicate the status of the nCTS input
+        (##) USART_IT_LBD : to indicate the status of the LIN break detection
+        (##) USART_IT_NE : to indicate if a noise error occur
+        (##) USART_IT_FE : to indicate if a frame error occur
+        (##) USART_IT_PE : to indicate if a parity error occur
+        (##) USART_IT_ORE : to indicate if an Overrun error occur
+
+      (#) Interrupt Source:
+
+        (##) USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
+                            interrupt. 
+        (##) USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
+                             empty interrupt.
+        (##) USART_IT_TC : specifies the interrupt source for the Transmit complete 
+                           interrupt. 
+        (##) USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
+        (##) USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
+        (##) USART_IT_LBD : specifies the interrupt source for the LIN break detection
+                            interrupt. 
+        (##) USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
+        (##) USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
+
+      -@@- Some parameters are coded in order to use them as interrupt source 
+          or as pending bits.
+    [..]
+    In this Mode it is advised to use the following functions:
+      (+) void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
+      (+) ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
+      (+) void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
+
+    *** DMA Mode ***
+    ================
+    [..]
+    In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
+      (#) USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
+      (#) USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
+    [..]
+    In this Mode it is advised to use the following function:
+      (+) void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified USART interrupts.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
+  *          This parameter can be one of the following values:
+  *            @arg USART_IT_CTS:  CTS change interrupt
+  *            @arg USART_IT_LBD:  LIN Break detection interrupt
+  *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
+  *            @arg USART_IT_TC:   Transmission complete interrupt
+  *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
+  *            @arg USART_IT_IDLE: Idle line detection interrupt
+  *            @arg USART_IT_PE:   Parity Error interrupt
+  *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
+  * @param  NewState: new state of the specified USARTx interrupts.
+  *          This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
+{
+  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
+  uint32_t usartxbase = 0x00;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CONFIG_IT(USART_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* The CTS interrupt is not available for UART4 and UART5 */
+  if (USART_IT == USART_IT_CTS)
+  {
+    assert_param(IS_USART_1236_PERIPH(USARTx));
+  } 
+    
+  usartxbase = (uint32_t)USARTx;
+
+  /* Get the USART register index */
+  usartreg = (((uint8_t)USART_IT) >> 0x05);
+
+  /* Get the interrupt position */
+  itpos = USART_IT & IT_MASK;
+  itmask = (((uint32_t)0x01) << itpos);
+    
+  if (usartreg == 0x01) /* The IT is in CR1 register */
+  {
+    usartxbase += 0x0C;
+  }
+  else if (usartreg == 0x02) /* The IT is in CR2 register */
+  {
+    usartxbase += 0x10;
+  }
+  else /* The IT is in CR3 register */
+  {
+    usartxbase += 0x14; 
+  }
+  if (NewState != DISABLE)
+  {
+    *(__IO uint32_t*)usartxbase  |= itmask;
+  }
+  else
+  {
+    *(__IO uint32_t*)usartxbase &= ~itmask;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified USART flag is set or not.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_FLAG: specifies the flag to check.
+  *          This parameter can be one of the following values:
+  *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
+  *            @arg USART_FLAG_LBD:  LIN Break detection flag
+  *            @arg USART_FLAG_TXE:  Transmit data register empty flag
+  *            @arg USART_FLAG_TC:   Transmission Complete flag
+  *            @arg USART_FLAG_RXNE: Receive data register not empty flag
+  *            @arg USART_FLAG_IDLE: Idle Line detection flag
+  *            @arg USART_FLAG_ORE:  OverRun Error flag
+  *            @arg USART_FLAG_NE:   Noise Error flag
+  *            @arg USART_FLAG_FE:   Framing Error flag
+  *            @arg USART_FLAG_PE:   Parity Error flag
+  * @retval The new state of USART_FLAG (SET or RESET).
+  */
+FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_FLAG(USART_FLAG));
+
+  /* The CTS flag is not available for UART4 and UART5 */
+  if (USART_FLAG == USART_FLAG_CTS)
+  {
+    assert_param(IS_USART_1236_PERIPH(USARTx));
+  } 
+    
+  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the USARTx's pending flags.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_FLAG: specifies the flag to clear.
+  *          This parameter can be any combination of the following values:
+  *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
+  *            @arg USART_FLAG_LBD:  LIN Break detection flag.
+  *            @arg USART_FLAG_TC:   Transmission Complete flag.
+  *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
+  *   
+  * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
+  *          error) and IDLE (Idle line detected) flags are cleared by software 
+  *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
+  *          followed by a read operation to USART_DR register (USART_ReceiveData()).
+  * @note   RXNE flag can be also cleared by a read to the USART_DR register 
+  *          (USART_ReceiveData()).
+  * @note   TC flag can be also cleared by software sequence: a read operation to 
+  *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
+  *          to USART_DR register (USART_SendData()).
+  * @note   TXE flag is cleared only by a write to the USART_DR register 
+  *          (USART_SendData()).
+  *   
+  * @retval None
+  */
+void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
+
+  /* The CTS flag is not available for UART4 and UART5 */
+  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
+  {
+    assert_param(IS_USART_1236_PERIPH(USARTx));
+  } 
+       
+  USARTx->SR = (uint16_t)~USART_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified USART interrupt has occurred or not.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_IT: specifies the USART interrupt source to check.
+  *          This parameter can be one of the following values:
+  *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
+  *            @arg USART_IT_LBD:  LIN Break detection interrupt
+  *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
+  *            @arg USART_IT_TC:   Transmission complete interrupt
+  *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
+  *            @arg USART_IT_IDLE: Idle line detection interrupt
+  *            @arg USART_IT_ORE_RX : OverRun Error interrupt if the RXNEIE bit is set
+  *            @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set  
+  *            @arg USART_IT_NE:   Noise Error interrupt
+  *            @arg USART_IT_FE:   Framing Error interrupt
+  *            @arg USART_IT_PE:   Parity Error interrupt
+  * @retval The new state of USART_IT (SET or RESET).
+  */
+ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
+{
+  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_GET_IT(USART_IT)); 
+
+  /* The CTS interrupt is not available for UART4 and UART5 */ 
+  if (USART_IT == USART_IT_CTS)
+  {
+    assert_param(IS_USART_1236_PERIPH(USARTx));
+  } 
+    
+  /* Get the USART register index */
+  usartreg = (((uint8_t)USART_IT) >> 0x05);
+  /* Get the interrupt position */
+  itmask = USART_IT & IT_MASK;
+  itmask = (uint32_t)0x01 << itmask;
+  
+  if (usartreg == 0x01) /* The IT  is in CR1 register */
+  {
+    itmask &= USARTx->CR1;
+  }
+  else if (usartreg == 0x02) /* The IT  is in CR2 register */
+  {
+    itmask &= USARTx->CR2;
+  }
+  else /* The IT  is in CR3 register */
+  {
+    itmask &= USARTx->CR3;
+  }
+  
+  bitpos = USART_IT >> 0x08;
+  bitpos = (uint32_t)0x01 << bitpos;
+  bitpos &= USARTx->SR;
+  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  
+  return bitstatus;  
+}
+
+/**
+  * @brief  Clears the USARTx's interrupt pending bits.
+  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
+  *         UART peripheral.
+  * @param  USART_IT: specifies the interrupt pending bit to clear.
+  *          This parameter can be one of the following values:
+  *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
+  *            @arg USART_IT_LBD:  LIN Break detection interrupt
+  *            @arg USART_IT_TC:   Transmission complete interrupt. 
+  *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
+  *
+  * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
+  *          error) and IDLE (Idle line detected) pending bits are cleared by 
+  *          software sequence: a read operation to USART_SR register 
+  *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
+  *          (USART_ReceiveData()).
+  * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
+  *          (USART_ReceiveData()).
+  * @note   TC pending bit can be also cleared by software sequence: a read 
+  *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
+  *          operation to USART_DR register (USART_SendData()).
+  * @note   TXE pending bit is cleared only by a write to the USART_DR register 
+  *          (USART_SendData()).
+  *  
+  * @retval None
+  */
+void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
+{
+  uint16_t bitpos = 0x00, itmask = 0x00;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CLEAR_IT(USART_IT)); 
+
+  /* The CTS interrupt is not available for UART4 and UART5 */
+  if (USART_IT == USART_IT_CTS)
+  {
+    assert_param(IS_USART_1236_PERIPH(USARTx));
+  } 
+    
+  bitpos = USART_IT >> 0x08;
+  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
+  USARTx->SR = (uint16_t)~itmask;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_wwdg.c b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_wwdg.c
new file mode 100644
index 0000000..8e88af1
--- /dev/null
+++ b/stm32f407zg/uniproton/board/FWLIB/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_wwdg.c
@@ -0,0 +1,307 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx_wwdg.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file provides firmware functions to manage the following 
+  *          functionalities of the Window watchdog (WWDG) peripheral:           
+  *           + Prescaler, Refresh window and Counter configuration
+  *           + WWDG activation
+  *           + Interrupts and flags management
+  *             
+ @verbatim    
+ ===============================================================================
+                           ##### WWDG features #####
+ ===============================================================================
+    [..]                                      
+        Once enabled the WWDG generates a system reset on expiry of a programmed
+        time period, unless the program refreshes the counter (downcounter) 
+        before to reach 0x3F value (i.e. a reset is generated when the counter
+        value rolls over from 0x40 to 0x3F). 
+        An MCU reset is also generated if the counter value is refreshed
+        before the counter has reached the refresh window value. This 
+        implies that the counter must be refreshed in a limited window.
+              
+        Once enabled the WWDG cannot be disabled except by a system reset.
+          
+        WWDGRST flag in RCC_CSR register can be used to inform when a WWDG
+        reset occurs.
+             
+        The WWDG counter input clock is derived from the APB clock divided 
+        by a programmable prescaler.
+                
+        WWDG counter clock = PCLK1 / Prescaler
+        WWDG timeout = (WWDG counter clock) * (counter value)
+                       
+        Min-max timeout value @42 MHz(PCLK1): ~97.5 us / ~49.9 ms
+                             
+                      ##### How to use this driver #####
+ ===============================================================================
+    [..]
+      (#) Enable WWDG clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE) function
+              
+      (#) Configure the WWDG prescaler using WWDG_SetPrescaler() function
+                             
+      (#) Configure the WWDG refresh window using WWDG_SetWindowValue() function
+              
+      (#) Set the WWDG counter value and start it using WWDG_Enable() function.
+          When the WWDG is enabled the counter value should be configured to 
+          a value greater than 0x40 to prevent generating an immediate reset.     
+              
+      (#) Optionally you can enable the Early wakeup interrupt which is 
+          generated when the counter reach 0x40.
+          Once enabled this interrupt cannot be disabled except by a system reset.
+                  
+      (#) Then the application program must refresh the WWDG counter at regular
+          intervals during normal operation to prevent an MCU reset, using
+          WWDG_SetCounter() function. This operation must occur only when
+          the counter value is lower than the refresh window value, 
+          programmed using WWDG_SetWindowValue().         
+  
+    @endverbatim
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_wwdg.h"
+#include "stm32f4xx_rcc.h"
+
+/** @addtogroup STM32F4xx_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup WWDG 
+  * @brief WWDG driver modules
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* ----------- WWDG registers bit address in the alias region ----------- */
+#define WWDG_OFFSET       (WWDG_BASE - PERIPH_BASE)
+/* Alias word address of EWI bit */
+#define CFR_OFFSET        (WWDG_OFFSET + 0x04)
+#define EWI_BitNumber     0x09
+#define CFR_EWI_BB        (PERIPH_BB_BASE + (CFR_OFFSET * 32) + (EWI_BitNumber * 4))
+
+/* --------------------- WWDG registers bit mask ------------------------ */
+/* CFR register bit mask */
+#define CFR_WDGTB_MASK    ((uint32_t)0xFFFFFE7F)
+#define CFR_W_MASK        ((uint32_t)0xFFFFFF80)
+#define BIT_MASK          ((uint8_t)0x7F)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup WWDG_Private_Functions
+  * @{
+  */
+
+/** @defgroup WWDG_Group1 Prescaler, Refresh window and Counter configuration functions
+ *  @brief   Prescaler, Refresh window and Counter configuration functions 
+ *
+@verbatim   
+ ===============================================================================
+    ##### Prescaler, Refresh window and Counter configuration functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void WWDG_DeInit(void)
+{
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
+}
+
+/**
+  * @brief  Sets the WWDG Prescaler.
+  * @param  WWDG_Prescaler: specifies the WWDG Prescaler.
+  *   This parameter can be one of the following values:
+  *     @arg WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1
+  *     @arg WWDG_Prescaler_2: WWDG counter clock = (PCLK1/4096)/2
+  *     @arg WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4
+  *     @arg WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8
+  * @retval None
+  */
+void WWDG_SetPrescaler(uint32_t WWDG_Prescaler)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
+  /* Clear WDGTB[1:0] bits */
+  tmpreg = WWDG->CFR & CFR_WDGTB_MASK;
+  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
+  tmpreg |= WWDG_Prescaler;
+  /* Store the new value */
+  WWDG->CFR = tmpreg;
+}
+
+/**
+  * @brief  Sets the WWDG window value.
+  * @param  WindowValue: specifies the window value to be compared to the downcounter.
+  *   This parameter value must be lower than 0x80.
+  * @retval None
+  */
+void WWDG_SetWindowValue(uint8_t WindowValue)
+{
+  __IO uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
+  /* Clear W[6:0] bits */
+
+  tmpreg = WWDG->CFR & CFR_W_MASK;
+
+  /* Set W[6:0] bits according to WindowValue value */
+  tmpreg |= WindowValue & (uint32_t) BIT_MASK;
+
+  /* Store the new value */
+  WWDG->CFR = tmpreg;
+}
+
+/**
+  * @brief  Enables the WWDG Early Wakeup interrupt(EWI).
+  * @note   Once enabled this interrupt cannot be disabled except by a system reset.
+  * @param  None
+  * @retval None
+  */
+void WWDG_EnableIT(void)
+{
+  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;
+}
+
+/**
+  * @brief  Sets the WWDG counter value.
+  * @param  Counter: specifies the watchdog counter value.
+  *   This parameter must be a number between 0x40 and 0x7F (to prevent generating
+  *   an immediate reset) 
+  * @retval None
+  */
+void WWDG_SetCounter(uint8_t Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_WWDG_COUNTER(Counter));
+  /* Write to T[6:0] bits to configure the counter value, no need to do
+     a read-modify-write; writing a 0 to WDGA bit does nothing */
+  WWDG->CR = Counter & BIT_MASK;
+}
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Group2 WWDG activation functions
+ *  @brief   WWDG activation functions 
+ *
+@verbatim   
+ ===============================================================================
+                    ##### WWDG activation function #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Enables WWDG and load the counter value.                  
+  * @param  Counter: specifies the watchdog counter value.
+  *   This parameter must be a number between 0x40 and 0x7F (to prevent generating
+  *   an immediate reset)
+  * @retval None
+  */
+void WWDG_Enable(uint8_t Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_WWDG_COUNTER(Counter));
+  WWDG->CR = WWDG_CR_WDGA | Counter;
+}
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Group3 Interrupts and flags management functions
+ *  @brief   Interrupts and flags management functions 
+ *
+@verbatim   
+ ===============================================================================
+            ##### Interrupts and flags management functions #####
+ ===============================================================================  
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Checks whether the Early Wakeup interrupt flag is set or not.
+  * @param  None
+  * @retval The new state of the Early Wakeup interrupt flag (SET or RESET)
+  */
+FlagStatus WWDG_GetFlagStatus(void)
+{
+  FlagStatus bitstatus = RESET;
+    
+  if ((WWDG->SR) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears Early Wakeup interrupt flag.
+  * @param  None
+  * @retval None
+  */
+void WWDG_ClearFlag(void)
+{
+  WWDG->SR = (uint32_t)RESET;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/HARDWARE/ETHERNET/lan8720.c b/stm32f407zg/uniproton/board/HARDWARE/ETHERNET/lan8720.c
new file mode 100644
index 0000000..0f9d9ff
--- /dev/null
+++ b/stm32f407zg/uniproton/board/HARDWARE/ETHERNET/lan8720.c
@@ -0,0 +1,266 @@
+#include "lan8720.h"
+#include "stm32f4x7_eth.h"
+#include "usart.h"
+#include "prt_module.h"
+
+//////////////////////////////////////////////////////////////////////////////////	 
+//本程序只供学习使用，未经作者许可，不得用于其它任何用途
+//ALIENTEK STM32F407开发板
+//LAN8720 驱动代码	   
+//正点原子@ALIENTEK
+//技术论坛:www.openedv.com
+//创建日期:2014/8/15
+//版本：V1.0
+//版权所有，盗版必究。
+//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
+//All rights reserved									  
+////////////////////////////////////////////////////////////////////////////////// 
+
+ETH_DMADESCTypeDef *DMARxDscrTab;	//以太网DMA接收描述符数据结构体指针
+ETH_DMADESCTypeDef *DMATxDscrTab;	//以太网DMA发送描述符数据结构体指针 
+uint8_t *Rx_Buff; 					//以太网底层驱动接收buffers指针 
+uint8_t *Tx_Buff; 					//以太网底层驱动发送buffers指针
+  
+static void ETHERNET_NVICConfiguration(void);
+//LAN8720初始化
+//返回值:0,成功;
+//    其他,失败
+u8 LAN8720_Init(void)
+{
+	u8 rval=0;
+	GPIO_InitTypeDef GPIO_InitStructure;
+  
+	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA|RCC_AHB1Periph_GPIOC|RCC_AHB1Periph_GPIOG|RCC_AHB1Periph_GPIOD, ENABLE);//使能GPIO时钟 RMII接口
+	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);   //使能SYSCFG时钟
+  
+	SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_RMII); //MAC和PHY之间使用RMII接口
+
+	/*网络引脚设置 RMII接口
+	  ETH_MDIO -------------------------> PA2
+	  ETH_MDC --------------------------> PC1
+	  ETH_RMII_REF_CLK------------------> PA1
+	  ETH_RMII_CRS_DV ------------------> PA7
+	  ETH_RMII_RXD0 --------------------> PC4
+	  ETH_RMII_RXD1 --------------------> PC5
+	  ETH_RMII_TX_EN -------------------> PG11
+	  ETH_RMII_TXD0 --------------------> PG13
+	  ETH_RMII_TXD1 --------------------> PG14
+	  ETH_RESET-------------------------> PD3*/
+					
+	  //配置PA1 PA2 PA7
+	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_7;
+	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
+	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
+	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
+	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;  
+	GPIO_Init(GPIOA, &GPIO_InitStructure);
+	
+	GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_ETH); //引脚复用到网络接口上
+	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_ETH);
+	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_ETH);
+
+	//配置PC1,PC4 and PC5
+	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5;
+	GPIO_Init(GPIOC, &GPIO_InitStructure);
+	GPIO_PinAFConfig(GPIOC, GPIO_PinSource1, GPIO_AF_ETH); //引脚复用到网络接口上
+	GPIO_PinAFConfig(GPIOC, GPIO_PinSource4, GPIO_AF_ETH);
+	GPIO_PinAFConfig(GPIOC, GPIO_PinSource5, GPIO_AF_ETH);
+                                
+	//配置PG11, PG14 and PG13 
+	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14;
+	GPIO_Init(GPIOG, &GPIO_InitStructure);
+	GPIO_PinAFConfig(GPIOG, GPIO_PinSource11, GPIO_AF_ETH);
+	GPIO_PinAFConfig(GPIOG, GPIO_PinSource13, GPIO_AF_ETH);
+	GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_ETH);
+	
+	//配置PD3为推完输出
+	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
+	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
+	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
+	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	//推完输出
+	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;  
+	GPIO_Init(GPIOD, &GPIO_InitStructure);
+	
+	LAN8720_RST=0;					//硬件复位LAN8720
+	for (int i = 0; i < 2000; i++);
+	LAN8720_RST=1;				 	//复位结束 
+	ETHERNET_NVICConfiguration();	//设置中断优先级
+	rval=ETH_MACDMA_Config();		//配置MAC及DMA
+	return !rval;					//ETH的规则为:0,失败;1,成功;所以要取反一下 
+}
+
+//以太网中断分组配置
+void ETHERNET_NVICConfiguration(void)
+{
+	NVIC_InitTypeDef NVIC_InitStructure;
+	
+	NVIC_InitStructure.NVIC_IRQChannel = ETH_IRQn;  //以太网中断
+	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0X00;  //中断寄存器组2最高优先级
+	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0X00;
+	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
+	NVIC_Init(&NVIC_InitStructure);
+}
+
+//得到8720的速度模式
+//返回值:
+//001:10M半双工
+//101:10M全双工
+//010:100M半双工
+//110:100M全双工
+//其他:错误.
+u8 LAN8720_Get_Speed(void)
+{
+	u8 speed;
+	speed=((ETH_ReadPHYRegister(0x00,31)&0x1C)>>2); //从LAN8720的31号寄存器中读取网络速度和双工模式
+	return speed;
+}
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//以下部分为STM32F407网卡配置/接口函数.
+
+//初始化ETH MAC层及DMA配置
+//返回值:ETH_ERROR,发送失败(0)
+//		ETH_SUCCESS,发送成功(1)
+u8 ETH_MACDMA_Config(void)
+{
+	u8 rval;
+	ETH_InitTypeDef ETH_InitStructure; 
+	
+	//使能以太网MAC以及MAC接收和发送时钟
+	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx |RCC_AHB1Periph_ETH_MAC_Rx, ENABLE);
+                        
+	ETH_DeInit();  								//AHB总线重启以太网
+	ETH_SoftwareReset();  						//软件重启网络
+	while (ETH_GetSoftwareResetStatus() == SET);//等待软件重启网络完成 
+	ETH_StructInit(&ETH_InitStructure); 	 	//初始化网络为默认值  
+
+	///网络MAC参数设置 
+	ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;   			//开启网络自适应功能
+	ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;					//关闭反馈
+	ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable; 		//关闭重传功能
+	ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable; 	//关闭自动去除PDA/CRC功能 
+	ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Disable;						//关闭接收所有的帧
+	ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;//允许接收所有广播帧
+	ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;			//关闭混合模式的地址过滤  
+	ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;//对于组播地址使用完美地址过滤   
+	ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;	//对单播地址使用完美地址过滤 
+#ifdef CHECKSUM_BY_HARDWARE
+	ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable; 			//开启ipv4和TCP/UDP/ICMP的帧校验和卸载   
+#endif
+	//当我们使用帧校验和卸载功能的时候，一定要使能存储转发模式,存储转发模式中要保证整个帧存储在FIFO中,
+	//这样MAC能插入/识别出帧校验值,当真校验正确的时候DMA就可以处理帧,否则就丢弃掉该帧
+	ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; //开启丢弃TCP/IP错误帧
+	ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;     //开启接收数据的存储转发模式    
+	ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;   //开启发送数据的存储转发模式  
+
+	ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;     	//禁止转发错误帧  
+	ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;	//不转发过小的好帧 
+	ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;  		//打开处理第二帧功能
+	ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;  	//开启DMA传输的地址对齐功能
+	ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;            			//开启固定突发功能    
+	ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;     		//DMA发送的最大突发长度为32个节拍   
+	ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;			//DMA接收的最大突发长度为32个节拍
+	ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;
+	rval=ETH_Init(&ETH_InitStructure,LAN8720_PHY_ADDRESS);		//配置ETH
+	if(rval==ETH_SUCCESS)//配置成功
+	{
+		ETH_DMAITConfig(ETH_DMA_IT_NIS|ETH_DMA_IT_R,ENABLE);  	//使能以太网接收中断
+	}
+	return rval;
+}
+
+extern void lwip_pkt_handle(void);		//在lwip_comm.c里面定义
+//以太网DMA接收中断服务函数
+void ETH_IRQHandler(void)
+{
+	uint32_t len = 0;
+	while((len = ETH_GetRxPktSize(DMARxDescToGet)) != 0) 	//检测是否收到数据包
+	{ 
+		lwip_pkt_handle();
+	}
+	ETH_DMAClearITPendingBit(ETH_DMA_IT_R); 	//清除DMA中断标志位
+	ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS);	//清除DMA接收中断标志位
+}  
+//接收一个网卡数据包
+//返回值:网络数据包帧结构体
+FrameTypeDef ETH_Rx_Packet(void)
+{ 
+	u32 framelength=0;
+	FrameTypeDef frame={0,0};   
+	//检查当前描述符,是否属于ETHERNET DMA(设置的时候)/CPU(复位的时候)
+	if((DMARxDescToGet->Status&ETH_DMARxDesc_OWN)!=(u32)RESET)
+	{	
+		frame.length=ETH_ERROR; 
+		if ((ETH->DMASR&ETH_DMASR_RBUS)!=(u32)RESET)  
+		{ 
+			ETH->DMASR = ETH_DMASR_RBUS;//清除ETH DMA的RBUS位 
+			ETH->DMARPDR=0;//恢复DMA接收
+		}
+		return frame;//错误,OWN位被设置了
+	}
+	if(((DMARxDescToGet->Status&ETH_DMARxDesc_ES)==(u32)RESET)&& 
+	((DMARxDescToGet->Status & ETH_DMARxDesc_LS)!=(u32)RESET)&&  
+	((DMARxDescToGet->Status & ETH_DMARxDesc_FS)!=(u32)RESET))  
+	{       
+		framelength=((DMARxDescToGet->Status&ETH_DMARxDesc_FL)>>ETH_DMARxDesc_FrameLengthShift)-4;//得到接收包帧长度(不包含4字节CRC)
+ 		frame.buffer = DMARxDescToGet->Buffer1Addr;//得到包数据所在的位置
+	}else framelength=ETH_ERROR;//错误  
+	frame.length=framelength; 
+	frame.descriptor=DMARxDescToGet;  
+	//更新ETH DMA全局Rx描述符为下一个Rx描述符
+	//为下一次buffer读取设置下一个DMA Rx描述符
+	DMARxDescToGet=(ETH_DMADESCTypeDef*)(DMARxDescToGet->Buffer2NextDescAddr);   
+	return frame;  
+}
+//发送一个网卡数据包
+//FrameLength:数据包长度
+//返回值:ETH_ERROR,发送失败(0)
+//		ETH_SUCCESS,发送成功(1)
+u8 ETH_Tx_Packet(u16 FrameLength)
+{   
+	//检查当前描述符,是否属于ETHERNET DMA(设置的时候)/CPU(复位的时候)
+	if((DMATxDescToSet->Status&ETH_DMATxDesc_OWN)!=(u32)RESET)return ETH_ERROR;//错误,OWN位被设置了 
+ 	DMATxDescToSet->ControlBufferSize=(FrameLength&ETH_DMATxDesc_TBS1);//设置帧长度,bits[12:0]
+	DMATxDescToSet->Status|=ETH_DMATxDesc_LS|ETH_DMATxDesc_FS;//设置最后一个和第一个位段置位(1个描述符传输一帧)
+  	DMATxDescToSet->Status|=ETH_DMATxDesc_OWN;//设置Tx描述符的OWN位,buffer重归ETH DMA
+	if((ETH->DMASR&ETH_DMASR_TBUS)!=(u32)RESET)//当Tx Buffer不可用位(TBUS)被设置的时候,重置它.恢复传输
+	{ 
+		ETH->DMASR=ETH_DMASR_TBUS;//重置ETH DMA TBUS位 
+		ETH->DMATPDR=0;//恢复DMA发送
+	} 
+	//更新ETH DMA全局Tx描述符为下一个Tx描述符
+	//为下一次buffer发送设置下一个DMA Tx描述符 
+	DMATxDescToSet=(ETH_DMADESCTypeDef*)(DMATxDescToSet->Buffer2NextDescAddr);    
+	return ETH_SUCCESS;   
+}
+//得到当前描述符的Tx buffer地址
+//返回值:Tx buffer地址
+u32 ETH_GetCurrentTxBuffer(void)
+{  
+  return DMATxDescToSet->Buffer1Addr;//返回Tx buffer地址  
+}
+
+//为ETH底层驱动申请内存
+//返回值:0,正常
+//    其他,失败
+u8 ETH_Mem_Malloc(void)
+{ 
+	DMARxDscrTab = PRT_MemAlloc(OS_MID_MEM, 0, ETH_RXBUFNB*sizeof(ETH_DMADESCTypeDef));
+	DMATxDscrTab = PRT_MemAlloc(OS_MID_MEM, 0, ETH_TXBUFNB*sizeof(ETH_DMADESCTypeDef));
+	Rx_Buff = PRT_MemAlloc(OS_MID_MEM, 0, ETH_RX_BUF_SIZE*ETH_RXBUFNB);
+	Tx_Buff = PRT_MemAlloc(OS_MID_MEM, 0, ETH_TX_BUF_SIZE*ETH_TXBUFNB);
+	if(!DMARxDscrTab||!DMATxDscrTab||!Rx_Buff||!Tx_Buff)
+	{
+		ETH_Mem_Free();
+		return 1;	//申请失败
+	}	
+	return 0;		//申请成功
+}
+
+//释放ETH 底层驱动申请的内存
+void ETH_Mem_Free(void)
+{ 
+	PRT_MemFree(OS_MID_MEM, DMARxDscrTab);
+	PRT_MemFree(OS_MID_MEM, DMATxDscrTab);
+	PRT_MemFree(OS_MID_MEM, Rx_Buff);
+	PRT_MemFree(OS_MID_MEM, Tx_Buff);
+}
diff --git a/stm32f407zg/uniproton/board/HARDWARE/ETHERNET/lan8720.h b/stm32f407zg/uniproton/board/HARDWARE/ETHERNET/lan8720.h
new file mode 100644
index 0000000..28b44e3
--- /dev/null
+++ b/stm32f407zg/uniproton/board/HARDWARE/ETHERNET/lan8720.h
@@ -0,0 +1,39 @@
+#ifndef __LAN8720_H
+#define __LAN8720_H
+#include "sys.h"
+#include "stm32f4x7_eth.h"
+//////////////////////////////////////////////////////////////////////////////////	 
+//本程序只供学习使用，未经作者许可，不得用于其它任何用途
+//ALIENTEK STM32F407开发板
+//LAN8720 驱动代码	   
+//正点原子@ALIENTEK
+//技术论坛:www.openedv.com
+//创建日期:2014/8/15
+//版本：V1.0
+//版权所有，盗版必究。
+//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
+//All rights reserved									  
+////////////////////////////////////////////////////////////////////////////////// 
+
+#define LAN8720_PHY_ADDRESS  	0x00				//LAN8720 PHY芯片地址.
+#define LAN8720_RST 		   	PDout(3) 			//LAN8720复位引脚	 
+
+extern ETH_DMADESCTypeDef *DMARxDscrTab;			//以太网DMA接收描述符数据结构体指针
+extern ETH_DMADESCTypeDef *DMATxDscrTab;			//以太网DMA发送描述符数据结构体指针 
+extern uint8_t *Rx_Buff; 							//以太网底层驱动接收buffers指针 
+extern uint8_t *Tx_Buff; 							//以太网底层驱动发送buffers指针
+extern ETH_DMADESCTypeDef  *DMATxDescToSet;			//DMA发送描述符追踪指针
+extern ETH_DMADESCTypeDef  *DMARxDescToGet; 		//DMA接收描述符追踪指针 
+extern ETH_DMA_Rx_Frame_infos *DMA_RX_FRAME_infos;	//DMA最后接收到的帧信息指针
+ 
+u8 LAN8720_Init(void);
+u8 LAN8720_Get_Speed(void);
+u8 ETH_MACDMA_Config(void);
+FrameTypeDef ETH_Rx_Packet(void);
+u8 ETH_Tx_Packet(u16 FrameLength);
+u32 ETH_GetCurrentTxBuffer(void);
+u8 ETH_Mem_Malloc(void);
+void ETH_Mem_Free(void);
+void ETH_IRQHandler(void);
+#endif 
+
diff --git a/stm32f407zg/uniproton/board/LWIP/lwip_comm.c b/stm32f407zg/uniproton/board/LWIP/lwip_comm.c
new file mode 100644
index 0000000..686c0a5
--- /dev/null
+++ b/stm32f407zg/uniproton/board/LWIP/lwip_comm.c
@@ -0,0 +1,282 @@
+#include "lwip_comm.h" 
+#include "netif/etharp.h"
+#include "lwip/dhcp.h"
+#include "ethernetif.h" 
+#include "lwip/timeouts.h"
+#include "lwip/tcp.h"
+#include "lwip/ip4_frag.h"
+#include "lwip/tcpip.h" 
+#include "usart.h"  
+#include <stdio.h>
+#include "prt_module.h"
+#include "prt_task.h"
+#include "lwip/priv/tcp_priv.h"
+#include "lwipopts.h"
+#include "lwip/netifapi.h"
+#include "stm32f4xx.h"
+#include "os_cpu_armv7_m_external.h"
+#include "prt_hwi.h"
+#include "lan8720.h"
+#include "lwip/netif.h"
+#include "lwip/dhcp.h"
+
+#define NETIF_SETUP_OVERTIME       100
+
+__lwip_dev lwipdev;			// lwip控制结构体 
+struct netif lwip_netif;	// 定义一个全局的网络接口
+
+TskHandle lwipDhcpTaskId;	// DHCP任务的ID
+
+//如果使能了DHCP
+#if LWIP_DHCP
+
+// 删除DHCP任务
+void lwip_comm_dhcp_delete(void)
+{
+	U32 ret;
+	dhcp_stop(&lwip_netif); 				//关闭DHCP
+	ret = PRT_TaskDelete(lwipDhcpTaskId);	//删除DHCP任务
+	if (ret != OS_OK) {
+		printf("lwip_comm_dhcp_delete failed!!!\n\r");
+	}
+}
+
+// DHCP处理任务
+void lwip_dhcp_task(void *pdata)
+{
+	uintptr_t intSave = PRT_HwiLock();
+	
+	U32 ip=0,netmask=0,gw=0;
+	dhcp_start(&lwip_netif);//开启DHCP 
+	lwipdev.dhcpstatus=0;	//正在DHCP
+
+	while(1) {
+		ip		= lwip_netif.ip_addr.addr;	//读取新IP地址
+		netmask	= lwip_netif.netmask.addr;	//读取子网掩码
+		gw		= lwip_netif.gw.addr;		//读取默认网关
+
+		struct dhcp *dhcp = netif_dhcp_data(&lwip_netif);
+
+		if(ip != 0) {  					//当正确读取到IP地址的时候
+			lwipdev.dhcpstatus=2;	//DHCP成功
+ 			printf("DHCP MAC:............%d.%d.%d.%d.%d.%d\r\n",lwipdev.mac[0],lwipdev.mac[1],lwipdev.mac[2],lwipdev.mac[3],lwipdev.mac[4],lwipdev.mac[5]);
+			//解析出通过DHCP获取到的IP地址
+			lwipdev.ip[3]=(uint8_t)(ip>>24); 
+			lwipdev.ip[2]=(uint8_t)(ip>>16);
+			lwipdev.ip[1]=(uint8_t)(ip>>8);
+			lwipdev.ip[0]=(uint8_t)(ip);
+			printf("DHCP IP..............%d.%d.%d.%d\r\n",lwipdev.ip[0],lwipdev.ip[1],lwipdev.ip[2],lwipdev.ip[3]);
+			//解析通过DHCP获取到的子网掩码地址
+			lwipdev.netmask[3]=(uint8_t)(netmask>>24);
+			lwipdev.netmask[2]=(uint8_t)(netmask>>16);
+			lwipdev.netmask[1]=(uint8_t)(netmask>>8);
+			lwipdev.netmask[0]=(uint8_t)(netmask);
+			printf("DHCP AMSK............%d.%d.%d.%d\r\n",lwipdev.netmask[0],lwipdev.netmask[1],lwipdev.netmask[2],lwipdev.netmask[3]);
+			//解析出通过DHCP获取到的默认网关
+			lwipdev.gateway[3]=(uint8_t)(gw>>24);
+			lwipdev.gateway[2]=(uint8_t)(gw>>16);
+			lwipdev.gateway[1]=(uint8_t)(gw>>8);
+			lwipdev.gateway[0]=(uint8_t)(gw);
+			printf("DHCP GATE............%d.%d.%d.%d\r\n",lwipdev.gateway[0],lwipdev.gateway[1],lwipdev.gateway[2],lwipdev.gateway[3]);
+			break;
+		} else if (dhcp->tries > LWIP_MAX_DHCP_TRIES) { //通过DHCP服务获取IP地址失败,且超过最大尝试次数
+			lwipdev.dhcpstatus=0XFF;//DHCP失败.
+			//使用静态IP地址
+			IP4_ADDR(&(lwip_netif.ip_addr),lwipdev.ip[0],lwipdev.ip[1],lwipdev.ip[2],lwipdev.ip[3]);
+			IP4_ADDR(&(lwip_netif.netmask),lwipdev.netmask[0],lwipdev.netmask[1],lwipdev.netmask[2],lwipdev.netmask[3]);
+			IP4_ADDR(&(lwip_netif.gw),lwipdev.gateway[0],lwipdev.gateway[1],lwipdev.gateway[2],lwipdev.gateway[3]);
+			printf("DHCP TIMEOUT, USE STATIC IP ADDR!\r\n");
+			printf("MAC......%d.%d.%d.%d.%d.%d\r\n",lwipdev.mac[0],lwipdev.mac[1],lwipdev.mac[2],lwipdev.mac[3],lwipdev.mac[4],lwipdev.mac[5]);
+			printf("IP.......%d.%d.%d.%d\r\n",lwipdev.ip[0],lwipdev.ip[1],lwipdev.ip[2],lwipdev.ip[3]);
+			printf("MASK.....%d.%d.%d.%d\r\n",lwipdev.netmask[0],lwipdev.netmask[1],lwipdev.netmask[2],lwipdev.netmask[3]);
+			printf("GATE.....%d.%d.%d.%d\r\n",lwipdev.gateway[0],lwipdev.gateway[1],lwipdev.gateway[2],lwipdev.gateway[3]);
+			break;
+		}  
+	}
+	lwip_comm_dhcp_delete(); //删除DHCP任务 
+
+	PRT_HwiRestore(intSave);
+}
+
+//创建DHCP任务
+U32 lwip_comm_dhcp_creat(void)
+{
+    U32 ret;
+    struct TskInitParam taskParam;
+    
+    taskParam.taskEntry = (TskEntryFunc)lwip_dhcp_task;
+    taskParam.stackSize = 0x800;
+    taskParam.name = "lwipDhcpTask";
+    taskParam.taskPrio = OS_TSK_PRIORITY_06;
+    taskParam.stackAddr = 0;
+	
+    ret = PRT_TaskCreate(&lwipDhcpTaskId, &taskParam);
+	printf("	lwip_comm_dhcp_creat:\n\r");
+    printf("		lwipDhcpTask taskId = %d\n\r", lwipDhcpTaskId);
+	printf("		lwipDhcpTask name = %s\n\r", taskParam.name);
+	printf("		lwipDhcpTask taskPrio = %d\n\r", taskParam.taskPrio);
+	printf("		lwipDhcpTask taskEntry = %p\n\r", taskParam.taskEntry);
+    if (ret != OS_OK) {
+        return ret;
+    }
+
+    ret = PRT_TaskResume(lwipDhcpTaskId);
+    if (ret != OS_OK) {
+        return ret;
+    }
+
+    return OS_OK;	
+}
+#endif	/* #if LWIP_DHCP */
+
+//用于以太网中断调用
+void lwip_pkt_handle(void)
+{
+	ethernetif_input(&lwip_netif);
+}
+
+//lwip 默认IP设置
+//lwipx:lwip控制结构体指针
+void lwip_comm_default_ip_set(__lwip_dev *lwipx)
+{
+	u32 sn0;
+	sn0=*(u32*)(0x1FFF7A10);//获取STM32的唯一ID的前24位作为MAC地址后三字节
+	//默认远端IP为:192.168.1.100
+	lwipx->remoteip[0]=192;	
+	lwipx->remoteip[1]=168;
+	lwipx->remoteip[2]=1;
+	lwipx->remoteip[3]=11;
+	//MAC地址设置(高三字节固定为:2.0.0,低三字节用STM32唯一ID)
+	lwipx->mac[0]=2;//高三字节(IEEE称之为组织唯一ID,OUI)地址固定为:2.0.0
+	lwipx->mac[1]=0;
+	lwipx->mac[2]=0;
+	lwipx->mac[3]=(sn0>>16)&0XFF;//低三字节用STM32的唯一ID
+	lwipx->mac[4]=(sn0>>8)&0XFFF;;
+	lwipx->mac[5]=sn0&0XFF; 
+	//默认本地IP为:192.168.1.30
+	lwipx->ip[0]=192;	
+	lwipx->ip[1]=168;
+	lwipx->ip[2]=1;
+	lwipx->ip[3]=30;
+	//默认子网掩码:255.255.255.0
+	lwipx->netmask[0]=255;	
+	lwipx->netmask[1]=255;
+	lwipx->netmask[2]=255;
+	lwipx->netmask[3]=0;
+	//默认网关:192.168.1.1
+	lwipx->gateway[0]=192;	
+	lwipx->gateway[1]=168;
+	lwipx->gateway[2]=1;
+	lwipx->gateway[3]=1;	
+	lwipx->dhcpstatus=0;//没有DHCP	
+}
+
+//LWIP初始化(LWIP启动的时候使用)
+u8 lwip_comm_init(void)
+{
+	printf("	lwip_comm_init:\n\r");
+	u8 res;
+	uintptr_t intSave;
+	struct netif *Netif_Init_Flag;	//调用netif_add()函数时的返回值,用于判断网络初始化是否成功
+	static uint32_t overtime = 0;
+	ip4_addr_t ipaddr;  			//ip地址
+	ip4_addr_t netmask; 			//子网掩码
+	ip4_addr_t gw;      			//默认网关 
+	
+	res = ETH_Mem_Malloc();
+	if(res != 0) {
+		printf("		ETH_Mem_Malloc failed\n\r");
+		return 1;					//内存申请失败
+	}
+
+	res = LAN8720_Init();
+	if(res != 0) {
+		printf("		LAN8720_Init failed\n\r");
+		return 2;					//初始化LAN8720失败 
+	}
+
+	// 初始化tcp ip内核,该函数里面会创建tcpip_thread内核任务
+	tcpip_init(NULL,NULL);
+
+	// 设置默认IP等信息
+	lwip_comm_default_ip_set(&lwipdev);
+
+#if LWIP_DHCP		// 使用动态IP
+	ip4_addr_set_zero(&gw);
+	ip4_addr_set_zero(&ipaddr);
+	ip4_addr_set_zero(&netmask);
+#else				// 使用静态IPs
+	IP4_ADDR(&ipaddr,lwipdev.ip[0],lwipdev.ip[1],lwipdev.ip[2],lwipdev.ip[3]);
+	IP4_ADDR(&netmask,lwipdev.netmask[0],lwipdev.netmask[1] ,lwipdev.netmask[2],lwipdev.netmask[3]);
+	IP4_ADDR(&gw,lwipdev.gateway[0],lwipdev.gateway[1],lwipdev.gateway[2],lwipdev.gateway[3]);
+	printf("		lwip_comm_default_ip_set OK: \n\r");
+	printf("		MAC......%d.%d.%d.%d.%d.%d\r\n",lwipdev.mac[0],lwipdev.mac[1],lwipdev.mac[2],lwipdev.mac[3],lwipdev.mac[4],lwipdev.mac[5]);
+	printf("		IP.......%d.%d.%d.%d\r\n",lwipdev.ip[0],lwipdev.ip[1],lwipdev.ip[2],lwipdev.ip[3]);
+	printf("		MASK.....%d.%d.%d.%d\r\n",lwipdev.netmask[0],lwipdev.netmask[1],lwipdev.netmask[2],lwipdev.netmask[3]);
+	printf("		GATE.....%d.%d.%d.%d\r\n",lwipdev.gateway[0],lwipdev.gateway[1],lwipdev.gateway[2],lwipdev.gateway[3]);
+#endif	
+
+	// 向网卡列表中添加一个网口
+	Netif_Init_Flag = netif_add(&lwip_netif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
+	if (Netif_Init_Flag = NULL) {
+		printf("		netif_add failed!!!\n\r");
+	}
+    netif_set_default(&lwip_netif);		// 设置为默认网口
+    netif_set_up(&lwip_netif);			// 开启网口
+    do {
+		for (int i = 0; i < 2000; i++);
+        overtime++;
+        if (overtime > NETIF_SETUP_OVERTIME) {
+            printf("		netif_is_link_up overtime!\n\r");
+            break;
+        }
+    } while (netif_is_link_up(&lwip_netif) == 0);
+	if (overtime <= NETIF_SETUP_OVERTIME) {
+		printf("		netif init succeed!\n\r");
+	}
+
+	// 设置硬中断属性接口：
+	intSave = PRT_HwiSetAttr(ETH_IRQn, OS_HWI_PRI_HIGHEST, OS_HWI_MODE_ENGROSS);
+	if (intSave != OS_OK) {
+		printf("		PRT_HwiSetAttr failed!!!\n\r");
+	}
+	// 注册硬中断的处理函数：
+	intSave = PRT_HwiCreate(ETH_IRQn, ETH_IRQHandler, NULL);
+	if (intSave != OS_OK) {
+		printf("		PRT_HwiCreate failed!!!\n\r");
+	}
+	// 使能指定的硬中断：
+	PRT_HwiEnable(ETH_IRQn);
+
+/*
+	// 在系统netif列表中按照名称搜索刚才添加的网口
+	printf("		before netif_find\n\r");
+	struct netif *test_netif = NULL;
+	NETIF_FOREACH(test_netif) {
+		if (strcmp(test_netif->name, lwip_netif.name) == 0) {
+			printf("			netif_find_by_name: found %s\n\r", lwip_netif.name);
+			break;
+		}
+	}
+	
+	// 在列表中搜索到添加的网口,则将其打印出来
+	if (test_netif != NULL) {
+		printf("			Get Board IP:%d.%d.%d.%d\n\r",  \
+			((test_netif->ip_addr.addr)&0x000000ff),       \
+			(((test_netif->ip_addr.addr)&0x0000ff00)>>8),  \
+			(((test_netif->ip_addr.addr)&0x00ff0000)>>16), \
+			((test_netif->ip_addr.addr)&0xff000000)>>24);
+	}
+	printf("		after netif_find\n\r");
+*/
+
+#if LWIP_DHCP
+	U32 ret = lwip_comm_dhcp_creat();
+	if (ret != OS_OK) {
+		printf("lwip_comm_dhcp_creat error, ret = 0x%x!!!", ret);
+	}
+#endif
+
+	return 0;
+}
+
diff --git a/stm32f407zg/uniproton/board/LWIP/lwip_comm.h b/stm32f407zg/uniproton/board/LWIP/lwip_comm.h
new file mode 100644
index 0000000..286c260
--- /dev/null
+++ b/stm32f407zg/uniproton/board/LWIP/lwip_comm.h
@@ -0,0 +1,46 @@
+
+#ifndef _LWIP_COMM_H
+#define _LWIP_COMM_H 
+#include "lan8720.h" 
+//////////////////////////////////////////////////////////////////////////////////	 
+//本程序只供学习使用，未经作者许可，不得用于其它任何用途
+//ALIENTEK STM32F407开发板
+//lwip通用驱动 代码	   
+//正点原子@ALIENTEK
+//技术论坛:www.openedv.com
+//创建日期:2014/8/15
+//版本：V1.0
+//版权所有，盗版必究。
+//Copyright(C) 广州市星翼电子科技有限公司 2009-2019
+//All rights reserved									  
+//*******************************************************************************
+//修改信息
+//无
+////////////////////////////////////////////////////////////////////////////////// 	   
+
+#define LWIP_MAX_DHCP_TRIES		4   //DHCP服务器最大重试次数
+
+//lwip控制结构体
+typedef struct  
+{
+	u8 mac[6];      //MAC地址
+	u8 remoteip[4];	//远端主机IP地址 
+	u8 ip[4];       //本机IP地址
+	u8 netmask[4]; 	//子网掩码
+	u8 gateway[4]; 	//默认网关的IP地址
+	
+	vu8 dhcpstatus;	//dhcp状态 
+					//0,未获取DHCP地址;
+					//1,进入DHCP获取状态
+					//2,成功获取DHCP地址
+					//0XFF,获取失败.
+}__lwip_dev;
+extern __lwip_dev lwipdev;	//lwip控制结构体
+
+extern struct netif lwip_netif;	// 定义一个全局的网络接口
+
+void lwip_pkt_handle(void);
+void lwip_comm_default_ip_set(__lwip_dev *lwipx);
+u8 lwip_comm_init(void);
+
+#endif
diff --git a/stm32f407zg/uniproton/board/SYSTEM/sys/sys.c b/stm32f407zg/uniproton/board/SYSTEM/sys/sys.c
new file mode 100644
index 0000000..ed742f5
--- /dev/null
+++ b/stm32f407zg/uniproton/board/SYSTEM/sys/sys.c
@@ -0,0 +1,63 @@
+#include "sys.h"  
+//////////////////////////////////////////////////////////////////////////////////	 
+//本程序只供学习使用，未经作者许可，不得用于其它任何用途
+//ALIENTEK STM32F407开发板
+//系统时钟初始化	
+//包括时钟设置/中断管理/GPIO设置等
+//正点原子@ALIENTEK
+//技术论坛:www.openedv.com
+//创建日期:2014/5/2
+//版本：V1.0
+//版权所有，盗版必究。
+//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
+//All rights reserved
+//********************************************************************************
+//修改说明
+//无
+//////////////////////////////////////////////////////////////////////////////////  
+
+//THUMB指令不支持汇编内联
+//采用如下方法实现执行汇编指令WFI  
+void WFI_SET(void)
+{
+    __ASM volatile("WFI");
+}
+
+//关闭所有中断(但是不包括fault和NMI中断)
+void INTX_DISABLE(void)
+{
+    __ASM volatile("CPSID I");
+	__ASM volatile("BX LR");
+}
+
+//开启所有中断
+void INTX_ENABLE(void)
+{
+    __ASM volatile("CPSIE I");
+	__ASM volatile("BX LR");
+}
+
+
+//设置栈顶地址
+//addr:栈顶地址
+void MSR_MSP(void)
+{
+    __ASM volatile("MSR MSP, r0");
+	__ASM volatile("BX r14");
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/stm32f407zg/uniproton/board/SYSTEM/sys/sys.h b/stm32f407zg/uniproton/board/SYSTEM/sys/sys.h
new file mode 100644
index 0000000..567fcbd
--- /dev/null
+++ b/stm32f407zg/uniproton/board/SYSTEM/sys/sys.h
@@ -0,0 +1,98 @@
+#ifndef __SYS_H
+#define __SYS_H	 
+
+#include "stm32f4xx.h" 
+//////////////////////////////////////////////////////////////////////////////////	 
+//本程序只供学习使用，未经作者许可，不得用于其它任何用途
+//ALIENTEK STM32F407开发板
+//系统时钟初始化	
+//正点原子@ALIENTEK
+//技术论坛:www.openedv.com
+//创建日期:2014/5/2
+//版本：V1.0
+//版权所有，盗版必究。
+//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
+//All rights reserved
+//********************************************************************************
+//修改说明
+//无
+////////////////////////////////////////////////////////////////////////////////// 
+
+//0,不支持ucos
+//1,支持ucos
+#define SYSTEM_SUPPORT_OS		0		//定义系统文件夹是否支持UCOS
+	 
+//位带操作,实现51类似的GPIO控制功能
+//具体实现思想,参考<<CM3权威指南>>第五章(87页~92页).M4同M3类似,只是寄存器地址变了.
+//IO口操作宏定义
+#define BITBAND(addr, bitnum) ((addr & 0xF0000000)+0x2000000+((addr &0xFFFFF)<<5)+(bitnum<<2)) 
+#define MEM_ADDR(addr)  *((volatile unsigned long  *)(addr)) 
+#define BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum)) 
+//IO口地址映射
+#define GPIOA_ODR_Addr    (GPIOA_BASE+20) //0x40020014
+#define GPIOB_ODR_Addr    (GPIOB_BASE+20) //0x40020414 
+#define GPIOC_ODR_Addr    (GPIOC_BASE+20) //0x40020814 
+#define GPIOD_ODR_Addr    (GPIOD_BASE+20) //0x40020C14 
+#define GPIOE_ODR_Addr    (GPIOE_BASE+20) //0x40021014 
+#define GPIOF_ODR_Addr    (GPIOF_BASE+20) //0x40021414    
+#define GPIOG_ODR_Addr    (GPIOG_BASE+20) //0x40021814   
+#define GPIOH_ODR_Addr    (GPIOH_BASE+20) //0x40021C14    
+#define GPIOI_ODR_Addr    (GPIOI_BASE+20) //0x40022014     
+
+#define GPIOA_IDR_Addr    (GPIOA_BASE+16) //0x40020010 
+#define GPIOB_IDR_Addr    (GPIOB_BASE+16) //0x40020410 
+#define GPIOC_IDR_Addr    (GPIOC_BASE+16) //0x40020810 
+#define GPIOD_IDR_Addr    (GPIOD_BASE+16) //0x40020C10 
+#define GPIOE_IDR_Addr    (GPIOE_BASE+16) //0x40021010 
+#define GPIOF_IDR_Addr    (GPIOF_BASE+16) //0x40021410 
+#define GPIOG_IDR_Addr    (GPIOG_BASE+16) //0x40021810 
+#define GPIOH_IDR_Addr    (GPIOH_BASE+16) //0x40021C10 
+#define GPIOI_IDR_Addr    (GPIOI_BASE+16) //0x40022010 
+ 
+//IO口操作,只对单一的IO口!
+//确保n的值小于16!
+#define PAout(n)   BIT_ADDR(GPIOA_ODR_Addr,n)  //输出 
+#define PAin(n)    BIT_ADDR(GPIOA_IDR_Addr,n)  //输入 
+
+#define PBout(n)   BIT_ADDR(GPIOB_ODR_Addr,n)  //输出 
+#define PBin(n)    BIT_ADDR(GPIOB_IDR_Addr,n)  //输入 
+
+#define PCout(n)   BIT_ADDR(GPIOC_ODR_Addr,n)  //输出 
+#define PCin(n)    BIT_ADDR(GPIOC_IDR_Addr,n)  //输入 
+
+#define PDout(n)   BIT_ADDR(GPIOD_ODR_Addr,n)  //输出 
+#define PDin(n)    BIT_ADDR(GPIOD_IDR_Addr,n)  //输入 
+
+#define PEout(n)   BIT_ADDR(GPIOE_ODR_Addr,n)  //输出 
+#define PEin(n)    BIT_ADDR(GPIOE_IDR_Addr,n)  //输入
+
+#define PFout(n)   BIT_ADDR(GPIOF_ODR_Addr,n)  //输出 
+#define PFin(n)    BIT_ADDR(GPIOF_IDR_Addr,n)  //输入
+
+#define PGout(n)   BIT_ADDR(GPIOG_ODR_Addr,n)  //输出 
+#define PGin(n)    BIT_ADDR(GPIOG_IDR_Addr,n)  //输入
+
+#define PHout(n)   BIT_ADDR(GPIOH_ODR_Addr,n)  //输出 
+#define PHin(n)    BIT_ADDR(GPIOH_IDR_Addr,n)  //输入
+
+#define PIout(n)   BIT_ADDR(GPIOI_ODR_Addr,n)  //输出 
+#define PIin(n)    BIT_ADDR(GPIOI_IDR_Addr,n)  //输入
+
+//以下为汇编函数
+void WFI_SET(void);		//执行WFI指令
+void INTX_DISABLE(void);//关闭所有中断
+void INTX_ENABLE(void);	//开启所有中断
+void MSR_MSP(void);	//设置堆栈地址 
+
+#endif
+
+
+
+
+
+
+
+
+
+
+
diff --git a/stm32f407zg/uniproton/board/SYSTEM/usart/usart.c b/stm32f407zg/uniproton/board/SYSTEM/usart/usart.c
new file mode 100644
index 0000000..9264203
--- /dev/null
+++ b/stm32f407zg/uniproton/board/SYSTEM/usart/usart.c
@@ -0,0 +1,161 @@
+
+#include "usart.h"	
+
+////////////////////////////////////////////////////////////////////////////////// 	 
+//如果使用ucos,则包括下面的头文件即可.
+#if SYSTEM_SUPPORT_OS
+#include "includes.h"					//ucos 使用	  
+#endif
+//////////////////////////////////////////////////////////////////////////////////	 
+//本程序只供学习使用，未经作者许可，不得用于其它任何用途
+//ALIENTEK STM32F4探索者开发板
+//串口1初始化		   
+//正点原子@ALIENTEK
+//技术论坛:www.openedv.com
+//修改日期:2014/6/10
+//版本：V1.5
+//版权所有，盗版必究。
+//Copyright(C) 广州市星翼电子科技有限公司 2009-2019
+//All rights reserved
+//********************************************************************************
+//V1.3修改说明 
+//支持适应不同频率下的串口波特率设置.
+//加入了对printf的支持
+//增加了串口接收命令功能.
+//修正了printf第一个字符丢失的bug
+//V1.4修改说明
+//1,修改串口初始化IO的bug
+//2,修改了USART_RX_STA,使得串口最大接收字节数为2的14次方
+//3,增加了USART_REC_LEN,用于定义串口最大允许接收的字节数(不大于2的14次方)
+//4,修改了EN_USART1_RX的使能方式
+//V1.5修改说明
+//1,增加了对UCOSII的支持
+////////////////////////////////////////////////////////////////////////////////// 	  
+ 
+
+//////////////////////////////////////////////////////////////////
+//加入以下代码,支持printf函数,而不需要选择use MicroLIB	  
+#if 1
+#pragma import(__use_no_semihosting)             
+//标准库需要的支持函数                 
+struct __FILE 
+{ 
+	int handle; 
+}; 
+
+FILE __stdout;       
+//定义_sys_exit()以避免使用半主机模式    
+void _sys_exit(int x) 
+{ 
+	x = x; 
+} 
+//重定义fputc函数 
+int fputc(int ch, FILE *f)
+{ 	
+	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
+	USART1->DR = (u8) ch;      
+	return ch;
+}
+#endif
+ 
+#if EN_USART1_RX   //如果使能了接收
+//串口1中断服务程序
+//注意,读取USARTx->SR能避免莫名其妙的错误   	
+u8 USART_RX_BUF[USART_REC_LEN];     //接收缓冲,最大USART_REC_LEN个字节.
+//接收状态
+//bit15，	接收完成标志
+//bit14，	接收到0x0d
+//bit13~0，	接收到的有效字节数目
+u16 USART_RX_STA=0;       //接收状态标记	
+
+//初始化IO 串口1 
+//bound:波特率
+void uart_init(u32 bound) {
+   	//GPIO端口设置
+  	GPIO_InitTypeDef GPIO_InitStructure;
+	USART_InitTypeDef USART_InitStructure;
+	NVIC_InitTypeDef NVIC_InitStructure;
+	
+	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE); //使能GPIOA时钟
+	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);//使能USART1时钟
+ 
+	//串口1对应引脚复用映射
+	GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1); //GPIOA9复用为USART1
+	GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1); //GPIOA10复用为USART1
+	
+	//USART1端口配置
+  	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10; //GPIOA9与GPIOA10
+	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
+	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	//速度50MHz
+	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; //推挽复用输出
+	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //上拉
+	GPIO_Init(GPIOA,&GPIO_InitStructure); //初始化PA9，PA10
+
+   //USART1 初始化设置
+	USART_InitStructure.USART_BaudRate = bound;//波特率设置
+	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
+	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
+	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
+	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
+	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
+  	USART_Init(USART1, &USART_InitStructure); //初始化串口1
+	
+  	USART_Cmd(USART1, ENABLE);  //使能串口1 
+	
+	//USART_ClearFlag(USART1, USART_FLAG_TC);
+	
+#if EN_USART1_RX	
+// #if 0
+	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启相关中断
+
+	//Usart1 NVIC 配置
+  	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口1中断通道
+	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3;//抢占优先级3
+	NVIC_InitStructure.NVIC_IRQChannelSubPriority =3;		//子优先级3
+	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
+	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器、
+
+#endif
+
+}
+
+
+void USART1_IRQHandler(void)                	//串口1中断服务程序
+{
+	u8 Res;
+#if SYSTEM_SUPPORT_OS 		//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
+	OSIntEnter();    
+#endif
+	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
+	{
+		Res =USART_ReceiveData(USART1);//(USART1->DR);	//读取接收到的数据
+		
+		if((USART_RX_STA&0x8000)==0)//接收未完成
+		{
+			if(USART_RX_STA&0x4000)//接收到了0x0d
+			{
+				if(Res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
+				else USART_RX_STA|=0x8000;	//接收完成了 
+			}
+			else //还没收到0X0D
+			{	
+				if(Res==0x0d)USART_RX_STA|=0x4000;
+				else
+				{
+					USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;
+					USART_RX_STA++;
+					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
+				}		 
+			}
+		}   		 
+  } 
+#if SYSTEM_SUPPORT_OS 	//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
+	OSIntExit();  											 
+#endif
+} 
+#endif	
+
+ 
+
+
+
diff --git a/stm32f407zg/uniproton/board/SYSTEM/usart/usart.h b/stm32f407zg/uniproton/board/SYSTEM/usart/usart.h
new file mode 100644
index 0000000..da14508
--- /dev/null
+++ b/stm32f407zg/uniproton/board/SYSTEM/usart/usart.h
@@ -0,0 +1,38 @@
+#ifndef __USART_H
+#define __USART_H
+#include "stdio.h"	
+#include "stm32f4xx_conf.h"
+#include "sys.h" 
+//////////////////////////////////////////////////////////////////////////////////	 
+//本程序只供学习使用，未经作者许可，不得用于其它任何用途
+//Mini STM32开发板
+//串口1初始化		   
+//正点原子@ALIENTEK
+//技术论坛:www.openedv.csom
+//修改日期:2011/6/14
+//版本：V1.4
+//版权所有，盗版必究。
+//Copyright(C) 正点原子 2009-2019
+//All rights reserved
+//********************************************************************************
+//V1.3修改说明 
+//支持适应不同频率下的串口波特率设置.
+//加入了对printf的支持
+//增加了串口接收命令功能.
+//修正了printf第一个字符丢失的bug
+//V1.4修改说明
+//1,修改串口初始化IO的bug
+//2,修改了USART_RX_STA,使得串口最大接收字节数为2的14次方
+//3,增加了USART_REC_LEN,用于定义串口最大允许接收的字节数(不大于2的14次方)
+//4,修改了EN_USART1_RX的使能方式
+////////////////////////////////////////////////////////////////////////////////// 	
+#define USART_REC_LEN  			200  	//定义最大接收字节数 200
+#define EN_USART1_RX 			1		//使能（1）/禁止（0）串口1接收
+	  	
+extern u8  USART_RX_BUF[USART_REC_LEN]; //接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 
+extern u16 USART_RX_STA;         		//接收状态标记	
+//如果想串口中断接收，请不要注释以下宏定义
+void uart_init(u32 bound);
+#endif
+
+
diff --git a/stm32f407zg/uniproton/board/USER/board.c b/stm32f407zg/uniproton/board/USER/board.c
new file mode 100644
index 0000000..94abae3
--- /dev/null
+++ b/stm32f407zg/uniproton/board/USER/board.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "prt_task.h"
+#include "prt_config.h"
+#include "prt_lib_external.h"
+#include "lwip/netif.h"
+#include "lwip_comm.h"
+#include "securec.h"
+
+extern u8 lwip_comm_init(void);
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cpluscplus */
+#endif /* __cpluscplus */
+
+extern struct netif lwip_netif;
+
+unsigned int __stack_chk_guard = 12124232;
+void __stack_chk_fail(void)
+{
+    printf("__stack_chk_fail failed");
+}
+
+U32 PRT_HardDrvInit(void)
+{
+    uart_init(115200);
+    return OS_OK;
+}
+
+extern unsigned long g_data_start;
+extern unsigned long g_data_end;
+extern unsigned long data_load_start;
+void PRT_HardBootInit(void)
+{
+    int size = (unsigned long)&g_data_end - (unsigned long)&g_data_start;
+    (void)memcpy_s((void *)&g_data_start, size, (void *)&data_load_start, size);
+}
+
+static void udpTestTask(void)
+{
+#define BUF_SIZE 48
+	char *port = "8086";
+	int serv_sock;
+	char message[BUF_SIZE];
+	int str_len;
+	socklen_t clnt_adr_sz;
+	
+	struct sockaddr_in serv_adr, clnt_adr;
+	
+	serv_sock = socket(PF_INET, SOCK_DGRAM, 0);
+	if(serv_sock == -1) {
+        printf("lwip udp socket error\n\r");
+    }
+
+	memset(&serv_adr, 0, sizeof(serv_adr));
+	serv_adr.sin_family = AF_INET;
+	serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
+	serv_adr.sin_port = htons(atoi(port));
+	
+	if(bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr)) == -1) {
+        printf("lwip udp bind error\n\r");
+    }
+
+	while (TRUE) {
+		clnt_adr_sz = sizeof(clnt_adr);
+		str_len = recvfrom(serv_sock, message, BUF_SIZE, 0,   \
+								(struct sockaddr*)&clnt_adr, &clnt_adr_sz);
+		sendto(serv_sock, message, str_len, 0,  \
+								(struct sockaddr*)&clnt_adr, clnt_adr_sz);
+	}
+
+	close(serv_sock);
+}
+
+static void tcpTestTask(void)
+{
+#define BUF_SIZE 1024
+    char *port = "8086";
+	int serv_sock, clnt_sock;
+	char message[BUF_SIZE];
+	int str_len, i;
+	
+	struct sockaddr_in serv_adr;
+	struct sockaddr_in clnt_adr;
+	socklen_t clnt_adr_sz;
+	
+	serv_sock = socket(PF_INET, SOCK_STREAM, 0);   
+	if(serv_sock == -1) {
+        printf("lwip tcp socket error\n\r");
+    }
+
+	memset(&serv_adr, 0, sizeof(serv_adr));
+	serv_adr.sin_family = AF_INET;
+	serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
+	serv_adr.sin_port = htons(atoi(port));
+
+	if(bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr)) == -1) {
+        printf("lwip udp bind error\n\r");
+    }
+
+	if(listen(serv_sock, 5) == -1)
+		printf("lwip udp listen error\n\r");
+	
+	clnt_adr_sz = sizeof(clnt_adr);
+
+	for(i = 0; i < 5; i++) {
+		clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_sz);
+		if(clnt_sock == -1) {
+            printf("lwip udp accept error\n\r");
+        } else {
+			printf("Connected client %d\n\r", i + 1);
+        }
+
+		while((str_len=lwip_read(clnt_sock, message, BUF_SIZE))!=0) {
+            printf("lwip udp lwip_read ok\n\r");
+            lwip_write(clnt_sock, message, str_len);
+        }
+
+		lwip_close(clnt_sock);
+	}
+
+	lwip_close(serv_sock);
+}
+
+static void OsTskUser(void)
+{
+	int ret;
+    printf("OsTskUser:\n\r");
+    /*
+     * 主机和开发板使用网线直连(使用静态IP)；
+     * 主机打开串口工具和网络调试助手；
+     * 下载程序运行，主机的网络调试助手中采用UDP协议；
+     * 设置主机IP，设置端口号为8086(和程序中相同)；
+     * 设置开发板IP为192.168.1.30，端口号为8086；
+     * 即可使用UDP协议进行数据传输。
+     */
+    // udpTestTask();
+
+    /*
+     * tcp操作同udp，主机选择tcp client
+     */
+    tcpTestTask();
+    
+    /*
+     * 不测试tcp、udp时，系统循环输出日志
+     */
+    // while (TRUE) {
+    //     printf("	OsTskUser loop\n\r"); 
+    //     printf("		Get Board IP:%d.%d.%d.%d\n\r",  \
+    //             ((lwip_netif.ip_addr.addr)&0x000000ff),       \
+    //             (((lwip_netif.ip_addr.addr)&0x0000ff00)>>8),  \
+    //             (((lwip_netif.ip_addr.addr)&0x00ff0000)>>16), \
+    //             ((lwip_netif.ip_addr.addr)&0xff000000)>>24);
+    //     PRT_TaskDelay(500);
+	// }
+}
+
+U32 PRT_AppInit(void)
+{   
+    U32 ret;
+    TskHandle taskId;
+    struct TskInitParam taskParam;
+    
+    taskParam.taskEntry = (TskEntryFunc)OsTskUser;
+    taskParam.stackSize = 0x800;
+    taskParam.name = "uniUserTask";
+    taskParam.taskPrio = OS_TSK_PRIORITY_03;
+    taskParam.stackAddr = 0;
+
+    ret = PRT_TaskCreate(&taskId, &taskParam);
+	printf("    PRT_AppInit:\n\r");
+    printf("        uniUserTask taskId = %d\n\r", taskId);
+	printf("        uniUserTask name = %s\n\r", taskParam.name);
+	printf("        uniUserTask taskPrio = %d\n\r", taskParam.taskPrio);
+	printf("        uniUserTask taskEntry = %p\n\r", taskParam.taskEntry);
+	
+    if (ret != OS_OK) {
+        return ret;
+    }
+
+    ret = PRT_TaskResume(taskId);
+    if (ret != OS_OK) {
+        return ret;
+    }
+
+    // 初始化lwip
+    lwip_comm_init();
+
+    return OS_OK;
+}
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cpluscplus */
+#endif /* __cpluscplus */
diff --git a/stm32f407zg/uniproton/board/USER/dprintf.c b/stm32f407zg/uniproton/board/USER/dprintf.c
new file mode 100644
index 0000000..96289a1
--- /dev/null
+++ b/stm32f407zg/uniproton/board/USER/dprintf.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include "securec.h"
+#include "prt_hwi.h"
+
+static void dputs(char const *s, int (*pFputc)(int n, FILE *cookie), void *cookie)
+{
+    unsigned int intSave;
+
+    intSave = PRT_HwiLock();
+    while (*s) {
+        pFputc(*s++, cookie);
+    }
+    PRT_HwiRestore(intSave);
+}
+
+int printf(char const  *fmt, ...)
+{
+#define BUFSIZE  256
+    char buf[BUFSIZE] = { 0 };
+    va_list ap;
+    va_start(ap, fmt);
+    int len = vsnprintf_s(buf, sizeof(buf), BUFSIZE - 1, fmt, ap);
+    va_end(ap);
+    if (len > 0) {
+        dputs(buf, fputc, 0);
+    } else {
+        dputs("printf error!\n", fputc, 0);
+    }
+    return len;
+}
diff --git a/stm32f407zg/uniproton/board/USER/stm32f4xx.h b/stm32f407zg/uniproton/board/USER/stm32f4xx.h
new file mode 100644
index 0000000..a4a9973
--- /dev/null
+++ b/stm32f407zg/uniproton/board/USER/stm32f4xx.h
@@ -0,0 +1,9177 @@
+/**
+  ******************************************************************************
+  * @file    stm32f4xx.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer Header File. 
+  *          This file contains all the peripheral register's definitions, bits 
+  *          definitions and memory mapping for STM32F4xx devices.            
+  *            
+  *          The file is the unique include file that the application programmer
+  *          is using in the C source code, usually in main.c. This file contains:
+  *           - Configuration section that allows to select:
+  *              - The device used in the target application
+  *              - To use or not the peripheral�s drivers in application code(i.e. 
+  *                code will be based on direct access to peripheral�s registers 
+  *                rather than drivers API), this option is controlled by 
+  *                "#define USE_STDPERIPH_DRIVER"
+  *              - To change few application-specific parameters such as the HSE 
+  *                crystal frequency
+  *           - Data structures and the address mapping for all peripherals
+  *           - Peripheral's registers declarations and bits definition
+  *           - Macros to access peripheral�s registers hardware
+  *  
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/** @addtogroup CMSIS
+  * @{
+  */
+
+/** @addtogroup stm32f4xx
+  * @{
+  */
+    
+#ifndef __STM32F4xx_H
+#define __STM32F4xx_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif /* __cplusplus */
+  
+/** @addtogroup Library_configuration_section
+  * @{
+  */
+  
+/* Uncomment the line below according to the target STM32 device used in your
+   application 
+  */
+
+#if !defined (STM32F40_41xxx) && !defined (STM32F427_437xx) && !defined (STM32F429_439xx) && !defined (STM32F401xx) && !defined (STM32F411xE)
+  /* #define STM32F40_41xxx */   /*!< STM32F405RG, STM32F405VG, STM32F405ZG, STM32F415RG, STM32F415VG, STM32F415ZG,  
+                                      STM32F407VG, STM32F407VE, STM32F407ZG, STM32F407ZE, STM32F407IG, STM32F407IE, 
+                                      STM32F417VG, STM32F417VE, STM32F417ZG, STM32F417ZE, STM32F417IG and STM32F417IE Devices */
+
+  /* #define STM32F427_437xx */  /*!< STM32F427VG, STM32F427VI, STM32F427ZG, STM32F427ZI, STM32F427IG, STM32F427II,  
+                                      STM32F437VG, STM32F437VI, STM32F437ZG, STM32F437ZI, STM32F437IG, STM32F437II Devices */
+
+  /* #define STM32F429_439xx */  /*!< STM32F429VG, STM32F429VI, STM32F429ZG, STM32F429ZI, STM32F429BG, STM32F429BI,  
+                                      STM32F429NG, STM32F439NI, STM32F429IG, STM32F429II, STM32F439VG, STM32F439VI, 
+                                      STM32F439ZG, STM32F439ZI, STM32F439BG, STM32F439BI, STM32F439NG, STM32F439NI,
+                                      STM32F439IG and STM32F439II Devices */
+
+  /* #define STM32F401xx */      /*!< STM32F401CB, STM32F401CC,  STM32F401RB, STM32F401RC, STM32F401VB, STM32F401VC  
+                                      STM32F401CD, STM32F401RD, STM32F401VD, STM32F401CExx, STM32F401RE and STM32F401VE Devices */
+
+  /* #define STM32F411xE */      /*!< STM32F411CD, STM32F411RD, STM32F411VD, STM32F411CE, STM32F411RE and STM32F411VE Devices */
+#endif
+
+/* Old STM32F40XX definition, maintained for legacy purpose */
+#define STM32F40XX
+#ifdef STM32F40XX
+  #define STM32F40_41xxx
+#endif /* STM32F40XX */
+
+/* Old STM32F427X definition, maintained for legacy purpose */
+#define STM32F427X
+#ifdef STM32F427X
+  #define STM32F427_437xx
+#endif /* STM32F427X */
+
+/*  Tip: To avoid modifying this file each time you need to switch between these
+        devices, you can define the device in your toolchain compiler preprocessor.
+  */
+
+#if !defined (STM32F40_41xxx) && !defined (STM32F427_437xx) && !defined (STM32F429_439xx) && !defined (STM32F401xx) && !defined (STM32F411xE)
+ #error "Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)"
+#endif
+
+#if !defined  (USE_STDPERIPH_DRIVER)
+/**
+ * @brief Comment the line below if you will not use the peripherals drivers.
+   In this case, these drivers will not be included and the application code will 
+   be based on direct access to peripherals registers 
+   */
+  /*#define USE_STDPERIPH_DRIVER */
+#endif /* USE_STDPERIPH_DRIVER */
+
+/**
+ * @brief In the following line adjust the value of External High Speed oscillator (HSE)
+   used in your application 
+   
+   Tip: To avoid modifying this file each time you need to use different HSE, you
+        can define the HSE value in your toolchain compiler preprocessor.
+  */           
+
+#if !defined  (HSE_VALUE) 
+  #define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
+  
+#endif /* HSE_VALUE */
+
+/**
+ * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
+   Timeout value 
+   */
+#if !defined  (HSE_STARTUP_TIMEOUT) 
+  #define HSE_STARTUP_TIMEOUT    ((uint16_t)0x05000)   /*!< Time out for HSE start up */
+#endif /* HSE_STARTUP_TIMEOUT */   
+
+#if !defined  (HSI_VALUE)   
+  #define HSI_VALUE    ((uint32_t)16000000) /*!< Value of the Internal oscillator in Hz*/
+#endif /* HSI_VALUE */   
+
+/**
+ * @brief STM32F4XX Standard Peripherals Library version number V1.4.0
+   */
+#define __STM32F4XX_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version */
+#define __STM32F4XX_STDPERIPH_VERSION_SUB1   (0x04) /*!< [23:16] sub1 version */
+#define __STM32F4XX_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
+#define __STM32F4XX_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
+#define __STM32F4XX_STDPERIPH_VERSION        ((__STM32F4XX_STDPERIPH_VERSION_MAIN << 24)\
+                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB1 << 16)\
+                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB2 << 8)\
+                                             |(__STM32F4XX_STDPERIPH_VERSION_RC))
+                                             
+/**
+  * @}
+  */
+
+/** @addtogroup Configuration_section_for_CMSIS
+  * @{
+  */
+
+/**
+ * @brief Configuration of the Cortex-M4 Processor and Core Peripherals 
+ */
+#define __CM4_REV                 0x0001  /*!< Core revision r0p1                            */
+#define __MPU_PRESENT             1       /*!< STM32F4XX provides an MPU                     */
+#define __NVIC_PRIO_BITS          4       /*!< STM32F4XX uses 4 Bits for the Priority Levels */
+#define __Vendor_SysTickConfig    0       /*!< Set to 1 if different SysTick Config is used  */
+#define __FPU_PRESENT             1       /*!< FPU present                                   */
+
+/**
+ * @brief STM32F4XX Interrupt Number Definition, according to the selected device 
+ *        in @ref Library_configuration_section 
+ */
+typedef enum IRQn
+{
+/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/
+  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
+  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                           */
+  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                   */
+  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                 */
+  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                    */
+  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                              */
+  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                    */
+  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                */
+/******  STM32 specific Interrupt Numbers **********************************************************************/
+  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
+  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt                         */
+  TAMP_STAMP_IRQn             = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI line             */
+  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line                        */
+  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                            */
+  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                              */
+  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                              */
+  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                              */
+  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                              */
+  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                              */
+  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                              */
+  DMA1_Stream0_IRQn           = 11,     /*!< DMA1 Stream 0 global Interrupt                                    */
+  DMA1_Stream1_IRQn           = 12,     /*!< DMA1 Stream 1 global Interrupt                                    */
+  DMA1_Stream2_IRQn           = 13,     /*!< DMA1 Stream 2 global Interrupt                                    */
+  DMA1_Stream3_IRQn           = 14,     /*!< DMA1 Stream 3 global Interrupt                                    */
+  DMA1_Stream4_IRQn           = 15,     /*!< DMA1 Stream 4 global Interrupt                                    */
+  DMA1_Stream5_IRQn           = 16,     /*!< DMA1 Stream 5 global Interrupt                                    */
+  DMA1_Stream6_IRQn           = 17,     /*!< DMA1 Stream 6 global Interrupt                                    */
+  ADC_IRQn                    = 18,     /*!< ADC1, ADC2 and ADC3 global Interrupts                             */
+
+#if defined (STM32F40_41xxx)
+  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
+  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
+  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
+  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
+  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
+  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
+  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
+  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
+  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
+  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
+  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
+  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
+  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
+  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
+  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
+  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
+  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
+  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
+  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
+  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                             */
+  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
+  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
+  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
+  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
+  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
+  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
+  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
+  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
+  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
+  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
+  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
+  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
+  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
+  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
+  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
+  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
+  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
+  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
+  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
+  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
+  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
+  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
+  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
+  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
+  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
+  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
+  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
+  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
+  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
+  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
+  CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
+  HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
+  FPU_IRQn                    = 81      /*!< FPU global interrupt                                              */
+#endif /* STM32F40_41xxx */
+
+// #if defined (STM32F427_437xx)
+//   CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
+//   CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
+//   CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
+//   CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
+//   EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
+//   TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
+//   TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
+//   TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
+//   TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
+//   TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
+//   TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
+//   TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
+//   I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
+//   I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
+//   I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
+//   I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
+//   SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
+//   SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
+//   USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
+//   USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
+//   USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
+//   EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
+//   RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
+//   OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */    
+//   TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
+//   TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
+//   TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
+//   TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
+//   DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
+//   FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
+//   SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
+//   TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
+//   SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
+//   UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
+//   UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
+//   TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
+//   TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
+//   DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
+//   DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
+//   DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
+//   DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
+//   DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
+//   ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
+//   ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
+//   CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
+//   CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
+//   CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
+//   CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
+//   OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
+//   DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
+//   DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
+//   DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
+//   USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
+//   I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
+//   I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
+//   OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
+//   OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
+//   OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
+//   OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
+//   DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
+//   CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
+//   HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
+//   FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
+//   UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */
+//   UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */
+//   SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
+//   SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
+//   SPI6_IRQn                   = 86,     /*!< SPI6 global Interrupt                                             */
+//   SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
+//   DMA2D_IRQn                  = 90      /*!< DMA2D global Interrupt                                            */   
+// #endif /* STM32F427_437xx */
+    
+// #if defined (STM32F429_439xx)
+//   CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
+//   CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
+//   CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
+//   CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
+//   EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
+//   TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
+//   TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
+//   TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
+//   TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
+//   TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
+//   TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
+//   TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
+//   I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
+//   I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
+//   I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
+//   I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
+//   SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
+//   SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
+//   USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
+//   USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
+//   USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
+//   EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
+//   RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
+//   OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */    
+//   TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
+//   TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
+//   TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
+//   TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
+//   DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
+//   FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
+//   SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
+//   TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
+//   SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
+//   UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
+//   UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
+//   TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
+//   TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
+//   DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
+//   DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
+//   DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
+//   DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
+//   DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
+//   ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
+//   ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
+//   CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
+//   CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
+//   CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
+//   CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
+//   OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
+//   DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
+//   DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
+//   DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
+//   USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
+//   I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
+//   I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
+//   OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
+//   OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
+//   OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
+//   OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
+//   DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
+//   CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
+//   HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
+//   FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
+//   UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */
+//   UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */
+//   SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
+//   SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
+//   SPI6_IRQn                   = 86,     /*!< SPI6 global Interrupt                                             */
+//   SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
+//   LTDC_IRQn                   = 88,     /*!< LTDC global Interrupt                                             */
+//   LTDC_ER_IRQn                = 89,     /*!< LTDC Error global Interrupt                                       */
+//   DMA2D_IRQn                  = 90      /*!< DMA2D global Interrupt                                            */
+// #endif /* STM32F429_439xx */
+   
+#if defined (STM32F401xx) || defined (STM32F411xE)
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
+  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
+  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
+  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
+  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
+  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
+  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
+  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
+  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
+  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
+  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
+  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
+  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
+  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
+  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
+  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
+  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
+  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
+  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
+  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
+  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
+  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
+  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
+  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
+  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
+  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
+  FPU_IRQn                    = 81,      /*!< FPU global interrupt                                             */
+#if defined (STM32F401xx)
+  SPI4_IRQn                   = 84       /*!< SPI4 global Interrupt                                            */
+#endif /* STM32F411xE */
+#if defined (STM32F411xE)
+  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
+  SPI5_IRQn                   = 85      /*!< SPI5 global Interrupt                                             */
+#endif /* STM32F411xE */
+#endif /* STM32F401xx || STM32F411xE */
+
+} IRQn_Type;
+
+/**
+  * @}
+  */
+
+#include "core_cm4.h"             /* Cortex-M4 processor and core peripherals */
+#include "system_stm32f4xx.h"
+#include <stdint.h>
+
+/** @addtogroup Exported_types
+  * @{
+  */  
+/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */
+typedef int32_t  s32;
+typedef int16_t s16;
+typedef int8_t  s8;
+
+typedef const int32_t sc32;  /*!< Read Only */
+typedef const int16_t sc16;  /*!< Read Only */
+typedef const int8_t sc8;   /*!< Read Only */
+
+typedef __IO int32_t  vs32;
+typedef __IO int16_t  vs16;
+typedef __IO int8_t   vs8;
+
+typedef __I int32_t vsc32;  /*!< Read Only */
+typedef __I int16_t vsc16;  /*!< Read Only */
+typedef __I int8_t vsc8;   /*!< Read Only */
+
+typedef uint32_t  u32;
+typedef uint16_t u16;
+typedef uint8_t  u8;
+
+typedef const uint32_t uc32;  /*!< Read Only */
+typedef const uint16_t uc16;  /*!< Read Only */
+typedef const uint8_t uc8;   /*!< Read Only */
+
+typedef __IO uint32_t  vu32;
+typedef __IO uint16_t vu16;
+typedef __IO uint8_t  vu8;
+
+typedef __I uint32_t vuc32;  /*!< Read Only */
+typedef __I uint16_t vuc16;  /*!< Read Only */
+typedef __I uint8_t vuc8;   /*!< Read Only */
+
+typedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
+
+typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
+#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
+
+typedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
+
+/**
+  * @}
+  */
+
+/** @addtogroup Peripheral_registers_structures
+  * @{
+  */   
+
+/** 
+  * @brief Analog to Digital Converter  
+  */
+
+typedef struct
+{
+  __IO uint32_t SR;     /*!< ADC status register,                         Address offset: 0x00 */
+  __IO uint32_t CR1;    /*!< ADC control register 1,                      Address offset: 0x04 */      
+  __IO uint32_t CR2;    /*!< ADC control register 2,                      Address offset: 0x08 */
+  __IO uint32_t SMPR1;  /*!< ADC sample time register 1,                  Address offset: 0x0C */
+  __IO uint32_t SMPR2;  /*!< ADC sample time register 2,                  Address offset: 0x10 */
+  __IO uint32_t JOFR1;  /*!< ADC injected channel data offset register 1, Address offset: 0x14 */
+  __IO uint32_t JOFR2;  /*!< ADC injected channel data offset register 2, Address offset: 0x18 */
+  __IO uint32_t JOFR3;  /*!< ADC injected channel data offset register 3, Address offset: 0x1C */
+  __IO uint32_t JOFR4;  /*!< ADC injected channel data offset register 4, Address offset: 0x20 */
+  __IO uint32_t HTR;    /*!< ADC watchdog higher threshold register,      Address offset: 0x24 */
+  __IO uint32_t LTR;    /*!< ADC watchdog lower threshold register,       Address offset: 0x28 */
+  __IO uint32_t SQR1;   /*!< ADC regular sequence register 1,             Address offset: 0x2C */
+  __IO uint32_t SQR2;   /*!< ADC regular sequence register 2,             Address offset: 0x30 */
+  __IO uint32_t SQR3;   /*!< ADC regular sequence register 3,             Address offset: 0x34 */
+  __IO uint32_t JSQR;   /*!< ADC injected sequence register,              Address offset: 0x38*/
+  __IO uint32_t JDR1;   /*!< ADC injected data register 1,                Address offset: 0x3C */
+  __IO uint32_t JDR2;   /*!< ADC injected data register 2,                Address offset: 0x40 */
+  __IO uint32_t JDR3;   /*!< ADC injected data register 3,                Address offset: 0x44 */
+  __IO uint32_t JDR4;   /*!< ADC injected data register 4,                Address offset: 0x48 */
+  __IO uint32_t DR;     /*!< ADC regular data register,                   Address offset: 0x4C */
+} ADC_TypeDef;
+
+typedef struct
+{
+  __IO uint32_t CSR;    /*!< ADC Common status register,                  Address offset: ADC1 base address + 0x300 */
+  __IO uint32_t CCR;    /*!< ADC common control register,                 Address offset: ADC1 base address + 0x304 */
+  __IO uint32_t CDR;    /*!< ADC common regular data register for dual
+                             AND triple modes,                            Address offset: ADC1 base address + 0x308 */
+} ADC_Common_TypeDef;
+
+
+/** 
+  * @brief Controller Area Network TxMailBox 
+  */
+
+typedef struct
+{
+  __IO uint32_t TIR;  /*!< CAN TX mailbox identifier register */
+  __IO uint32_t TDTR; /*!< CAN mailbox data length control and time stamp register */
+  __IO uint32_t TDLR; /*!< CAN mailbox data low register */
+  __IO uint32_t TDHR; /*!< CAN mailbox data high register */
+} CAN_TxMailBox_TypeDef;
+
+/** 
+  * @brief Controller Area Network FIFOMailBox 
+  */
+  
+typedef struct
+{
+  __IO uint32_t RIR;  /*!< CAN receive FIFO mailbox identifier register */
+  __IO uint32_t RDTR; /*!< CAN receive FIFO mailbox data length control and time stamp register */
+  __IO uint32_t RDLR; /*!< CAN receive FIFO mailbox data low register */
+  __IO uint32_t RDHR; /*!< CAN receive FIFO mailbox data high register */
+} CAN_FIFOMailBox_TypeDef;
+
+/** 
+  * @brief Controller Area Network FilterRegister 
+  */
+  
+typedef struct
+{
+  __IO uint32_t FR1; /*!< CAN Filter bank register 1 */
+  __IO uint32_t FR2; /*!< CAN Filter bank register 1 */
+} CAN_FilterRegister_TypeDef;
+
+/** 
+  * @brief Controller Area Network 
+  */
+  
+typedef struct
+{
+  __IO uint32_t              MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
+  __IO uint32_t              MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
+  __IO uint32_t              TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
+  __IO uint32_t              RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
+  __IO uint32_t              RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
+  __IO uint32_t              IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
+  __IO uint32_t              ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
+  __IO uint32_t              BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
+  uint32_t                   RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
+  CAN_TxMailBox_TypeDef      sTxMailBox[3];       /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
+  CAN_FIFOMailBox_TypeDef    sFIFOMailBox[2];     /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
+  uint32_t                   RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
+  __IO uint32_t              FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
+  __IO uint32_t              FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
+  uint32_t                   RESERVED2;           /*!< Reserved, 0x208                                                    */
+  __IO uint32_t              FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
+  uint32_t                   RESERVED3;           /*!< Reserved, 0x210                                                    */
+  __IO uint32_t              FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
+  uint32_t                   RESERVED4;           /*!< Reserved, 0x218                                                    */
+  __IO uint32_t              FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
+  uint32_t                   RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */ 
+  CAN_FilterRegister_TypeDef sFilterRegister[28]; /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
+} CAN_TypeDef;
+
+/** 
+  * @brief CRC calculation unit 
+  */
+
+typedef struct
+{
+  __IO uint32_t DR;         /*!< CRC Data register,             Address offset: 0x00 */
+  __IO uint8_t  IDR;        /*!< CRC Independent data register, Address offset: 0x04 */
+  uint8_t       RESERVED0;  /*!< Reserved, 0x05                                      */
+  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                      */
+  __IO uint32_t CR;         /*!< CRC Control register,          Address offset: 0x08 */
+} CRC_TypeDef;
+
+/** 
+  * @brief Digital to Analog Converter
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;       /*!< DAC control register,                                    Address offset: 0x00 */
+  __IO uint32_t SWTRIGR;  /*!< DAC software trigger register,                           Address offset: 0x04 */
+  __IO uint32_t DHR12R1;  /*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 */
+  __IO uint32_t DHR12L1;  /*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C */
+  __IO uint32_t DHR8R1;   /*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 */
+  __IO uint32_t DHR12R2;  /*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 */
+  __IO uint32_t DHR12L2;  /*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 */
+  __IO uint32_t DHR8R2;   /*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C */
+  __IO uint32_t DHR12RD;  /*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 */
+  __IO uint32_t DHR12LD;  /*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 */
+  __IO uint32_t DHR8RD;   /*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 */
+  __IO uint32_t DOR1;     /*!< DAC channel1 data output register,                       Address offset: 0x2C */
+  __IO uint32_t DOR2;     /*!< DAC channel2 data output register,                       Address offset: 0x30 */
+  __IO uint32_t SR;       /*!< DAC status register,                                     Address offset: 0x34 */
+} DAC_TypeDef;
+
+/** 
+  * @brief Debug MCU
+  */
+
+typedef struct
+{
+  __IO uint32_t IDCODE;  /*!< MCU device ID code,               Address offset: 0x00 */
+  __IO uint32_t CR;      /*!< Debug MCU configuration register, Address offset: 0x04 */
+  __IO uint32_t APB1FZ;  /*!< Debug MCU APB1 freeze register,   Address offset: 0x08 */
+  __IO uint32_t APB2FZ;  /*!< Debug MCU APB2 freeze register,   Address offset: 0x0C */
+}DBGMCU_TypeDef;
+
+/** 
+  * @brief DCMI
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;       /*!< DCMI control register 1,                       Address offset: 0x00 */
+  __IO uint32_t SR;       /*!< DCMI status register,                          Address offset: 0x04 */
+  __IO uint32_t RISR;     /*!< DCMI raw interrupt status register,            Address offset: 0x08 */
+  __IO uint32_t IER;      /*!< DCMI interrupt enable register,                Address offset: 0x0C */
+  __IO uint32_t MISR;     /*!< DCMI masked interrupt status register,         Address offset: 0x10 */
+  __IO uint32_t ICR;      /*!< DCMI interrupt clear register,                 Address offset: 0x14 */
+  __IO uint32_t ESCR;     /*!< DCMI embedded synchronization code register,   Address offset: 0x18 */
+  __IO uint32_t ESUR;     /*!< DCMI embedded synchronization unmask register, Address offset: 0x1C */
+  __IO uint32_t CWSTRTR;  /*!< DCMI crop window start,                        Address offset: 0x20 */
+  __IO uint32_t CWSIZER;  /*!< DCMI crop window size,                         Address offset: 0x24 */
+  __IO uint32_t DR;       /*!< DCMI data register,                            Address offset: 0x28 */
+} DCMI_TypeDef;
+
+/** 
+  * @brief DMA Controller
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;     /*!< DMA stream x configuration register      */
+  __IO uint32_t NDTR;   /*!< DMA stream x number of data register     */
+  __IO uint32_t PAR;    /*!< DMA stream x peripheral address register */
+  __IO uint32_t M0AR;   /*!< DMA stream x memory 0 address register   */
+  __IO uint32_t M1AR;   /*!< DMA stream x memory 1 address register   */
+  __IO uint32_t FCR;    /*!< DMA stream x FIFO control register       */
+} DMA_Stream_TypeDef;
+
+typedef struct
+{
+  __IO uint32_t LISR;   /*!< DMA low interrupt status register,      Address offset: 0x00 */
+  __IO uint32_t HISR;   /*!< DMA high interrupt status register,     Address offset: 0x04 */
+  __IO uint32_t LIFCR;  /*!< DMA low interrupt flag clear register,  Address offset: 0x08 */
+  __IO uint32_t HIFCR;  /*!< DMA high interrupt flag clear register, Address offset: 0x0C */
+} DMA_TypeDef;
+ 
+/** 
+  * @brief DMA2D Controller
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;            /*!< DMA2D Control Register,                         Address offset: 0x00 */
+  __IO uint32_t ISR;           /*!< DMA2D Interrupt Status Register,                Address offset: 0x04 */
+  __IO uint32_t IFCR;          /*!< DMA2D Interrupt Flag Clear Register,            Address offset: 0x08 */
+  __IO uint32_t FGMAR;         /*!< DMA2D Foreground Memory Address Register,       Address offset: 0x0C */
+  __IO uint32_t FGOR;          /*!< DMA2D Foreground Offset Register,               Address offset: 0x10 */
+  __IO uint32_t BGMAR;         /*!< DMA2D Background Memory Address Register,       Address offset: 0x14 */
+  __IO uint32_t BGOR;          /*!< DMA2D Background Offset Register,               Address offset: 0x18 */
+  __IO uint32_t FGPFCCR;       /*!< DMA2D Foreground PFC Control Register,          Address offset: 0x1C */
+  __IO uint32_t FGCOLR;        /*!< DMA2D Foreground Color Register,                Address offset: 0x20 */
+  __IO uint32_t BGPFCCR;       /*!< DMA2D Background PFC Control Register,          Address offset: 0x24 */
+  __IO uint32_t BGCOLR;        /*!< DMA2D Background Color Register,                Address offset: 0x28 */
+  __IO uint32_t FGCMAR;        /*!< DMA2D Foreground CLUT Memory Address Register,  Address offset: 0x2C */
+  __IO uint32_t BGCMAR;        /*!< DMA2D Background CLUT Memory Address Register,  Address offset: 0x30 */
+  __IO uint32_t OPFCCR;        /*!< DMA2D Output PFC Control Register,              Address offset: 0x34 */
+  __IO uint32_t OCOLR;         /*!< DMA2D Output Color Register,                    Address offset: 0x38 */
+  __IO uint32_t OMAR;          /*!< DMA2D Output Memory Address Register,           Address offset: 0x3C */
+  __IO uint32_t OOR;           /*!< DMA2D Output Offset Register,                   Address offset: 0x40 */
+  __IO uint32_t NLR;           /*!< DMA2D Number of Line Register,                  Address offset: 0x44 */
+  __IO uint32_t LWR;           /*!< DMA2D Line Watermark Register,                  Address offset: 0x48 */
+  __IO uint32_t AMTCR;         /*!< DMA2D AHB Master Timer Configuration Register,  Address offset: 0x4C */
+  uint32_t      RESERVED[236]; /*!< Reserved, 0x50-0x3FF */
+  __IO uint32_t FGCLUT[256];   /*!< DMA2D Foreground CLUT,                          Address offset:400-7FF */
+  __IO uint32_t BGCLUT[256];   /*!< DMA2D Background CLUT,                          Address offset:800-BFF */
+} DMA2D_TypeDef;
+
+/** 
+  * @brief Ethernet MAC
+  */
+
+typedef struct
+{
+  __IO uint32_t MACCR;
+  __IO uint32_t MACFFR;
+  __IO uint32_t MACHTHR;
+  __IO uint32_t MACHTLR;
+  __IO uint32_t MACMIIAR;
+  __IO uint32_t MACMIIDR;
+  __IO uint32_t MACFCR;
+  __IO uint32_t MACVLANTR;             /*    8 */
+  uint32_t      RESERVED0[2];
+  __IO uint32_t MACRWUFFR;             /*   11 */
+  __IO uint32_t MACPMTCSR;
+  uint32_t      RESERVED1[2];
+  __IO uint32_t MACSR;                 /*   15 */
+  __IO uint32_t MACIMR;
+  __IO uint32_t MACA0HR;
+  __IO uint32_t MACA0LR;
+  __IO uint32_t MACA1HR;
+  __IO uint32_t MACA1LR;
+  __IO uint32_t MACA2HR;
+  __IO uint32_t MACA2LR;
+  __IO uint32_t MACA3HR;
+  __IO uint32_t MACA3LR;               /*   24 */
+  uint32_t      RESERVED2[40];
+  __IO uint32_t MMCCR;                 /*   65 */
+  __IO uint32_t MMCRIR;
+  __IO uint32_t MMCTIR;
+  __IO uint32_t MMCRIMR;
+  __IO uint32_t MMCTIMR;               /*   69 */
+  uint32_t      RESERVED3[14];
+  __IO uint32_t MMCTGFSCCR;            /*   84 */
+  __IO uint32_t MMCTGFMSCCR;
+  uint32_t      RESERVED4[5];
+  __IO uint32_t MMCTGFCR;
+  uint32_t      RESERVED5[10];
+  __IO uint32_t MMCRFCECR;
+  __IO uint32_t MMCRFAECR;
+  uint32_t      RESERVED6[10];
+  __IO uint32_t MMCRGUFCR;
+  uint32_t      RESERVED7[334];
+  __IO uint32_t PTPTSCR;
+  __IO uint32_t PTPSSIR;
+  __IO uint32_t PTPTSHR;
+  __IO uint32_t PTPTSLR;
+  __IO uint32_t PTPTSHUR;
+  __IO uint32_t PTPTSLUR;
+  __IO uint32_t PTPTSAR;
+  __IO uint32_t PTPTTHR;
+  __IO uint32_t PTPTTLR;
+  __IO uint32_t RESERVED8;
+  __IO uint32_t PTPTSSR;
+  uint32_t      RESERVED9[565];
+  __IO uint32_t DMABMR;
+  __IO uint32_t DMATPDR;
+  __IO uint32_t DMARPDR;
+  __IO uint32_t DMARDLAR;
+  __IO uint32_t DMATDLAR;
+  __IO uint32_t DMASR;
+  __IO uint32_t DMAOMR;
+  __IO uint32_t DMAIER;
+  __IO uint32_t DMAMFBOCR;
+  __IO uint32_t DMARSWTR;
+  uint32_t      RESERVED10[8];
+  __IO uint32_t DMACHTDR;
+  __IO uint32_t DMACHRDR;
+  __IO uint32_t DMACHTBAR;
+  __IO uint32_t DMACHRBAR;
+} ETH_TypeDef;
+
+/** 
+  * @brief External Interrupt/Event Controller
+  */
+
+typedef struct
+{
+  __IO uint32_t IMR;    /*!< EXTI Interrupt mask register,            Address offset: 0x00 */
+  __IO uint32_t EMR;    /*!< EXTI Event mask register,                Address offset: 0x04 */
+  __IO uint32_t RTSR;   /*!< EXTI Rising trigger selection register,  Address offset: 0x08 */
+  __IO uint32_t FTSR;   /*!< EXTI Falling trigger selection register, Address offset: 0x0C */
+  __IO uint32_t SWIER;  /*!< EXTI Software interrupt event register,  Address offset: 0x10 */
+  __IO uint32_t PR;     /*!< EXTI Pending register,                   Address offset: 0x14 */
+} EXTI_TypeDef;
+
+/** 
+  * @brief FLASH Registers
+  */
+
+typedef struct
+{
+  __IO uint32_t ACR;      /*!< FLASH access control register,   Address offset: 0x00 */
+  __IO uint32_t KEYR;     /*!< FLASH key register,              Address offset: 0x04 */
+  __IO uint32_t OPTKEYR;  /*!< FLASH option key register,       Address offset: 0x08 */
+  __IO uint32_t SR;       /*!< FLASH status register,           Address offset: 0x0C */
+  __IO uint32_t CR;       /*!< FLASH control register,          Address offset: 0x10 */
+  __IO uint32_t OPTCR;    /*!< FLASH option control register ,  Address offset: 0x14 */
+  __IO uint32_t OPTCR1;   /*!< FLASH option control register 1, Address offset: 0x18 */
+} FLASH_TypeDef;
+
+#if defined (STM32F40_41xxx)
+/** 
+  * @brief Flexible Static Memory Controller
+  */
+
+typedef struct
+{
+  __IO uint32_t BTCR[8];    /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */   
+} FSMC_Bank1_TypeDef; 
+
+/** 
+  * @brief Flexible Static Memory Controller Bank1E
+  */
+  
+typedef struct
+{
+  __IO uint32_t BWTR[7];    /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
+} FSMC_Bank1E_TypeDef;
+
+/** 
+  * @brief Flexible Static Memory Controller Bank2
+  */
+  
+typedef struct
+{
+  __IO uint32_t PCR2;       /*!< NAND Flash control register 2,                       Address offset: 0x60 */
+  __IO uint32_t SR2;        /*!< NAND Flash FIFO status and interrupt register 2,     Address offset: 0x64 */
+  __IO uint32_t PMEM2;      /*!< NAND Flash Common memory space timing register 2,    Address offset: 0x68 */
+  __IO uint32_t PATT2;      /*!< NAND Flash Attribute memory space timing register 2, Address offset: 0x6C */
+  uint32_t      RESERVED0;  /*!< Reserved, 0x70                                                            */
+  __IO uint32_t ECCR2;      /*!< NAND Flash ECC result registers 2,                   Address offset: 0x74 */
+} FSMC_Bank2_TypeDef;
+
+/** 
+  * @brief Flexible Static Memory Controller Bank3
+  */
+  
+typedef struct
+{
+  __IO uint32_t PCR3;       /*!< NAND Flash control register 3,                       Address offset: 0x80 */
+  __IO uint32_t SR3;        /*!< NAND Flash FIFO status and interrupt register 3,     Address offset: 0x84 */
+  __IO uint32_t PMEM3;      /*!< NAND Flash Common memory space timing register 3,    Address offset: 0x88 */
+  __IO uint32_t PATT3;      /*!< NAND Flash Attribute memory space timing register 3, Address offset: 0x8C */
+  uint32_t      RESERVED0;  /*!< Reserved, 0x90                                                            */
+  __IO uint32_t ECCR3;      /*!< NAND Flash ECC result registers 3,                   Address offset: 0x94 */
+} FSMC_Bank3_TypeDef;
+
+/** 
+  * @brief Flexible Static Memory Controller Bank4
+  */
+  
+typedef struct
+{
+  __IO uint32_t PCR4;       /*!< PC Card  control register 4,                       Address offset: 0xA0 */
+  __IO uint32_t SR4;        /*!< PC Card  FIFO status and interrupt register 4,     Address offset: 0xA4 */
+  __IO uint32_t PMEM4;      /*!< PC Card  Common memory space timing register 4,    Address offset: 0xA8 */
+  __IO uint32_t PATT4;      /*!< PC Card  Attribute memory space timing register 4, Address offset: 0xAC */
+  __IO uint32_t PIO4;       /*!< PC Card  I/O space timing register 4,              Address offset: 0xB0 */
+} FSMC_Bank4_TypeDef; 
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+/** 
+  * @brief Flexible Memory Controller
+  */
+
+typedef struct
+{
+  __IO uint32_t BTCR[8];    /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */   
+} FMC_Bank1_TypeDef; 
+
+/** 
+  * @brief Flexible Memory Controller Bank1E
+  */
+  
+typedef struct
+{
+  __IO uint32_t BWTR[7];    /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
+} FMC_Bank1E_TypeDef;
+
+/** 
+  * @brief Flexible Memory Controller Bank2
+  */
+  
+typedef struct
+{
+  __IO uint32_t PCR2;       /*!< NAND Flash control register 2,                       Address offset: 0x60 */
+  __IO uint32_t SR2;        /*!< NAND Flash FIFO status and interrupt register 2,     Address offset: 0x64 */
+  __IO uint32_t PMEM2;      /*!< NAND Flash Common memory space timing register 2,    Address offset: 0x68 */
+  __IO uint32_t PATT2;      /*!< NAND Flash Attribute memory space timing register 2, Address offset: 0x6C */
+  uint32_t      RESERVED0;  /*!< Reserved, 0x70                                                            */
+  __IO uint32_t ECCR2;      /*!< NAND Flash ECC result registers 2,                   Address offset: 0x74 */
+} FMC_Bank2_TypeDef;
+
+/** 
+  * @brief Flexible Memory Controller Bank3
+  */
+  
+typedef struct
+{
+  __IO uint32_t PCR3;       /*!< NAND Flash control register 3,                       Address offset: 0x80 */
+  __IO uint32_t SR3;        /*!< NAND Flash FIFO status and interrupt register 3,     Address offset: 0x84 */
+  __IO uint32_t PMEM3;      /*!< NAND Flash Common memory space timing register 3,    Address offset: 0x88 */
+  __IO uint32_t PATT3;      /*!< NAND Flash Attribute memory space timing register 3, Address offset: 0x8C */
+  uint32_t      RESERVED0;  /*!< Reserved, 0x90                                                            */
+  __IO uint32_t ECCR3;      /*!< NAND Flash ECC result registers 3,                   Address offset: 0x94 */
+} FMC_Bank3_TypeDef;
+
+/** 
+  * @brief Flexible Memory Controller Bank4
+  */
+  
+typedef struct
+{
+  __IO uint32_t PCR4;       /*!< PC Card  control register 4,                       Address offset: 0xA0 */
+  __IO uint32_t SR4;        /*!< PC Card  FIFO status and interrupt register 4,     Address offset: 0xA4 */
+  __IO uint32_t PMEM4;      /*!< PC Card  Common memory space timing register 4,    Address offset: 0xA8 */
+  __IO uint32_t PATT4;      /*!< PC Card  Attribute memory space timing register 4, Address offset: 0xAC */
+  __IO uint32_t PIO4;       /*!< PC Card  I/O space timing register 4,              Address offset: 0xB0 */
+} FMC_Bank4_TypeDef; 
+
+/** 
+  * @brief Flexible Memory Controller Bank5_6
+  */
+  
+typedef struct
+{
+  __IO uint32_t SDCR[2];        /*!< SDRAM Control registers ,      Address offset: 0x140-0x144  */
+  __IO uint32_t SDTR[2];        /*!< SDRAM Timing registers ,       Address offset: 0x148-0x14C  */
+  __IO uint32_t SDCMR;       /*!< SDRAM Command Mode register,    Address offset: 0x150  */
+  __IO uint32_t SDRTR;       /*!< SDRAM Refresh Timer register,   Address offset: 0x154  */
+  __IO uint32_t SDSR;        /*!< SDRAM Status register,          Address offset: 0x158  */
+} FMC_Bank5_6_TypeDef; 
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+/** 
+  * @brief General Purpose I/O
+  */
+
+typedef struct
+{
+  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00      */
+  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04      */
+  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08      */
+  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
+  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10      */
+  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14      */
+  __IO uint16_t BSRRL;    /*!< GPIO port bit set/reset low register,  Address offset: 0x18      */
+  __IO uint16_t BSRRH;    /*!< GPIO port bit set/reset high register, Address offset: 0x1A      */
+  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C      */
+  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
+} GPIO_TypeDef;
+
+/** 
+  * @brief System configuration controller
+  */
+  
+typedef struct
+{
+  __IO uint32_t MEMRMP;       /*!< SYSCFG memory remap register,                      Address offset: 0x00      */
+  __IO uint32_t PMC;          /*!< SYSCFG peripheral mode configuration register,     Address offset: 0x04      */
+  __IO uint32_t EXTICR[4];    /*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 */
+  uint32_t      RESERVED[2];  /*!< Reserved, 0x18-0x1C                                                          */ 
+  __IO uint32_t CMPCR;        /*!< SYSCFG Compensation cell control register,         Address offset: 0x20      */
+} SYSCFG_TypeDef;
+
+/** 
+  * @brief Inter-integrated Circuit Interface
+  */
+
+typedef struct
+{
+  __IO uint16_t CR1;        /*!< I2C Control register 1,     Address offset: 0x00 */
+  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                   */
+  __IO uint16_t CR2;        /*!< I2C Control register 2,     Address offset: 0x04 */
+  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                   */
+  __IO uint16_t OAR1;       /*!< I2C Own address register 1, Address offset: 0x08 */
+  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                   */
+  __IO uint16_t OAR2;       /*!< I2C Own address register 2, Address offset: 0x0C */
+  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                   */
+  __IO uint16_t DR;         /*!< I2C Data register,          Address offset: 0x10 */
+  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                   */
+  __IO uint16_t SR1;        /*!< I2C Status register 1,      Address offset: 0x14 */
+  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                   */
+  __IO uint16_t SR2;        /*!< I2C Status register 2,      Address offset: 0x18 */
+  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                   */
+  __IO uint16_t CCR;        /*!< I2C Clock control register, Address offset: 0x1C */
+  uint16_t      RESERVED7;  /*!< Reserved, 0x1E                                   */
+  __IO uint16_t TRISE;      /*!< I2C TRISE register,         Address offset: 0x20 */
+  uint16_t      RESERVED8;  /*!< Reserved, 0x22                                   */
+  __IO uint16_t FLTR;       /*!< I2C FLTR register,          Address offset: 0x24 */
+  uint16_t      RESERVED9;  /*!< Reserved, 0x26                                   */
+} I2C_TypeDef;
+
+/** 
+  * @brief Independent WATCHDOG
+  */
+
+typedef struct
+{
+  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
+  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
+  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
+  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
+} IWDG_TypeDef;
+
+/** 
+  * @brief LCD-TFT Display Controller
+  */
+  
+typedef struct
+{
+  uint32_t      RESERVED0[2];  /*!< Reserved, 0x00-0x04 */
+  __IO uint32_t SSCR;          /*!< LTDC Synchronization Size Configuration Register,    Address offset: 0x08 */
+  __IO uint32_t BPCR;          /*!< LTDC Back Porch Configuration Register,              Address offset: 0x0C */
+  __IO uint32_t AWCR;          /*!< LTDC Active Width Configuration Register,            Address offset: 0x10 */
+  __IO uint32_t TWCR;          /*!< LTDC Total Width Configuration Register,             Address offset: 0x14 */
+  __IO uint32_t GCR;           /*!< LTDC Global Control Register,                        Address offset: 0x18 */
+  uint32_t      RESERVED1[2];  /*!< Reserved, 0x1C-0x20 */
+  __IO uint32_t SRCR;          /*!< LTDC Shadow Reload Configuration Register,           Address offset: 0x24 */
+  uint32_t      RESERVED2[1];  /*!< Reserved, 0x28 */
+  __IO uint32_t BCCR;          /*!< LTDC Background Color Configuration Register,        Address offset: 0x2C */
+  uint32_t      RESERVED3[1];  /*!< Reserved, 0x30 */
+  __IO uint32_t IER;           /*!< LTDC Interrupt Enable Register,                      Address offset: 0x34 */
+  __IO uint32_t ISR;           /*!< LTDC Interrupt Status Register,                      Address offset: 0x38 */
+  __IO uint32_t ICR;           /*!< LTDC Interrupt Clear Register,                       Address offset: 0x3C */
+  __IO uint32_t LIPCR;         /*!< LTDC Line Interrupt Position Configuration Register, Address offset: 0x40 */
+  __IO uint32_t CPSR;          /*!< LTDC Current Position Status Register,               Address offset: 0x44 */
+  __IO uint32_t CDSR;         /*!< LTDC Current Display Status Register,                       Address offset: 0x48 */
+} LTDC_TypeDef;  
+
+/** 
+  * @brief LCD-TFT Display layer x Controller
+  */
+  
+typedef struct
+{  
+  __IO uint32_t CR;            /*!< LTDC Layerx Control Register                                  Address offset: 0x84 */
+  __IO uint32_t WHPCR;         /*!< LTDC Layerx Window Horizontal Position Configuration Register Address offset: 0x88 */
+  __IO uint32_t WVPCR;         /*!< LTDC Layerx Window Vertical Position Configuration Register   Address offset: 0x8C */
+  __IO uint32_t CKCR;          /*!< LTDC Layerx Color Keying Configuration Register               Address offset: 0x90 */
+  __IO uint32_t PFCR;          /*!< LTDC Layerx Pixel Format Configuration Register               Address offset: 0x94 */
+  __IO uint32_t CACR;          /*!< LTDC Layerx Constant Alpha Configuration Register             Address offset: 0x98 */
+  __IO uint32_t DCCR;          /*!< LTDC Layerx Default Color Configuration Register              Address offset: 0x9C */
+  __IO uint32_t BFCR;          /*!< LTDC Layerx Blending Factors Configuration Register           Address offset: 0xA0 */
+  uint32_t      RESERVED0[2];  /*!< Reserved */
+  __IO uint32_t CFBAR;         /*!< LTDC Layerx Color Frame Buffer Address Register               Address offset: 0xAC */
+  __IO uint32_t CFBLR;         /*!< LTDC Layerx Color Frame Buffer Length Register                Address offset: 0xB0 */
+  __IO uint32_t CFBLNR;        /*!< LTDC Layerx ColorFrame Buffer Line Number Register            Address offset: 0xB4 */
+  uint32_t      RESERVED1[3];  /*!< Reserved */
+  __IO uint32_t CLUTWR;         /*!< LTDC Layerx CLUT Write Register                               Address offset: 0x144 */
+
+} LTDC_Layer_TypeDef;
+
+/** 
+  * @brief Power Control
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
+  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
+} PWR_TypeDef;
+
+/** 
+  * @brief Reset and Clock Control
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;            /*!< RCC clock control register,                                  Address offset: 0x00 */
+  __IO uint32_t PLLCFGR;       /*!< RCC PLL configuration register,                              Address offset: 0x04 */
+  __IO uint32_t CFGR;          /*!< RCC clock configuration register,                            Address offset: 0x08 */
+  __IO uint32_t CIR;           /*!< RCC clock interrupt register,                                Address offset: 0x0C */
+  __IO uint32_t AHB1RSTR;      /*!< RCC AHB1 peripheral reset register,                          Address offset: 0x10 */
+  __IO uint32_t AHB2RSTR;      /*!< RCC AHB2 peripheral reset register,                          Address offset: 0x14 */
+  __IO uint32_t AHB3RSTR;      /*!< RCC AHB3 peripheral reset register,                          Address offset: 0x18 */
+  uint32_t      RESERVED0;     /*!< Reserved, 0x1C                                                                    */
+  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                          Address offset: 0x20 */
+  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                          Address offset: 0x24 */
+  uint32_t      RESERVED1[2];  /*!< Reserved, 0x28-0x2C                                                               */
+  __IO uint32_t AHB1ENR;       /*!< RCC AHB1 peripheral clock register,                          Address offset: 0x30 */
+  __IO uint32_t AHB2ENR;       /*!< RCC AHB2 peripheral clock register,                          Address offset: 0x34 */
+  __IO uint32_t AHB3ENR;       /*!< RCC AHB3 peripheral clock register,                          Address offset: 0x38 */
+  uint32_t      RESERVED2;     /*!< Reserved, 0x3C                                                                    */
+  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x40 */
+  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x44 */
+  uint32_t      RESERVED3[2];  /*!< Reserved, 0x48-0x4C                                                               */
+  __IO uint32_t AHB1LPENR;     /*!< RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 */
+  __IO uint32_t AHB2LPENR;     /*!< RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 */
+  __IO uint32_t AHB3LPENR;     /*!< RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 */
+  uint32_t      RESERVED4;     /*!< Reserved, 0x5C                                                                    */
+  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 */
+  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 */
+  uint32_t      RESERVED5[2];  /*!< Reserved, 0x68-0x6C                                                               */
+  __IO uint32_t BDCR;          /*!< RCC Backup domain control register,                          Address offset: 0x70 */
+  __IO uint32_t CSR;           /*!< RCC clock control & status register,                         Address offset: 0x74 */
+  uint32_t      RESERVED6[2];  /*!< Reserved, 0x78-0x7C                                                               */
+  __IO uint32_t SSCGR;         /*!< RCC spread spectrum clock generation register,               Address offset: 0x80 */
+  __IO uint32_t PLLI2SCFGR;    /*!< RCC PLLI2S configuration register,                           Address offset: 0x84 */
+  __IO uint32_t PLLSAICFGR;    /*!< RCC PLLSAI configuration register,                           Address offset: 0x88 */
+  __IO uint32_t DCKCFGR;       /*!< RCC Dedicated Clocks configuration register,                 Address offset: 0x8C */
+
+} RCC_TypeDef;
+
+/** 
+  * @brief Real-Time Clock
+  */
+
+typedef struct
+{
+  __IO uint32_t TR;      /*!< RTC time register,                                        Address offset: 0x00 */
+  __IO uint32_t DR;      /*!< RTC date register,                                        Address offset: 0x04 */
+  __IO uint32_t CR;      /*!< RTC control register,                                     Address offset: 0x08 */
+  __IO uint32_t ISR;     /*!< RTC initialization and status register,                   Address offset: 0x0C */
+  __IO uint32_t PRER;    /*!< RTC prescaler register,                                   Address offset: 0x10 */
+  __IO uint32_t WUTR;    /*!< RTC wakeup timer register,                                Address offset: 0x14 */
+  __IO uint32_t CALIBR;  /*!< RTC calibration register,                                 Address offset: 0x18 */
+  __IO uint32_t ALRMAR;  /*!< RTC alarm A register,                                     Address offset: 0x1C */
+  __IO uint32_t ALRMBR;  /*!< RTC alarm B register,                                     Address offset: 0x20 */
+  __IO uint32_t WPR;     /*!< RTC write protection register,                            Address offset: 0x24 */
+  __IO uint32_t SSR;     /*!< RTC sub second register,                                  Address offset: 0x28 */
+  __IO uint32_t SHIFTR;  /*!< RTC shift control register,                               Address offset: 0x2C */
+  __IO uint32_t TSTR;    /*!< RTC time stamp time register,                             Address offset: 0x30 */
+  __IO uint32_t TSDR;    /*!< RTC time stamp date register,                             Address offset: 0x34 */
+  __IO uint32_t TSSSR;   /*!< RTC time-stamp sub second register,                       Address offset: 0x38 */
+  __IO uint32_t CALR;    /*!< RTC calibration register,                                 Address offset: 0x3C */
+  __IO uint32_t TAFCR;   /*!< RTC tamper and alternate function configuration register, Address offset: 0x40 */
+  __IO uint32_t ALRMASSR;/*!< RTC alarm A sub second register,                          Address offset: 0x44 */
+  __IO uint32_t ALRMBSSR;/*!< RTC alarm B sub second register,                          Address offset: 0x48 */
+  uint32_t RESERVED7;    /*!< Reserved, 0x4C                                                                 */
+  __IO uint32_t BKP0R;   /*!< RTC backup register 1,                                    Address offset: 0x50 */
+  __IO uint32_t BKP1R;   /*!< RTC backup register 1,                                    Address offset: 0x54 */
+  __IO uint32_t BKP2R;   /*!< RTC backup register 2,                                    Address offset: 0x58 */
+  __IO uint32_t BKP3R;   /*!< RTC backup register 3,                                    Address offset: 0x5C */
+  __IO uint32_t BKP4R;   /*!< RTC backup register 4,                                    Address offset: 0x60 */
+  __IO uint32_t BKP5R;   /*!< RTC backup register 5,                                    Address offset: 0x64 */
+  __IO uint32_t BKP6R;   /*!< RTC backup register 6,                                    Address offset: 0x68 */
+  __IO uint32_t BKP7R;   /*!< RTC backup register 7,                                    Address offset: 0x6C */
+  __IO uint32_t BKP8R;   /*!< RTC backup register 8,                                    Address offset: 0x70 */
+  __IO uint32_t BKP9R;   /*!< RTC backup register 9,                                    Address offset: 0x74 */
+  __IO uint32_t BKP10R;  /*!< RTC backup register 10,                                   Address offset: 0x78 */
+  __IO uint32_t BKP11R;  /*!< RTC backup register 11,                                   Address offset: 0x7C */
+  __IO uint32_t BKP12R;  /*!< RTC backup register 12,                                   Address offset: 0x80 */
+  __IO uint32_t BKP13R;  /*!< RTC backup register 13,                                   Address offset: 0x84 */
+  __IO uint32_t BKP14R;  /*!< RTC backup register 14,                                   Address offset: 0x88 */
+  __IO uint32_t BKP15R;  /*!< RTC backup register 15,                                   Address offset: 0x8C */
+  __IO uint32_t BKP16R;  /*!< RTC backup register 16,                                   Address offset: 0x90 */
+  __IO uint32_t BKP17R;  /*!< RTC backup register 17,                                   Address offset: 0x94 */
+  __IO uint32_t BKP18R;  /*!< RTC backup register 18,                                   Address offset: 0x98 */
+  __IO uint32_t BKP19R;  /*!< RTC backup register 19,                                   Address offset: 0x9C */
+} RTC_TypeDef;
+
+
+/** 
+  * @brief Serial Audio Interface
+  */
+  
+typedef struct
+{
+  __IO uint32_t GCR;      /*!< SAI global configuration register,        Address offset: 0x00 */
+} SAI_TypeDef;
+
+typedef struct
+{
+  __IO uint32_t CR1;      /*!< SAI block x configuration register 1,     Address offset: 0x04 */
+  __IO uint32_t CR2;      /*!< SAI block x configuration register 2,     Address offset: 0x08 */
+  __IO uint32_t FRCR;     /*!< SAI block x frame configuration register, Address offset: 0x0C */
+  __IO uint32_t SLOTR;    /*!< SAI block x slot register,                Address offset: 0x10 */
+  __IO uint32_t IMR;      /*!< SAI block x interrupt mask register,      Address offset: 0x14 */
+  __IO uint32_t SR;       /*!< SAI block x status register,              Address offset: 0x18 */
+  __IO uint32_t CLRFR;    /*!< SAI block x clear flag register,          Address offset: 0x1C */
+  __IO uint32_t DR;       /*!< SAI block x data register,                Address offset: 0x20 */
+} SAI_Block_TypeDef;
+
+/** 
+  * @brief SD host Interface
+  */
+
+typedef struct
+{
+  __IO uint32_t POWER;          /*!< SDIO power control register,    Address offset: 0x00 */
+  __IO uint32_t CLKCR;          /*!< SDI clock control register,     Address offset: 0x04 */
+  __IO uint32_t ARG;            /*!< SDIO argument register,         Address offset: 0x08 */
+  __IO uint32_t CMD;            /*!< SDIO command register,          Address offset: 0x0C */
+  __I uint32_t  RESPCMD;        /*!< SDIO command response register, Address offset: 0x10 */
+  __I uint32_t  RESP1;          /*!< SDIO response 1 register,       Address offset: 0x14 */
+  __I uint32_t  RESP2;          /*!< SDIO response 2 register,       Address offset: 0x18 */
+  __I uint32_t  RESP3;          /*!< SDIO response 3 register,       Address offset: 0x1C */
+  __I uint32_t  RESP4;          /*!< SDIO response 4 register,       Address offset: 0x20 */
+  __IO uint32_t DTIMER;         /*!< SDIO data timer register,       Address offset: 0x24 */
+  __IO uint32_t DLEN;           /*!< SDIO data length register,      Address offset: 0x28 */
+  __IO uint32_t DCTRL;          /*!< SDIO data control register,     Address offset: 0x2C */
+  __I uint32_t  DCOUNT;         /*!< SDIO data counter register,     Address offset: 0x30 */
+  __I uint32_t  STA;            /*!< SDIO status register,           Address offset: 0x34 */
+  __IO uint32_t ICR;            /*!< SDIO interrupt clear register,  Address offset: 0x38 */
+  __IO uint32_t MASK;           /*!< SDIO mask register,             Address offset: 0x3C */
+  uint32_t      RESERVED0[2];   /*!< Reserved, 0x40-0x44                                  */
+  __I uint32_t  FIFOCNT;        /*!< SDIO FIFO counter register,     Address offset: 0x48 */
+  uint32_t      RESERVED1[13];  /*!< Reserved, 0x4C-0x7C                                  */
+  __IO uint32_t FIFO;           /*!< SDIO data FIFO register,        Address offset: 0x80 */
+} SDIO_TypeDef;
+
+/** 
+  * @brief Serial Peripheral Interface
+  */
+
+typedef struct
+{
+  __IO uint16_t CR1;        /*!< SPI control register 1 (not used in I2S mode),      Address offset: 0x00 */
+  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                           */
+  __IO uint16_t CR2;        /*!< SPI control register 2,                             Address offset: 0x04 */
+  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                           */
+  __IO uint16_t SR;         /*!< SPI status register,                                Address offset: 0x08 */
+  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                           */
+  __IO uint16_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
+  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                           */
+  __IO uint16_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
+  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                           */
+  __IO uint16_t RXCRCR;     /*!< SPI RX CRC register (not used in I2S mode),         Address offset: 0x14 */
+  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                           */
+  __IO uint16_t TXCRCR;     /*!< SPI TX CRC register (not used in I2S mode),         Address offset: 0x18 */
+  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                           */
+  __IO uint16_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
+  uint16_t      RESERVED7;  /*!< Reserved, 0x1E                                                           */
+  __IO uint16_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
+  uint16_t      RESERVED8;  /*!< Reserved, 0x22                                                           */
+} SPI_TypeDef;
+
+/** 
+  * @brief TIM
+  */
+
+typedef struct
+{
+  __IO uint16_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
+  uint16_t      RESERVED0;   /*!< Reserved, 0x02                                            */
+  __IO uint16_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
+  uint16_t      RESERVED1;   /*!< Reserved, 0x06                                            */
+  __IO uint16_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
+  uint16_t      RESERVED2;   /*!< Reserved, 0x0A                                            */
+  __IO uint16_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
+  uint16_t      RESERVED3;   /*!< Reserved, 0x0E                                            */
+  __IO uint16_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
+  uint16_t      RESERVED4;   /*!< Reserved, 0x12                                            */
+  __IO uint16_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
+  uint16_t      RESERVED5;   /*!< Reserved, 0x16                                            */
+  __IO uint16_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
+  uint16_t      RESERVED6;   /*!< Reserved, 0x1A                                            */
+  __IO uint16_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
+  uint16_t      RESERVED7;   /*!< Reserved, 0x1E                                            */
+  __IO uint16_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
+  uint16_t      RESERVED8;   /*!< Reserved, 0x22                                            */
+  __IO uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
+  __IO uint16_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
+  uint16_t      RESERVED9;   /*!< Reserved, 0x2A                                            */
+  __IO uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
+  __IO uint16_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
+  uint16_t      RESERVED10;  /*!< Reserved, 0x32                                            */
+  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
+  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
+  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
+  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
+  __IO uint16_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
+  uint16_t      RESERVED11;  /*!< Reserved, 0x46                                            */
+  __IO uint16_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
+  uint16_t      RESERVED12;  /*!< Reserved, 0x4A                                            */
+  __IO uint16_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
+  uint16_t      RESERVED13;  /*!< Reserved, 0x4E                                            */
+  __IO uint16_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
+  uint16_t      RESERVED14;  /*!< Reserved, 0x52                                            */
+} TIM_TypeDef;
+
+/** 
+  * @brief Universal Synchronous Asynchronous Receiver Transmitter
+  */
+ 
+typedef struct
+{
+  __IO uint16_t SR;         /*!< USART Status register,                   Address offset: 0x00 */
+  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                */
+  __IO uint16_t DR;         /*!< USART Data register,                     Address offset: 0x04 */
+  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                */
+  __IO uint16_t BRR;        /*!< USART Baud rate register,                Address offset: 0x08 */
+  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                */
+  __IO uint16_t CR1;        /*!< USART Control register 1,                Address offset: 0x0C */
+  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                */
+  __IO uint16_t CR2;        /*!< USART Control register 2,                Address offset: 0x10 */
+  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                */
+  __IO uint16_t CR3;        /*!< USART Control register 3,                Address offset: 0x14 */
+  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                */
+  __IO uint16_t GTPR;       /*!< USART Guard time and prescaler register, Address offset: 0x18 */
+  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                */
+} USART_TypeDef;
+
+/** 
+  * @brief Window WATCHDOG
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
+  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
+  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
+} WWDG_TypeDef;
+
+/** 
+  * @brief Crypto Processor
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;         /*!< CRYP control register,                                    Address offset: 0x00 */
+  __IO uint32_t SR;         /*!< CRYP status register,                                     Address offset: 0x04 */
+  __IO uint32_t DR;         /*!< CRYP data input register,                                 Address offset: 0x08 */
+  __IO uint32_t DOUT;       /*!< CRYP data output register,                                Address offset: 0x0C */
+  __IO uint32_t DMACR;      /*!< CRYP DMA control register,                                Address offset: 0x10 */
+  __IO uint32_t IMSCR;      /*!< CRYP interrupt mask set/clear register,                   Address offset: 0x14 */
+  __IO uint32_t RISR;       /*!< CRYP raw interrupt status register,                       Address offset: 0x18 */
+  __IO uint32_t MISR;       /*!< CRYP masked interrupt status register,                    Address offset: 0x1C */
+  __IO uint32_t K0LR;       /*!< CRYP key left  register 0,                                Address offset: 0x20 */
+  __IO uint32_t K0RR;       /*!< CRYP key right register 0,                                Address offset: 0x24 */
+  __IO uint32_t K1LR;       /*!< CRYP key left  register 1,                                Address offset: 0x28 */
+  __IO uint32_t K1RR;       /*!< CRYP key right register 1,                                Address offset: 0x2C */
+  __IO uint32_t K2LR;       /*!< CRYP key left  register 2,                                Address offset: 0x30 */
+  __IO uint32_t K2RR;       /*!< CRYP key right register 2,                                Address offset: 0x34 */
+  __IO uint32_t K3LR;       /*!< CRYP key left  register 3,                                Address offset: 0x38 */
+  __IO uint32_t K3RR;       /*!< CRYP key right register 3,                                Address offset: 0x3C */
+  __IO uint32_t IV0LR;      /*!< CRYP initialization vector left-word  register 0,         Address offset: 0x40 */
+  __IO uint32_t IV0RR;      /*!< CRYP initialization vector right-word register 0,         Address offset: 0x44 */
+  __IO uint32_t IV1LR;      /*!< CRYP initialization vector left-word  register 1,         Address offset: 0x48 */
+  __IO uint32_t IV1RR;      /*!< CRYP initialization vector right-word register 1,         Address offset: 0x4C */
+  __IO uint32_t CSGCMCCM0R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 0,        Address offset: 0x50 */
+  __IO uint32_t CSGCMCCM1R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 1,        Address offset: 0x54 */
+  __IO uint32_t CSGCMCCM2R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 2,        Address offset: 0x58 */
+  __IO uint32_t CSGCMCCM3R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 3,        Address offset: 0x5C */
+  __IO uint32_t CSGCMCCM4R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 4,        Address offset: 0x60 */
+  __IO uint32_t CSGCMCCM5R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 5,        Address offset: 0x64 */
+  __IO uint32_t CSGCMCCM6R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 6,        Address offset: 0x68 */
+  __IO uint32_t CSGCMCCM7R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 7,        Address offset: 0x6C */
+  __IO uint32_t CSGCM0R;    /*!< CRYP GCM/GMAC context swap register 0,                    Address offset: 0x70 */
+  __IO uint32_t CSGCM1R;    /*!< CRYP GCM/GMAC context swap register 1,                    Address offset: 0x74 */
+  __IO uint32_t CSGCM2R;    /*!< CRYP GCM/GMAC context swap register 2,                    Address offset: 0x78 */
+  __IO uint32_t CSGCM3R;    /*!< CRYP GCM/GMAC context swap register 3,                    Address offset: 0x7C */
+  __IO uint32_t CSGCM4R;    /*!< CRYP GCM/GMAC context swap register 4,                    Address offset: 0x80 */
+  __IO uint32_t CSGCM5R;    /*!< CRYP GCM/GMAC context swap register 5,                    Address offset: 0x84 */
+  __IO uint32_t CSGCM6R;    /*!< CRYP GCM/GMAC context swap register 6,                    Address offset: 0x88 */
+  __IO uint32_t CSGCM7R;    /*!< CRYP GCM/GMAC context swap register 7,                    Address offset: 0x8C */
+} CRYP_TypeDef;
+
+/** 
+  * @brief HASH
+  */
+  
+typedef struct 
+{
+  __IO uint32_t CR;               /*!< HASH control register,          Address offset: 0x00        */
+  __IO uint32_t DIN;              /*!< HASH data input register,       Address offset: 0x04        */
+  __IO uint32_t STR;              /*!< HASH start register,            Address offset: 0x08        */
+  __IO uint32_t HR[5];            /*!< HASH digest registers,          Address offset: 0x0C-0x1C   */
+  __IO uint32_t IMR;              /*!< HASH interrupt enable register, Address offset: 0x20        */
+  __IO uint32_t SR;               /*!< HASH status register,           Address offset: 0x24        */
+       uint32_t RESERVED[52];     /*!< Reserved, 0x28-0xF4                                         */
+  __IO uint32_t CSR[54];          /*!< HASH context swap registers,    Address offset: 0x0F8-0x1CC */
+} HASH_TypeDef;
+
+/** 
+  * @brief HASH_DIGEST
+  */
+  
+typedef struct 
+{
+  __IO uint32_t HR[8];     /*!< HASH digest registers,          Address offset: 0x310-0x32C */ 
+} HASH_DIGEST_TypeDef;
+
+/** 
+  * @brief RNG
+  */
+  
+typedef struct 
+{
+  __IO uint32_t CR;  /*!< RNG control register, Address offset: 0x00 */
+  __IO uint32_t SR;  /*!< RNG status register,  Address offset: 0x04 */
+  __IO uint32_t DR;  /*!< RNG data register,    Address offset: 0x08 */
+} RNG_TypeDef;
+
+/**
+  * @}
+  */
+  
+/** @addtogroup Peripheral_memory_map
+  * @{
+  */
+#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH(up to 1 MB) base address in the alias region                         */
+#define CCMDATARAM_BASE       ((uint32_t)0x10000000) /*!< CCM(core coupled memory) data RAM(64 KB) base address in the alias region  */
+#define SRAM1_BASE            ((uint32_t)0x20000000) /*!< SRAM1(112 KB) base address in the alias region                             */
+#define SRAM2_BASE            ((uint32_t)0x2001C000) /*!< SRAM2(16 KB) base address in the alias region                              */
+#define SRAM3_BASE            ((uint32_t)0x20020000) /*!< SRAM3(64 KB) base address in the alias region                              */
+#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region                                */
+#define BKPSRAM_BASE          ((uint32_t)0x40024000) /*!< Backup SRAM(4 KB) base address in the alias region                         */
+
+#if defined (STM32F40_41xxx)
+#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address                                                */
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define FMC_R_BASE            ((uint32_t)0xA0000000) /*!< FMC registers base address                                                 */
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+#define CCMDATARAM_BB_BASE    ((uint32_t)0x12000000) /*!< CCM(core coupled memory) data RAM(64 KB) base address in the bit-band region  */
+#define SRAM1_BB_BASE         ((uint32_t)0x22000000) /*!< SRAM1(112 KB) base address in the bit-band region                             */
+#define SRAM2_BB_BASE         ((uint32_t)0x2201C000) /*!< SRAM2(16 KB) base address in the bit-band region                              */
+#define SRAM3_BB_BASE         ((uint32_t)0x22400000) /*!< SRAM3(64 KB) base address in the bit-band region                              */
+#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region                                */
+#define BKPSRAM_BB_BASE       ((uint32_t)0x42024000) /*!< Backup SRAM(4 KB) base address in the bit-band region                         */
+
+/* Legacy defines */
+#define SRAM_BASE             SRAM1_BASE
+#define SRAM_BB_BASE          SRAM1_BB_BASE
+
+
+/*!< Peripheral memory map */
+#define APB1PERIPH_BASE       PERIPH_BASE
+#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000)
+#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000)
+#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x10000000)
+
+/*!< APB1 peripherals */
+#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
+#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
+#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
+#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
+#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
+#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
+#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
+#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)
+#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)
+#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
+#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
+#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
+#define I2S2ext_BASE          (APB1PERIPH_BASE + 0x3400)
+#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
+#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
+#define I2S3ext_BASE          (APB1PERIPH_BASE + 0x4000)
+#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
+#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
+#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
+#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
+#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
+#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
+#define I2C3_BASE             (APB1PERIPH_BASE + 0x5C00)
+#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)
+#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800)
+#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
+#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
+#define UART7_BASE            (APB1PERIPH_BASE + 0x7800)
+#define UART8_BASE            (APB1PERIPH_BASE + 0x7C00)
+
+/*!< APB2 peripherals */
+#define TIM1_BASE             (APB2PERIPH_BASE + 0x0000)
+#define TIM8_BASE             (APB2PERIPH_BASE + 0x0400)
+#define USART1_BASE           (APB2PERIPH_BASE + 0x1000)
+#define USART6_BASE           (APB2PERIPH_BASE + 0x1400)
+#define ADC1_BASE             (APB2PERIPH_BASE + 0x2000)
+#define ADC2_BASE             (APB2PERIPH_BASE + 0x2100)
+#define ADC3_BASE             (APB2PERIPH_BASE + 0x2200)
+#define ADC_BASE              (APB2PERIPH_BASE + 0x2300)
+#define SDIO_BASE             (APB2PERIPH_BASE + 0x2C00)
+#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
+#define SPI4_BASE             (APB2PERIPH_BASE + 0x3400)
+#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x3800)
+#define EXTI_BASE             (APB2PERIPH_BASE + 0x3C00)
+#define TIM9_BASE             (APB2PERIPH_BASE + 0x4000)
+#define TIM10_BASE            (APB2PERIPH_BASE + 0x4400)
+#define TIM11_BASE            (APB2PERIPH_BASE + 0x4800)
+#define SPI5_BASE             (APB2PERIPH_BASE + 0x5000)
+#define SPI6_BASE             (APB2PERIPH_BASE + 0x5400)
+#define SAI1_BASE             (APB2PERIPH_BASE + 0x5800)
+#define SAI1_Block_A_BASE     (SAI1_BASE + 0x004)
+#define SAI1_Block_B_BASE     (SAI1_BASE + 0x024)
+#define LTDC_BASE             (APB2PERIPH_BASE + 0x6800)
+#define LTDC_Layer1_BASE      (LTDC_BASE + 0x84)
+#define LTDC_Layer2_BASE      (LTDC_BASE + 0x104) 
+
+/*!< AHB1 peripherals */
+#define GPIOA_BASE            (AHB1PERIPH_BASE + 0x0000)
+#define GPIOB_BASE            (AHB1PERIPH_BASE + 0x0400)
+#define GPIOC_BASE            (AHB1PERIPH_BASE + 0x0800)
+#define GPIOD_BASE            (AHB1PERIPH_BASE + 0x0C00)
+#define GPIOE_BASE            (AHB1PERIPH_BASE + 0x1000)
+#define GPIOF_BASE            (AHB1PERIPH_BASE + 0x1400)
+#define GPIOG_BASE            (AHB1PERIPH_BASE + 0x1800)
+#define GPIOH_BASE            (AHB1PERIPH_BASE + 0x1C00)
+#define GPIOI_BASE            (AHB1PERIPH_BASE + 0x2000)
+#define GPIOJ_BASE            (AHB1PERIPH_BASE + 0x2400)
+#define GPIOK_BASE            (AHB1PERIPH_BASE + 0x2800)
+#define CRC_BASE              (AHB1PERIPH_BASE + 0x3000)
+#define RCC_BASE              (AHB1PERIPH_BASE + 0x3800)
+#define FLASH_R_BASE          (AHB1PERIPH_BASE + 0x3C00)
+#define DMA1_BASE             (AHB1PERIPH_BASE + 0x6000)
+#define DMA1_Stream0_BASE     (DMA1_BASE + 0x010)
+#define DMA1_Stream1_BASE     (DMA1_BASE + 0x028)
+#define DMA1_Stream2_BASE     (DMA1_BASE + 0x040)
+#define DMA1_Stream3_BASE     (DMA1_BASE + 0x058)
+#define DMA1_Stream4_BASE     (DMA1_BASE + 0x070)
+#define DMA1_Stream5_BASE     (DMA1_BASE + 0x088)
+#define DMA1_Stream6_BASE     (DMA1_BASE + 0x0A0)
+#define DMA1_Stream7_BASE     (DMA1_BASE + 0x0B8)
+#define DMA2_BASE             (AHB1PERIPH_BASE + 0x6400)
+#define DMA2_Stream0_BASE     (DMA2_BASE + 0x010)
+#define DMA2_Stream1_BASE     (DMA2_BASE + 0x028)
+#define DMA2_Stream2_BASE     (DMA2_BASE + 0x040)
+#define DMA2_Stream3_BASE     (DMA2_BASE + 0x058)
+#define DMA2_Stream4_BASE     (DMA2_BASE + 0x070)
+#define DMA2_Stream5_BASE     (DMA2_BASE + 0x088)
+#define DMA2_Stream6_BASE     (DMA2_BASE + 0x0A0)
+#define DMA2_Stream7_BASE     (DMA2_BASE + 0x0B8)
+#define ETH_BASE              (AHB1PERIPH_BASE + 0x8000)
+#define ETH_MAC_BASE          (ETH_BASE)
+#define ETH_MMC_BASE          (ETH_BASE + 0x0100)
+#define ETH_PTP_BASE          (ETH_BASE + 0x0700)
+#define ETH_DMA_BASE          (ETH_BASE + 0x1000)
+#define DMA2D_BASE            (AHB1PERIPH_BASE + 0xB000)
+
+/*!< AHB2 peripherals */
+#define DCMI_BASE             (AHB2PERIPH_BASE + 0x50000)
+#define CRYP_BASE             (AHB2PERIPH_BASE + 0x60000)
+#define HASH_BASE             (AHB2PERIPH_BASE + 0x60400)
+#define HASH_DIGEST_BASE      (AHB2PERIPH_BASE + 0x60710)
+#define RNG_BASE              (AHB2PERIPH_BASE + 0x60800)
+
+#if defined (STM32F40_41xxx)
+/*!< FSMC Bankx registers base address */
+#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
+#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
+#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
+#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
+#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+/*!< FMC Bankx registers base address */
+#define FMC_Bank1_R_BASE      (FMC_R_BASE + 0x0000)
+#define FMC_Bank1E_R_BASE     (FMC_R_BASE + 0x0104)
+#define FMC_Bank2_R_BASE      (FMC_R_BASE + 0x0060)
+#define FMC_Bank3_R_BASE      (FMC_R_BASE + 0x0080)
+#define FMC_Bank4_R_BASE      (FMC_R_BASE + 0x00A0)
+#define FMC_Bank5_6_R_BASE    (FMC_R_BASE + 0x0140)
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+/* Debug MCU registers base address */
+#define DBGMCU_BASE           ((uint32_t )0xE0042000)
+
+/**
+  * @}
+  */
+  
+/** @addtogroup Peripheral_declaration
+  * @{
+  */  
+#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
+#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
+#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
+#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
+#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
+#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
+#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
+#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
+#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
+#define RTC                 ((RTC_TypeDef *) RTC_BASE)
+#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
+#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
+#define I2S2ext             ((SPI_TypeDef *) I2S2ext_BASE)
+#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
+#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
+#define I2S3ext             ((SPI_TypeDef *) I2S3ext_BASE)
+#define USART2              ((USART_TypeDef *) USART2_BASE)
+#define USART3              ((USART_TypeDef *) USART3_BASE)
+#define UART4               ((USART_TypeDef *) UART4_BASE)
+#define UART5               ((USART_TypeDef *) UART5_BASE)
+#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
+#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
+#define I2C3                ((I2C_TypeDef *) I2C3_BASE)
+#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
+#define CAN2                ((CAN_TypeDef *) CAN2_BASE)
+#define PWR                 ((PWR_TypeDef *) PWR_BASE)
+#define DAC                 ((DAC_TypeDef *) DAC_BASE)
+#define UART7               ((USART_TypeDef *) UART7_BASE)
+#define UART8               ((USART_TypeDef *) UART8_BASE)
+#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
+#define TIM8                ((TIM_TypeDef *) TIM8_BASE)
+#define USART1              ((USART_TypeDef *) USART1_BASE)
+#define USART6              ((USART_TypeDef *) USART6_BASE)
+#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE)
+#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
+#define ADC2                ((ADC_TypeDef *) ADC2_BASE)
+#define ADC3                ((ADC_TypeDef *) ADC3_BASE)
+#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
+#define SPI1                ((SPI_TypeDef *) SPI1_BASE) 
+#define SPI4                ((SPI_TypeDef *) SPI4_BASE)
+#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
+#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
+#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
+#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
+#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
+#define SPI5                ((SPI_TypeDef *) SPI5_BASE)
+#define SPI6                ((SPI_TypeDef *) SPI6_BASE)
+#define SAI1                ((SAI_TypeDef *) SAI1_BASE)
+#define SAI1_Block_A        ((SAI_Block_TypeDef *)SAI1_Block_A_BASE)
+#define SAI1_Block_B        ((SAI_Block_TypeDef *)SAI1_Block_B_BASE)
+#define LTDC                ((LTDC_TypeDef *)LTDC_BASE)
+#define LTDC_Layer1         ((LTDC_Layer_TypeDef *)LTDC_Layer1_BASE)
+#define LTDC_Layer2         ((LTDC_Layer_TypeDef *)LTDC_Layer2_BASE)
+#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
+#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
+#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
+#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
+#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
+#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
+#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
+#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)
+#define GPIOI               ((GPIO_TypeDef *) GPIOI_BASE)
+#define GPIOJ               ((GPIO_TypeDef *) GPIOJ_BASE)
+#define GPIOK               ((GPIO_TypeDef *) GPIOK_BASE)
+#define CRC                 ((CRC_TypeDef *) CRC_BASE)
+#define RCC                 ((RCC_TypeDef *) RCC_BASE)
+#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
+#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
+#define DMA1_Stream0        ((DMA_Stream_TypeDef *) DMA1_Stream0_BASE)
+#define DMA1_Stream1        ((DMA_Stream_TypeDef *) DMA1_Stream1_BASE)
+#define DMA1_Stream2        ((DMA_Stream_TypeDef *) DMA1_Stream2_BASE)
+#define DMA1_Stream3        ((DMA_Stream_TypeDef *) DMA1_Stream3_BASE)
+#define DMA1_Stream4        ((DMA_Stream_TypeDef *) DMA1_Stream4_BASE)
+#define DMA1_Stream5        ((DMA_Stream_TypeDef *) DMA1_Stream5_BASE)
+#define DMA1_Stream6        ((DMA_Stream_TypeDef *) DMA1_Stream6_BASE)
+#define DMA1_Stream7        ((DMA_Stream_TypeDef *) DMA1_Stream7_BASE)
+#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
+#define DMA2_Stream0        ((DMA_Stream_TypeDef *) DMA2_Stream0_BASE)
+#define DMA2_Stream1        ((DMA_Stream_TypeDef *) DMA2_Stream1_BASE)
+#define DMA2_Stream2        ((DMA_Stream_TypeDef *) DMA2_Stream2_BASE)
+#define DMA2_Stream3        ((DMA_Stream_TypeDef *) DMA2_Stream3_BASE)
+#define DMA2_Stream4        ((DMA_Stream_TypeDef *) DMA2_Stream4_BASE)
+#define DMA2_Stream5        ((DMA_Stream_TypeDef *) DMA2_Stream5_BASE)
+#define DMA2_Stream6        ((DMA_Stream_TypeDef *) DMA2_Stream6_BASE)
+#define DMA2_Stream7        ((DMA_Stream_TypeDef *) DMA2_Stream7_BASE)
+#define ETH                 ((ETH_TypeDef *) ETH_BASE)  
+#define DMA2D               ((DMA2D_TypeDef *)DMA2D_BASE)
+#define DCMI                ((DCMI_TypeDef *) DCMI_BASE)
+#define CRYP                ((CRYP_TypeDef *) CRYP_BASE)
+#define HASH                ((HASH_TypeDef *) HASH_BASE)
+#define HASH_DIGEST         ((HASH_DIGEST_TypeDef *) HASH_DIGEST_BASE)
+#define RNG                 ((RNG_TypeDef *) RNG_BASE)
+
+#if defined (STM32F40_41xxx)
+#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
+#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
+#define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
+#define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
+#define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define FMC_Bank1           ((FMC_Bank1_TypeDef *) FMC_Bank1_R_BASE)
+#define FMC_Bank1E          ((FMC_Bank1E_TypeDef *) FMC_Bank1E_R_BASE)
+#define FMC_Bank2           ((FMC_Bank2_TypeDef *) FMC_Bank2_R_BASE)
+#define FMC_Bank3           ((FMC_Bank3_TypeDef *) FMC_Bank3_R_BASE)
+#define FMC_Bank4           ((FMC_Bank4_TypeDef *) FMC_Bank4_R_BASE)
+#define FMC_Bank5_6         ((FMC_Bank5_6_TypeDef *) FMC_Bank5_6_R_BASE)
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
+
+/**
+  * @}
+  */
+
+/** @addtogroup Exported_constants
+  * @{
+  */
+  
+  /** @addtogroup Peripheral_Registers_Bits_Definition
+  * @{
+  */
+    
+/******************************************************************************/
+/*                         Peripheral Registers_Bits_Definition               */
+/******************************************************************************/
+
+/******************************************************************************/
+/*                                                                            */
+/*                        Analog to Digital Converter                         */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bit definition for ADC_SR register  ********************/
+#define  ADC_SR_AWD                          ((uint8_t)0x01)               /*!<Analog watchdog flag               */
+#define  ADC_SR_EOC                          ((uint8_t)0x02)               /*!<End of conversion                  */
+#define  ADC_SR_JEOC                         ((uint8_t)0x04)               /*!<Injected channel end of conversion */
+#define  ADC_SR_JSTRT                        ((uint8_t)0x08)               /*!<Injected channel Start flag        */
+#define  ADC_SR_STRT                         ((uint8_t)0x10)               /*!<Regular channel Start flag         */
+#define  ADC_SR_OVR                          ((uint8_t)0x20)               /*!<Overrun flag                       */
+
+/*******************  Bit definition for ADC_CR1 register  ********************/
+#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!<AWDCH[4:0] bits (Analog watchdog channel select bits) */
+#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!<Interrupt enable for EOC                              */
+#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!<AAnalog Watchdog interrupt enable                     */
+#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!<Interrupt enable for injected channels                */
+#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!<Scan mode                                             */
+#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!<Enable the watchdog on a single channel in scan mode  */
+#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!<Automatic injected group conversion                   */
+#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!<Discontinuous mode on regular channels                */
+#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!<Discontinuous mode on injected channels               */
+#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!<DISCNUM[2:0] bits (Discontinuous mode channel count)  */
+#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!<Bit 0 */
+#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!<Bit 1 */
+#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!<Bit 2 */
+#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!<Analog watchdog enable on injected channels           */
+#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!<Analog watchdog enable on regular channels            */
+#define  ADC_CR1_RES                         ((uint32_t)0x03000000)        /*!<RES[2:0] bits (Resolution)                            */
+#define  ADC_CR1_RES_0                       ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  ADC_CR1_RES_1                       ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  ADC_CR1_OVRIE                       ((uint32_t)0x04000000)         /*!<overrun interrupt enable                              */
+  
+/*******************  Bit definition for ADC_CR2 register  ********************/
+#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!<A/D Converter ON / OFF             */
+#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!<Continuous Conversion              */
+#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!<Direct Memory access mode          */
+#define  ADC_CR2_DDS                         ((uint32_t)0x00000200)        /*!<DMA disable selection (Single ADC) */
+#define  ADC_CR2_EOCS                        ((uint32_t)0x00000400)        /*!<End of conversion selection        */
+#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!<Data Alignment                     */
+#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x000F0000)        /*!<JEXTSEL[3:0] bits (External event select for injected group) */
+#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  ADC_CR2_JEXTSEL_3                   ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  ADC_CR2_JEXTEN                      ((uint32_t)0x00300000)        /*!<JEXTEN[1:0] bits (External Trigger Conversion mode for injected channelsp) */
+#define  ADC_CR2_JEXTEN_0                    ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  ADC_CR2_JEXTEN_1                    ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00400000)        /*!<Start Conversion of injected channels */
+#define  ADC_CR2_EXTSEL                      ((uint32_t)0x0F000000)        /*!<EXTSEL[3:0] bits (External Event Select for regular group) */
+#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  ADC_CR2_EXTSEL_3                    ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  ADC_CR2_EXTEN                       ((uint32_t)0x30000000)        /*!<EXTEN[1:0] bits (External Trigger Conversion mode for regular channelsp) */
+#define  ADC_CR2_EXTEN_0                     ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  ADC_CR2_EXTEN_1                     ((uint32_t)0x20000000)        /*!<Bit 1 */
+#define  ADC_CR2_SWSTART                     ((uint32_t)0x40000000)        /*!<Start Conversion of regular channels */
+
+/******************  Bit definition for ADC_SMPR1 register  *******************/
+#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)        /*!<SMP10[2:0] bits (Channel 10 Sample time selection) */
+#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)        /*!<SMP11[2:0] bits (Channel 11 Sample time selection) */
+#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)        /*!<Bit 0 */
+#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)        /*!<Bit 1 */
+#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)        /*!<Bit 2 */
+#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)        /*!<SMP12[2:0] bits (Channel 12 Sample time selection) */
+#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)        /*!<Bit 0 */
+#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)        /*!<Bit 1 */
+#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)        /*!<Bit 2 */
+#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)        /*!<SMP13[2:0] bits (Channel 13 Sample time selection) */
+#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)        /*!<Bit 0 */
+#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)        /*!<Bit 1 */
+#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)        /*!<Bit 2 */
+#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)        /*!<SMP14[2:0] bits (Channel 14 Sample time selection) */
+#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)        /*!<Bit 0 */
+#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)        /*!<Bit 1 */
+#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)        /*!<Bit 2 */
+#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)        /*!<SMP15[2:0] bits (Channel 15 Sample time selection) */
+#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!<Bit 0 */
+#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!<Bit 1 */
+#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!<Bit 2 */
+#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!<SMP16[2:0] bits (Channel 16 Sample time selection) */
+#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!<Bit 0 */
+#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!<Bit 1 */
+#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!<Bit 2 */
+#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!<SMP17[2:0] bits (Channel 17 Sample time selection) */
+#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!<Bit 0 */
+#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!<Bit 1 */
+#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!<Bit 2 */
+#define  ADC_SMPR1_SMP18                     ((uint32_t)0x07000000)        /*!<SMP18[2:0] bits (Channel 18 Sample time selection) */
+#define  ADC_SMPR1_SMP18_0                   ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  ADC_SMPR1_SMP18_1                   ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  ADC_SMPR1_SMP18_2                   ((uint32_t)0x04000000)        /*!<Bit 2 */
+
+/******************  Bit definition for ADC_SMPR2 register  *******************/
+#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!<SMP0[2:0] bits (Channel 0 Sample time selection) */
+#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!<SMP1[2:0] bits (Channel 1 Sample time selection) */
+#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!<Bit 2 */
+#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!<SMP2[2:0] bits (Channel 2 Sample time selection) */
+#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!<Bit 2 */
+#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!<SMP3[2:0] bits (Channel 3 Sample time selection) */
+#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
+#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!<SMP4[2:0] bits (Channel 4 Sample time selection) */
+#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!<Bit 2 */
+#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!<SMP5[2:0] bits (Channel 5 Sample time selection) */
+#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!<Bit 2 */
+#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!<SMP6[2:0] bits (Channel 6 Sample time selection) */
+#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!<Bit 2 */
+#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!<SMP7[2:0] bits (Channel 7 Sample time selection) */
+#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!<Bit 2 */
+#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!<SMP8[2:0] bits (Channel 8 Sample time selection) */
+#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!<SMP9[2:0] bits (Channel 9 Sample time selection) */
+#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!<Bit 0 */
+#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!<Bit 1 */
+#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!<Bit 2 */
+
+/******************  Bit definition for ADC_JOFR1 register  *******************/
+#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 1 */
+
+/******************  Bit definition for ADC_JOFR2 register  *******************/
+#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 2 */
+
+/******************  Bit definition for ADC_JOFR3 register  *******************/
+#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 3 */
+
+/******************  Bit definition for ADC_JOFR4 register  *******************/
+#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 4 */
+
+/*******************  Bit definition for ADC_HTR register  ********************/
+#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!<Analog watchdog high threshold */
+
+/*******************  Bit definition for ADC_LTR register  ********************/
+#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!<Analog watchdog low threshold */
+
+/*******************  Bit definition for ADC_SQR1 register  *******************/
+#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!<SQ13[4:0] bits (13th conversion in regular sequence) */
+#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!<SQ14[4:0] bits (14th conversion in regular sequence) */
+#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!<Bit 0 */
+#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!<Bit 1 */
+#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!<Bit 2 */
+#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!<Bit 3 */
+#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!<Bit 4 */
+#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!<SQ15[4:0] bits (15th conversion in regular sequence) */
+#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!<Bit 0 */
+#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!<Bit 1 */
+#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!<Bit 2 */
+#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!<Bit 3 */
+#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!<Bit 4 */
+#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!<SQ16[4:0] bits (16th conversion in regular sequence) */
+#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!<Bit 0 */
+#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!<Bit 1 */
+#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!<Bit 2 */
+#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!<Bit 3 */
+#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!<Bit 4 */
+#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!<L[3:0] bits (Regular channel sequence length) */
+#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+/*******************  Bit definition for ADC_SQR2 register  *******************/
+#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!<SQ7[4:0] bits (7th conversion in regular sequence) */
+#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!<SQ8[4:0] bits (8th conversion in regular sequence) */
+#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!<Bit 0 */
+#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!<Bit 1 */
+#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!<Bit 2 */
+#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!<Bit 3 */
+#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!<Bit 4 */
+#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!<SQ9[4:0] bits (9th conversion in regular sequence) */
+#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!<Bit 0 */
+#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!<Bit 1 */
+#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!<Bit 2 */
+#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!<Bit 3 */
+#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!<Bit 4 */
+#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!<SQ10[4:0] bits (10th conversion in regular sequence) */
+#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!<Bit 0 */
+#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!<Bit 1 */
+#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!<Bit 2 */
+#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!<Bit 3 */
+#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!<Bit 4 */
+#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!<SQ11[4:0] bits (11th conversion in regular sequence) */
+#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!<Bit 3 */
+#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!<Bit 4 */
+#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!<SQ12[4:0] bits (12th conversion in regular sequence) */
+#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!<Bit 0 */
+#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!<Bit 1 */
+#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!<Bit 2 */
+#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!<Bit 3 */
+#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!<Bit 4 */
+
+/*******************  Bit definition for ADC_SQR3 register  *******************/
+#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!<SQ1[4:0] bits (1st conversion in regular sequence) */
+#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!<SQ2[4:0] bits (2nd conversion in regular sequence) */
+#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!<Bit 0 */
+#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!<Bit 1 */
+#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!<Bit 2 */
+#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!<Bit 3 */
+#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!<Bit 4 */
+#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!<SQ3[4:0] bits (3rd conversion in regular sequence) */
+#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!<Bit 0 */
+#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!<Bit 1 */
+#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!<Bit 2 */
+#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!<Bit 3 */
+#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!<Bit 4 */
+#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!<SQ4[4:0] bits (4th conversion in regular sequence) */
+#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!<Bit 0 */
+#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!<Bit 1 */
+#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!<Bit 2 */
+#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!<Bit 3 */
+#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!<Bit 4 */
+#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!<SQ5[4:0] bits (5th conversion in regular sequence) */
+#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!<Bit 3 */
+#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!<Bit 4 */
+#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!<SQ6[4:0] bits (6th conversion in regular sequence) */
+#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!<Bit 0 */
+#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!<Bit 1 */
+#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!<Bit 2 */
+#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!<Bit 3 */
+#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!<Bit 4 */
+
+/*******************  Bit definition for ADC_JSQR register  *******************/
+#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!<JSQ1[4:0] bits (1st conversion in injected sequence) */  
+#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!<JSQ2[4:0] bits (2nd conversion in injected sequence) */
+#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!<Bit 0 */
+#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!<Bit 1 */
+#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!<Bit 2 */
+#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!<Bit 3 */
+#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!<Bit 4 */
+#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!<JSQ3[4:0] bits (3rd conversion in injected sequence) */
+#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!<Bit 0 */
+#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!<Bit 1 */
+#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!<Bit 2 */
+#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!<Bit 3 */
+#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!<Bit 4 */
+#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!<JSQ4[4:0] bits (4th conversion in injected sequence) */
+#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!<Bit 0 */
+#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!<Bit 1 */
+#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!<Bit 2 */
+#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!<Bit 3 */
+#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!<Bit 4 */
+#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!<JL[1:0] bits (Injected Sequence length) */
+#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!<Bit 1 */
+
+/*******************  Bit definition for ADC_JDR1 register  *******************/
+#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
+
+/*******************  Bit definition for ADC_JDR2 register  *******************/
+#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
+
+/*******************  Bit definition for ADC_JDR3 register  *******************/
+#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
+
+/*******************  Bit definition for ADC_JDR4 register  *******************/
+#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
+
+/********************  Bit definition for ADC_DR register  ********************/
+#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!<Regular data */
+#define  ADC_DR_ADC2DATA                     ((uint32_t)0xFFFF0000)        /*!<ADC2 data */
+
+/*******************  Bit definition for ADC_CSR register  ********************/
+#define  ADC_CSR_AWD1                        ((uint32_t)0x00000001)        /*!<ADC1 Analog watchdog flag */
+#define  ADC_CSR_EOC1                        ((uint32_t)0x00000002)        /*!<ADC1 End of conversion */
+#define  ADC_CSR_JEOC1                       ((uint32_t)0x00000004)        /*!<ADC1 Injected channel end of conversion */
+#define  ADC_CSR_JSTRT1                      ((uint32_t)0x00000008)        /*!<ADC1 Injected channel Start flag */
+#define  ADC_CSR_STRT1                       ((uint32_t)0x00000010)        /*!<ADC1 Regular channel Start flag */
+#define  ADC_CSR_DOVR1                       ((uint32_t)0x00000020)        /*!<ADC1 DMA overrun  flag */
+#define  ADC_CSR_AWD2                        ((uint32_t)0x00000100)        /*!<ADC2 Analog watchdog flag */
+#define  ADC_CSR_EOC2                        ((uint32_t)0x00000200)        /*!<ADC2 End of conversion */
+#define  ADC_CSR_JEOC2                       ((uint32_t)0x00000400)        /*!<ADC2 Injected channel end of conversion */
+#define  ADC_CSR_JSTRT2                      ((uint32_t)0x00000800)        /*!<ADC2 Injected channel Start flag */
+#define  ADC_CSR_STRT2                       ((uint32_t)0x00001000)        /*!<ADC2 Regular channel Start flag */
+#define  ADC_CSR_DOVR2                       ((uint32_t)0x00002000)        /*!<ADC2 DMA overrun  flag */
+#define  ADC_CSR_AWD3                        ((uint32_t)0x00010000)        /*!<ADC3 Analog watchdog flag */
+#define  ADC_CSR_EOC3                        ((uint32_t)0x00020000)        /*!<ADC3 End of conversion */
+#define  ADC_CSR_JEOC3                       ((uint32_t)0x00040000)        /*!<ADC3 Injected channel end of conversion */
+#define  ADC_CSR_JSTRT3                      ((uint32_t)0x00080000)        /*!<ADC3 Injected channel Start flag */
+#define  ADC_CSR_STRT3                       ((uint32_t)0x00100000)        /*!<ADC3 Regular channel Start flag */
+#define  ADC_CSR_DOVR3                       ((uint32_t)0x00200000)        /*!<ADC3 DMA overrun  flag */
+
+/*******************  Bit definition for ADC_CCR register  ********************/
+#define  ADC_CCR_MULTI                       ((uint32_t)0x0000001F)        /*!<MULTI[4:0] bits (Multi-ADC mode selection) */  
+#define  ADC_CCR_MULTI_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  ADC_CCR_MULTI_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  ADC_CCR_MULTI_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  ADC_CCR_MULTI_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  ADC_CCR_MULTI_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  ADC_CCR_DELAY                       ((uint32_t)0x00000F00)        /*!<DELAY[3:0] bits (Delay between 2 sampling phases) */  
+#define  ADC_CCR_DELAY_0                     ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  ADC_CCR_DELAY_1                     ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  ADC_CCR_DELAY_2                     ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  ADC_CCR_DELAY_3                     ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  ADC_CCR_DDS                         ((uint32_t)0x00002000)        /*!<DMA disable selection (Multi-ADC mode) */
+#define  ADC_CCR_DMA                         ((uint32_t)0x0000C000)        /*!<DMA[1:0] bits (Direct Memory Access mode for multimode) */  
+#define  ADC_CCR_DMA_0                       ((uint32_t)0x00004000)        /*!<Bit 0 */
+#define  ADC_CCR_DMA_1                       ((uint32_t)0x00008000)        /*!<Bit 1 */
+#define  ADC_CCR_ADCPRE                      ((uint32_t)0x00030000)        /*!<ADCPRE[1:0] bits (ADC prescaler) */  
+#define  ADC_CCR_ADCPRE_0                    ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  ADC_CCR_ADCPRE_1                    ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  ADC_CCR_VBATE                       ((uint32_t)0x00400000)        /*!<VBAT Enable */
+#define  ADC_CCR_TSVREFE                     ((uint32_t)0x00800000)        /*!<Temperature Sensor and VREFINT Enable */
+
+/*******************  Bit definition for ADC_CDR register  ********************/
+#define  ADC_CDR_DATA1                      ((uint32_t)0x0000FFFF)         /*!<1st data of a pair of regular conversions */
+#define  ADC_CDR_DATA2                      ((uint32_t)0xFFFF0000)         /*!<2nd data of a pair of regular conversions */
+
+/******************************************************************************/
+/*                                                                            */
+/*                         Controller Area Network                            */
+/*                                                                            */
+/******************************************************************************/
+/*!<CAN control and status registers */
+/*******************  Bit definition for CAN_MCR register  ********************/
+#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!<Initialization Request */
+#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!<Sleep Mode Request */
+#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!<Transmit FIFO Priority */
+#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!<Receive FIFO Locked Mode */
+#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!<No Automatic Retransmission */
+#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!<Automatic Wakeup Mode */
+#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!<Automatic Bus-Off Management */
+#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!<Time Triggered Communication Mode */
+#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!<bxCAN software master reset */
+
+/*******************  Bit definition for CAN_MSR register  ********************/
+#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!<Initialization Acknowledge */
+#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!<Sleep Acknowledge */
+#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!<Error Interrupt */
+#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!<Wakeup Interrupt */
+#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!<Sleep Acknowledge Interrupt */
+#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!<Transmit Mode */
+#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!<Receive Mode */
+#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!<Last Sample Point */
+#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!<CAN Rx Signal */
+
+/*******************  Bit definition for CAN_TSR register  ********************/
+#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!<Request Completed Mailbox0 */
+#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!<Transmission OK of Mailbox0 */
+#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!<Arbitration Lost for Mailbox0 */
+#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!<Transmission Error of Mailbox0 */
+#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!<Abort Request for Mailbox0 */
+#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!<Request Completed Mailbox1 */
+#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!<Transmission OK of Mailbox1 */
+#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!<Arbitration Lost for Mailbox1 */
+#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!<Transmission Error of Mailbox1 */
+#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!<Abort Request for Mailbox 1 */
+#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!<Request Completed Mailbox2 */
+#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!<Transmission OK of Mailbox 2 */
+#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!<Arbitration Lost for mailbox 2 */
+#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!<Transmission Error of Mailbox 2 */
+#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!<Abort Request for Mailbox 2 */
+#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!<Mailbox Code */
+
+#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!<TME[2:0] bits */
+#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!<Transmit Mailbox 0 Empty */
+#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!<Transmit Mailbox 1 Empty */
+#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!<Transmit Mailbox 2 Empty */
+
+#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!<LOW[2:0] bits */
+#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!<Lowest Priority Flag for Mailbox 0 */
+#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!<Lowest Priority Flag for Mailbox 1 */
+#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!<Lowest Priority Flag for Mailbox 2 */
+
+/*******************  Bit definition for CAN_RF0R register  *******************/
+#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!<FIFO 0 Message Pending */
+#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!<FIFO 0 Full */
+#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!<FIFO 0 Overrun */
+#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!<Release FIFO 0 Output Mailbox */
+
+/*******************  Bit definition for CAN_RF1R register  *******************/
+#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!<FIFO 1 Message Pending */
+#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!<FIFO 1 Full */
+#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!<FIFO 1 Overrun */
+#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!<Release FIFO 1 Output Mailbox */
+
+/********************  Bit definition for CAN_IER register  *******************/
+#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Empty Interrupt Enable */
+#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!<FIFO Message Pending Interrupt Enable */
+#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!<FIFO Full Interrupt Enable */
+#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!<FIFO Overrun Interrupt Enable */
+#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!<FIFO Message Pending Interrupt Enable */
+#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!<FIFO Full Interrupt Enable */
+#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!<FIFO Overrun Interrupt Enable */
+#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!<Error Warning Interrupt Enable */
+#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!<Error Passive Interrupt Enable */
+#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!<Bus-Off Interrupt Enable */
+#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!<Last Error Code Interrupt Enable */
+#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!<Error Interrupt Enable */
+#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!<Wakeup Interrupt Enable */
+#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!<Sleep Interrupt Enable */
+
+/********************  Bit definition for CAN_ESR register  *******************/
+#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!<Error Warning Flag */
+#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!<Error Passive Flag */
+#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!<Bus-Off Flag */
+
+#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!<LEC[2:0] bits (Last Error Code) */
+#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!<Bit 2 */
+
+#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!<Least significant byte of the 9-bit Transmit Error Counter */
+#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!<Receive Error Counter */
+
+/*******************  Bit definition for CAN_BTR register  ********************/
+#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!<Baud Rate Prescaler */
+#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!<Time Segment 1 */
+#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!<Time Segment 2 */
+#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!<Resynchronization Jump Width */
+#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!<Loop Back Mode (Debug) */
+#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!<Silent Mode */
+
+/*!<Mailbox registers */
+/******************  Bit definition for CAN_TI0R register  ********************/
+#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
+#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
+#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
+#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
+#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
+
+/******************  Bit definition for CAN_TDT0R register  *******************/
+#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
+#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
+#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
+
+/******************  Bit definition for CAN_TDL0R register  *******************/
+#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
+#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
+#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
+#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
+
+/******************  Bit definition for CAN_TDH0R register  *******************/
+#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
+#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
+#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
+#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
+
+/*******************  Bit definition for CAN_TI1R register  *******************/
+#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
+#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
+#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
+#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
+#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
+
+/*******************  Bit definition for CAN_TDT1R register  ******************/
+#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
+#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
+#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
+
+/*******************  Bit definition for CAN_TDL1R register  ******************/
+#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
+#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
+#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
+#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
+
+/*******************  Bit definition for CAN_TDH1R register  ******************/
+#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
+#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
+#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
+#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
+
+/*******************  Bit definition for CAN_TI2R register  *******************/
+#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
+#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
+#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
+#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
+#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
+
+/*******************  Bit definition for CAN_TDT2R register  ******************/  
+#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
+#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
+#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
+
+/*******************  Bit definition for CAN_TDL2R register  ******************/
+#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
+#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
+#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
+#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
+
+/*******************  Bit definition for CAN_TDH2R register  ******************/
+#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
+#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
+#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
+#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
+
+/*******************  Bit definition for CAN_RI0R register  *******************/
+#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
+#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
+#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
+#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
+
+/*******************  Bit definition for CAN_RDT0R register  ******************/
+#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
+#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
+#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
+
+/*******************  Bit definition for CAN_RDL0R register  ******************/
+#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
+#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
+#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
+#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
+
+/*******************  Bit definition for CAN_RDH0R register  ******************/
+#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
+#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
+#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
+#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
+
+/*******************  Bit definition for CAN_RI1R register  *******************/
+#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
+#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
+#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
+#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
+
+/*******************  Bit definition for CAN_RDT1R register  ******************/
+#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
+#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
+#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
+
+/*******************  Bit definition for CAN_RDL1R register  ******************/
+#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
+#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
+#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
+#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
+
+/*******************  Bit definition for CAN_RDH1R register  ******************/
+#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
+#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
+#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
+#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
+
+/*!<CAN filter registers */
+/*******************  Bit definition for CAN_FMR register  ********************/
+#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!<Filter Init Mode */
+
+/*******************  Bit definition for CAN_FM1R register  *******************/
+#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!<Filter Mode */
+#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!<Filter Init Mode bit 0 */
+#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!<Filter Init Mode bit 1 */
+#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!<Filter Init Mode bit 2 */
+#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!<Filter Init Mode bit 3 */
+#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!<Filter Init Mode bit 4 */
+#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!<Filter Init Mode bit 5 */
+#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!<Filter Init Mode bit 6 */
+#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!<Filter Init Mode bit 7 */
+#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!<Filter Init Mode bit 8 */
+#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!<Filter Init Mode bit 9 */
+#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!<Filter Init Mode bit 10 */
+#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!<Filter Init Mode bit 11 */
+#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!<Filter Init Mode bit 12 */
+#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!<Filter Init Mode bit 13 */
+
+/*******************  Bit definition for CAN_FS1R register  *******************/
+#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!<Filter Scale Configuration */
+#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!<Filter Scale Configuration bit 0 */
+#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!<Filter Scale Configuration bit 1 */
+#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!<Filter Scale Configuration bit 2 */
+#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!<Filter Scale Configuration bit 3 */
+#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!<Filter Scale Configuration bit 4 */
+#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!<Filter Scale Configuration bit 5 */
+#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!<Filter Scale Configuration bit 6 */
+#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!<Filter Scale Configuration bit 7 */
+#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!<Filter Scale Configuration bit 8 */
+#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!<Filter Scale Configuration bit 9 */
+#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!<Filter Scale Configuration bit 10 */
+#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!<Filter Scale Configuration bit 11 */
+#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!<Filter Scale Configuration bit 12 */
+#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!<Filter Scale Configuration bit 13 */
+
+/******************  Bit definition for CAN_FFA1R register  *******************/
+#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!<Filter FIFO Assignment */
+#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!<Filter FIFO Assignment for Filter 0 */
+#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!<Filter FIFO Assignment for Filter 1 */
+#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!<Filter FIFO Assignment for Filter 2 */
+#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!<Filter FIFO Assignment for Filter 3 */
+#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!<Filter FIFO Assignment for Filter 4 */
+#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!<Filter FIFO Assignment for Filter 5 */
+#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!<Filter FIFO Assignment for Filter 6 */
+#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!<Filter FIFO Assignment for Filter 7 */
+#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!<Filter FIFO Assignment for Filter 8 */
+#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!<Filter FIFO Assignment for Filter 9 */
+#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!<Filter FIFO Assignment for Filter 10 */
+#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!<Filter FIFO Assignment for Filter 11 */
+#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!<Filter FIFO Assignment for Filter 12 */
+#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!<Filter FIFO Assignment for Filter 13 */
+
+/*******************  Bit definition for CAN_FA1R register  *******************/
+#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!<Filter Active */
+#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!<Filter 0 Active */
+#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!<Filter 1 Active */
+#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!<Filter 2 Active */
+#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!<Filter 3 Active */
+#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!<Filter 4 Active */
+#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!<Filter 5 Active */
+#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!<Filter 6 Active */
+#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!<Filter 7 Active */
+#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!<Filter 8 Active */
+#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!<Filter 9 Active */
+#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!<Filter 10 Active */
+#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!<Filter 11 Active */
+#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!<Filter 12 Active */
+#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!<Filter 13 Active */
+
+/*******************  Bit definition for CAN_F0R1 register  *******************/
+#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F1R1 register  *******************/
+#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F2R1 register  *******************/
+#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F3R1 register  *******************/
+#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F4R1 register  *******************/
+#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F5R1 register  *******************/
+#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F6R1 register  *******************/
+#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F7R1 register  *******************/
+#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F8R1 register  *******************/
+#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F9R1 register  *******************/
+#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F10R1 register  ******************/
+#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F11R1 register  ******************/
+#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F12R1 register  ******************/
+#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F13R1 register  ******************/
+#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F0R2 register  *******************/
+#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F1R2 register  *******************/
+#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F2R2 register  *******************/
+#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F3R2 register  *******************/
+#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F4R2 register  *******************/
+#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F5R2 register  *******************/
+#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F6R2 register  *******************/
+#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F7R2 register  *******************/
+#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F8R2 register  *******************/
+#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F9R2 register  *******************/
+#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F10R2 register  ******************/
+#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F11R2 register  ******************/
+#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F12R2 register  ******************/
+#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/*******************  Bit definition for CAN_F13R2 register  ******************/
+#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
+#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
+#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
+#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
+#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
+#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
+#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
+#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
+#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
+#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
+#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
+#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
+#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
+#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
+#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
+#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
+#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
+#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
+#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
+#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
+#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
+#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
+#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
+#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
+#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
+#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
+#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
+#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
+#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
+#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
+#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
+#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
+
+/******************************************************************************/
+/*                                                                            */
+/*                          CRC calculation unit                              */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bit definition for CRC_DR register  *********************/
+#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
+
+
+/*******************  Bit definition for CRC_IDR register  ********************/
+#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
+
+
+/********************  Bit definition for CRC_CR register  ********************/
+#define  CRC_CR_RESET                        ((uint8_t)0x01)        /*!< RESET bit */
+
+/******************************************************************************/
+/*                                                                            */
+/*                            Crypto Processor                                */
+/*                                                                            */
+/******************************************************************************/
+/******************* Bits definition for CRYP_CR register  ********************/
+#define CRYP_CR_ALGODIR                      ((uint32_t)0x00000004)
+
+#define CRYP_CR_ALGOMODE                     ((uint32_t)0x00080038)
+#define CRYP_CR_ALGOMODE_0                   ((uint32_t)0x00000008)
+#define CRYP_CR_ALGOMODE_1                   ((uint32_t)0x00000010)
+#define CRYP_CR_ALGOMODE_2                   ((uint32_t)0x00000020)
+#define CRYP_CR_ALGOMODE_TDES_ECB            ((uint32_t)0x00000000)
+#define CRYP_CR_ALGOMODE_TDES_CBC            ((uint32_t)0x00000008)
+#define CRYP_CR_ALGOMODE_DES_ECB             ((uint32_t)0x00000010)
+#define CRYP_CR_ALGOMODE_DES_CBC             ((uint32_t)0x00000018)
+#define CRYP_CR_ALGOMODE_AES_ECB             ((uint32_t)0x00000020)
+#define CRYP_CR_ALGOMODE_AES_CBC             ((uint32_t)0x00000028)
+#define CRYP_CR_ALGOMODE_AES_CTR             ((uint32_t)0x00000030)
+#define CRYP_CR_ALGOMODE_AES_KEY             ((uint32_t)0x00000038)
+
+#define CRYP_CR_DATATYPE                     ((uint32_t)0x000000C0)
+#define CRYP_CR_DATATYPE_0                   ((uint32_t)0x00000040)
+#define CRYP_CR_DATATYPE_1                   ((uint32_t)0x00000080)
+#define CRYP_CR_KEYSIZE                      ((uint32_t)0x00000300)
+#define CRYP_CR_KEYSIZE_0                    ((uint32_t)0x00000100)
+#define CRYP_CR_KEYSIZE_1                    ((uint32_t)0x00000200)
+#define CRYP_CR_FFLUSH                       ((uint32_t)0x00004000)
+#define CRYP_CR_CRYPEN                       ((uint32_t)0x00008000)
+
+#define CRYP_CR_GCM_CCMPH                    ((uint32_t)0x00030000)
+#define CRYP_CR_GCM_CCMPH_0                  ((uint32_t)0x00010000)
+#define CRYP_CR_GCM_CCMPH_1                  ((uint32_t)0x00020000)
+#define CRYP_CR_ALGOMODE_3                   ((uint32_t)0x00080000) 
+
+/****************** Bits definition for CRYP_SR register  *********************/
+#define CRYP_SR_IFEM                         ((uint32_t)0x00000001)
+#define CRYP_SR_IFNF                         ((uint32_t)0x00000002)
+#define CRYP_SR_OFNE                         ((uint32_t)0x00000004)
+#define CRYP_SR_OFFU                         ((uint32_t)0x00000008)
+#define CRYP_SR_BUSY                         ((uint32_t)0x00000010)
+/****************** Bits definition for CRYP_DMACR register  ******************/
+#define CRYP_DMACR_DIEN                      ((uint32_t)0x00000001)
+#define CRYP_DMACR_DOEN                      ((uint32_t)0x00000002)
+/*****************  Bits definition for CRYP_IMSCR register  ******************/
+#define CRYP_IMSCR_INIM                      ((uint32_t)0x00000001)
+#define CRYP_IMSCR_OUTIM                     ((uint32_t)0x00000002)
+/****************** Bits definition for CRYP_RISR register  *******************/
+#define CRYP_RISR_OUTRIS                     ((uint32_t)0x00000001)
+#define CRYP_RISR_INRIS                      ((uint32_t)0x00000002)
+/****************** Bits definition for CRYP_MISR register  *******************/
+#define CRYP_MISR_INMIS                      ((uint32_t)0x00000001)
+#define CRYP_MISR_OUTMIS                     ((uint32_t)0x00000002)
+
+/******************************************************************************/
+/*                                                                            */
+/*                      Digital to Analog Converter                           */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bit definition for DAC_CR register  ********************/
+#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!<DAC channel1 enable */
+#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!<DAC channel1 output buffer disable */
+#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!<DAC channel1 Trigger enable */
+
+#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!<TSEL1[2:0] (DAC channel1 Trigger selection) */
+#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!<Bit 0 */
+#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!<Bit 1 */
+#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!<Bit 2 */
+
+#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!<WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
+#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!<Bit 0 */
+#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!<Bit 1 */
+
+#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!<MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
+#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!<DAC channel1 DMA enable */
+#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!<DAC channel2 enable */
+#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!<DAC channel2 output buffer disable */
+#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!<DAC channel2 Trigger enable */
+
+#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!<TSEL2[2:0] (DAC channel2 Trigger selection) */
+#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!<Bit 0 */
+#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!<Bit 1 */
+#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!<Bit 2 */
+
+#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!<WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
+#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!<Bit 0 */
+#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!<Bit 1 */
+
+#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!<MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
+#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!<DAC channel2 DMA enabled */
+
+/*****************  Bit definition for DAC_SWTRIGR register  ******************/
+#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!<DAC channel1 software trigger */
+#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!<DAC channel2 software trigger */
+
+/*****************  Bit definition for DAC_DHR12R1 register  ******************/
+#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!<DAC channel1 12-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12L1 register  ******************/
+#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!<DAC channel1 12-bit Left aligned data */
+
+/******************  Bit definition for DAC_DHR8R1 register  ******************/
+#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!<DAC channel1 8-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12R2 register  ******************/
+#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!<DAC channel2 12-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12L2 register  ******************/
+#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!<DAC channel2 12-bit Left aligned data */
+
+/******************  Bit definition for DAC_DHR8R2 register  ******************/
+#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!<DAC channel2 8-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12RD register  ******************/
+#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!<DAC channel1 12-bit Right aligned data */
+#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!<DAC channel2 12-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12LD register  ******************/
+#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!<DAC channel1 12-bit Left aligned data */
+#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!<DAC channel2 12-bit Left aligned data */
+
+/******************  Bit definition for DAC_DHR8RD register  ******************/
+#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!<DAC channel1 8-bit Right aligned data */
+#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!<DAC channel2 8-bit Right aligned data */
+
+/*******************  Bit definition for DAC_DOR1 register  *******************/
+#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel1 data output */
+
+/*******************  Bit definition for DAC_DOR2 register  *******************/
+#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel2 data output */
+
+/********************  Bit definition for DAC_SR register  ********************/
+#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!<DAC channel1 DMA underrun flag */
+#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!<DAC channel2 DMA underrun flag */
+
+/******************************************************************************/
+/*                                                                            */
+/*                                 Debug MCU                                  */
+/*                                                                            */
+/******************************************************************************/
+
+/******************************************************************************/
+/*                                                                            */
+/*                                    DCMI                                    */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bits definition for DCMI_CR register  ******************/
+#define DCMI_CR_CAPTURE                      ((uint32_t)0x00000001)
+#define DCMI_CR_CM                           ((uint32_t)0x00000002)
+#define DCMI_CR_CROP                         ((uint32_t)0x00000004)
+#define DCMI_CR_JPEG                         ((uint32_t)0x00000008)
+#define DCMI_CR_ESS                          ((uint32_t)0x00000010)
+#define DCMI_CR_PCKPOL                       ((uint32_t)0x00000020)
+#define DCMI_CR_HSPOL                        ((uint32_t)0x00000040)
+#define DCMI_CR_VSPOL                        ((uint32_t)0x00000080)
+#define DCMI_CR_FCRC_0                       ((uint32_t)0x00000100)
+#define DCMI_CR_FCRC_1                       ((uint32_t)0x00000200)
+#define DCMI_CR_EDM_0                        ((uint32_t)0x00000400)
+#define DCMI_CR_EDM_1                        ((uint32_t)0x00000800)
+#define DCMI_CR_CRE                          ((uint32_t)0x00001000)
+#define DCMI_CR_ENABLE                       ((uint32_t)0x00004000)
+
+/********************  Bits definition for DCMI_SR register  ******************/
+#define DCMI_SR_HSYNC                        ((uint32_t)0x00000001)
+#define DCMI_SR_VSYNC                        ((uint32_t)0x00000002)
+#define DCMI_SR_FNE                          ((uint32_t)0x00000004)
+
+/********************  Bits definition for DCMI_RISR register  ****************/
+#define DCMI_RISR_FRAME_RIS                  ((uint32_t)0x00000001)
+#define DCMI_RISR_OVF_RIS                    ((uint32_t)0x00000002)
+#define DCMI_RISR_ERR_RIS                    ((uint32_t)0x00000004)
+#define DCMI_RISR_VSYNC_RIS                  ((uint32_t)0x00000008)
+#define DCMI_RISR_LINE_RIS                   ((uint32_t)0x00000010)
+
+/********************  Bits definition for DCMI_IER register  *****************/
+#define DCMI_IER_FRAME_IE                    ((uint32_t)0x00000001)
+#define DCMI_IER_OVF_IE                      ((uint32_t)0x00000002)
+#define DCMI_IER_ERR_IE                      ((uint32_t)0x00000004)
+#define DCMI_IER_VSYNC_IE                    ((uint32_t)0x00000008)
+#define DCMI_IER_LINE_IE                     ((uint32_t)0x00000010)
+
+/********************  Bits definition for DCMI_MISR register  ****************/
+#define DCMI_MISR_FRAME_MIS                  ((uint32_t)0x00000001)
+#define DCMI_MISR_OVF_MIS                    ((uint32_t)0x00000002)
+#define DCMI_MISR_ERR_MIS                    ((uint32_t)0x00000004)
+#define DCMI_MISR_VSYNC_MIS                  ((uint32_t)0x00000008)
+#define DCMI_MISR_LINE_MIS                   ((uint32_t)0x00000010)
+
+/********************  Bits definition for DCMI_ICR register  *****************/
+#define DCMI_ICR_FRAME_ISC                   ((uint32_t)0x00000001)
+#define DCMI_ICR_OVF_ISC                     ((uint32_t)0x00000002)
+#define DCMI_ICR_ERR_ISC                     ((uint32_t)0x00000004)
+#define DCMI_ICR_VSYNC_ISC                   ((uint32_t)0x00000008)
+#define DCMI_ICR_LINE_ISC                    ((uint32_t)0x00000010)
+
+/******************************************************************************/
+/*                                                                            */
+/*                             DMA Controller                                 */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bits definition for DMA_SxCR register  *****************/ 
+#define DMA_SxCR_CHSEL                       ((uint32_t)0x0E000000)
+#define DMA_SxCR_CHSEL_0                     ((uint32_t)0x02000000)
+#define DMA_SxCR_CHSEL_1                     ((uint32_t)0x04000000)
+#define DMA_SxCR_CHSEL_2                     ((uint32_t)0x08000000) 
+#define DMA_SxCR_MBURST                      ((uint32_t)0x01800000)
+#define DMA_SxCR_MBURST_0                    ((uint32_t)0x00800000)
+#define DMA_SxCR_MBURST_1                    ((uint32_t)0x01000000)
+#define DMA_SxCR_PBURST                      ((uint32_t)0x00600000)
+#define DMA_SxCR_PBURST_0                    ((uint32_t)0x00200000)
+#define DMA_SxCR_PBURST_1                    ((uint32_t)0x00400000)
+#define DMA_SxCR_ACK                         ((uint32_t)0x00100000)
+#define DMA_SxCR_CT                          ((uint32_t)0x00080000)  
+#define DMA_SxCR_DBM                         ((uint32_t)0x00040000)
+#define DMA_SxCR_PL                          ((uint32_t)0x00030000)
+#define DMA_SxCR_PL_0                        ((uint32_t)0x00010000)
+#define DMA_SxCR_PL_1                        ((uint32_t)0x00020000)
+#define DMA_SxCR_PINCOS                      ((uint32_t)0x00008000)
+#define DMA_SxCR_MSIZE                       ((uint32_t)0x00006000)
+#define DMA_SxCR_MSIZE_0                     ((uint32_t)0x00002000)
+#define DMA_SxCR_MSIZE_1                     ((uint32_t)0x00004000)
+#define DMA_SxCR_PSIZE                       ((uint32_t)0x00001800)
+#define DMA_SxCR_PSIZE_0                     ((uint32_t)0x00000800)
+#define DMA_SxCR_PSIZE_1                     ((uint32_t)0x00001000)
+#define DMA_SxCR_MINC                        ((uint32_t)0x00000400)
+#define DMA_SxCR_PINC                        ((uint32_t)0x00000200)
+#define DMA_SxCR_CIRC                        ((uint32_t)0x00000100)
+#define DMA_SxCR_DIR                         ((uint32_t)0x000000C0)
+#define DMA_SxCR_DIR_0                       ((uint32_t)0x00000040)
+#define DMA_SxCR_DIR_1                       ((uint32_t)0x00000080)
+#define DMA_SxCR_PFCTRL                      ((uint32_t)0x00000020)
+#define DMA_SxCR_TCIE                        ((uint32_t)0x00000010)
+#define DMA_SxCR_HTIE                        ((uint32_t)0x00000008)
+#define DMA_SxCR_TEIE                        ((uint32_t)0x00000004)
+#define DMA_SxCR_DMEIE                       ((uint32_t)0x00000002)
+#define DMA_SxCR_EN                          ((uint32_t)0x00000001)
+
+/********************  Bits definition for DMA_SxCNDTR register  **************/
+#define DMA_SxNDT                            ((uint32_t)0x0000FFFF)
+#define DMA_SxNDT_0                          ((uint32_t)0x00000001)
+#define DMA_SxNDT_1                          ((uint32_t)0x00000002)
+#define DMA_SxNDT_2                          ((uint32_t)0x00000004)
+#define DMA_SxNDT_3                          ((uint32_t)0x00000008)
+#define DMA_SxNDT_4                          ((uint32_t)0x00000010)
+#define DMA_SxNDT_5                          ((uint32_t)0x00000020)
+#define DMA_SxNDT_6                          ((uint32_t)0x00000040)
+#define DMA_SxNDT_7                          ((uint32_t)0x00000080)
+#define DMA_SxNDT_8                          ((uint32_t)0x00000100)
+#define DMA_SxNDT_9                          ((uint32_t)0x00000200)
+#define DMA_SxNDT_10                         ((uint32_t)0x00000400)
+#define DMA_SxNDT_11                         ((uint32_t)0x00000800)
+#define DMA_SxNDT_12                         ((uint32_t)0x00001000)
+#define DMA_SxNDT_13                         ((uint32_t)0x00002000)
+#define DMA_SxNDT_14                         ((uint32_t)0x00004000)
+#define DMA_SxNDT_15                         ((uint32_t)0x00008000)
+
+/********************  Bits definition for DMA_SxFCR register  ****************/ 
+#define DMA_SxFCR_FEIE                       ((uint32_t)0x00000080)
+#define DMA_SxFCR_FS                         ((uint32_t)0x00000038)
+#define DMA_SxFCR_FS_0                       ((uint32_t)0x00000008)
+#define DMA_SxFCR_FS_1                       ((uint32_t)0x00000010)
+#define DMA_SxFCR_FS_2                       ((uint32_t)0x00000020)
+#define DMA_SxFCR_DMDIS                      ((uint32_t)0x00000004)
+#define DMA_SxFCR_FTH                        ((uint32_t)0x00000003)
+#define DMA_SxFCR_FTH_0                      ((uint32_t)0x00000001)
+#define DMA_SxFCR_FTH_1                      ((uint32_t)0x00000002)
+
+/********************  Bits definition for DMA_LISR register  *****************/ 
+#define DMA_LISR_TCIF3                       ((uint32_t)0x08000000)
+#define DMA_LISR_HTIF3                       ((uint32_t)0x04000000)
+#define DMA_LISR_TEIF3                       ((uint32_t)0x02000000)
+#define DMA_LISR_DMEIF3                      ((uint32_t)0x01000000)
+#define DMA_LISR_FEIF3                       ((uint32_t)0x00400000)
+#define DMA_LISR_TCIF2                       ((uint32_t)0x00200000)
+#define DMA_LISR_HTIF2                       ((uint32_t)0x00100000)
+#define DMA_LISR_TEIF2                       ((uint32_t)0x00080000)
+#define DMA_LISR_DMEIF2                      ((uint32_t)0x00040000)
+#define DMA_LISR_FEIF2                       ((uint32_t)0x00010000)
+#define DMA_LISR_TCIF1                       ((uint32_t)0x00000800)
+#define DMA_LISR_HTIF1                       ((uint32_t)0x00000400)
+#define DMA_LISR_TEIF1                       ((uint32_t)0x00000200)
+#define DMA_LISR_DMEIF1                      ((uint32_t)0x00000100)
+#define DMA_LISR_FEIF1                       ((uint32_t)0x00000040)
+#define DMA_LISR_TCIF0                       ((uint32_t)0x00000020)
+#define DMA_LISR_HTIF0                       ((uint32_t)0x00000010)
+#define DMA_LISR_TEIF0                       ((uint32_t)0x00000008)
+#define DMA_LISR_DMEIF0                      ((uint32_t)0x00000004)
+#define DMA_LISR_FEIF0                       ((uint32_t)0x00000001)
+
+/********************  Bits definition for DMA_HISR register  *****************/ 
+#define DMA_HISR_TCIF7                       ((uint32_t)0x08000000)
+#define DMA_HISR_HTIF7                       ((uint32_t)0x04000000)
+#define DMA_HISR_TEIF7                       ((uint32_t)0x02000000)
+#define DMA_HISR_DMEIF7                      ((uint32_t)0x01000000)
+#define DMA_HISR_FEIF7                       ((uint32_t)0x00400000)
+#define DMA_HISR_TCIF6                       ((uint32_t)0x00200000)
+#define DMA_HISR_HTIF6                       ((uint32_t)0x00100000)
+#define DMA_HISR_TEIF6                       ((uint32_t)0x00080000)
+#define DMA_HISR_DMEIF6                      ((uint32_t)0x00040000)
+#define DMA_HISR_FEIF6                       ((uint32_t)0x00010000)
+#define DMA_HISR_TCIF5                       ((uint32_t)0x00000800)
+#define DMA_HISR_HTIF5                       ((uint32_t)0x00000400)
+#define DMA_HISR_TEIF5                       ((uint32_t)0x00000200)
+#define DMA_HISR_DMEIF5                      ((uint32_t)0x00000100)
+#define DMA_HISR_FEIF5                       ((uint32_t)0x00000040)
+#define DMA_HISR_TCIF4                       ((uint32_t)0x00000020)
+#define DMA_HISR_HTIF4                       ((uint32_t)0x00000010)
+#define DMA_HISR_TEIF4                       ((uint32_t)0x00000008)
+#define DMA_HISR_DMEIF4                      ((uint32_t)0x00000004)
+#define DMA_HISR_FEIF4                       ((uint32_t)0x00000001)
+
+/********************  Bits definition for DMA_LIFCR register  ****************/ 
+#define DMA_LIFCR_CTCIF3                     ((uint32_t)0x08000000)
+#define DMA_LIFCR_CHTIF3                     ((uint32_t)0x04000000)
+#define DMA_LIFCR_CTEIF3                     ((uint32_t)0x02000000)
+#define DMA_LIFCR_CDMEIF3                    ((uint32_t)0x01000000)
+#define DMA_LIFCR_CFEIF3                     ((uint32_t)0x00400000)
+#define DMA_LIFCR_CTCIF2                     ((uint32_t)0x00200000)
+#define DMA_LIFCR_CHTIF2                     ((uint32_t)0x00100000)
+#define DMA_LIFCR_CTEIF2                     ((uint32_t)0x00080000)
+#define DMA_LIFCR_CDMEIF2                    ((uint32_t)0x00040000)
+#define DMA_LIFCR_CFEIF2                     ((uint32_t)0x00010000)
+#define DMA_LIFCR_CTCIF1                     ((uint32_t)0x00000800)
+#define DMA_LIFCR_CHTIF1                     ((uint32_t)0x00000400)
+#define DMA_LIFCR_CTEIF1                     ((uint32_t)0x00000200)
+#define DMA_LIFCR_CDMEIF1                    ((uint32_t)0x00000100)
+#define DMA_LIFCR_CFEIF1                     ((uint32_t)0x00000040)
+#define DMA_LIFCR_CTCIF0                     ((uint32_t)0x00000020)
+#define DMA_LIFCR_CHTIF0                     ((uint32_t)0x00000010)
+#define DMA_LIFCR_CTEIF0                     ((uint32_t)0x00000008)
+#define DMA_LIFCR_CDMEIF0                    ((uint32_t)0x00000004)
+#define DMA_LIFCR_CFEIF0                     ((uint32_t)0x00000001)
+
+/********************  Bits definition for DMA_HIFCR  register  ****************/ 
+#define DMA_HIFCR_CTCIF7                     ((uint32_t)0x08000000)
+#define DMA_HIFCR_CHTIF7                     ((uint32_t)0x04000000)
+#define DMA_HIFCR_CTEIF7                     ((uint32_t)0x02000000)
+#define DMA_HIFCR_CDMEIF7                    ((uint32_t)0x01000000)
+#define DMA_HIFCR_CFEIF7                     ((uint32_t)0x00400000)
+#define DMA_HIFCR_CTCIF6                     ((uint32_t)0x00200000)
+#define DMA_HIFCR_CHTIF6                     ((uint32_t)0x00100000)
+#define DMA_HIFCR_CTEIF6                     ((uint32_t)0x00080000)
+#define DMA_HIFCR_CDMEIF6                    ((uint32_t)0x00040000)
+#define DMA_HIFCR_CFEIF6                     ((uint32_t)0x00010000)
+#define DMA_HIFCR_CTCIF5                     ((uint32_t)0x00000800)
+#define DMA_HIFCR_CHTIF5                     ((uint32_t)0x00000400)
+#define DMA_HIFCR_CTEIF5                     ((uint32_t)0x00000200)
+#define DMA_HIFCR_CDMEIF5                    ((uint32_t)0x00000100)
+#define DMA_HIFCR_CFEIF5                     ((uint32_t)0x00000040)
+#define DMA_HIFCR_CTCIF4                     ((uint32_t)0x00000020)
+#define DMA_HIFCR_CHTIF4                     ((uint32_t)0x00000010)
+#define DMA_HIFCR_CTEIF4                     ((uint32_t)0x00000008)
+#define DMA_HIFCR_CDMEIF4                    ((uint32_t)0x00000004)
+#define DMA_HIFCR_CFEIF4                     ((uint32_t)0x00000001)
+
+/******************************************************************************/
+/*                                                                            */
+/*                         AHB Master DMA2D Controller (DMA2D)                */
+/*                                                                            */
+/******************************************************************************/
+
+/********************  Bit definition for DMA2D_CR register  ******************/
+
+#define DMA2D_CR_START                     ((uint32_t)0x00000001)               /*!< Start transfer */
+#define DMA2D_CR_SUSP                      ((uint32_t)0x00000002)               /*!< Suspend transfer */
+#define DMA2D_CR_ABORT                     ((uint32_t)0x00000004)               /*!< Abort transfer */
+#define DMA2D_CR_TEIE                      ((uint32_t)0x00000100)               /*!< Transfer Error Interrupt Enable */
+#define DMA2D_CR_TCIE                      ((uint32_t)0x00000200)               /*!< Transfer Complete Interrupt Enable */
+#define DMA2D_CR_TWIE                      ((uint32_t)0x00000400)               /*!< Transfer Watermark Interrupt Enable */
+#define DMA2D_CR_CAEIE                     ((uint32_t)0x00000800)               /*!< CLUT Access Error Interrupt Enable */
+#define DMA2D_CR_CTCIE                     ((uint32_t)0x00001000)               /*!< CLUT Transfer Complete Interrupt Enable */
+#define DMA2D_CR_CEIE                      ((uint32_t)0x00002000)               /*!< Configuration Error Interrupt Enable */
+#define DMA2D_CR_MODE                      ((uint32_t)0x00030000)               /*!< DMA2D Mode */
+
+/********************  Bit definition for DMA2D_ISR register  *****************/
+
+#define DMA2D_ISR_TEIF                     ((uint32_t)0x00000001)               /*!< Transfer Error Interrupt Flag */
+#define DMA2D_ISR_TCIF                     ((uint32_t)0x00000002)               /*!< Transfer Complete Interrupt Flag */
+#define DMA2D_ISR_TWIF                     ((uint32_t)0x00000004)               /*!< Transfer Watermark Interrupt Flag */
+#define DMA2D_ISR_CAEIF                    ((uint32_t)0x00000008)               /*!< CLUT Access Error Interrupt Flag */
+#define DMA2D_ISR_CTCIF                    ((uint32_t)0x00000010)               /*!< CLUT Transfer Complete Interrupt Flag */
+#define DMA2D_ISR_CEIF                     ((uint32_t)0x00000020)               /*!< Configuration Error Interrupt Flag */
+
+/********************  Bit definition for DMA2D_IFSR register  ****************/
+
+#define DMA2D_IFSR_CTEIF                   ((uint32_t)0x00000001)               /*!< Clears Transfer Error Interrupt Flag */
+#define DMA2D_IFSR_CTCIF                   ((uint32_t)0x00000002)               /*!< Clears Transfer Complete Interrupt Flag */
+#define DMA2D_IFSR_CTWIF                   ((uint32_t)0x00000004)               /*!< Clears Transfer Watermark Interrupt Flag */
+#define DMA2D_IFSR_CCAEIF                  ((uint32_t)0x00000008)               /*!< Clears CLUT Access Error Interrupt Flag */
+#define DMA2D_IFSR_CCTCIF                  ((uint32_t)0x00000010)               /*!< Clears CLUT Transfer Complete Interrupt Flag */
+#define DMA2D_IFSR_CCEIF                   ((uint32_t)0x00000020)               /*!< Clears Configuration Error Interrupt Flag */
+
+/********************  Bit definition for DMA2D_FGMAR register  ***************/
+
+#define DMA2D_FGMAR_MA                     ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
+
+/********************  Bit definition for DMA2D_FGOR register  ****************/
+
+#define DMA2D_FGOR_LO                      ((uint32_t)0x00003FFF)               /*!< Line Offset */
+
+/********************  Bit definition for DMA2D_BGMAR register  ***************/
+
+#define DMA2D_BGMAR_MA                     ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
+
+/********************  Bit definition for DMA2D_BGOR register  ****************/
+
+#define DMA2D_BGOR_LO                      ((uint32_t)0x00003FFF)               /*!< Line Offset */
+
+/********************  Bit definition for DMA2D_FGPFCCR register  *************/
+
+#define DMA2D_FGPFCCR_CM                   ((uint32_t)0x0000000F)               /*!< Color mode */
+#define DMA2D_FGPFCCR_CCM                  ((uint32_t)0x00000010)               /*!< CLUT Color mode */
+#define DMA2D_FGPFCCR_START                ((uint32_t)0x00000020)               /*!< Start */
+#define DMA2D_FGPFCCR_CS                   ((uint32_t)0x0000FF00)               /*!< CLUT size */
+#define DMA2D_FGPFCCR_AM                   ((uint32_t)0x00030000)               /*!< Alpha mode */
+#define DMA2D_FGPFCCR_ALPHA                ((uint32_t)0xFF000000)               /*!< Alpha value */
+
+/********************  Bit definition for DMA2D_FGCOLR register  **************/
+
+#define DMA2D_FGCOLR_BLUE                  ((uint32_t)0x000000FF)               /*!< Blue Value */
+#define DMA2D_FGCOLR_GREEN                 ((uint32_t)0x0000FF00)               /*!< Green Value */
+#define DMA2D_FGCOLR_RED                   ((uint32_t)0x00FF0000)               /*!< Red Value */   
+
+/********************  Bit definition for DMA2D_BGPFCCR register  *************/
+
+#define DMA2D_BGPFCCR_CM                   ((uint32_t)0x0000000F)               /*!< Color mode */
+#define DMA2D_BGPFCCR_CCM                  ((uint32_t)0x00000010)               /*!< CLUT Color mode */
+#define DMA2D_BGPFCCR_START                ((uint32_t)0x00000020)               /*!< Start */
+#define DMA2D_BGPFCCR_CS                   ((uint32_t)0x0000FF00)               /*!< CLUT size */
+#define DMA2D_BGPFCCR_AM                   ((uint32_t)0x00030000)               /*!< Alpha Mode */
+#define DMA2D_BGPFCCR_ALPHA                ((uint32_t)0xFF000000)               /*!< Alpha value */
+
+/********************  Bit definition for DMA2D_BGCOLR register  **************/
+
+#define DMA2D_BGCOLR_BLUE                  ((uint32_t)0x000000FF)               /*!< Blue Value */
+#define DMA2D_BGCOLR_GREEN                 ((uint32_t)0x0000FF00)               /*!< Green Value */
+#define DMA2D_BGCOLR_RED                   ((uint32_t)0x00FF0000)               /*!< Red Value */
+
+/********************  Bit definition for DMA2D_FGCMAR register  **************/
+
+#define DMA2D_FGCMAR_MA                    ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
+
+/********************  Bit definition for DMA2D_BGCMAR register  **************/
+
+#define DMA2D_BGCMAR_MA                    ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
+
+/********************  Bit definition for DMA2D_OPFCCR register  **************/
+
+#define DMA2D_OPFCCR_CM                    ((uint32_t)0x00000007)               /*!< Color mode */
+
+/********************  Bit definition for DMA2D_OCOLR register  ***************/
+
+/*!<Mode_ARGB8888/RGB888 */
+
+#define DMA2D_OCOLR_BLUE_1                 ((uint32_t)0x000000FF)               /*!< BLUE Value */
+#define DMA2D_OCOLR_GREEN_1                ((uint32_t)0x0000FF00)               /*!< GREEN Value  */
+#define DMA2D_OCOLR_RED_1                  ((uint32_t)0x00FF0000)               /*!< Red Value */
+#define DMA2D_OCOLR_ALPHA_1                ((uint32_t)0xFF000000)               /*!< Alpha Channel Value */
+
+/*!<Mode_RGB565 */
+#define DMA2D_OCOLR_BLUE_2                 ((uint32_t)0x0000001F)               /*!< BLUE Value */
+#define DMA2D_OCOLR_GREEN_2                ((uint32_t)0x000007E0)               /*!< GREEN Value  */
+#define DMA2D_OCOLR_RED_2                  ((uint32_t)0x0000F800)               /*!< Red Value */
+
+/*!<Mode_ARGB1555 */
+#define DMA2D_OCOLR_BLUE_3                 ((uint32_t)0x0000001F)               /*!< BLUE Value */
+#define DMA2D_OCOLR_GREEN_3                ((uint32_t)0x000003E0)               /*!< GREEN Value  */
+#define DMA2D_OCOLR_RED_3                  ((uint32_t)0x00007C00)               /*!< Red Value */
+#define DMA2D_OCOLR_ALPHA_3                ((uint32_t)0x00008000)               /*!< Alpha Channel Value */
+
+/*!<Mode_ARGB4444 */
+#define DMA2D_OCOLR_BLUE_4                 ((uint32_t)0x0000000F)               /*!< BLUE Value */
+#define DMA2D_OCOLR_GREEN_4                ((uint32_t)0x000000F0)               /*!< GREEN Value  */
+#define DMA2D_OCOLR_RED_4                  ((uint32_t)0x00000F00)               /*!< Red Value */
+#define DMA2D_OCOLR_ALPHA_4                ((uint32_t)0x0000F000)               /*!< Alpha Channel Value */
+
+/********************  Bit definition for DMA2D_OMAR register  ****************/
+
+#define DMA2D_OMAR_MA                      ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
+
+/********************  Bit definition for DMA2D_OOR register  *****************/
+
+#define DMA2D_OOR_LO                       ((uint32_t)0x00003FFF)               /*!< Line Offset */
+
+/********************  Bit definition for DMA2D_NLR register  *****************/
+
+#define DMA2D_NLR_NL                       ((uint32_t)0x0000FFFF)               /*!< Number of Lines */
+#define DMA2D_NLR_PL                       ((uint32_t)0x3FFF0000)               /*!< Pixel per Lines */
+
+/********************  Bit definition for DMA2D_LWR register  *****************/
+
+#define DMA2D_LWR_LW                       ((uint32_t)0x0000FFFF)               /*!< Line Watermark */
+
+/********************  Bit definition for DMA2D_AMTCR register  ***************/
+
+#define DMA2D_AMTCR_EN                     ((uint32_t)0x00000001)               /*!< Enable */
+#define DMA2D_AMTCR_DT                     ((uint32_t)0x0000FF00)               /*!< Dead Time */
+
+
+
+/********************  Bit definition for DMA2D_FGCLUT register  **************/
+                                                                     
+/********************  Bit definition for DMA2D_BGCLUT register  **************/
+
+
+/******************************************************************************/
+/*                                                                            */
+/*                    External Interrupt/Event Controller                     */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bit definition for EXTI_IMR register  *******************/
+#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
+#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
+#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
+#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
+#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
+#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
+#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
+#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
+#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
+#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
+#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
+#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
+#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
+#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
+#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
+#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
+#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
+#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
+#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
+#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
+
+/*******************  Bit definition for EXTI_EMR register  *******************/
+#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
+#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
+#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
+#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
+#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
+#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
+#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
+#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
+#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
+#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
+#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
+#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
+#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
+#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
+#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
+#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
+#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
+#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
+#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
+#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
+
+/******************  Bit definition for EXTI_RTSR register  *******************/
+#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
+#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
+#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
+#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
+#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
+#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
+#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
+#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
+#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
+#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
+#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
+#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
+#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
+#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
+#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
+#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
+#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
+#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
+#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
+#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
+
+/******************  Bit definition for EXTI_FTSR register  *******************/
+#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
+#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
+#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
+#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
+#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
+#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
+#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
+#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
+#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
+#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
+#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
+#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
+#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
+#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
+#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
+#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
+#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
+#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
+#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
+#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
+
+/******************  Bit definition for EXTI_SWIER register  ******************/
+#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
+#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
+#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
+#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
+#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
+#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
+#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
+#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
+#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
+#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
+#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
+#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
+#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
+#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
+#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
+#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
+#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
+#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
+#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
+#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
+
+/*******************  Bit definition for EXTI_PR register  ********************/
+#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */
+#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
+#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */
+#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */
+#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */
+#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */
+#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */
+#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */
+#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */
+#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */
+#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */
+#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */
+#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */
+#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */
+#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */
+#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */
+#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */
+#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */
+#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */
+#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */
+
+/******************************************************************************/
+/*                                                                            */
+/*                                    FLASH                                   */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bits definition for FLASH_ACR register  *****************/
+#define FLASH_ACR_LATENCY                    ((uint32_t)0x0000000F)
+#define FLASH_ACR_LATENCY_0WS                ((uint32_t)0x00000000)
+#define FLASH_ACR_LATENCY_1WS                ((uint32_t)0x00000001)
+#define FLASH_ACR_LATENCY_2WS                ((uint32_t)0x00000002)
+#define FLASH_ACR_LATENCY_3WS                ((uint32_t)0x00000003)
+#define FLASH_ACR_LATENCY_4WS                ((uint32_t)0x00000004)
+#define FLASH_ACR_LATENCY_5WS                ((uint32_t)0x00000005)
+#define FLASH_ACR_LATENCY_6WS                ((uint32_t)0x00000006)
+#define FLASH_ACR_LATENCY_7WS                ((uint32_t)0x00000007)
+#define FLASH_ACR_LATENCY_8WS                ((uint32_t)0x00000008)
+#define FLASH_ACR_LATENCY_9WS                ((uint32_t)0x00000009)
+#define FLASH_ACR_LATENCY_10WS               ((uint32_t)0x0000000A)
+#define FLASH_ACR_LATENCY_11WS               ((uint32_t)0x0000000B)
+#define FLASH_ACR_LATENCY_12WS               ((uint32_t)0x0000000C)
+#define FLASH_ACR_LATENCY_13WS               ((uint32_t)0x0000000D)
+#define FLASH_ACR_LATENCY_14WS               ((uint32_t)0x0000000E)
+#define FLASH_ACR_LATENCY_15WS               ((uint32_t)0x0000000F)
+
+#define FLASH_ACR_PRFTEN                     ((uint32_t)0x00000100)
+#define FLASH_ACR_ICEN                       ((uint32_t)0x00000200)
+#define FLASH_ACR_DCEN                       ((uint32_t)0x00000400)
+#define FLASH_ACR_ICRST                      ((uint32_t)0x00000800)
+#define FLASH_ACR_DCRST                      ((uint32_t)0x00001000)
+#define FLASH_ACR_BYTE0_ADDRESS              ((uint32_t)0x40023C00)
+#define FLASH_ACR_BYTE2_ADDRESS              ((uint32_t)0x40023C03)
+
+/*******************  Bits definition for FLASH_SR register  ******************/
+#define FLASH_SR_EOP                         ((uint32_t)0x00000001)
+#define FLASH_SR_SOP                         ((uint32_t)0x00000002)
+#define FLASH_SR_WRPERR                      ((uint32_t)0x00000010)
+#define FLASH_SR_PGAERR                      ((uint32_t)0x00000020)
+#define FLASH_SR_PGPERR                      ((uint32_t)0x00000040)
+#define FLASH_SR_PGSERR                      ((uint32_t)0x00000080)
+#define FLASH_SR_BSY                         ((uint32_t)0x00010000)
+
+/*******************  Bits definition for FLASH_CR register  ******************/
+#define FLASH_CR_PG                          ((uint32_t)0x00000001)
+#define FLASH_CR_SER                         ((uint32_t)0x00000002)
+#define FLASH_CR_MER                         ((uint32_t)0x00000004)
+#define FLASH_CR_MER1                        FLASH_CR_MER
+#define FLASH_CR_SNB                         ((uint32_t)0x000000F8)
+#define FLASH_CR_SNB_0                       ((uint32_t)0x00000008)
+#define FLASH_CR_SNB_1                       ((uint32_t)0x00000010)
+#define FLASH_CR_SNB_2                       ((uint32_t)0x00000020)
+#define FLASH_CR_SNB_3                       ((uint32_t)0x00000040)
+#define FLASH_CR_SNB_4                       ((uint32_t)0x00000040)
+#define FLASH_CR_PSIZE                       ((uint32_t)0x00000300)
+#define FLASH_CR_PSIZE_0                     ((uint32_t)0x00000100)
+#define FLASH_CR_PSIZE_1                     ((uint32_t)0x00000200)
+#define FLASH_CR_MER2                        ((uint32_t)0x00008000)
+#define FLASH_CR_STRT                        ((uint32_t)0x00010000)
+#define FLASH_CR_EOPIE                       ((uint32_t)0x01000000)
+#define FLASH_CR_LOCK                        ((uint32_t)0x80000000)
+
+/*******************  Bits definition for FLASH_OPTCR register  ***************/
+#define FLASH_OPTCR_OPTLOCK                 ((uint32_t)0x00000001)
+#define FLASH_OPTCR_OPTSTRT                 ((uint32_t)0x00000002)
+#define FLASH_OPTCR_BOR_LEV_0               ((uint32_t)0x00000004)
+#define FLASH_OPTCR_BOR_LEV_1               ((uint32_t)0x00000008)
+#define FLASH_OPTCR_BOR_LEV                 ((uint32_t)0x0000000C)
+#define FLASH_OPTCR_BFB2                    ((uint32_t)0x00000010)
+
+#define FLASH_OPTCR_WDG_SW                  ((uint32_t)0x00000020)
+#define FLASH_OPTCR_nRST_STOP               ((uint32_t)0x00000040)
+#define FLASH_OPTCR_nRST_STDBY              ((uint32_t)0x00000080)
+#define FLASH_OPTCR_RDP                     ((uint32_t)0x0000FF00)
+#define FLASH_OPTCR_RDP_0                   ((uint32_t)0x00000100)
+#define FLASH_OPTCR_RDP_1                   ((uint32_t)0x00000200)
+#define FLASH_OPTCR_RDP_2                   ((uint32_t)0x00000400)
+#define FLASH_OPTCR_RDP_3                   ((uint32_t)0x00000800)
+#define FLASH_OPTCR_RDP_4                   ((uint32_t)0x00001000)
+#define FLASH_OPTCR_RDP_5                   ((uint32_t)0x00002000)
+#define FLASH_OPTCR_RDP_6                   ((uint32_t)0x00004000)
+#define FLASH_OPTCR_RDP_7                   ((uint32_t)0x00008000)
+#define FLASH_OPTCR_nWRP                    ((uint32_t)0x0FFF0000)
+#define FLASH_OPTCR_nWRP_0                  ((uint32_t)0x00010000)
+#define FLASH_OPTCR_nWRP_1                  ((uint32_t)0x00020000)
+#define FLASH_OPTCR_nWRP_2                  ((uint32_t)0x00040000)
+#define FLASH_OPTCR_nWRP_3                  ((uint32_t)0x00080000)
+#define FLASH_OPTCR_nWRP_4                  ((uint32_t)0x00100000)
+#define FLASH_OPTCR_nWRP_5                  ((uint32_t)0x00200000)
+#define FLASH_OPTCR_nWRP_6                  ((uint32_t)0x00400000)
+#define FLASH_OPTCR_nWRP_7                  ((uint32_t)0x00800000)
+#define FLASH_OPTCR_nWRP_8                  ((uint32_t)0x01000000)
+#define FLASH_OPTCR_nWRP_9                  ((uint32_t)0x02000000)
+#define FLASH_OPTCR_nWRP_10                 ((uint32_t)0x04000000)
+#define FLASH_OPTCR_nWRP_11                 ((uint32_t)0x08000000)
+
+#define FLASH_OPTCR_DB1M                    ((uint32_t)0x40000000) 
+#define FLASH_OPTCR_SPRMOD                  ((uint32_t)0x80000000) 
+                                             
+/******************  Bits definition for FLASH_OPTCR1 register  ***************/
+#define FLASH_OPTCR1_nWRP                    ((uint32_t)0x0FFF0000)
+#define FLASH_OPTCR1_nWRP_0                  ((uint32_t)0x00010000)
+#define FLASH_OPTCR1_nWRP_1                  ((uint32_t)0x00020000)
+#define FLASH_OPTCR1_nWRP_2                  ((uint32_t)0x00040000)
+#define FLASH_OPTCR1_nWRP_3                  ((uint32_t)0x00080000)
+#define FLASH_OPTCR1_nWRP_4                  ((uint32_t)0x00100000)
+#define FLASH_OPTCR1_nWRP_5                  ((uint32_t)0x00200000)
+#define FLASH_OPTCR1_nWRP_6                  ((uint32_t)0x00400000)
+#define FLASH_OPTCR1_nWRP_7                  ((uint32_t)0x00800000)
+#define FLASH_OPTCR1_nWRP_8                  ((uint32_t)0x01000000)
+#define FLASH_OPTCR1_nWRP_9                  ((uint32_t)0x02000000)
+#define FLASH_OPTCR1_nWRP_10                 ((uint32_t)0x04000000)
+#define FLASH_OPTCR1_nWRP_11                 ((uint32_t)0x08000000)
+
+#if defined (STM32F40_41xxx)
+/******************************************************************************/
+/*                                                                            */
+/*                       Flexible Static Memory Controller                    */
+/*                                                                            */
+/******************************************************************************/
+/******************  Bit definition for FSMC_BCR1 register  *******************/
+#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
+#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
+
+#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
+#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
+#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
+#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
+#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
+#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
+#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
+#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
+#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
+#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
+#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
+#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
+
+/******************  Bit definition for FSMC_BCR2 register  *******************/
+#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                */
+#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
+
+#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
+#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
+#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
+#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
+#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
+#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
+#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
+#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
+#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
+#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
+#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
+#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
+
+/******************  Bit definition for FSMC_BCR3 register  *******************/
+#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
+#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
+
+#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
+#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
+#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
+#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
+#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
+#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
+#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
+#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
+#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
+#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
+#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
+#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
+
+/******************  Bit definition for FSMC_BCR4 register  *******************/
+#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit */
+#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
+
+#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
+#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
+#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
+#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
+#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
+#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
+#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
+#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
+#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
+#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
+#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
+#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
+
+/******************  Bit definition for FSMC_BTR1 register  ******************/
+#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+
+#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FSMC_BTR2 register  *******************/
+#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+
+#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/*******************  Bit definition for FSMC_BTR3 register  *******************/
+#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+
+#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FSMC_BTR4 register  *******************/
+#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+
+#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FSMC_BWTR1 register  ******************/
+#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FSMC_BWTR1_CLKDIV                   ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BWTR1_CLKDIV_0                 ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FSMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FSMC_BWTR1_CLKDIV_2                 ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FSMC_BWTR1_CLKDIV_3                 ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FSMC_BWTR1_DATLAT                   ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FSMC_BWTR1_DATLAT_0                 ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_BWTR1_DATLAT_2                 ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_BWTR1_DATLAT_3                 ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FSMC_BWTR2 register  ******************/
+#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FSMC_BWTR2_CLKDIV                   ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BWTR2_CLKDIV_0                 ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FSMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!<Bit 1*/
+#define  FSMC_BWTR2_CLKDIV_2                 ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FSMC_BWTR2_CLKDIV_3                 ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FSMC_BWTR2_DATLAT                   ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FSMC_BWTR2_DATLAT_0                 ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_BWTR2_DATLAT_2                 ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_BWTR2_DATLAT_3                 ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FSMC_BWTR3 register  ******************/
+#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FSMC_BWTR3_CLKDIV                   ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BWTR3_CLKDIV_0                 ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FSMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FSMC_BWTR3_CLKDIV_2                 ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FSMC_BWTR3_CLKDIV_3                 ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FSMC_BWTR3_DATLAT                   ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FSMC_BWTR3_DATLAT_0                 ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_BWTR3_DATLAT_2                 ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_BWTR3_DATLAT_3                 ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FSMC_BWTR4 register  ******************/
+#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FSMC_BWTR4_CLKDIV                   ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BWTR4_CLKDIV_0                 ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FSMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FSMC_BWTR4_CLKDIV_2                 ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FSMC_BWTR4_CLKDIV_3                 ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FSMC_BWTR4_DATLAT                   ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FSMC_BWTR4_DATLAT_0                 ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_BWTR4_DATLAT_2                 ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_BWTR4_DATLAT_3                 ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FSMC_PCR2 register  *******************/
+#define  FSMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit */
+#define  FSMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
+#define  FSMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type */
+
+#define  FSMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
+#define  FSMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */
+
+#define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */
+#define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
+#define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
+#define  FSMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
+#define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
+
+#define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */
+#define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
+#define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
+#define  FSMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
+#define  FSMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
+
+#define  FSMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[1:0] bits (ECC page size) */
+#define  FSMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
+#define  FSMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
+#define  FSMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
+
+/******************  Bit definition for FSMC_PCR3 register  *******************/
+#define  FSMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit */
+#define  FSMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
+#define  FSMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type */
+
+#define  FSMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
+#define  FSMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */
+
+#define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */
+#define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
+#define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
+#define  FSMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
+#define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
+
+#define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */
+#define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
+#define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
+#define  FSMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
+#define  FSMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
+
+#define  FSMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size) */
+#define  FSMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
+#define  FSMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
+#define  FSMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
+
+/******************  Bit definition for FSMC_PCR4 register  *******************/
+#define  FSMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit */
+#define  FSMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
+#define  FSMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type */
+
+#define  FSMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
+#define  FSMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FSMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */
+
+#define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */
+#define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
+#define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
+#define  FSMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
+#define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
+
+#define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */
+#define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
+#define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
+#define  FSMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
+#define  FSMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
+
+#define  FSMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size) */
+#define  FSMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
+#define  FSMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
+#define  FSMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
+
+/*******************  Bit definition for FSMC_SR2 register  *******************/
+#define  FSMC_SR2_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
+#define  FSMC_SR2_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
+#define  FSMC_SR2_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
+#define  FSMC_SR2_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
+#define  FSMC_SR2_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
+#define  FSMC_SR2_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
+#define  FSMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty */
+
+/*******************  Bit definition for FSMC_SR3 register  *******************/
+#define  FSMC_SR3_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
+#define  FSMC_SR3_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
+#define  FSMC_SR3_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
+#define  FSMC_SR3_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
+#define  FSMC_SR3_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
+#define  FSMC_SR3_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
+#define  FSMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty */
+
+/*******************  Bit definition for FSMC_SR4 register  *******************/
+#define  FSMC_SR4_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                 */
+#define  FSMC_SR4_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                       */
+#define  FSMC_SR4_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status                */
+#define  FSMC_SR4_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit   */
+#define  FSMC_SR4_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit         */
+#define  FSMC_SR4_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit  */
+#define  FSMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty */
+
+/******************  Bit definition for FSMC_PMEM2 register  ******************/
+#define  FSMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!<MEMSET2[7:0] bits (Common memory 2 setup time) */
+#define  FSMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FSMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FSMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FSMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FSMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FSMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT2[7:0] bits (Common memory 2 wait time) */
+#define  FSMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FSMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FSMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FSMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FSMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FSMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD2[7:0] bits (Common memory 2 hold time) */
+#define  FSMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FSMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FSMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FSMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FSMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FSMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!<MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
+#define  FSMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FSMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FSMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FSMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FSMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FSMC_PMEM3 register  ******************/
+#define  FSMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!<MEMSET3[7:0] bits (Common memory 3 setup time) */
+#define  FSMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FSMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FSMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FSMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FSMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FSMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT3[7:0] bits (Common memory 3 wait time) */
+#define  FSMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FSMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FSMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FSMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FSMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FSMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD3[7:0] bits (Common memory 3 hold time) */
+#define  FSMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FSMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FSMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FSMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FSMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FSMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!<MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
+#define  FSMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FSMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FSMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FSMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FSMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FSMC_PMEM4 register  ******************/
+#define  FSMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!<MEMSET4[7:0] bits (Common memory 4 setup time) */
+#define  FSMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FSMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FSMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FSMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FSMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FSMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT4[7:0] bits (Common memory 4 wait time) */
+#define  FSMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FSMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FSMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FSMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FSMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FSMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD4[7:0] bits (Common memory 4 hold time) */
+#define  FSMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FSMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FSMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FSMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FSMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FSMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!<MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
+#define  FSMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FSMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FSMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FSMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FSMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FSMC_PATT2 register  ******************/
+#define  FSMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!<ATTSET2[7:0] bits (Attribute memory 2 setup time) */
+#define  FSMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FSMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FSMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FSMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FSMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FSMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
+#define  FSMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FSMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FSMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FSMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FSMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FSMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
+#define  FSMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FSMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FSMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FSMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FSMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FSMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!<ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
+#define  FSMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FSMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FSMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FSMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FSMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FSMC_PATT3 register  ******************/
+#define  FSMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!<ATTSET3[7:0] bits (Attribute memory 3 setup time) */
+#define  FSMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FSMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FSMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FSMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FSMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FSMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
+#define  FSMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FSMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FSMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FSMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FSMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FSMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
+#define  FSMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FSMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FSMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FSMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FSMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FSMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!<ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
+#define  FSMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FSMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FSMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FSMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FSMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FSMC_PATT4 register  ******************/
+#define  FSMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!<ATTSET4[7:0] bits (Attribute memory 4 setup time) */
+#define  FSMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FSMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FSMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FSMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FSMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FSMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
+#define  FSMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FSMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FSMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FSMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FSMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FSMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
+#define  FSMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FSMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FSMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FSMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FSMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FSMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!<ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
+#define  FSMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FSMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FSMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FSMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FSMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FSMC_PIO4 register  *******************/
+#define  FSMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!<IOSET4[7:0] bits (I/O 4 setup time) */
+#define  FSMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FSMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FSMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FSMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FSMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FSMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FSMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FSMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FSMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!<IOWAIT4[7:0] bits (I/O 4 wait time) */
+#define  FSMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FSMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FSMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FSMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FSMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FSMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FSMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FSMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FSMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!<IOHOLD4[7:0] bits (I/O 4 hold time) */
+#define  FSMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FSMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FSMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FSMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FSMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FSMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FSMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FSMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FSMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!<IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
+#define  FSMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FSMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FSMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FSMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FSMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FSMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FSMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FSMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FSMC_ECCR2 register  ******************/
+#define  FSMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
+
+/******************  Bit definition for FSMC_ECCR3 register  ******************/
+#define  FSMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+/******************************************************************************/
+/*                                                                            */
+/*                          Flexible Memory Controller                        */
+/*                                                                            */
+/******************************************************************************/
+/******************  Bit definition for FMC_BCR1 register  *******************/
+#define  FMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
+#define  FMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
+
+#define  FMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
+#define  FMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
+#define  FMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
+#define  FMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
+#define  FMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
+#define  FMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
+#define  FMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
+#define  FMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
+#define  FMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
+#define  FMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
+#define  FMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
+#define  FMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
+#define  FMC_BCR1_CCLKEN                    ((uint32_t)0x00100000)        /*!<Continous clock enable     */
+
+/******************  Bit definition for FMC_BCR2 register  *******************/
+#define  FMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
+#define  FMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
+
+#define  FMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
+#define  FMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
+#define  FMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
+#define  FMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
+#define  FMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
+#define  FMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
+#define  FMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
+#define  FMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
+#define  FMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
+#define  FMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
+#define  FMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
+#define  FMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
+
+/******************  Bit definition for FMC_BCR3 register  *******************/
+#define  FMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
+#define  FMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
+
+#define  FMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
+#define  FMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
+#define  FMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
+#define  FMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
+#define  FMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
+#define  FMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
+#define  FMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
+#define  FMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
+#define  FMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
+#define  FMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
+#define  FMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
+#define  FMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
+
+/******************  Bit definition for FMC_BCR4 register  *******************/
+#define  FMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
+#define  FMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
+
+#define  FMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
+#define  FMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
+#define  FMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
+#define  FMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
+#define  FMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
+#define  FMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
+#define  FMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
+#define  FMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
+#define  FMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
+#define  FMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
+#define  FMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
+#define  FMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
+
+/******************  Bit definition for FMC_BTR1 register  ******************/
+#define  FMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration)  */
+#define  FMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_BTR1_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_BTR1_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_BTR1_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_BTR1_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+
+#define  FMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FMC_BTR2 register  *******************/
+#define  FMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_BTR2_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_BTR2_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_BTR2_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_BTR2_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+
+#define  FMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/*******************  Bit definition for FMC_BTR3 register  *******************/
+#define  FMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_BTR3_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_BTR3_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_BTR3_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_BTR3_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+
+#define  FMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FMC_BTR4 register  *******************/
+#define  FMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_BTR4_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_BTR4_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_BTR4_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_BTR4_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+
+#define  FMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FMC_BWTR1 register  ******************/
+#define  FMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_BWTR1_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_BWTR1_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_BWTR1_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_BWTR1_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_BWTR1_CLKDIV                   ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FMC_BWTR1_CLKDIV_0                 ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FMC_BWTR1_CLKDIV_2                 ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FMC_BWTR1_CLKDIV_3                 ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FMC_BWTR1_DATLAT                   ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FMC_BWTR1_DATLAT_0                 ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_BWTR1_DATLAT_2                 ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_BWTR1_DATLAT_3                 ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FMC_BWTR2 register  ******************/
+#define  FMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_BWTR2_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_BWTR2_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_BWTR2_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_BWTR2_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_BWTR2_CLKDIV                   ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FMC_BWTR2_CLKDIV_0                 ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!<Bit 1*/
+#define  FMC_BWTR2_CLKDIV_2                 ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FMC_BWTR2_CLKDIV_3                 ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FMC_BWTR2_DATLAT                   ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FMC_BWTR2_DATLAT_0                 ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_BWTR2_DATLAT_2                 ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_BWTR2_DATLAT_3                 ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FMC_BWTR3 register  ******************/
+#define  FMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_BWTR3_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_BWTR3_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_BWTR3_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_BWTR3_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_BWTR3_CLKDIV                   ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FMC_BWTR3_CLKDIV_0                 ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FMC_BWTR3_CLKDIV_2                 ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FMC_BWTR3_CLKDIV_3                 ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FMC_BWTR3_DATLAT                   ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FMC_BWTR3_DATLAT_0                 ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_BWTR3_DATLAT_2                 ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_BWTR3_DATLAT_3                 ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FMC_BWTR4 register  ******************/
+#define  FMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
+#define  FMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
+
+#define  FMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
+#define  FMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_BWTR4_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_BWTR4_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_BWTR4_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_BWTR4_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_BWTR4_CLKDIV                   ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FMC_BWTR4_CLKDIV_0                 ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FMC_BWTR4_CLKDIV_2                 ((uint32_t)0x00400000)        /*!<Bit 2 */
+#define  FMC_BWTR4_CLKDIV_3                 ((uint32_t)0x00800000)        /*!<Bit 3 */
+
+#define  FMC_BWTR4_DATLAT                   ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
+#define  FMC_BWTR4_DATLAT_0                 ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_BWTR4_DATLAT_2                 ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_BWTR4_DATLAT_3                 ((uint32_t)0x08000000)        /*!<Bit 3 */
+
+#define  FMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
+#define  FMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
+#define  FMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
+
+/******************  Bit definition for FMC_PCR2 register  *******************/
+#define  FMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit                   */
+#define  FMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
+#define  FMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type                               */
+
+#define  FMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
+#define  FMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit          */
+
+#define  FMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay)          */
+#define  FMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
+#define  FMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
+#define  FMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
+#define  FMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
+
+#define  FMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay)           */
+#define  FMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
+#define  FMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
+#define  FMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
+#define  FMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
+
+#define  FMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[1:0] bits (ECC page size)           */
+#define  FMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
+#define  FMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
+#define  FMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
+
+/******************  Bit definition for FMC_PCR3 register  *******************/
+#define  FMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit                   */
+#define  FMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
+#define  FMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type                               */
+
+#define  FMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
+#define  FMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit          */
+
+#define  FMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay)          */
+#define  FMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
+#define  FMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
+#define  FMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
+#define  FMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
+
+#define  FMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay)           */
+#define  FMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
+#define  FMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
+#define  FMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
+#define  FMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
+
+#define  FMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size)           */
+#define  FMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
+#define  FMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
+#define  FMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
+
+/******************  Bit definition for FMC_PCR4 register  *******************/
+#define  FMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit                   */
+#define  FMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
+#define  FMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type                               */
+
+#define  FMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
+#define  FMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit          */
+
+#define  FMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay)          */
+#define  FMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
+#define  FMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
+#define  FMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
+#define  FMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
+
+#define  FMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay)           */
+#define  FMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
+#define  FMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
+#define  FMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
+#define  FMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
+
+#define  FMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size)           */
+#define  FMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
+#define  FMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
+#define  FMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
+
+/*******************  Bit definition for FMC_SR2 register  *******************/
+#define  FMC_SR2_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
+#define  FMC_SR2_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
+#define  FMC_SR2_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
+#define  FMC_SR2_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
+#define  FMC_SR2_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
+#define  FMC_SR2_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
+#define  FMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty                                  */
+
+/*******************  Bit definition for FMC_SR3 register  *******************/
+#define  FMC_SR3_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
+#define  FMC_SR3_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
+#define  FMC_SR3_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
+#define  FMC_SR3_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
+#define  FMC_SR3_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
+#define  FMC_SR3_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
+#define  FMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty                                  */
+
+/*******************  Bit definition for FMC_SR4 register  *******************/
+#define  FMC_SR4_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
+#define  FMC_SR4_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
+#define  FMC_SR4_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
+#define  FMC_SR4_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
+#define  FMC_SR4_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
+#define  FMC_SR4_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
+#define  FMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty                                  */
+
+/******************  Bit definition for FMC_PMEM2 register  ******************/
+#define  FMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!<MEMSET2[7:0] bits (Common memory 2 setup time) */
+#define  FMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT2[7:0] bits (Common memory 2 wait time) */
+#define  FMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD2[7:0] bits (Common memory 2 hold time) */
+#define  FMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!<MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
+#define  FMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FMC_PMEM3 register  ******************/
+#define  FMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!<MEMSET3[7:0] bits (Common memory 3 setup time) */
+#define  FMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT3[7:0] bits (Common memory 3 wait time) */
+#define  FMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD3[7:0] bits (Common memory 3 hold time) */
+#define  FMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!<MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
+#define  FMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FMC_PMEM4 register  ******************/
+#define  FMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!<MEMSET4[7:0] bits (Common memory 4 setup time) */
+#define  FMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT4[7:0] bits (Common memory 4 wait time) */
+#define  FMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD4[7:0] bits (Common memory 4 hold time) */
+#define  FMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!<MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
+#define  FMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FMC_PATT2 register  ******************/
+#define  FMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!<ATTSET2[7:0] bits (Attribute memory 2 setup time) */
+#define  FMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
+#define  FMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
+#define  FMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!<ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
+#define  FMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FMC_PATT3 register  ******************/
+#define  FMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!<ATTSET3[7:0] bits (Attribute memory 3 setup time) */
+#define  FMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
+#define  FMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
+#define  FMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!<ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
+#define  FMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FMC_PATT4 register  ******************/
+#define  FMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!<ATTSET4[7:0] bits (Attribute memory 4 setup time) */
+#define  FMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
+#define  FMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
+#define  FMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!<ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
+#define  FMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FMC_PIO4 register  *******************/
+#define  FMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!<IOSET4[7:0] bits (I/O 4 setup time) */
+#define  FMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  FMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  FMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  FMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  FMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  FMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!<IOWAIT4[7:0] bits (I/O 4 wait time) */
+#define  FMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  FMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  FMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  FMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
+#define  FMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
+
+#define  FMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!<IOHOLD4[7:0] bits (I/O 4 hold time) */
+#define  FMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
+#define  FMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
+#define  FMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!<Bit 4 */
+#define  FMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!<Bit 5 */
+#define  FMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!<Bit 6 */
+#define  FMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!<Bit 7 */
+
+#define  FMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!<IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
+#define  FMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
+#define  FMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
+#define  FMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!<Bit 4 */
+#define  FMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!<Bit 5 */
+#define  FMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!<Bit 6 */
+#define  FMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!<Bit 7 */
+
+/******************  Bit definition for FMC_ECCR2 register  ******************/
+#define  FMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
+
+/******************  Bit definition for FMC_ECCR3 register  ******************/
+#define  FMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
+
+/******************  Bit definition for FMC_SDCR1 register  ******************/
+#define  FMC_SDCR1_NC                       ((uint32_t)0x00000003)        /*!<NC[1:0] bits (Number of column bits) */
+#define  FMC_SDCR1_NC_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_SDCR1_NC_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
+
+#define  FMC_SDCR1_NR                       ((uint32_t)0x0000000C)        /*!<NR[1:0] bits (Number of row bits) */
+#define  FMC_SDCR1_NR_0                     ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FMC_SDCR1_NR_1                     ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FMC_SDCR1_MWID                     ((uint32_t)0x00000030)        /*!<NR[1:0] bits (Number of row bits) */
+#define  FMC_SDCR1_MWID_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_SDCR1_MWID_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FMC_SDCR1_NB                       ((uint32_t)0x00000040)        /*!<Number of internal bank */
+
+#define  FMC_SDCR1_CAS                      ((uint32_t)0x00000180)        /*!<CAS[1:0] bits (CAS latency) */
+#define  FMC_SDCR1_CAS_0                    ((uint32_t)0x00000080)        /*!<Bit 0 */
+#define  FMC_SDCR1_CAS_1                    ((uint32_t)0x00000100)        /*!<Bit 1 */
+
+#define  FMC_SDCR1_WP                       ((uint32_t)0x00000200)        /*!<Write protection */
+
+#define  FMC_SDCR1_SDCLK                    ((uint32_t)0x00000C00)        /*!<SDRAM clock configuration */
+#define  FMC_SDCR1_SDCLK_0                  ((uint32_t)0x00000400)        /*!<Bit 0 */
+#define  FMC_SDCR1_SDCLK_1                  ((uint32_t)0x00000800)        /*!<Bit 1 */
+
+#define  FMC_SDCR1_RBURST                   ((uint32_t)0x00001000)        /*!<Read burst */
+
+#define  FMC_SDCR1_RPIPE                    ((uint32_t)0x00006000)        /*!<Write protection */
+#define  FMC_SDCR1_RPIPE_0                  ((uint32_t)0x00002000)        /*!<Bit 0 */
+#define  FMC_SDCR1_RPIPE_1                  ((uint32_t)0x00004000)        /*!<Bit 1 */
+
+/******************  Bit definition for FMC_SDCR2 register  ******************/
+#define  FMC_SDCR2_NC                       ((uint32_t)0x00000003)        /*!<NC[1:0] bits (Number of column bits) */
+#define  FMC_SDCR2_NC_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_SDCR2_NC_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
+
+#define  FMC_SDCR2_NR                       ((uint32_t)0x0000000C)        /*!<NR[1:0] bits (Number of row bits) */
+#define  FMC_SDCR2_NR_0                     ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  FMC_SDCR2_NR_1                     ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  FMC_SDCR2_MWID                     ((uint32_t)0x00000030)        /*!<NR[1:0] bits (Number of row bits) */
+#define  FMC_SDCR2_MWID_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_SDCR2_MWID_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+#define  FMC_SDCR2_NB                       ((uint32_t)0x00000040)        /*!<Number of internal bank */
+
+#define  FMC_SDCR2_CAS                      ((uint32_t)0x00000180)        /*!<CAS[1:0] bits (CAS latency) */
+#define  FMC_SDCR2_CAS_0                    ((uint32_t)0x00000080)        /*!<Bit 0 */
+#define  FMC_SDCR2_CAS_1                    ((uint32_t)0x00000100)        /*!<Bit 1 */
+
+#define  FMC_SDCR2_WP                       ((uint32_t)0x00000200)        /*!<Write protection */
+
+#define  FMC_SDCR2_SDCLK                    ((uint32_t)0x00000C00)        /*!<SDCLK[1:0] (SDRAM clock configuration) */
+#define  FMC_SDCR2_SDCLK_0                  ((uint32_t)0x00000400)        /*!<Bit 0 */
+#define  FMC_SDCR2_SDCLK_1                  ((uint32_t)0x00000800)        /*!<Bit 1 */
+
+#define  FMC_SDCR2_RBURST                   ((uint32_t)0x00001000)        /*!<Read burst */
+
+#define  FMC_SDCR2_RPIPE                    ((uint32_t)0x00006000)        /*!<RPIPE[1:0](Read pipe) */
+#define  FMC_SDCR2_RPIPE_0                  ((uint32_t)0x00002000)        /*!<Bit 0 */
+#define  FMC_SDCR2_RPIPE_1                  ((uint32_t)0x00004000)        /*!<Bit 1 */
+
+/******************  Bit definition for FMC_SDTR1 register  ******************/
+#define  FMC_SDTR1_TMRD                     ((uint32_t)0x0000000F)        /*!<TMRD[3:0] bits (Load mode register to active) */
+#define  FMC_SDTR1_TMRD_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_SDTR1_TMRD_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_SDTR1_TMRD_2                   ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_SDTR1_TMRD_3                   ((uint32_t)0x00000008)        /*!<Bit 3 */
+                                            
+#define  FMC_SDTR1_TXSR                     ((uint32_t)0x000000F0)        /*!<TXSR[3:0] bits (Exit self refresh) */
+#define  FMC_SDTR1_TXSR_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_SDTR1_TXSR_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_SDTR1_TXSR_2                   ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_SDTR1_TXSR_3                   ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_SDTR1_TRAS                     ((uint32_t)0x00000F00)        /*!<TRAS[3:0] bits (Self refresh time) */
+#define  FMC_SDTR1_TRAS_0                   ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_SDTR1_TRAS_1                   ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_SDTR1_TRAS_2                   ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_SDTR1_TRAS_3                   ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FMC_SDTR1_TRC                      ((uint32_t)0x0000F000)        /*!<TRC[2:0] bits (Row cycle delay) */
+#define  FMC_SDTR1_TRC_0                    ((uint32_t)0x00001000)        /*!<Bit 0 */
+#define  FMC_SDTR1_TRC_1                    ((uint32_t)0x00002000)        /*!<Bit 1 */
+#define  FMC_SDTR1_TRC_2                    ((uint32_t)0x00004000)        /*!<Bit 2 */
+
+#define  FMC_SDTR1_TWR                      ((uint32_t)0x000F0000)        /*!<TRC[2:0] bits (Write recovery delay) */
+#define  FMC_SDTR1_TWR_0                    ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_SDTR1_TWR_1                    ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_SDTR1_TWR_2                    ((uint32_t)0x00040000)        /*!<Bit 2 */
+
+#define  FMC_SDTR1_TRP                      ((uint32_t)0x00F00000)        /*!<TRP[2:0] bits (Row precharge delay) */
+#define  FMC_SDTR1_TRP_0                    ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_SDTR1_TRP_1                    ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FMC_SDTR1_TRP_2                    ((uint32_t)0x00400000)        /*!<Bit 2 */
+
+#define  FMC_SDTR1_TRCD                     ((uint32_t)0x0F000000)        /*!<TRP[2:0] bits (Row to column delay) */
+#define  FMC_SDTR1_TRCD_0                   ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_SDTR1_TRCD_1                   ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_SDTR1_TRCD_2                   ((uint32_t)0x04000000)        /*!<Bit 2 */
+
+/******************  Bit definition for FMC_SDTR2 register  ******************/
+#define  FMC_SDTR2_TMRD                     ((uint32_t)0x0000000F)        /*!<TMRD[3:0] bits (Load mode register to active) */
+#define  FMC_SDTR2_TMRD_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_SDTR2_TMRD_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_SDTR2_TMRD_2                   ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  FMC_SDTR2_TMRD_3                   ((uint32_t)0x00000008)        /*!<Bit 3 */
+                                            
+#define  FMC_SDTR2_TXSR                     ((uint32_t)0x000000F0)        /*!<TXSR[3:0] bits (Exit self refresh) */
+#define  FMC_SDTR2_TXSR_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  FMC_SDTR2_TXSR_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
+#define  FMC_SDTR2_TXSR_2                   ((uint32_t)0x00000040)        /*!<Bit 2 */
+#define  FMC_SDTR2_TXSR_3                   ((uint32_t)0x00000080)        /*!<Bit 3 */
+
+#define  FMC_SDTR2_TRAS                     ((uint32_t)0x00000F00)        /*!<TRAS[3:0] bits (Self refresh time) */
+#define  FMC_SDTR2_TRAS_0                   ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  FMC_SDTR2_TRAS_1                   ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  FMC_SDTR2_TRAS_2                   ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  FMC_SDTR2_TRAS_3                   ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  FMC_SDTR2_TRC                      ((uint32_t)0x0000F000)        /*!<TRC[2:0] bits (Row cycle delay) */
+#define  FMC_SDTR2_TRC_0                    ((uint32_t)0x00001000)        /*!<Bit 0 */
+#define  FMC_SDTR2_TRC_1                    ((uint32_t)0x00002000)        /*!<Bit 1 */
+#define  FMC_SDTR2_TRC_2                    ((uint32_t)0x00004000)        /*!<Bit 2 */
+
+#define  FMC_SDTR2_TWR                      ((uint32_t)0x000F0000)        /*!<TRC[2:0] bits (Write recovery delay) */
+#define  FMC_SDTR2_TWR_0                    ((uint32_t)0x00010000)        /*!<Bit 0 */
+#define  FMC_SDTR2_TWR_1                    ((uint32_t)0x00020000)        /*!<Bit 1 */
+#define  FMC_SDTR2_TWR_2                    ((uint32_t)0x00040000)        /*!<Bit 2 */
+
+#define  FMC_SDTR2_TRP                      ((uint32_t)0x00F00000)        /*!<TRP[2:0] bits (Row precharge delay) */
+#define  FMC_SDTR2_TRP_0                    ((uint32_t)0x00100000)        /*!<Bit 0 */
+#define  FMC_SDTR2_TRP_1                    ((uint32_t)0x00200000)        /*!<Bit 1 */
+#define  FMC_SDTR2_TRP_2                    ((uint32_t)0x00400000)        /*!<Bit 2 */
+
+#define  FMC_SDTR2_TRCD                     ((uint32_t)0x0F000000)        /*!<TRP[2:0] bits (Row to column delay) */
+#define  FMC_SDTR2_TRCD_0                   ((uint32_t)0x01000000)        /*!<Bit 0 */
+#define  FMC_SDTR2_TRCD_1                   ((uint32_t)0x02000000)        /*!<Bit 1 */
+#define  FMC_SDTR2_TRCD_2                   ((uint32_t)0x04000000)        /*!<Bit 2 */
+
+/******************  Bit definition for FMC_SDCMR register  ******************/
+#define  FMC_SDCMR_MODE                     ((uint32_t)0x00000007)        /*!<MODE[2:0] bits (Command mode) */
+#define  FMC_SDCMR_MODE_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  FMC_SDCMR_MODE_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  FMC_SDCMR_MODE_2                   ((uint32_t)0x00000003)        /*!<Bit 2 */
+                                            
+#define  FMC_SDCMR_CTB2                     ((uint32_t)0x00000008)        /*!<Command target 2 */
+
+#define  FMC_SDCMR_CTB1                     ((uint32_t)0x00000010)        /*!<Command target 1 */
+
+#define  FMC_SDCMR_NRFS                     ((uint32_t)0x000001E0)        /*!<NRFS[3:0] bits (Number of auto-refresh) */
+#define  FMC_SDCMR_NRFS_0                   ((uint32_t)0x00000020)        /*!<Bit 0 */
+#define  FMC_SDCMR_NRFS_1                   ((uint32_t)0x00000040)        /*!<Bit 1 */
+#define  FMC_SDCMR_NRFS_2                   ((uint32_t)0x00000080)        /*!<Bit 2 */
+#define  FMC_SDCMR_NRFS_3                   ((uint32_t)0x00000100)        /*!<Bit 3 */
+
+#define  FMC_SDCMR_MRD                      ((uint32_t)0x003FFE00)        /*!<MRD[12:0] bits (Mode register definition) */
+
+/******************  Bit definition for FMC_SDRTR register  ******************/
+#define  FMC_SDRTR_CRE                      ((uint32_t)0x00000001)        /*!<Clear refresh error flag */
+
+#define  FMC_SDRTR_COUNT                    ((uint32_t)0x00003FFE)        /*!<COUNT[12:0] bits (Refresh timer count) */
+
+#define  FMC_SDRTR_REIE                     ((uint32_t)0x00004000)        /*!<RES interupt enable */
+
+/******************  Bit definition for FMC_SDSR register  ******************/
+#define  FMC_SDSR_RE                        ((uint32_t)0x00000001)        /*!<Refresh error flag */
+
+#define  FMC_SDSR_MODES1                    ((uint32_t)0x00000006)        /*!<MODES1[1:0]bits (Status mode for bank 1) */
+#define  FMC_SDSR_MODES1_0                  ((uint32_t)0x00000002)        /*!<Bit 0 */
+#define  FMC_SDSR_MODES1_1                  ((uint32_t)0x00000004)        /*!<Bit 1 */
+
+#define  FMC_SDSR_MODES2                    ((uint32_t)0x00000018)        /*!<MODES2[1:0]bits (Status mode for bank 2) */
+#define  FMC_SDSR_MODES2_0                  ((uint32_t)0x00000008)        /*!<Bit 0 */
+#define  FMC_SDSR_MODES2_1                  ((uint32_t)0x00000010)        /*!<Bit 1 */
+
+#define  FMC_SDSR_BUSY                      ((uint32_t)0x00000020)        /*!<Busy status */
+
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+/******************************************************************************/
+/*                                                                            */
+/*                            General Purpose I/O                             */
+/*                                                                            */
+/******************************************************************************/
+/******************  Bits definition for GPIO_MODER register  *****************/
+#define GPIO_MODER_MODER0                    ((uint32_t)0x00000003)
+#define GPIO_MODER_MODER0_0                  ((uint32_t)0x00000001)
+#define GPIO_MODER_MODER0_1                  ((uint32_t)0x00000002)
+
+#define GPIO_MODER_MODER1                    ((uint32_t)0x0000000C)
+#define GPIO_MODER_MODER1_0                  ((uint32_t)0x00000004)
+#define GPIO_MODER_MODER1_1                  ((uint32_t)0x00000008)
+
+#define GPIO_MODER_MODER2                    ((uint32_t)0x00000030)
+#define GPIO_MODER_MODER2_0                  ((uint32_t)0x00000010)
+#define GPIO_MODER_MODER2_1                  ((uint32_t)0x00000020)
+
+#define GPIO_MODER_MODER3                    ((uint32_t)0x000000C0)
+#define GPIO_MODER_MODER3_0                  ((uint32_t)0x00000040)
+#define GPIO_MODER_MODER3_1                  ((uint32_t)0x00000080)
+
+#define GPIO_MODER_MODER4                    ((uint32_t)0x00000300)
+#define GPIO_MODER_MODER4_0                  ((uint32_t)0x00000100)
+#define GPIO_MODER_MODER4_1                  ((uint32_t)0x00000200)
+
+#define GPIO_MODER_MODER5                    ((uint32_t)0x00000C00)
+#define GPIO_MODER_MODER5_0                  ((uint32_t)0x00000400)
+#define GPIO_MODER_MODER5_1                  ((uint32_t)0x00000800)
+
+#define GPIO_MODER_MODER6                    ((uint32_t)0x00003000)
+#define GPIO_MODER_MODER6_0                  ((uint32_t)0x00001000)
+#define GPIO_MODER_MODER6_1                  ((uint32_t)0x00002000)
+
+#define GPIO_MODER_MODER7                    ((uint32_t)0x0000C000)
+#define GPIO_MODER_MODER7_0                  ((uint32_t)0x00004000)
+#define GPIO_MODER_MODER7_1                  ((uint32_t)0x00008000)
+
+#define GPIO_MODER_MODER8                    ((uint32_t)0x00030000)
+#define GPIO_MODER_MODER8_0                  ((uint32_t)0x00010000)
+#define GPIO_MODER_MODER8_1                  ((uint32_t)0x00020000)
+
+#define GPIO_MODER_MODER9                    ((uint32_t)0x000C0000)
+#define GPIO_MODER_MODER9_0                  ((uint32_t)0x00040000)
+#define GPIO_MODER_MODER9_1                  ((uint32_t)0x00080000)
+
+#define GPIO_MODER_MODER10                   ((uint32_t)0x00300000)
+#define GPIO_MODER_MODER10_0                 ((uint32_t)0x00100000)
+#define GPIO_MODER_MODER10_1                 ((uint32_t)0x00200000)
+
+#define GPIO_MODER_MODER11                   ((uint32_t)0x00C00000)
+#define GPIO_MODER_MODER11_0                 ((uint32_t)0x00400000)
+#define GPIO_MODER_MODER11_1                 ((uint32_t)0x00800000)
+
+#define GPIO_MODER_MODER12                   ((uint32_t)0x03000000)
+#define GPIO_MODER_MODER12_0                 ((uint32_t)0x01000000)
+#define GPIO_MODER_MODER12_1                 ((uint32_t)0x02000000)
+
+#define GPIO_MODER_MODER13                   ((uint32_t)0x0C000000)
+#define GPIO_MODER_MODER13_0                 ((uint32_t)0x04000000)
+#define GPIO_MODER_MODER13_1                 ((uint32_t)0x08000000)
+
+#define GPIO_MODER_MODER14                   ((uint32_t)0x30000000)
+#define GPIO_MODER_MODER14_0                 ((uint32_t)0x10000000)
+#define GPIO_MODER_MODER14_1                 ((uint32_t)0x20000000)
+
+#define GPIO_MODER_MODER15                   ((uint32_t)0xC0000000)
+#define GPIO_MODER_MODER15_0                 ((uint32_t)0x40000000)
+#define GPIO_MODER_MODER15_1                 ((uint32_t)0x80000000)
+
+/******************  Bits definition for GPIO_OTYPER register  ****************/
+#define GPIO_OTYPER_OT_0                     ((uint32_t)0x00000001)
+#define GPIO_OTYPER_OT_1                     ((uint32_t)0x00000002)
+#define GPIO_OTYPER_OT_2                     ((uint32_t)0x00000004)
+#define GPIO_OTYPER_OT_3                     ((uint32_t)0x00000008)
+#define GPIO_OTYPER_OT_4                     ((uint32_t)0x00000010)
+#define GPIO_OTYPER_OT_5                     ((uint32_t)0x00000020)
+#define GPIO_OTYPER_OT_6                     ((uint32_t)0x00000040)
+#define GPIO_OTYPER_OT_7                     ((uint32_t)0x00000080)
+#define GPIO_OTYPER_OT_8                     ((uint32_t)0x00000100)
+#define GPIO_OTYPER_OT_9                     ((uint32_t)0x00000200)
+#define GPIO_OTYPER_OT_10                    ((uint32_t)0x00000400)
+#define GPIO_OTYPER_OT_11                    ((uint32_t)0x00000800)
+#define GPIO_OTYPER_OT_12                    ((uint32_t)0x00001000)
+#define GPIO_OTYPER_OT_13                    ((uint32_t)0x00002000)
+#define GPIO_OTYPER_OT_14                    ((uint32_t)0x00004000)
+#define GPIO_OTYPER_OT_15                    ((uint32_t)0x00008000)
+
+/******************  Bits definition for GPIO_OSPEEDR register  ***************/
+#define GPIO_OSPEEDER_OSPEEDR0               ((uint32_t)0x00000003)
+#define GPIO_OSPEEDER_OSPEEDR0_0             ((uint32_t)0x00000001)
+#define GPIO_OSPEEDER_OSPEEDR0_1             ((uint32_t)0x00000002)
+
+#define GPIO_OSPEEDER_OSPEEDR1               ((uint32_t)0x0000000C)
+#define GPIO_OSPEEDER_OSPEEDR1_0             ((uint32_t)0x00000004)
+#define GPIO_OSPEEDER_OSPEEDR1_1             ((uint32_t)0x00000008)
+
+#define GPIO_OSPEEDER_OSPEEDR2               ((uint32_t)0x00000030)
+#define GPIO_OSPEEDER_OSPEEDR2_0             ((uint32_t)0x00000010)
+#define GPIO_OSPEEDER_OSPEEDR2_1             ((uint32_t)0x00000020)
+
+#define GPIO_OSPEEDER_OSPEEDR3               ((uint32_t)0x000000C0)
+#define GPIO_OSPEEDER_OSPEEDR3_0             ((uint32_t)0x00000040)
+#define GPIO_OSPEEDER_OSPEEDR3_1             ((uint32_t)0x00000080)
+
+#define GPIO_OSPEEDER_OSPEEDR4               ((uint32_t)0x00000300)
+#define GPIO_OSPEEDER_OSPEEDR4_0             ((uint32_t)0x00000100)
+#define GPIO_OSPEEDER_OSPEEDR4_1             ((uint32_t)0x00000200)
+
+#define GPIO_OSPEEDER_OSPEEDR5               ((uint32_t)0x00000C00)
+#define GPIO_OSPEEDER_OSPEEDR5_0             ((uint32_t)0x00000400)
+#define GPIO_OSPEEDER_OSPEEDR5_1             ((uint32_t)0x00000800)
+
+#define GPIO_OSPEEDER_OSPEEDR6               ((uint32_t)0x00003000)
+#define GPIO_OSPEEDER_OSPEEDR6_0             ((uint32_t)0x00001000)
+#define GPIO_OSPEEDER_OSPEEDR6_1             ((uint32_t)0x00002000)
+
+#define GPIO_OSPEEDER_OSPEEDR7               ((uint32_t)0x0000C000)
+#define GPIO_OSPEEDER_OSPEEDR7_0             ((uint32_t)0x00004000)
+#define GPIO_OSPEEDER_OSPEEDR7_1             ((uint32_t)0x00008000)
+
+#define GPIO_OSPEEDER_OSPEEDR8               ((uint32_t)0x00030000)
+#define GPIO_OSPEEDER_OSPEEDR8_0             ((uint32_t)0x00010000)
+#define GPIO_OSPEEDER_OSPEEDR8_1             ((uint32_t)0x00020000)
+
+#define GPIO_OSPEEDER_OSPEEDR9               ((uint32_t)0x000C0000)
+#define GPIO_OSPEEDER_OSPEEDR9_0             ((uint32_t)0x00040000)
+#define GPIO_OSPEEDER_OSPEEDR9_1             ((uint32_t)0x00080000)
+
+#define GPIO_OSPEEDER_OSPEEDR10              ((uint32_t)0x00300000)
+#define GPIO_OSPEEDER_OSPEEDR10_0            ((uint32_t)0x00100000)
+#define GPIO_OSPEEDER_OSPEEDR10_1            ((uint32_t)0x00200000)
+
+#define GPIO_OSPEEDER_OSPEEDR11              ((uint32_t)0x00C00000)
+#define GPIO_OSPEEDER_OSPEEDR11_0            ((uint32_t)0x00400000)
+#define GPIO_OSPEEDER_OSPEEDR11_1            ((uint32_t)0x00800000)
+
+#define GPIO_OSPEEDER_OSPEEDR12              ((uint32_t)0x03000000)
+#define GPIO_OSPEEDER_OSPEEDR12_0            ((uint32_t)0x01000000)
+#define GPIO_OSPEEDER_OSPEEDR12_1            ((uint32_t)0x02000000)
+
+#define GPIO_OSPEEDER_OSPEEDR13              ((uint32_t)0x0C000000)
+#define GPIO_OSPEEDER_OSPEEDR13_0            ((uint32_t)0x04000000)
+#define GPIO_OSPEEDER_OSPEEDR13_1            ((uint32_t)0x08000000)
+
+#define GPIO_OSPEEDER_OSPEEDR14              ((uint32_t)0x30000000)
+#define GPIO_OSPEEDER_OSPEEDR14_0            ((uint32_t)0x10000000)
+#define GPIO_OSPEEDER_OSPEEDR14_1            ((uint32_t)0x20000000)
+
+#define GPIO_OSPEEDER_OSPEEDR15              ((uint32_t)0xC0000000)
+#define GPIO_OSPEEDER_OSPEEDR15_0            ((uint32_t)0x40000000)
+#define GPIO_OSPEEDER_OSPEEDR15_1            ((uint32_t)0x80000000)
+
+/******************  Bits definition for GPIO_PUPDR register  *****************/
+#define GPIO_PUPDR_PUPDR0                    ((uint32_t)0x00000003)
+#define GPIO_PUPDR_PUPDR0_0                  ((uint32_t)0x00000001)
+#define GPIO_PUPDR_PUPDR0_1                  ((uint32_t)0x00000002)
+
+#define GPIO_PUPDR_PUPDR1                    ((uint32_t)0x0000000C)
+#define GPIO_PUPDR_PUPDR1_0                  ((uint32_t)0x00000004)
+#define GPIO_PUPDR_PUPDR1_1                  ((uint32_t)0x00000008)
+
+#define GPIO_PUPDR_PUPDR2                    ((uint32_t)0x00000030)
+#define GPIO_PUPDR_PUPDR2_0                  ((uint32_t)0x00000010)
+#define GPIO_PUPDR_PUPDR2_1                  ((uint32_t)0x00000020)
+
+#define GPIO_PUPDR_PUPDR3                    ((uint32_t)0x000000C0)
+#define GPIO_PUPDR_PUPDR3_0                  ((uint32_t)0x00000040)
+#define GPIO_PUPDR_PUPDR3_1                  ((uint32_t)0x00000080)
+
+#define GPIO_PUPDR_PUPDR4                    ((uint32_t)0x00000300)
+#define GPIO_PUPDR_PUPDR4_0                  ((uint32_t)0x00000100)
+#define GPIO_PUPDR_PUPDR4_1                  ((uint32_t)0x00000200)
+
+#define GPIO_PUPDR_PUPDR5                    ((uint32_t)0x00000C00)
+#define GPIO_PUPDR_PUPDR5_0                  ((uint32_t)0x00000400)
+#define GPIO_PUPDR_PUPDR5_1                  ((uint32_t)0x00000800)
+
+#define GPIO_PUPDR_PUPDR6                    ((uint32_t)0x00003000)
+#define GPIO_PUPDR_PUPDR6_0                  ((uint32_t)0x00001000)
+#define GPIO_PUPDR_PUPDR6_1                  ((uint32_t)0x00002000)
+
+#define GPIO_PUPDR_PUPDR7                    ((uint32_t)0x0000C000)
+#define GPIO_PUPDR_PUPDR7_0                  ((uint32_t)0x00004000)
+#define GPIO_PUPDR_PUPDR7_1                  ((uint32_t)0x00008000)
+
+#define GPIO_PUPDR_PUPDR8                    ((uint32_t)0x00030000)
+#define GPIO_PUPDR_PUPDR8_0                  ((uint32_t)0x00010000)
+#define GPIO_PUPDR_PUPDR8_1                  ((uint32_t)0x00020000)
+
+#define GPIO_PUPDR_PUPDR9                    ((uint32_t)0x000C0000)
+#define GPIO_PUPDR_PUPDR9_0                  ((uint32_t)0x00040000)
+#define GPIO_PUPDR_PUPDR9_1                  ((uint32_t)0x00080000)
+
+#define GPIO_PUPDR_PUPDR10                   ((uint32_t)0x00300000)
+#define GPIO_PUPDR_PUPDR10_0                 ((uint32_t)0x00100000)
+#define GPIO_PUPDR_PUPDR10_1                 ((uint32_t)0x00200000)
+
+#define GPIO_PUPDR_PUPDR11                   ((uint32_t)0x00C00000)
+#define GPIO_PUPDR_PUPDR11_0                 ((uint32_t)0x00400000)
+#define GPIO_PUPDR_PUPDR11_1                 ((uint32_t)0x00800000)
+
+#define GPIO_PUPDR_PUPDR12                   ((uint32_t)0x03000000)
+#define GPIO_PUPDR_PUPDR12_0                 ((uint32_t)0x01000000)
+#define GPIO_PUPDR_PUPDR12_1                 ((uint32_t)0x02000000)
+
+#define GPIO_PUPDR_PUPDR13                   ((uint32_t)0x0C000000)
+#define GPIO_PUPDR_PUPDR13_0                 ((uint32_t)0x04000000)
+#define GPIO_PUPDR_PUPDR13_1                 ((uint32_t)0x08000000)
+
+#define GPIO_PUPDR_PUPDR14                   ((uint32_t)0x30000000)
+#define GPIO_PUPDR_PUPDR14_0                 ((uint32_t)0x10000000)
+#define GPIO_PUPDR_PUPDR14_1                 ((uint32_t)0x20000000)
+
+#define GPIO_PUPDR_PUPDR15                   ((uint32_t)0xC0000000)
+#define GPIO_PUPDR_PUPDR15_0                 ((uint32_t)0x40000000)
+#define GPIO_PUPDR_PUPDR15_1                 ((uint32_t)0x80000000)
+
+/******************  Bits definition for GPIO_IDR register  *******************/
+#define GPIO_IDR_IDR_0                       ((uint32_t)0x00000001)
+#define GPIO_IDR_IDR_1                       ((uint32_t)0x00000002)
+#define GPIO_IDR_IDR_2                       ((uint32_t)0x00000004)
+#define GPIO_IDR_IDR_3                       ((uint32_t)0x00000008)
+#define GPIO_IDR_IDR_4                       ((uint32_t)0x00000010)
+#define GPIO_IDR_IDR_5                       ((uint32_t)0x00000020)
+#define GPIO_IDR_IDR_6                       ((uint32_t)0x00000040)
+#define GPIO_IDR_IDR_7                       ((uint32_t)0x00000080)
+#define GPIO_IDR_IDR_8                       ((uint32_t)0x00000100)
+#define GPIO_IDR_IDR_9                       ((uint32_t)0x00000200)
+#define GPIO_IDR_IDR_10                      ((uint32_t)0x00000400)
+#define GPIO_IDR_IDR_11                      ((uint32_t)0x00000800)
+#define GPIO_IDR_IDR_12                      ((uint32_t)0x00001000)
+#define GPIO_IDR_IDR_13                      ((uint32_t)0x00002000)
+#define GPIO_IDR_IDR_14                      ((uint32_t)0x00004000)
+#define GPIO_IDR_IDR_15                      ((uint32_t)0x00008000)
+/* Old GPIO_IDR register bits definition, maintained for legacy purpose */
+#define GPIO_OTYPER_IDR_0                    GPIO_IDR_IDR_0
+#define GPIO_OTYPER_IDR_1                    GPIO_IDR_IDR_1
+#define GPIO_OTYPER_IDR_2                    GPIO_IDR_IDR_2
+#define GPIO_OTYPER_IDR_3                    GPIO_IDR_IDR_3
+#define GPIO_OTYPER_IDR_4                    GPIO_IDR_IDR_4
+#define GPIO_OTYPER_IDR_5                    GPIO_IDR_IDR_5
+#define GPIO_OTYPER_IDR_6                    GPIO_IDR_IDR_6
+#define GPIO_OTYPER_IDR_7                    GPIO_IDR_IDR_7
+#define GPIO_OTYPER_IDR_8                    GPIO_IDR_IDR_8
+#define GPIO_OTYPER_IDR_9                    GPIO_IDR_IDR_9
+#define GPIO_OTYPER_IDR_10                   GPIO_IDR_IDR_10
+#define GPIO_OTYPER_IDR_11                   GPIO_IDR_IDR_11
+#define GPIO_OTYPER_IDR_12                   GPIO_IDR_IDR_12
+#define GPIO_OTYPER_IDR_13                   GPIO_IDR_IDR_13
+#define GPIO_OTYPER_IDR_14                   GPIO_IDR_IDR_14
+#define GPIO_OTYPER_IDR_15                   GPIO_IDR_IDR_15
+
+/******************  Bits definition for GPIO_ODR register  *******************/
+#define GPIO_ODR_ODR_0                       ((uint32_t)0x00000001)
+#define GPIO_ODR_ODR_1                       ((uint32_t)0x00000002)
+#define GPIO_ODR_ODR_2                       ((uint32_t)0x00000004)
+#define GPIO_ODR_ODR_3                       ((uint32_t)0x00000008)
+#define GPIO_ODR_ODR_4                       ((uint32_t)0x00000010)
+#define GPIO_ODR_ODR_5                       ((uint32_t)0x00000020)
+#define GPIO_ODR_ODR_6                       ((uint32_t)0x00000040)
+#define GPIO_ODR_ODR_7                       ((uint32_t)0x00000080)
+#define GPIO_ODR_ODR_8                       ((uint32_t)0x00000100)
+#define GPIO_ODR_ODR_9                       ((uint32_t)0x00000200)
+#define GPIO_ODR_ODR_10                      ((uint32_t)0x00000400)
+#define GPIO_ODR_ODR_11                      ((uint32_t)0x00000800)
+#define GPIO_ODR_ODR_12                      ((uint32_t)0x00001000)
+#define GPIO_ODR_ODR_13                      ((uint32_t)0x00002000)
+#define GPIO_ODR_ODR_14                      ((uint32_t)0x00004000)
+#define GPIO_ODR_ODR_15                      ((uint32_t)0x00008000)
+/* Old GPIO_ODR register bits definition, maintained for legacy purpose */
+#define GPIO_OTYPER_ODR_0                    GPIO_ODR_ODR_0
+#define GPIO_OTYPER_ODR_1                    GPIO_ODR_ODR_1
+#define GPIO_OTYPER_ODR_2                    GPIO_ODR_ODR_2
+#define GPIO_OTYPER_ODR_3                    GPIO_ODR_ODR_3
+#define GPIO_OTYPER_ODR_4                    GPIO_ODR_ODR_4
+#define GPIO_OTYPER_ODR_5                    GPIO_ODR_ODR_5
+#define GPIO_OTYPER_ODR_6                    GPIO_ODR_ODR_6
+#define GPIO_OTYPER_ODR_7                    GPIO_ODR_ODR_7
+#define GPIO_OTYPER_ODR_8                    GPIO_ODR_ODR_8
+#define GPIO_OTYPER_ODR_9                    GPIO_ODR_ODR_9
+#define GPIO_OTYPER_ODR_10                   GPIO_ODR_ODR_10
+#define GPIO_OTYPER_ODR_11                   GPIO_ODR_ODR_11
+#define GPIO_OTYPER_ODR_12                   GPIO_ODR_ODR_12
+#define GPIO_OTYPER_ODR_13                   GPIO_ODR_ODR_13
+#define GPIO_OTYPER_ODR_14                   GPIO_ODR_ODR_14
+#define GPIO_OTYPER_ODR_15                   GPIO_ODR_ODR_15
+
+/******************  Bits definition for GPIO_BSRR register  ******************/
+#define GPIO_BSRR_BS_0                       ((uint32_t)0x00000001)
+#define GPIO_BSRR_BS_1                       ((uint32_t)0x00000002)
+#define GPIO_BSRR_BS_2                       ((uint32_t)0x00000004)
+#define GPIO_BSRR_BS_3                       ((uint32_t)0x00000008)
+#define GPIO_BSRR_BS_4                       ((uint32_t)0x00000010)
+#define GPIO_BSRR_BS_5                       ((uint32_t)0x00000020)
+#define GPIO_BSRR_BS_6                       ((uint32_t)0x00000040)
+#define GPIO_BSRR_BS_7                       ((uint32_t)0x00000080)
+#define GPIO_BSRR_BS_8                       ((uint32_t)0x00000100)
+#define GPIO_BSRR_BS_9                       ((uint32_t)0x00000200)
+#define GPIO_BSRR_BS_10                      ((uint32_t)0x00000400)
+#define GPIO_BSRR_BS_11                      ((uint32_t)0x00000800)
+#define GPIO_BSRR_BS_12                      ((uint32_t)0x00001000)
+#define GPIO_BSRR_BS_13                      ((uint32_t)0x00002000)
+#define GPIO_BSRR_BS_14                      ((uint32_t)0x00004000)
+#define GPIO_BSRR_BS_15                      ((uint32_t)0x00008000)
+#define GPIO_BSRR_BR_0                       ((uint32_t)0x00010000)
+#define GPIO_BSRR_BR_1                       ((uint32_t)0x00020000)
+#define GPIO_BSRR_BR_2                       ((uint32_t)0x00040000)
+#define GPIO_BSRR_BR_3                       ((uint32_t)0x00080000)
+#define GPIO_BSRR_BR_4                       ((uint32_t)0x00100000)
+#define GPIO_BSRR_BR_5                       ((uint32_t)0x00200000)
+#define GPIO_BSRR_BR_6                       ((uint32_t)0x00400000)
+#define GPIO_BSRR_BR_7                       ((uint32_t)0x00800000)
+#define GPIO_BSRR_BR_8                       ((uint32_t)0x01000000)
+#define GPIO_BSRR_BR_9                       ((uint32_t)0x02000000)
+#define GPIO_BSRR_BR_10                      ((uint32_t)0x04000000)
+#define GPIO_BSRR_BR_11                      ((uint32_t)0x08000000)
+#define GPIO_BSRR_BR_12                      ((uint32_t)0x10000000)
+#define GPIO_BSRR_BR_13                      ((uint32_t)0x20000000)
+#define GPIO_BSRR_BR_14                      ((uint32_t)0x40000000)
+#define GPIO_BSRR_BR_15                      ((uint32_t)0x80000000)
+
+/******************************************************************************/
+/*                                                                            */
+/*                                    HASH                                    */
+/*                                                                            */
+/******************************************************************************/
+/******************  Bits definition for HASH_CR register  ********************/
+#define HASH_CR_INIT                         ((uint32_t)0x00000004)
+#define HASH_CR_DMAE                         ((uint32_t)0x00000008)
+#define HASH_CR_DATATYPE                     ((uint32_t)0x00000030)
+#define HASH_CR_DATATYPE_0                   ((uint32_t)0x00000010)
+#define HASH_CR_DATATYPE_1                   ((uint32_t)0x00000020)
+#define HASH_CR_MODE                         ((uint32_t)0x00000040)
+#define HASH_CR_ALGO                         ((uint32_t)0x00040080)
+#define HASH_CR_ALGO_0                       ((uint32_t)0x00000080)
+#define HASH_CR_ALGO_1                       ((uint32_t)0x00040000)
+#define HASH_CR_NBW                          ((uint32_t)0x00000F00)
+#define HASH_CR_NBW_0                        ((uint32_t)0x00000100)
+#define HASH_CR_NBW_1                        ((uint32_t)0x00000200)
+#define HASH_CR_NBW_2                        ((uint32_t)0x00000400)
+#define HASH_CR_NBW_3                        ((uint32_t)0x00000800)
+#define HASH_CR_DINNE                        ((uint32_t)0x00001000)
+#define HASH_CR_MDMAT                        ((uint32_t)0x00002000)
+#define HASH_CR_LKEY                         ((uint32_t)0x00010000)
+
+/******************  Bits definition for HASH_STR register  *******************/
+#define HASH_STR_NBW                         ((uint32_t)0x0000001F)
+#define HASH_STR_NBW_0                       ((uint32_t)0x00000001)
+#define HASH_STR_NBW_1                       ((uint32_t)0x00000002)
+#define HASH_STR_NBW_2                       ((uint32_t)0x00000004)
+#define HASH_STR_NBW_3                       ((uint32_t)0x00000008)
+#define HASH_STR_NBW_4                       ((uint32_t)0x00000010)
+#define HASH_STR_DCAL                        ((uint32_t)0x00000100)
+
+/******************  Bits definition for HASH_IMR register  *******************/
+#define HASH_IMR_DINIM                       ((uint32_t)0x00000001)
+#define HASH_IMR_DCIM                        ((uint32_t)0x00000002)
+
+/******************  Bits definition for HASH_SR register  ********************/
+#define HASH_SR_DINIS                        ((uint32_t)0x00000001)
+#define HASH_SR_DCIS                         ((uint32_t)0x00000002)
+#define HASH_SR_DMAS                         ((uint32_t)0x00000004)
+#define HASH_SR_BUSY                         ((uint32_t)0x00000008)
+
+/******************************************************************************/
+/*                                                                            */
+/*                      Inter-integrated Circuit Interface                    */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bit definition for I2C_CR1 register  ********************/
+#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!<Peripheral Enable                             */
+#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!<SMBus Mode                                    */
+#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!<SMBus Type                                    */
+#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!<ARP Enable                                    */
+#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!<PEC Enable                                    */
+#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!<General Call Enable                           */
+#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!<Clock Stretching Disable (Slave mode)         */
+#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!<Start Generation                              */
+#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!<Stop Generation                               */
+#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!<Acknowledge Enable                            */
+#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!<Acknowledge/PEC Position (for data reception) */
+#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!<Packet Error Checking                         */
+#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!<SMBus Alert                                   */
+#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!<Software Reset                                */
+
+/*******************  Bit definition for I2C_CR2 register  ********************/
+#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!<FREQ[5:0] bits (Peripheral Clock Frequency)   */
+#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
+#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
+#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
+#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
+#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
+#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
+
+#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!<Error Interrupt Enable  */
+#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!<Event Interrupt Enable  */
+#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!<Buffer Interrupt Enable */
+#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!<DMA Requests Enable     */
+#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!<DMA Last Transfer       */
+
+/*******************  Bit definition for I2C_OAR1 register  *******************/
+#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!<Interface Address */
+#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!<Interface Address */
+
+#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!<Bit 0 */
+#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!<Bit 1 */
+#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!<Bit 2 */
+#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!<Bit 3 */
+#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!<Bit 4 */
+#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!<Bit 5 */
+#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!<Bit 6 */
+#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!<Bit 7 */
+#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!<Bit 8 */
+#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!<Bit 9 */
+
+#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!<Addressing Mode (Slave mode) */
+
+/*******************  Bit definition for I2C_OAR2 register  *******************/
+#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!<Dual addressing mode enable */
+#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!<Interface address           */
+
+/********************  Bit definition for I2C_DR register  ********************/
+#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!<8-bit Data Register         */
+
+/*******************  Bit definition for I2C_SR1 register  ********************/
+#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!<Start Bit (Master mode)                         */
+#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!<Address sent (master mode)/matched (slave mode) */
+#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!<Byte Transfer Finished                          */
+#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!<10-bit header sent (Master mode)                */
+#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!<Stop detection (Slave mode)                     */
+#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!<Data Register not Empty (receivers)             */
+#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!<Data Register Empty (transmitters)              */
+#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!<Bus Error                                       */
+#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!<Arbitration Lost (master mode)                  */
+#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!<Acknowledge Failure                             */
+#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!<Overrun/Underrun                                */
+#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!<PEC Error in reception                          */
+#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!<Timeout or Tlow Error                           */
+#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!<SMBus Alert                                     */
+
+/*******************  Bit definition for I2C_SR2 register  ********************/
+#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!<Master/Slave                              */
+#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!<Bus Busy                                  */
+#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!<Transmitter/Receiver                      */
+#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!<General Call Address (Slave mode)         */
+#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!<SMBus Device Default Address (Slave mode) */
+#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!<SMBus Host Header (Slave mode)            */
+#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!<Dual Flag (Slave mode)                    */
+#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!<Packet Error Checking Register            */
+
+/*******************  Bit definition for I2C_CCR register  ********************/
+#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!<Clock Control Register in Fast/Standard mode (Master mode) */
+#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!<Fast Mode Duty Cycle                                       */
+#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!<I2C Master Mode Selection                                  */
+
+/******************  Bit definition for I2C_TRISE register  *******************/
+#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!<Maximum Rise Time in Fast/Standard mode (Master mode) */
+
+/******************  Bit definition for I2C_FLTR register  *******************/
+#define  I2C_FLTR_DNF                     ((uint8_t)0x0F)                  /*!<Digital Noise Filter */
+#define  I2C_FLTR_ANOFF                   ((uint8_t)0x10)                  /*!<Analog Noise Filter OFF */
+
+/******************************************************************************/
+/*                                                                            */
+/*                           Independent WATCHDOG                             */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bit definition for IWDG_KR register  ********************/
+#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!<Key value (write only, read 0000h)  */
+
+/*******************  Bit definition for IWDG_PR register  ********************/
+#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!<PR[2:0] (Prescaler divider)         */
+#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!<Bit 0 */
+#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!<Bit 1 */
+#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!<Bit 2 */
+
+/*******************  Bit definition for IWDG_RLR register  *******************/
+#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!<Watchdog counter reload value        */
+
+/*******************  Bit definition for IWDG_SR register  ********************/
+#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!<Watchdog prescaler value update      */
+#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!<Watchdog counter reload value update */
+
+/******************************************************************************/
+/*                                                                            */
+/*                      LCD-TFT Display Controller (LTDC)                     */
+/*                                                                            */
+/******************************************************************************/
+
+/********************  Bit definition for LTDC_SSCR register  *****************/
+
+#define LTDC_SSCR_VSH                       ((uint32_t)0x000007FF)              /*!< Vertical Synchronization Height */
+#define LTDC_SSCR_HSW                       ((uint32_t)0x0FFF0000)              /*!< Horizontal Synchronization Width */
+
+/********************  Bit definition for LTDC_BPCR register  *****************/
+
+#define LTDC_BPCR_AVBP                      ((uint32_t)0x000007FF)              /*!< Accumulated Vertical Back Porch */
+#define LTDC_BPCR_AHBP                      ((uint32_t)0x0FFF0000)              /*!< Accumulated Horizontal Back Porch */
+
+/********************  Bit definition for LTDC_AWCR register  *****************/
+
+#define LTDC_AWCR_AAH                       ((uint32_t)0x000007FF)              /*!< Accumulated Active heigh */
+#define LTDC_AWCR_AAW                       ((uint32_t)0x0FFF0000)              /*!< Accumulated Active Width */
+
+/********************  Bit definition for LTDC_TWCR register  *****************/
+
+#define LTDC_TWCR_TOTALH                    ((uint32_t)0x000007FF)              /*!< Total Heigh */
+#define LTDC_TWCR_TOTALW                    ((uint32_t)0x0FFF0000)              /*!< Total Width */
+
+/********************  Bit definition for LTDC_GCR register  ******************/
+
+#define LTDC_GCR_LTDCEN                     ((uint32_t)0x00000001)              /*!< LCD-TFT controller enable bit */
+#define LTDC_GCR_DBW                        ((uint32_t)0x00000070)              /*!< Dither Blue Width */
+#define LTDC_GCR_DGW                        ((uint32_t)0x00000700)              /*!< Dither Green Width */
+#define LTDC_GCR_DRW                        ((uint32_t)0x00007000)              /*!< Dither Red Width */
+#define LTDC_GCR_DTEN                       ((uint32_t)0x00010000)              /*!< Dither Enable */
+#define LTDC_GCR_PCPOL                      ((uint32_t)0x10000000)              /*!< Pixel Clock Polarity */
+#define LTDC_GCR_DEPOL                      ((uint32_t)0x20000000)              /*!< Data Enable Polarity */
+#define LTDC_GCR_VSPOL                      ((uint32_t)0x40000000)              /*!< Vertical Synchronization Polarity */
+#define LTDC_GCR_HSPOL                      ((uint32_t)0x80000000)              /*!< Horizontal Synchronization Polarity */
+
+/********************  Bit definition for LTDC_SRCR register  *****************/
+
+#define LTDC_SRCR_IMR                      ((uint32_t)0x00000001)               /*!< Immediate Reload */
+#define LTDC_SRCR_VBR                      ((uint32_t)0x00000002)               /*!< Vertical Blanking Reload */
+
+/********************  Bit definition for LTDC_BCCR register  *****************/
+
+#define LTDC_BCCR_BCBLUE                    ((uint32_t)0x000000FF)              /*!< Background Blue value */
+#define LTDC_BCCR_BCGREEN                   ((uint32_t)0x0000FF00)              /*!< Background Green value */
+#define LTDC_BCCR_BCRED                     ((uint32_t)0x00FF0000)              /*!< Background Red value */
+
+/********************  Bit definition for LTDC_IER register  ******************/
+
+#define LTDC_IER_LIE                        ((uint32_t)0x00000001)              /*!< Line Interrupt Enable */
+#define LTDC_IER_FUIE                       ((uint32_t)0x00000002)              /*!< FIFO Underrun Interrupt Enable */
+#define LTDC_IER_TERRIE                     ((uint32_t)0x00000004)              /*!< Transfer Error Interrupt Enable */
+#define LTDC_IER_RRIE                       ((uint32_t)0x00000008)              /*!< Register Reload interrupt enable */
+
+/********************  Bit definition for LTDC_ISR register  ******************/
+
+#define LTDC_ISR_LIF                        ((uint32_t)0x00000001)              /*!< Line Interrupt Flag */
+#define LTDC_ISR_FUIF                       ((uint32_t)0x00000002)              /*!< FIFO Underrun Interrupt Flag */
+#define LTDC_ISR_TERRIF                     ((uint32_t)0x00000004)              /*!< Transfer Error Interrupt Flag */
+#define LTDC_ISR_RRIF                       ((uint32_t)0x00000008)              /*!< Register Reload interrupt Flag */
+
+/********************  Bit definition for LTDC_ICR register  ******************/
+
+#define LTDC_ICR_CLIF                       ((uint32_t)0x00000001)              /*!< Clears the Line Interrupt Flag */
+#define LTDC_ICR_CFUIF                      ((uint32_t)0x00000002)              /*!< Clears the FIFO Underrun Interrupt Flag */
+#define LTDC_ICR_CTERRIF                    ((uint32_t)0x00000004)              /*!< Clears the Transfer Error Interrupt Flag */
+#define LTDC_ICR_CRRIF                      ((uint32_t)0x00000008)              /*!< Clears Register Reload interrupt Flag */
+
+/********************  Bit definition for LTDC_LIPCR register  ****************/
+
+#define LTDC_LIPCR_LIPOS                    ((uint32_t)0x000007FF)              /*!< Line Interrupt Position */
+
+/********************  Bit definition for LTDC_CPSR register  *****************/
+
+#define LTDC_CPSR_CYPOS                     ((uint32_t)0x0000FFFF)              /*!< Current Y Position */
+#define LTDC_CPSR_CXPOS                     ((uint32_t)0xFFFF0000)              /*!< Current X Position */
+
+/********************  Bit definition for LTDC_CDSR register  *****************/
+
+#define LTDC_CDSR_VDES                      ((uint32_t)0x00000001)              /*!< Vertical Data Enable Status */
+#define LTDC_CDSR_HDES                      ((uint32_t)0x00000002)              /*!< Horizontal Data Enable Status */
+#define LTDC_CDSR_VSYNCS                    ((uint32_t)0x00000004)              /*!< Vertical Synchronization Status */
+#define LTDC_CDSR_HSYNCS                    ((uint32_t)0x00000008)              /*!< Horizontal Synchronization Status */
+
+/********************  Bit definition for LTDC_LxCR register  *****************/
+
+#define LTDC_LxCR_LEN                       ((uint32_t)0x00000001)              /*!< Layer Enable */
+#define LTDC_LxCR_COLKEN                    ((uint32_t)0x00000002)              /*!< Color Keying Enable */
+#define LTDC_LxCR_CLUTEN                    ((uint32_t)0x00000010)              /*!< Color Lockup Table Enable */
+
+/********************  Bit definition for LTDC_LxWHPCR register  **************/
+
+#define LTDC_LxWHPCR_WHSTPOS                ((uint32_t)0x00000FFF)              /*!< Window Horizontal Start Position */
+#define LTDC_LxWHPCR_WHSPPOS                ((uint32_t)0xFFFF0000)              /*!< Window Horizontal Stop Position */
+
+/********************  Bit definition for LTDC_LxWVPCR register  **************/
+
+#define LTDC_LxWVPCR_WVSTPOS                ((uint32_t)0x00000FFF)              /*!< Window Vertical Start Position */
+#define LTDC_LxWVPCR_WVSPPOS                ((uint32_t)0xFFFF0000)              /*!< Window Vertical Stop Position */
+
+/********************  Bit definition for LTDC_LxCKCR register  ***************/
+
+#define LTDC_LxCKCR_CKBLUE                  ((uint32_t)0x000000FF)              /*!< Color Key Blue value */
+#define LTDC_LxCKCR_CKGREEN                 ((uint32_t)0x0000FF00)              /*!< Color Key Green value */
+#define LTDC_LxCKCR_CKRED                   ((uint32_t)0x00FF0000)              /*!< Color Key Red value */
+
+/********************  Bit definition for LTDC_LxPFCR register  ***************/
+
+#define LTDC_LxPFCR_PF                      ((uint32_t)0x00000007)              /*!< Pixel Format */
+
+/********************  Bit definition for LTDC_LxCACR register  ***************/
+
+#define LTDC_LxCACR_CONSTA                  ((uint32_t)0x000000FF)              /*!< Constant Alpha */
+
+/********************  Bit definition for LTDC_LxDCCR register  ***************/
+
+#define LTDC_LxDCCR_DCBLUE                  ((uint32_t)0x000000FF)              /*!< Default Color Blue */
+#define LTDC_LxDCCR_DCGREEN                 ((uint32_t)0x0000FF00)              /*!< Default Color Green */
+#define LTDC_LxDCCR_DCRED                   ((uint32_t)0x00FF0000)              /*!< Default Color Red */
+#define LTDC_LxDCCR_DCALPHA                 ((uint32_t)0xFF000000)              /*!< Default Color Alpha */
+                                
+/********************  Bit definition for LTDC_LxBFCR register  ***************/
+
+#define LTDC_LxBFCR_BF2                     ((uint32_t)0x00000007)              /*!< Blending Factor 2 */
+#define LTDC_LxBFCR_BF1                     ((uint32_t)0x00000700)              /*!< Blending Factor 1 */
+
+/********************  Bit definition for LTDC_LxCFBAR register  **************/
+
+#define LTDC_LxCFBAR_CFBADD                 ((uint32_t)0xFFFFFFFF)              /*!< Color Frame Buffer Start Address */
+
+/********************  Bit definition for LTDC_LxCFBLR register  **************/
+
+#define LTDC_LxCFBLR_CFBLL                  ((uint32_t)0x00001FFF)              /*!< Color Frame Buffer Line Length */
+#define LTDC_LxCFBLR_CFBP                   ((uint32_t)0x1FFF0000)              /*!< Color Frame Buffer Pitch in bytes */
+
+/********************  Bit definition for LTDC_LxCFBLNR register  *************/
+
+#define LTDC_LxCFBLNR_CFBLNBR               ((uint32_t)0x000007FF)              /*!< Frame Buffer Line Number */
+
+/********************  Bit definition for LTDC_LxCLUTWR register  *************/
+
+#define LTDC_LxCLUTWR_BLUE                  ((uint32_t)0x000000FF)              /*!< Blue value */
+#define LTDC_LxCLUTWR_GREEN                 ((uint32_t)0x0000FF00)              /*!< Green value */
+#define LTDC_LxCLUTWR_RED                   ((uint32_t)0x00FF0000)              /*!< Red value */
+#define LTDC_LxCLUTWR_CLUTADD               ((uint32_t)0xFF000000)              /*!< CLUT address */
+
+/******************************************************************************/
+/*                                                                            */
+/*                             Power Control                                  */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bit definition for PWR_CR register  ********************/
+#define  PWR_CR_LPDS                         ((uint32_t)0x00000001)     /*!< Low-Power Deepsleep                 */
+#define  PWR_CR_PDDS                         ((uint32_t)0x00000002)     /*!< Power Down Deepsleep                */
+#define  PWR_CR_CWUF                         ((uint32_t)0x00000004)     /*!< Clear Wakeup Flag                   */
+#define  PWR_CR_CSBF                         ((uint32_t)0x00000008)     /*!< Clear Standby Flag                  */
+#define  PWR_CR_PVDE                         ((uint32_t)0x00000010)     /*!< Power Voltage Detector Enable       */
+
+#define  PWR_CR_PLS                          ((uint32_t)0x000000E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
+#define  PWR_CR_PLS_0                        ((uint32_t)0x00000020)     /*!< Bit 0 */
+#define  PWR_CR_PLS_1                        ((uint32_t)0x00000040)     /*!< Bit 1 */
+#define  PWR_CR_PLS_2                        ((uint32_t)0x00000080)     /*!< Bit 2 */
+
+/*!< PVD level configuration */
+#define  PWR_CR_PLS_LEV0                     ((uint32_t)0x00000000)     /*!< PVD level 0 */
+#define  PWR_CR_PLS_LEV1                     ((uint32_t)0x00000020)     /*!< PVD level 1 */
+#define  PWR_CR_PLS_LEV2                     ((uint32_t)0x00000040)     /*!< PVD level 2 */
+#define  PWR_CR_PLS_LEV3                     ((uint32_t)0x00000060)     /*!< PVD level 3 */
+#define  PWR_CR_PLS_LEV4                     ((uint32_t)0x00000080)     /*!< PVD level 4 */
+#define  PWR_CR_PLS_LEV5                     ((uint32_t)0x000000A0)     /*!< PVD level 5 */
+#define  PWR_CR_PLS_LEV6                     ((uint32_t)0x000000C0)     /*!< PVD level 6 */
+#define  PWR_CR_PLS_LEV7                     ((uint32_t)0x000000E0)     /*!< PVD level 7 */
+
+#define  PWR_CR_DBP                          ((uint32_t)0x00000100)     /*!< Disable Backup Domain write protection                     */
+#define  PWR_CR_FPDS                         ((uint32_t)0x00000200)     /*!< Flash power down in Stop mode                              */
+#define  PWR_CR_LPUDS                        ((uint32_t)0x00000400)     /*!< Low-Power Regulator in Stop under-drive mode               */
+#define  PWR_CR_MRUDS                        ((uint32_t)0x00000800)     /*!< Main regulator in Stop under-drive mode                    */
+#define  PWR_CR_LPLVDS                       ((uint32_t)0x00000400)     /*!< Low-power regulator Low Voltage in Deep Sleep mode         */
+#define  PWR_CR_MRLVDS                       ((uint32_t)0x00000800)     /*!< Main regulator Low Voltage in Deep Sleep mode              */
+
+#define  PWR_CR_ADCDC1                       ((uint32_t)0x00002000)     /*!< Refer to AN4073 on how to use this bit */ 
+
+#define  PWR_CR_VOS                          ((uint32_t)0x0000C000)     /*!< VOS[1:0] bits (Regulator voltage scaling output selection) */
+#define  PWR_CR_VOS_0                        ((uint32_t)0x00004000)     /*!< Bit 0 */
+#define  PWR_CR_VOS_1                        ((uint32_t)0x00008000)     /*!< Bit 1 */
+
+#define  PWR_CR_ODEN                         ((uint32_t)0x00010000)     /*!< Over Drive enable                   */
+#define  PWR_CR_ODSWEN                       ((uint32_t)0x00020000)     /*!< Over Drive switch enabled           */
+#define  PWR_CR_UDEN                         ((uint32_t)0x000C0000)     /*!< Under Drive enable in stop mode     */
+#define  PWR_CR_UDEN_0                       ((uint32_t)0x00040000)     /*!< Bit 0                               */
+#define  PWR_CR_UDEN_1                       ((uint32_t)0x00080000)     /*!< Bit 1                               */
+
+#define  PWR_CR_FMSSR                        ((uint32_t)0x00100000)     /*!< Flash Memory Sleep System Run        */
+#define  PWR_CR_FISSR                        ((uint32_t)0x00200000)     /*!< Flash Interface Stop while System Run */
+
+/* Legacy define */
+#define  PWR_CR_PMODE                        PWR_CR_VOS
+
+/*******************  Bit definition for PWR_CSR register  ********************/
+#define  PWR_CSR_WUF                         ((uint32_t)0x00000001)     /*!< Wakeup Flag                                      */
+#define  PWR_CSR_SBF                         ((uint32_t)0x00000002)     /*!< Standby Flag                                     */
+#define  PWR_CSR_PVDO                        ((uint32_t)0x00000004)     /*!< PVD Output                                       */
+#define  PWR_CSR_BRR                         ((uint32_t)0x00000008)     /*!< Backup regulator ready                           */
+#define  PWR_CSR_EWUP                        ((uint32_t)0x00000100)     /*!< Enable WKUP pin                                  */
+#define  PWR_CSR_BRE                         ((uint32_t)0x00000200)     /*!< Backup regulator enable                          */
+#define  PWR_CSR_VOSRDY                      ((uint32_t)0x00004000)     /*!< Regulator voltage scaling output selection ready */
+#define  PWR_CSR_ODRDY                       ((uint32_t)0x00010000)     /*!< Over Drive generator ready                       */
+#define  PWR_CSR_ODSWRDY                     ((uint32_t)0x00020000)     /*!< Over Drive Switch ready                          */
+#define  PWR_CSR_UDSWRDY                     ((uint32_t)0x000C0000)     /*!< Under Drive ready                                */
+
+/* Legacy define */
+#define  PWR_CSR_REGRDY                      PWR_CSR_VOSRDY
+
+/******************************************************************************/
+/*                                                                            */
+/*                         Reset and Clock Control                            */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bit definition for RCC_CR register  ********************/
+#define  RCC_CR_HSION                        ((uint32_t)0x00000001)
+#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)
+
+#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)
+#define  RCC_CR_HSITRIM_0                    ((uint32_t)0x00000008)/*!<Bit 0 */
+#define  RCC_CR_HSITRIM_1                    ((uint32_t)0x00000010)/*!<Bit 1 */
+#define  RCC_CR_HSITRIM_2                    ((uint32_t)0x00000020)/*!<Bit 2 */
+#define  RCC_CR_HSITRIM_3                    ((uint32_t)0x00000040)/*!<Bit 3 */
+#define  RCC_CR_HSITRIM_4                    ((uint32_t)0x00000080)/*!<Bit 4 */
+
+#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)
+#define  RCC_CR_HSICAL_0                     ((uint32_t)0x00000100)/*!<Bit 0 */
+#define  RCC_CR_HSICAL_1                     ((uint32_t)0x00000200)/*!<Bit 1 */
+#define  RCC_CR_HSICAL_2                     ((uint32_t)0x00000400)/*!<Bit 2 */
+#define  RCC_CR_HSICAL_3                     ((uint32_t)0x00000800)/*!<Bit 3 */
+#define  RCC_CR_HSICAL_4                     ((uint32_t)0x00001000)/*!<Bit 4 */
+#define  RCC_CR_HSICAL_5                     ((uint32_t)0x00002000)/*!<Bit 5 */
+#define  RCC_CR_HSICAL_6                     ((uint32_t)0x00004000)/*!<Bit 6 */
+#define  RCC_CR_HSICAL_7                     ((uint32_t)0x00008000)/*!<Bit 7 */
+
+#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)
+#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)
+#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)
+#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)
+#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)
+#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)
+#define  RCC_CR_PLLI2SON                     ((uint32_t)0x04000000)
+#define  RCC_CR_PLLI2SRDY                    ((uint32_t)0x08000000)
+#define  RCC_CR_PLLSAION                     ((uint32_t)0x10000000)
+#define  RCC_CR_PLLSAIRDY                    ((uint32_t)0x20000000)
+
+/********************  Bit definition for RCC_PLLCFGR register  ***************/
+#define  RCC_PLLCFGR_PLLM                    ((uint32_t)0x0000003F)
+#define  RCC_PLLCFGR_PLLM_0                  ((uint32_t)0x00000001)
+#define  RCC_PLLCFGR_PLLM_1                  ((uint32_t)0x00000002)
+#define  RCC_PLLCFGR_PLLM_2                  ((uint32_t)0x00000004)
+#define  RCC_PLLCFGR_PLLM_3                  ((uint32_t)0x00000008)
+#define  RCC_PLLCFGR_PLLM_4                  ((uint32_t)0x00000010)
+#define  RCC_PLLCFGR_PLLM_5                  ((uint32_t)0x00000020)
+
+#define  RCC_PLLCFGR_PLLN                     ((uint32_t)0x00007FC0)
+#define  RCC_PLLCFGR_PLLN_0                   ((uint32_t)0x00000040)
+#define  RCC_PLLCFGR_PLLN_1                   ((uint32_t)0x00000080)
+#define  RCC_PLLCFGR_PLLN_2                   ((uint32_t)0x00000100)
+#define  RCC_PLLCFGR_PLLN_3                   ((uint32_t)0x00000200)
+#define  RCC_PLLCFGR_PLLN_4                   ((uint32_t)0x00000400)
+#define  RCC_PLLCFGR_PLLN_5                   ((uint32_t)0x00000800)
+#define  RCC_PLLCFGR_PLLN_6                   ((uint32_t)0x00001000)
+#define  RCC_PLLCFGR_PLLN_7                   ((uint32_t)0x00002000)
+#define  RCC_PLLCFGR_PLLN_8                   ((uint32_t)0x00004000)
+
+#define  RCC_PLLCFGR_PLLP                    ((uint32_t)0x00030000)
+#define  RCC_PLLCFGR_PLLP_0                  ((uint32_t)0x00010000)
+#define  RCC_PLLCFGR_PLLP_1                  ((uint32_t)0x00020000)
+
+#define  RCC_PLLCFGR_PLLSRC                  ((uint32_t)0x00400000)
+#define  RCC_PLLCFGR_PLLSRC_HSE              ((uint32_t)0x00400000)
+#define  RCC_PLLCFGR_PLLSRC_HSI              ((uint32_t)0x00000000)
+
+#define  RCC_PLLCFGR_PLLQ                    ((uint32_t)0x0F000000)
+#define  RCC_PLLCFGR_PLLQ_0                  ((uint32_t)0x01000000)
+#define  RCC_PLLCFGR_PLLQ_1                  ((uint32_t)0x02000000)
+#define  RCC_PLLCFGR_PLLQ_2                  ((uint32_t)0x04000000)
+#define  RCC_PLLCFGR_PLLQ_3                  ((uint32_t)0x08000000)
+
+/********************  Bit definition for RCC_CFGR register  ******************/
+/*!< SW configuration */
+#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
+#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
+
+#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
+#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
+#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */
+
+/*!< SWS configuration */
+#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
+#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
+#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
+
+#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
+#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
+#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */
+
+/*!< HPRE configuration */
+#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
+#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
+#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
+#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
+#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
+#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
+#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
+#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
+#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
+#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
+
+/*!< PPRE1 configuration */
+#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00001C00)        /*!< PRE1[2:0] bits (APB1 prescaler) */
+#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00001000)        /*!< Bit 2 */
+
+#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
+#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00001000)        /*!< HCLK divided by 2 */
+#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00001400)        /*!< HCLK divided by 4 */
+#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00001800)        /*!< HCLK divided by 8 */
+#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00001C00)        /*!< HCLK divided by 16 */
+
+/*!< PPRE2 configuration */
+#define  RCC_CFGR_PPRE2                      ((uint32_t)0x0000E000)        /*!< PRE2[2:0] bits (APB2 prescaler) */
+#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00002000)        /*!< Bit 0 */
+#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00004000)        /*!< Bit 1 */
+#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00008000)        /*!< Bit 2 */
+
+#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
+#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00008000)        /*!< HCLK divided by 2 */
+#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x0000A000)        /*!< HCLK divided by 4 */
+#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x0000C000)        /*!< HCLK divided by 8 */
+#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x0000E000)        /*!< HCLK divided by 16 */
+
+/*!< RTCPRE configuration */
+#define  RCC_CFGR_RTCPRE                     ((uint32_t)0x001F0000)
+#define  RCC_CFGR_RTCPRE_0                   ((uint32_t)0x00010000)
+#define  RCC_CFGR_RTCPRE_1                   ((uint32_t)0x00020000)
+#define  RCC_CFGR_RTCPRE_2                   ((uint32_t)0x00040000)
+#define  RCC_CFGR_RTCPRE_3                   ((uint32_t)0x00080000)
+#define  RCC_CFGR_RTCPRE_4                   ((uint32_t)0x00100000)
+
+/*!< MCO1 configuration */
+#define  RCC_CFGR_MCO1                       ((uint32_t)0x00600000)
+#define  RCC_CFGR_MCO1_0                     ((uint32_t)0x00200000)
+#define  RCC_CFGR_MCO1_1                     ((uint32_t)0x00400000)
+
+#define  RCC_CFGR_I2SSRC                     ((uint32_t)0x00800000)
+
+#define  RCC_CFGR_MCO1PRE                    ((uint32_t)0x07000000)
+#define  RCC_CFGR_MCO1PRE_0                  ((uint32_t)0x01000000)
+#define  RCC_CFGR_MCO1PRE_1                  ((uint32_t)0x02000000)
+#define  RCC_CFGR_MCO1PRE_2                  ((uint32_t)0x04000000)
+
+#define  RCC_CFGR_MCO2PRE                    ((uint32_t)0x38000000)
+#define  RCC_CFGR_MCO2PRE_0                  ((uint32_t)0x08000000)
+#define  RCC_CFGR_MCO2PRE_1                  ((uint32_t)0x10000000)
+#define  RCC_CFGR_MCO2PRE_2                  ((uint32_t)0x20000000)
+
+#define  RCC_CFGR_MCO2                       ((uint32_t)0xC0000000)
+#define  RCC_CFGR_MCO2_0                     ((uint32_t)0x40000000)
+#define  RCC_CFGR_MCO2_1                     ((uint32_t)0x80000000)
+
+/********************  Bit definition for RCC_CIR register  *******************/
+#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)
+#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)
+#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)
+#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)
+#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)
+#define  RCC_CIR_PLLI2SRDYF                  ((uint32_t)0x00000020)
+#define  RCC_CIR_PLLSAIRDYF                  ((uint32_t)0x00000040)
+#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)
+#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)
+#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)
+#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)
+#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)
+#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)
+#define  RCC_CIR_PLLI2SRDYIE                 ((uint32_t)0x00002000)
+#define  RCC_CIR_PLLSAIRDYIE                 ((uint32_t)0x00004000)
+#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)
+#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)
+#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)
+#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)
+#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)
+#define  RCC_CIR_PLLI2SRDYC                  ((uint32_t)0x00200000)
+#define  RCC_CIR_PLLSAIRDYC                  ((uint32_t)0x00400000)
+#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)
+
+/********************  Bit definition for RCC_AHB1RSTR register  **************/
+#define  RCC_AHB1RSTR_GPIOARST               ((uint32_t)0x00000001)
+#define  RCC_AHB1RSTR_GPIOBRST               ((uint32_t)0x00000002)
+#define  RCC_AHB1RSTR_GPIOCRST               ((uint32_t)0x00000004)
+#define  RCC_AHB1RSTR_GPIODRST               ((uint32_t)0x00000008)
+#define  RCC_AHB1RSTR_GPIOERST               ((uint32_t)0x00000010)
+#define  RCC_AHB1RSTR_GPIOFRST               ((uint32_t)0x00000020)
+#define  RCC_AHB1RSTR_GPIOGRST               ((uint32_t)0x00000040)
+#define  RCC_AHB1RSTR_GPIOHRST               ((uint32_t)0x00000080)
+#define  RCC_AHB1RSTR_GPIOIRST               ((uint32_t)0x00000100)
+#define  RCC_AHB1RSTR_GPIOJRST               ((uint32_t)0x00000200)
+#define  RCC_AHB1RSTR_GPIOKRST               ((uint32_t)0x00000400)
+#define  RCC_AHB1RSTR_CRCRST                 ((uint32_t)0x00001000)
+#define  RCC_AHB1RSTR_DMA1RST                ((uint32_t)0x00200000)
+#define  RCC_AHB1RSTR_DMA2RST                ((uint32_t)0x00400000)
+#define  RCC_AHB1RSTR_DMA2DRST               ((uint32_t)0x00800000)
+#define  RCC_AHB1RSTR_ETHMACRST              ((uint32_t)0x02000000)
+#define  RCC_AHB1RSTR_OTGHRST                ((uint32_t)0x10000000)
+
+/********************  Bit definition for RCC_AHB2RSTR register  **************/
+#define  RCC_AHB2RSTR_DCMIRST                ((uint32_t)0x00000001)
+#define  RCC_AHB2RSTR_CRYPRST                ((uint32_t)0x00000010)
+#define  RCC_AHB2RSTR_HASHRST                ((uint32_t)0x00000020)
+ /* maintained for legacy purpose */
+ #define  RCC_AHB2RSTR_HSAHRST                RCC_AHB2RSTR_HASHRST
+#define  RCC_AHB2RSTR_RNGRST                 ((uint32_t)0x00000040)
+#define  RCC_AHB2RSTR_OTGFSRST               ((uint32_t)0x00000080)
+
+/********************  Bit definition for RCC_AHB3RSTR register  **************/
+#if defined(STM32F40_41xxx)
+#define  RCC_AHB3RSTR_FSMCRST                ((uint32_t)0x00000001)
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define  RCC_AHB3RSTR_FMCRST                ((uint32_t)0x00000001)
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+/********************  Bit definition for RCC_APB1RSTR register  **************/
+#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)
+#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)
+#define  RCC_APB1RSTR_TIM4RST                ((uint32_t)0x00000004)
+#define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)
+#define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)
+#define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)
+#define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)
+#define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)
+#define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)
+#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)
+#define  RCC_APB1RSTR_SPI2RST                ((uint32_t)0x00004000)
+#define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)
+#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)
+#define  RCC_APB1RSTR_USART3RST              ((uint32_t)0x00040000)
+#define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)
+#define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)
+#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)
+#define  RCC_APB1RSTR_I2C2RST                ((uint32_t)0x00400000)
+#define  RCC_APB1RSTR_I2C3RST                ((uint32_t)0x00800000)
+#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)
+#define  RCC_APB1RSTR_CAN2RST                ((uint32_t)0x04000000)
+#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)
+#define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)
+#define  RCC_APB1RSTR_UART7RST               ((uint32_t)0x40000000)
+#define  RCC_APB1RSTR_UART8RST               ((uint32_t)0x80000000)
+
+/********************  Bit definition for RCC_APB2RSTR register  **************/
+#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000001)
+#define  RCC_APB2RSTR_TIM8RST                ((uint32_t)0x00000002)
+#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00000010)
+#define  RCC_APB2RSTR_USART6RST              ((uint32_t)0x00000020)
+#define  RCC_APB2RSTR_ADCRST                 ((uint32_t)0x00000100)
+#define  RCC_APB2RSTR_SDIORST                ((uint32_t)0x00000800)
+#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)
+#define  RCC_APB2RSTR_SPI4RST                ((uint32_t)0x00002000)
+#define  RCC_APB2RSTR_SYSCFGRST              ((uint32_t)0x00004000)
+#define  RCC_APB2RSTR_TIM9RST                ((uint32_t)0x00010000)
+#define  RCC_APB2RSTR_TIM10RST               ((uint32_t)0x00020000)
+#define  RCC_APB2RSTR_TIM11RST               ((uint32_t)0x00040000)
+#define  RCC_APB2RSTR_SPI5RST                ((uint32_t)0x00100000)
+#define  RCC_APB2RSTR_SPI6RST                ((uint32_t)0x00200000)
+#define  RCC_APB2RSTR_SAI1RST                ((uint32_t)0x00400000)
+#define  RCC_APB2RSTR_LTDCRST                ((uint32_t)0x04000000)
+
+/* Old SPI1RST bit definition, maintained for legacy purpose */
+#define  RCC_APB2RSTR_SPI1                   RCC_APB2RSTR_SPI1RST
+
+/********************  Bit definition for RCC_AHB1ENR register  ***************/
+#define  RCC_AHB1ENR_GPIOAEN                 ((uint32_t)0x00000001)
+#define  RCC_AHB1ENR_GPIOBEN                 ((uint32_t)0x00000002)
+#define  RCC_AHB1ENR_GPIOCEN                 ((uint32_t)0x00000004)
+#define  RCC_AHB1ENR_GPIODEN                 ((uint32_t)0x00000008)
+#define  RCC_AHB1ENR_GPIOEEN                 ((uint32_t)0x00000010)
+#define  RCC_AHB1ENR_GPIOFEN                 ((uint32_t)0x00000020)
+#define  RCC_AHB1ENR_GPIOGEN                 ((uint32_t)0x00000040)
+#define  RCC_AHB1ENR_GPIOHEN                 ((uint32_t)0x00000080)
+#define  RCC_AHB1ENR_GPIOIEN                 ((uint32_t)0x00000100)
+#define  RCC_AHB1ENR_GPIOJEN                 ((uint32_t)0x00000200)
+#define  RCC_AHB1ENR_GPIOKEN                 ((uint32_t)0x00000400)
+#define  RCC_AHB1ENR_CRCEN                   ((uint32_t)0x00001000)
+#define  RCC_AHB1ENR_BKPSRAMEN               ((uint32_t)0x00040000)
+#define  RCC_AHB1ENR_CCMDATARAMEN            ((uint32_t)0x00100000)
+#define  RCC_AHB1ENR_DMA1EN                  ((uint32_t)0x00200000)
+#define  RCC_AHB1ENR_DMA2EN                  ((uint32_t)0x00400000)
+#define  RCC_AHB1ENR_DMA2DEN                 ((uint32_t)0x00800000)
+#define  RCC_AHB1ENR_ETHMACEN                ((uint32_t)0x02000000)
+#define  RCC_AHB1ENR_ETHMACTXEN              ((uint32_t)0x04000000)
+#define  RCC_AHB1ENR_ETHMACRXEN              ((uint32_t)0x08000000)
+#define  RCC_AHB1ENR_ETHMACPTPEN             ((uint32_t)0x10000000)
+#define  RCC_AHB1ENR_OTGHSEN                 ((uint32_t)0x20000000)
+#define  RCC_AHB1ENR_OTGHSULPIEN             ((uint32_t)0x40000000)
+
+/********************  Bit definition for RCC_AHB2ENR register  ***************/
+#define  RCC_AHB2ENR_DCMIEN                  ((uint32_t)0x00000001)
+#define  RCC_AHB2ENR_CRYPEN                  ((uint32_t)0x00000010)
+#define  RCC_AHB2ENR_HASHEN                  ((uint32_t)0x00000020)
+#define  RCC_AHB2ENR_RNGEN                   ((uint32_t)0x00000040)
+#define  RCC_AHB2ENR_OTGFSEN                 ((uint32_t)0x00000080)
+
+/********************  Bit definition for RCC_AHB3ENR register  ***************/
+
+#if defined(STM32F40_41xxx)
+#define  RCC_AHB3ENR_FSMCEN                  ((uint32_t)0x00000001)
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define  RCC_AHB3ENR_FMCEN                  ((uint32_t)0x00000001)
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+/********************  Bit definition for RCC_APB1ENR register  ***************/
+#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)
+#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)
+#define  RCC_APB1ENR_TIM4EN                  ((uint32_t)0x00000004)
+#define  RCC_APB1ENR_TIM5EN                  ((uint32_t)0x00000008)
+#define  RCC_APB1ENR_TIM6EN                  ((uint32_t)0x00000010)
+#define  RCC_APB1ENR_TIM7EN                  ((uint32_t)0x00000020)
+#define  RCC_APB1ENR_TIM12EN                 ((uint32_t)0x00000040)
+#define  RCC_APB1ENR_TIM13EN                 ((uint32_t)0x00000080)
+#define  RCC_APB1ENR_TIM14EN                 ((uint32_t)0x00000100)
+#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)
+#define  RCC_APB1ENR_SPI2EN                  ((uint32_t)0x00004000)
+#define  RCC_APB1ENR_SPI3EN                  ((uint32_t)0x00008000)
+#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)
+#define  RCC_APB1ENR_USART3EN                ((uint32_t)0x00040000)
+#define  RCC_APB1ENR_UART4EN                 ((uint32_t)0x00080000)
+#define  RCC_APB1ENR_UART5EN                 ((uint32_t)0x00100000)
+#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)
+#define  RCC_APB1ENR_I2C2EN                  ((uint32_t)0x00400000)
+#define  RCC_APB1ENR_I2C3EN                  ((uint32_t)0x00800000)
+#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)
+#define  RCC_APB1ENR_CAN2EN                  ((uint32_t)0x04000000)
+#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)
+#define  RCC_APB1ENR_DACEN                   ((uint32_t)0x20000000)
+#define  RCC_APB1ENR_UART7EN                 ((uint32_t)0x40000000)
+#define  RCC_APB1ENR_UART8EN                 ((uint32_t)0x80000000)
+
+/********************  Bit definition for RCC_APB2ENR register  ***************/
+#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000001)
+#define  RCC_APB2ENR_TIM8EN                  ((uint32_t)0x00000002)
+#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00000010)
+#define  RCC_APB2ENR_USART6EN                ((uint32_t)0x00000020)
+#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000100)
+#define  RCC_APB2ENR_ADC2EN                  ((uint32_t)0x00000200)
+#define  RCC_APB2ENR_ADC3EN                  ((uint32_t)0x00000400)
+#define  RCC_APB2ENR_SDIOEN                  ((uint32_t)0x00000800)
+#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)
+#define  RCC_APB2ENR_SPI4EN                  ((uint32_t)0x00002000)
+#define  RCC_APB2ENR_SYSCFGEN                ((uint32_t)0x00004000)
+#define  RCC_APB2ENR_TIM9EN                  ((uint32_t)0x00010000)
+#define  RCC_APB2ENR_TIM10EN                 ((uint32_t)0x00020000)
+#define  RCC_APB2ENR_TIM11EN                 ((uint32_t)0x00040000)
+#define  RCC_APB2ENR_SPI5EN                  ((uint32_t)0x00100000)
+#define  RCC_APB2ENR_SPI6EN                  ((uint32_t)0x00200000)
+#define  RCC_APB2ENR_SAI1EN                  ((uint32_t)0x00400000)
+#define  RCC_APB2ENR_LTDCEN                  ((uint32_t)0x04000000)
+
+/********************  Bit definition for RCC_AHB1LPENR register  *************/
+#define  RCC_AHB1LPENR_GPIOALPEN             ((uint32_t)0x00000001)
+#define  RCC_AHB1LPENR_GPIOBLPEN             ((uint32_t)0x00000002)
+#define  RCC_AHB1LPENR_GPIOCLPEN             ((uint32_t)0x00000004)
+#define  RCC_AHB1LPENR_GPIODLPEN             ((uint32_t)0x00000008)
+#define  RCC_AHB1LPENR_GPIOELPEN             ((uint32_t)0x00000010)
+#define  RCC_AHB1LPENR_GPIOFLPEN             ((uint32_t)0x00000020)
+#define  RCC_AHB1LPENR_GPIOGLPEN             ((uint32_t)0x00000040)
+#define  RCC_AHB1LPENR_GPIOHLPEN             ((uint32_t)0x00000080)
+#define  RCC_AHB1LPENR_GPIOILPEN             ((uint32_t)0x00000100)
+#define  RCC_AHB1LPENR_GPIOJLPEN             ((uint32_t)0x00000200)
+#define  RCC_AHB1LPENR_GPIOKLPEN             ((uint32_t)0x00000400)
+#define  RCC_AHB1LPENR_CRCLPEN               ((uint32_t)0x00001000)
+#define  RCC_AHB1LPENR_FLITFLPEN             ((uint32_t)0x00008000)
+#define  RCC_AHB1LPENR_SRAM1LPEN             ((uint32_t)0x00010000)
+#define  RCC_AHB1LPENR_SRAM2LPEN             ((uint32_t)0x00020000)
+#define  RCC_AHB1LPENR_BKPSRAMLPEN           ((uint32_t)0x00040000)
+#define  RCC_AHB1LPENR_SRAM3LPEN             ((uint32_t)0x00080000)
+#define  RCC_AHB1LPENR_DMA1LPEN              ((uint32_t)0x00200000)
+#define  RCC_AHB1LPENR_DMA2LPEN              ((uint32_t)0x00400000)
+#define  RCC_AHB1LPENR_DMA2DLPEN             ((uint32_t)0x00800000)
+#define  RCC_AHB1LPENR_ETHMACLPEN            ((uint32_t)0x02000000)
+#define  RCC_AHB1LPENR_ETHMACTXLPEN          ((uint32_t)0x04000000)
+#define  RCC_AHB1LPENR_ETHMACRXLPEN          ((uint32_t)0x08000000)
+#define  RCC_AHB1LPENR_ETHMACPTPLPEN         ((uint32_t)0x10000000)
+#define  RCC_AHB1LPENR_OTGHSLPEN             ((uint32_t)0x20000000)
+#define  RCC_AHB1LPENR_OTGHSULPILPEN         ((uint32_t)0x40000000)
+
+/********************  Bit definition for RCC_AHB2LPENR register  *************/
+#define  RCC_AHB2LPENR_DCMILPEN              ((uint32_t)0x00000001)
+#define  RCC_AHB2LPENR_CRYPLPEN              ((uint32_t)0x00000010)
+#define  RCC_AHB2LPENR_HASHLPEN              ((uint32_t)0x00000020)
+#define  RCC_AHB2LPENR_RNGLPEN               ((uint32_t)0x00000040)
+#define  RCC_AHB2LPENR_OTGFSLPEN             ((uint32_t)0x00000080)
+
+/********************  Bit definition for RCC_AHB3LPENR register  *************/
+#if defined(STM32F40_41xxx)
+#define  RCC_AHB3LPENR_FSMCLPEN              ((uint32_t)0x00000001)
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define  RCC_AHB3LPENR_FMCLPEN              ((uint32_t)0x00000001)
+#endif /* STM32F427_437xx ||  STM32F429_439xx */
+
+/********************  Bit definition for RCC_APB1LPENR register  *************/
+#define  RCC_APB1LPENR_TIM2LPEN              ((uint32_t)0x00000001)
+#define  RCC_APB1LPENR_TIM3LPEN              ((uint32_t)0x00000002)
+#define  RCC_APB1LPENR_TIM4LPEN              ((uint32_t)0x00000004)
+#define  RCC_APB1LPENR_TIM5LPEN              ((uint32_t)0x00000008)
+#define  RCC_APB1LPENR_TIM6LPEN              ((uint32_t)0x00000010)
+#define  RCC_APB1LPENR_TIM7LPEN              ((uint32_t)0x00000020)
+#define  RCC_APB1LPENR_TIM12LPEN             ((uint32_t)0x00000040)
+#define  RCC_APB1LPENR_TIM13LPEN             ((uint32_t)0x00000080)
+#define  RCC_APB1LPENR_TIM14LPEN             ((uint32_t)0x00000100)
+#define  RCC_APB1LPENR_WWDGLPEN              ((uint32_t)0x00000800)
+#define  RCC_APB1LPENR_SPI2LPEN              ((uint32_t)0x00004000)
+#define  RCC_APB1LPENR_SPI3LPEN              ((uint32_t)0x00008000)
+#define  RCC_APB1LPENR_USART2LPEN            ((uint32_t)0x00020000)
+#define  RCC_APB1LPENR_USART3LPEN            ((uint32_t)0x00040000)
+#define  RCC_APB1LPENR_UART4LPEN             ((uint32_t)0x00080000)
+#define  RCC_APB1LPENR_UART5LPEN             ((uint32_t)0x00100000)
+#define  RCC_APB1LPENR_I2C1LPEN              ((uint32_t)0x00200000)
+#define  RCC_APB1LPENR_I2C2LPEN              ((uint32_t)0x00400000)
+#define  RCC_APB1LPENR_I2C3LPEN              ((uint32_t)0x00800000)
+#define  RCC_APB1LPENR_CAN1LPEN              ((uint32_t)0x02000000)
+#define  RCC_APB1LPENR_CAN2LPEN              ((uint32_t)0x04000000)
+#define  RCC_APB1LPENR_PWRLPEN               ((uint32_t)0x10000000)
+#define  RCC_APB1LPENR_DACLPEN               ((uint32_t)0x20000000)
+#define  RCC_APB1LPENR_UART7LPEN             ((uint32_t)0x40000000)
+#define  RCC_APB1LPENR_UART8LPEN             ((uint32_t)0x80000000)
+
+/********************  Bit definition for RCC_APB2LPENR register  *************/
+#define  RCC_APB2LPENR_TIM1LPEN              ((uint32_t)0x00000001)
+#define  RCC_APB2LPENR_TIM8LPEN              ((uint32_t)0x00000002)
+#define  RCC_APB2LPENR_USART1LPEN            ((uint32_t)0x00000010)
+#define  RCC_APB2LPENR_USART6LPEN            ((uint32_t)0x00000020)
+#define  RCC_APB2LPENR_ADC1LPEN              ((uint32_t)0x00000100)
+#define  RCC_APB2LPENR_ADC2PEN               ((uint32_t)0x00000200)
+#define  RCC_APB2LPENR_ADC3LPEN              ((uint32_t)0x00000400)
+#define  RCC_APB2LPENR_SDIOLPEN              ((uint32_t)0x00000800)
+#define  RCC_APB2LPENR_SPI1LPEN              ((uint32_t)0x00001000)
+#define  RCC_APB2LPENR_SPI4LPEN              ((uint32_t)0x00002000)
+#define  RCC_APB2LPENR_SYSCFGLPEN            ((uint32_t)0x00004000)
+#define  RCC_APB2LPENR_TIM9LPEN              ((uint32_t)0x00010000)
+#define  RCC_APB2LPENR_TIM10LPEN             ((uint32_t)0x00020000)
+#define  RCC_APB2LPENR_TIM11LPEN             ((uint32_t)0x00040000)
+#define  RCC_APB2LPENR_SPI5LPEN              ((uint32_t)0x00100000)
+#define  RCC_APB2LPENR_SPI6LPEN              ((uint32_t)0x00200000)
+#define  RCC_APB2LPENR_SAI1LPEN              ((uint32_t)0x00400000)
+#define  RCC_APB2LPENR_LTDCLPEN              ((uint32_t)0x04000000)
+
+/********************  Bit definition for RCC_BDCR register  ******************/
+#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)
+#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)
+#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)
+#define  RCC_BDCR_LSEMOD                     ((uint32_t)0x00000008)
+
+#define  RCC_BDCR_RTCSEL                    ((uint32_t)0x00000300)
+#define  RCC_BDCR_RTCSEL_0                  ((uint32_t)0x00000100)
+#define  RCC_BDCR_RTCSEL_1                  ((uint32_t)0x00000200)
+
+#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)
+#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)
+
+/********************  Bit definition for RCC_CSR register  *******************/
+#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)
+#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)
+#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)
+#define  RCC_CSR_BORRSTF                     ((uint32_t)0x02000000)
+#define  RCC_CSR_PADRSTF                     ((uint32_t)0x04000000)
+#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)
+#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)
+#define  RCC_CSR_WDGRSTF                     ((uint32_t)0x20000000)
+#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)
+#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)
+
+/********************  Bit definition for RCC_SSCGR register  *****************/
+#define  RCC_SSCGR_MODPER                    ((uint32_t)0x00001FFF)
+#define  RCC_SSCGR_INCSTEP                   ((uint32_t)0x0FFFE000)
+#define  RCC_SSCGR_SPREADSEL                 ((uint32_t)0x40000000)
+#define  RCC_SSCGR_SSCGEN                    ((uint32_t)0x80000000)
+
+/********************  Bit definition for RCC_PLLI2SCFGR register  ************/
+#define  RCC_PLLI2SCFGR_PLLI2SM              ((uint32_t)0x0000003F)
+#define  RCC_PLLI2SCFGR_PLLI2SM_0            ((uint32_t)0x00000001)
+#define  RCC_PLLI2SCFGR_PLLI2SM_1            ((uint32_t)0x00000002)
+#define  RCC_PLLI2SCFGR_PLLI2SM_2            ((uint32_t)0x00000004)
+#define  RCC_PLLI2SCFGR_PLLI2SM_3            ((uint32_t)0x00000008)
+#define  RCC_PLLI2SCFGR_PLLI2SM_4            ((uint32_t)0x00000010)
+#define  RCC_PLLI2SCFGR_PLLI2SM_5            ((uint32_t)0x00000020)
+
+/********************  Bit definition for RCC_PLLI2SCFGR register  ************/
+#define  RCC_PLLI2SCFGR_PLLI2SN              ((uint32_t)0x00007FC0)
+#define  RCC_PLLI2SCFGR_PLLI2SQ              ((uint32_t)0x0F000000)
+#define  RCC_PLLI2SCFGR_PLLI2SR              ((uint32_t)0x70000000)
+
+/********************  Bit definition for RCC_PLLSAICFGR register  ************/
+#define  RCC_PLLSAICFGR_PLLI2SN              ((uint32_t)0x00007FC0)
+#define  RCC_PLLSAICFGR_PLLI2SQ              ((uint32_t)0x0F000000)
+#define  RCC_PLLSAICFGR_PLLI2SR              ((uint32_t)0x70000000)
+
+/********************  Bit definition for RCC_DCKCFGR register  ***************/
+#define  RCC_DCKCFGR_PLLI2SDIVQ              ((uint32_t)0x0000001F)
+#define  RCC_DCKCFGR_PLLSAIDIVQ              ((uint32_t)0x00001F00)
+#define  RCC_DCKCFGR_PLLSAIDIVR              ((uint32_t)0x00030000)
+#define  RCC_DCKCFGR_SAI1ASRC                ((uint32_t)0x00300000)
+#define  RCC_DCKCFGR_SAI1BSRC                ((uint32_t)0x00C00000)
+#define  RCC_DCKCFGR_TIMPRE                  ((uint32_t)0x01000000)
+
+
+/******************************************************************************/
+/*                                                                            */
+/*                                    RNG                                     */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bits definition for RNG_CR register  *******************/
+#define RNG_CR_RNGEN                         ((uint32_t)0x00000004)
+#define RNG_CR_IE                            ((uint32_t)0x00000008)
+
+/********************  Bits definition for RNG_SR register  *******************/
+#define RNG_SR_DRDY                          ((uint32_t)0x00000001)
+#define RNG_SR_CECS                          ((uint32_t)0x00000002)
+#define RNG_SR_SECS                          ((uint32_t)0x00000004)
+#define RNG_SR_CEIS                          ((uint32_t)0x00000020)
+#define RNG_SR_SEIS                          ((uint32_t)0x00000040)
+
+/******************************************************************************/
+/*                                                                            */
+/*                           Real-Time Clock (RTC)                            */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bits definition for RTC_TR register  *******************/
+#define RTC_TR_PM                            ((uint32_t)0x00400000)
+#define RTC_TR_HT                            ((uint32_t)0x00300000)
+#define RTC_TR_HT_0                          ((uint32_t)0x00100000)
+#define RTC_TR_HT_1                          ((uint32_t)0x00200000)
+#define RTC_TR_HU                            ((uint32_t)0x000F0000)
+#define RTC_TR_HU_0                          ((uint32_t)0x00010000)
+#define RTC_TR_HU_1                          ((uint32_t)0x00020000)
+#define RTC_TR_HU_2                          ((uint32_t)0x00040000)
+#define RTC_TR_HU_3                          ((uint32_t)0x00080000)
+#define RTC_TR_MNT                           ((uint32_t)0x00007000)
+#define RTC_TR_MNT_0                         ((uint32_t)0x00001000)
+#define RTC_TR_MNT_1                         ((uint32_t)0x00002000)
+#define RTC_TR_MNT_2                         ((uint32_t)0x00004000)
+#define RTC_TR_MNU                           ((uint32_t)0x00000F00)
+#define RTC_TR_MNU_0                         ((uint32_t)0x00000100)
+#define RTC_TR_MNU_1                         ((uint32_t)0x00000200)
+#define RTC_TR_MNU_2                         ((uint32_t)0x00000400)
+#define RTC_TR_MNU_3                         ((uint32_t)0x00000800)
+#define RTC_TR_ST                            ((uint32_t)0x00000070)
+#define RTC_TR_ST_0                          ((uint32_t)0x00000010)
+#define RTC_TR_ST_1                          ((uint32_t)0x00000020)
+#define RTC_TR_ST_2                          ((uint32_t)0x00000040)
+#define RTC_TR_SU                            ((uint32_t)0x0000000F)
+#define RTC_TR_SU_0                          ((uint32_t)0x00000001)
+#define RTC_TR_SU_1                          ((uint32_t)0x00000002)
+#define RTC_TR_SU_2                          ((uint32_t)0x00000004)
+#define RTC_TR_SU_3                          ((uint32_t)0x00000008)
+
+/********************  Bits definition for RTC_DR register  *******************/
+#define RTC_DR_YT                            ((uint32_t)0x00F00000)
+#define RTC_DR_YT_0                          ((uint32_t)0x00100000)
+#define RTC_DR_YT_1                          ((uint32_t)0x00200000)
+#define RTC_DR_YT_2                          ((uint32_t)0x00400000)
+#define RTC_DR_YT_3                          ((uint32_t)0x00800000)
+#define RTC_DR_YU                            ((uint32_t)0x000F0000)
+#define RTC_DR_YU_0                          ((uint32_t)0x00010000)
+#define RTC_DR_YU_1                          ((uint32_t)0x00020000)
+#define RTC_DR_YU_2                          ((uint32_t)0x00040000)
+#define RTC_DR_YU_3                          ((uint32_t)0x00080000)
+#define RTC_DR_WDU                           ((uint32_t)0x0000E000)
+#define RTC_DR_WDU_0                         ((uint32_t)0x00002000)
+#define RTC_DR_WDU_1                         ((uint32_t)0x00004000)
+#define RTC_DR_WDU_2                         ((uint32_t)0x00008000)
+#define RTC_DR_MT                            ((uint32_t)0x00001000)
+#define RTC_DR_MU                            ((uint32_t)0x00000F00)
+#define RTC_DR_MU_0                          ((uint32_t)0x00000100)
+#define RTC_DR_MU_1                          ((uint32_t)0x00000200)
+#define RTC_DR_MU_2                          ((uint32_t)0x00000400)
+#define RTC_DR_MU_3                          ((uint32_t)0x00000800)
+#define RTC_DR_DT                            ((uint32_t)0x00000030)
+#define RTC_DR_DT_0                          ((uint32_t)0x00000010)
+#define RTC_DR_DT_1                          ((uint32_t)0x00000020)
+#define RTC_DR_DU                            ((uint32_t)0x0000000F)
+#define RTC_DR_DU_0                          ((uint32_t)0x00000001)
+#define RTC_DR_DU_1                          ((uint32_t)0x00000002)
+#define RTC_DR_DU_2                          ((uint32_t)0x00000004)
+#define RTC_DR_DU_3                          ((uint32_t)0x00000008)
+
+/********************  Bits definition for RTC_CR register  *******************/
+#define RTC_CR_COE                           ((uint32_t)0x00800000)
+#define RTC_CR_OSEL                          ((uint32_t)0x00600000)
+#define RTC_CR_OSEL_0                        ((uint32_t)0x00200000)
+#define RTC_CR_OSEL_1                        ((uint32_t)0x00400000)
+#define RTC_CR_POL                           ((uint32_t)0x00100000)
+#define RTC_CR_COSEL                         ((uint32_t)0x00080000)
+#define RTC_CR_BCK                           ((uint32_t)0x00040000)
+#define RTC_CR_SUB1H                         ((uint32_t)0x00020000)
+#define RTC_CR_ADD1H                         ((uint32_t)0x00010000)
+#define RTC_CR_TSIE                          ((uint32_t)0x00008000)
+#define RTC_CR_WUTIE                         ((uint32_t)0x00004000)
+#define RTC_CR_ALRBIE                        ((uint32_t)0x00002000)
+#define RTC_CR_ALRAIE                        ((uint32_t)0x00001000)
+#define RTC_CR_TSE                           ((uint32_t)0x00000800)
+#define RTC_CR_WUTE                          ((uint32_t)0x00000400)
+#define RTC_CR_ALRBE                         ((uint32_t)0x00000200)
+#define RTC_CR_ALRAE                         ((uint32_t)0x00000100)
+#define RTC_CR_DCE                           ((uint32_t)0x00000080)
+#define RTC_CR_FMT                           ((uint32_t)0x00000040)
+#define RTC_CR_BYPSHAD                       ((uint32_t)0x00000020)
+#define RTC_CR_REFCKON                       ((uint32_t)0x00000010)
+#define RTC_CR_TSEDGE                        ((uint32_t)0x00000008)
+#define RTC_CR_WUCKSEL                       ((uint32_t)0x00000007)
+#define RTC_CR_WUCKSEL_0                     ((uint32_t)0x00000001)
+#define RTC_CR_WUCKSEL_1                     ((uint32_t)0x00000002)
+#define RTC_CR_WUCKSEL_2                     ((uint32_t)0x00000004)
+
+/********************  Bits definition for RTC_ISR register  ******************/
+#define RTC_ISR_RECALPF                      ((uint32_t)0x00010000)
+#define RTC_ISR_TAMP1F                       ((uint32_t)0x00002000)
+#define RTC_ISR_TSOVF                        ((uint32_t)0x00001000)
+#define RTC_ISR_TSF                          ((uint32_t)0x00000800)
+#define RTC_ISR_WUTF                         ((uint32_t)0x00000400)
+#define RTC_ISR_ALRBF                        ((uint32_t)0x00000200)
+#define RTC_ISR_ALRAF                        ((uint32_t)0x00000100)
+#define RTC_ISR_INIT                         ((uint32_t)0x00000080)
+#define RTC_ISR_INITF                        ((uint32_t)0x00000040)
+#define RTC_ISR_RSF                          ((uint32_t)0x00000020)
+#define RTC_ISR_INITS                        ((uint32_t)0x00000010)
+#define RTC_ISR_SHPF                         ((uint32_t)0x00000008)
+#define RTC_ISR_WUTWF                        ((uint32_t)0x00000004)
+#define RTC_ISR_ALRBWF                       ((uint32_t)0x00000002)
+#define RTC_ISR_ALRAWF                       ((uint32_t)0x00000001)
+
+/********************  Bits definition for RTC_PRER register  *****************/
+#define RTC_PRER_PREDIV_A                    ((uint32_t)0x007F0000)
+#define RTC_PRER_PREDIV_S                    ((uint32_t)0x00001FFF)
+
+/********************  Bits definition for RTC_WUTR register  *****************/
+#define RTC_WUTR_WUT                         ((uint32_t)0x0000FFFF)
+
+/********************  Bits definition for RTC_CALIBR register  ***************/
+#define RTC_CALIBR_DCS                       ((uint32_t)0x00000080)
+#define RTC_CALIBR_DC                        ((uint32_t)0x0000001F)
+
+/********************  Bits definition for RTC_ALRMAR register  ***************/
+#define RTC_ALRMAR_MSK4                      ((uint32_t)0x80000000)
+#define RTC_ALRMAR_WDSEL                     ((uint32_t)0x40000000)
+#define RTC_ALRMAR_DT                        ((uint32_t)0x30000000)
+#define RTC_ALRMAR_DT_0                      ((uint32_t)0x10000000)
+#define RTC_ALRMAR_DT_1                      ((uint32_t)0x20000000)
+#define RTC_ALRMAR_DU                        ((uint32_t)0x0F000000)
+#define RTC_ALRMAR_DU_0                      ((uint32_t)0x01000000)
+#define RTC_ALRMAR_DU_1                      ((uint32_t)0x02000000)
+#define RTC_ALRMAR_DU_2                      ((uint32_t)0x04000000)
+#define RTC_ALRMAR_DU_3                      ((uint32_t)0x08000000)
+#define RTC_ALRMAR_MSK3                      ((uint32_t)0x00800000)
+#define RTC_ALRMAR_PM                        ((uint32_t)0x00400000)
+#define RTC_ALRMAR_HT                        ((uint32_t)0x00300000)
+#define RTC_ALRMAR_HT_0                      ((uint32_t)0x00100000)
+#define RTC_ALRMAR_HT_1                      ((uint32_t)0x00200000)
+#define RTC_ALRMAR_HU                        ((uint32_t)0x000F0000)
+#define RTC_ALRMAR_HU_0                      ((uint32_t)0x00010000)
+#define RTC_ALRMAR_HU_1                      ((uint32_t)0x00020000)
+#define RTC_ALRMAR_HU_2                      ((uint32_t)0x00040000)
+#define RTC_ALRMAR_HU_3                      ((uint32_t)0x00080000)
+#define RTC_ALRMAR_MSK2                      ((uint32_t)0x00008000)
+#define RTC_ALRMAR_MNT                       ((uint32_t)0x00007000)
+#define RTC_ALRMAR_MNT_0                     ((uint32_t)0x00001000)
+#define RTC_ALRMAR_MNT_1                     ((uint32_t)0x00002000)
+#define RTC_ALRMAR_MNT_2                     ((uint32_t)0x00004000)
+#define RTC_ALRMAR_MNU                       ((uint32_t)0x00000F00)
+#define RTC_ALRMAR_MNU_0                     ((uint32_t)0x00000100)
+#define RTC_ALRMAR_MNU_1                     ((uint32_t)0x00000200)
+#define RTC_ALRMAR_MNU_2                     ((uint32_t)0x00000400)
+#define RTC_ALRMAR_MNU_3                     ((uint32_t)0x00000800)
+#define RTC_ALRMAR_MSK1                      ((uint32_t)0x00000080)
+#define RTC_ALRMAR_ST                        ((uint32_t)0x00000070)
+#define RTC_ALRMAR_ST_0                      ((uint32_t)0x00000010)
+#define RTC_ALRMAR_ST_1                      ((uint32_t)0x00000020)
+#define RTC_ALRMAR_ST_2                      ((uint32_t)0x00000040)
+#define RTC_ALRMAR_SU                        ((uint32_t)0x0000000F)
+#define RTC_ALRMAR_SU_0                      ((uint32_t)0x00000001)
+#define RTC_ALRMAR_SU_1                      ((uint32_t)0x00000002)
+#define RTC_ALRMAR_SU_2                      ((uint32_t)0x00000004)
+#define RTC_ALRMAR_SU_3                      ((uint32_t)0x00000008)
+
+/********************  Bits definition for RTC_ALRMBR register  ***************/
+#define RTC_ALRMBR_MSK4                      ((uint32_t)0x80000000)
+#define RTC_ALRMBR_WDSEL                     ((uint32_t)0x40000000)
+#define RTC_ALRMBR_DT                        ((uint32_t)0x30000000)
+#define RTC_ALRMBR_DT_0                      ((uint32_t)0x10000000)
+#define RTC_ALRMBR_DT_1                      ((uint32_t)0x20000000)
+#define RTC_ALRMBR_DU                        ((uint32_t)0x0F000000)
+#define RTC_ALRMBR_DU_0                      ((uint32_t)0x01000000)
+#define RTC_ALRMBR_DU_1                      ((uint32_t)0x02000000)
+#define RTC_ALRMBR_DU_2                      ((uint32_t)0x04000000)
+#define RTC_ALRMBR_DU_3                      ((uint32_t)0x08000000)
+#define RTC_ALRMBR_MSK3                      ((uint32_t)0x00800000)
+#define RTC_ALRMBR_PM                        ((uint32_t)0x00400000)
+#define RTC_ALRMBR_HT                        ((uint32_t)0x00300000)
+#define RTC_ALRMBR_HT_0                      ((uint32_t)0x00100000)
+#define RTC_ALRMBR_HT_1                      ((uint32_t)0x00200000)
+#define RTC_ALRMBR_HU                        ((uint32_t)0x000F0000)
+#define RTC_ALRMBR_HU_0                      ((uint32_t)0x00010000)
+#define RTC_ALRMBR_HU_1                      ((uint32_t)0x00020000)
+#define RTC_ALRMBR_HU_2                      ((uint32_t)0x00040000)
+#define RTC_ALRMBR_HU_3                      ((uint32_t)0x00080000)
+#define RTC_ALRMBR_MSK2                      ((uint32_t)0x00008000)
+#define RTC_ALRMBR_MNT                       ((uint32_t)0x00007000)
+#define RTC_ALRMBR_MNT_0                     ((uint32_t)0x00001000)
+#define RTC_ALRMBR_MNT_1                     ((uint32_t)0x00002000)
+#define RTC_ALRMBR_MNT_2                     ((uint32_t)0x00004000)
+#define RTC_ALRMBR_MNU                       ((uint32_t)0x00000F00)
+#define RTC_ALRMBR_MNU_0                     ((uint32_t)0x00000100)
+#define RTC_ALRMBR_MNU_1                     ((uint32_t)0x00000200)
+#define RTC_ALRMBR_MNU_2                     ((uint32_t)0x00000400)
+#define RTC_ALRMBR_MNU_3                     ((uint32_t)0x00000800)
+#define RTC_ALRMBR_MSK1                      ((uint32_t)0x00000080)
+#define RTC_ALRMBR_ST                        ((uint32_t)0x00000070)
+#define RTC_ALRMBR_ST_0                      ((uint32_t)0x00000010)
+#define RTC_ALRMBR_ST_1                      ((uint32_t)0x00000020)
+#define RTC_ALRMBR_ST_2                      ((uint32_t)0x00000040)
+#define RTC_ALRMBR_SU                        ((uint32_t)0x0000000F)
+#define RTC_ALRMBR_SU_0                      ((uint32_t)0x00000001)
+#define RTC_ALRMBR_SU_1                      ((uint32_t)0x00000002)
+#define RTC_ALRMBR_SU_2                      ((uint32_t)0x00000004)
+#define RTC_ALRMBR_SU_3                      ((uint32_t)0x00000008)
+
+/********************  Bits definition for RTC_WPR register  ******************/
+#define RTC_WPR_KEY                          ((uint32_t)0x000000FF)
+
+/********************  Bits definition for RTC_SSR register  ******************/
+#define RTC_SSR_SS                           ((uint32_t)0x0000FFFF)
+
+/********************  Bits definition for RTC_SHIFTR register  ***************/
+#define RTC_SHIFTR_SUBFS                     ((uint32_t)0x00007FFF)
+#define RTC_SHIFTR_ADD1S                     ((uint32_t)0x80000000)
+
+/********************  Bits definition for RTC_TSTR register  *****************/
+#define RTC_TSTR_PM                          ((uint32_t)0x00400000)
+#define RTC_TSTR_HT                          ((uint32_t)0x00300000)
+#define RTC_TSTR_HT_0                        ((uint32_t)0x00100000)
+#define RTC_TSTR_HT_1                        ((uint32_t)0x00200000)
+#define RTC_TSTR_HU                          ((uint32_t)0x000F0000)
+#define RTC_TSTR_HU_0                        ((uint32_t)0x00010000)
+#define RTC_TSTR_HU_1                        ((uint32_t)0x00020000)
+#define RTC_TSTR_HU_2                        ((uint32_t)0x00040000)
+#define RTC_TSTR_HU_3                        ((uint32_t)0x00080000)
+#define RTC_TSTR_MNT                         ((uint32_t)0x00007000)
+#define RTC_TSTR_MNT_0                       ((uint32_t)0x00001000)
+#define RTC_TSTR_MNT_1                       ((uint32_t)0x00002000)
+#define RTC_TSTR_MNT_2                       ((uint32_t)0x00004000)
+#define RTC_TSTR_MNU                         ((uint32_t)0x00000F00)
+#define RTC_TSTR_MNU_0                       ((uint32_t)0x00000100)
+#define RTC_TSTR_MNU_1                       ((uint32_t)0x00000200)
+#define RTC_TSTR_MNU_2                       ((uint32_t)0x00000400)
+#define RTC_TSTR_MNU_3                       ((uint32_t)0x00000800)
+#define RTC_TSTR_ST                          ((uint32_t)0x00000070)
+#define RTC_TSTR_ST_0                        ((uint32_t)0x00000010)
+#define RTC_TSTR_ST_1                        ((uint32_t)0x00000020)
+#define RTC_TSTR_ST_2                        ((uint32_t)0x00000040)
+#define RTC_TSTR_SU                          ((uint32_t)0x0000000F)
+#define RTC_TSTR_SU_0                        ((uint32_t)0x00000001)
+#define RTC_TSTR_SU_1                        ((uint32_t)0x00000002)
+#define RTC_TSTR_SU_2                        ((uint32_t)0x00000004)
+#define RTC_TSTR_SU_3                        ((uint32_t)0x00000008)
+
+/********************  Bits definition for RTC_TSDR register  *****************/
+#define RTC_TSDR_WDU                         ((uint32_t)0x0000E000)
+#define RTC_TSDR_WDU_0                       ((uint32_t)0x00002000)
+#define RTC_TSDR_WDU_1                       ((uint32_t)0x00004000)
+#define RTC_TSDR_WDU_2                       ((uint32_t)0x00008000)
+#define RTC_TSDR_MT                          ((uint32_t)0x00001000)
+#define RTC_TSDR_MU                          ((uint32_t)0x00000F00)
+#define RTC_TSDR_MU_0                        ((uint32_t)0x00000100)
+#define RTC_TSDR_MU_1                        ((uint32_t)0x00000200)
+#define RTC_TSDR_MU_2                        ((uint32_t)0x00000400)
+#define RTC_TSDR_MU_3                        ((uint32_t)0x00000800)
+#define RTC_TSDR_DT                          ((uint32_t)0x00000030)
+#define RTC_TSDR_DT_0                        ((uint32_t)0x00000010)
+#define RTC_TSDR_DT_1                        ((uint32_t)0x00000020)
+#define RTC_TSDR_DU                          ((uint32_t)0x0000000F)
+#define RTC_TSDR_DU_0                        ((uint32_t)0x00000001)
+#define RTC_TSDR_DU_1                        ((uint32_t)0x00000002)
+#define RTC_TSDR_DU_2                        ((uint32_t)0x00000004)
+#define RTC_TSDR_DU_3                        ((uint32_t)0x00000008)
+
+/********************  Bits definition for RTC_TSSSR register  ****************/
+#define RTC_TSSSR_SS                         ((uint32_t)0x0000FFFF)
+
+/********************  Bits definition for RTC_CAL register  *****************/
+#define RTC_CALR_CALP                        ((uint32_t)0x00008000)
+#define RTC_CALR_CALW8                       ((uint32_t)0x00004000)
+#define RTC_CALR_CALW16                      ((uint32_t)0x00002000)
+#define RTC_CALR_CALM                        ((uint32_t)0x000001FF)
+#define RTC_CALR_CALM_0                      ((uint32_t)0x00000001)
+#define RTC_CALR_CALM_1                      ((uint32_t)0x00000002)
+#define RTC_CALR_CALM_2                      ((uint32_t)0x00000004)
+#define RTC_CALR_CALM_3                      ((uint32_t)0x00000008)
+#define RTC_CALR_CALM_4                      ((uint32_t)0x00000010)
+#define RTC_CALR_CALM_5                      ((uint32_t)0x00000020)
+#define RTC_CALR_CALM_6                      ((uint32_t)0x00000040)
+#define RTC_CALR_CALM_7                      ((uint32_t)0x00000080)
+#define RTC_CALR_CALM_8                      ((uint32_t)0x00000100)
+
+/********************  Bits definition for RTC_TAFCR register  ****************/
+#define RTC_TAFCR_ALARMOUTTYPE               ((uint32_t)0x00040000)
+#define RTC_TAFCR_TSINSEL                    ((uint32_t)0x00020000)
+#define RTC_TAFCR_TAMPINSEL                  ((uint32_t)0x00010000)
+#define RTC_TAFCR_TAMPPUDIS                  ((uint32_t)0x00008000)
+#define RTC_TAFCR_TAMPPRCH                   ((uint32_t)0x00006000)
+#define RTC_TAFCR_TAMPPRCH_0                 ((uint32_t)0x00002000)
+#define RTC_TAFCR_TAMPPRCH_1                 ((uint32_t)0x00004000)
+#define RTC_TAFCR_TAMPFLT                    ((uint32_t)0x00001800)
+#define RTC_TAFCR_TAMPFLT_0                  ((uint32_t)0x00000800)
+#define RTC_TAFCR_TAMPFLT_1                  ((uint32_t)0x00001000)
+#define RTC_TAFCR_TAMPFREQ                   ((uint32_t)0x00000700)
+#define RTC_TAFCR_TAMPFREQ_0                 ((uint32_t)0x00000100)
+#define RTC_TAFCR_TAMPFREQ_1                 ((uint32_t)0x00000200)
+#define RTC_TAFCR_TAMPFREQ_2                 ((uint32_t)0x00000400)
+#define RTC_TAFCR_TAMPTS                     ((uint32_t)0x00000080)
+#define RTC_TAFCR_TAMPIE                     ((uint32_t)0x00000004)
+#define RTC_TAFCR_TAMP1TRG                   ((uint32_t)0x00000002)
+#define RTC_TAFCR_TAMP1E                     ((uint32_t)0x00000001)
+
+/********************  Bits definition for RTC_ALRMASSR register  *************/
+#define RTC_ALRMASSR_MASKSS                  ((uint32_t)0x0F000000)
+#define RTC_ALRMASSR_MASKSS_0                ((uint32_t)0x01000000)
+#define RTC_ALRMASSR_MASKSS_1                ((uint32_t)0x02000000)
+#define RTC_ALRMASSR_MASKSS_2                ((uint32_t)0x04000000)
+#define RTC_ALRMASSR_MASKSS_3                ((uint32_t)0x08000000)
+#define RTC_ALRMASSR_SS                      ((uint32_t)0x00007FFF)
+
+/********************  Bits definition for RTC_ALRMBSSR register  *************/
+#define RTC_ALRMBSSR_MASKSS                  ((uint32_t)0x0F000000)
+#define RTC_ALRMBSSR_MASKSS_0                ((uint32_t)0x01000000)
+#define RTC_ALRMBSSR_MASKSS_1                ((uint32_t)0x02000000)
+#define RTC_ALRMBSSR_MASKSS_2                ((uint32_t)0x04000000)
+#define RTC_ALRMBSSR_MASKSS_3                ((uint32_t)0x08000000)
+#define RTC_ALRMBSSR_SS                      ((uint32_t)0x00007FFF)
+
+/********************  Bits definition for RTC_BKP0R register  ****************/
+#define RTC_BKP0R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP1R register  ****************/
+#define RTC_BKP1R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP2R register  ****************/
+#define RTC_BKP2R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP3R register  ****************/
+#define RTC_BKP3R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP4R register  ****************/
+#define RTC_BKP4R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP5R register  ****************/
+#define RTC_BKP5R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP6R register  ****************/
+#define RTC_BKP6R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP7R register  ****************/
+#define RTC_BKP7R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP8R register  ****************/
+#define RTC_BKP8R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP9R register  ****************/
+#define RTC_BKP9R                            ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP10R register  ***************/
+#define RTC_BKP10R                           ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP11R register  ***************/
+#define RTC_BKP11R                           ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP12R register  ***************/
+#define RTC_BKP12R                           ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP13R register  ***************/
+#define RTC_BKP13R                           ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP14R register  ***************/
+#define RTC_BKP14R                           ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP15R register  ***************/
+#define RTC_BKP15R                           ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP16R register  ***************/
+#define RTC_BKP16R                           ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP17R register  ***************/
+#define RTC_BKP17R                           ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP18R register  ***************/
+#define RTC_BKP18R                           ((uint32_t)0xFFFFFFFF)
+
+/********************  Bits definition for RTC_BKP19R register  ***************/
+#define RTC_BKP19R                           ((uint32_t)0xFFFFFFFF)
+
+/******************************************************************************/
+/*                                                                            */
+/*                          Serial Audio Interface                            */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bit definition for SAI_GCR register  *******************/
+#define  SAI_GCR_SYNCIN                  ((uint32_t)0x00000003)        /*!<SYNCIN[1:0] bits (Synchronization Inputs)   */
+#define  SAI_GCR_SYNCIN_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  SAI_GCR_SYNCIN_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
+
+#define  SAI_GCR_SYNCOUT                 ((uint32_t)0x00000030)        /*!<SYNCOUT[1:0] bits (Synchronization Outputs) */
+#define  SAI_GCR_SYNCOUT_0               ((uint32_t)0x00000010)        /*!<Bit 0 */
+#define  SAI_GCR_SYNCOUT_1               ((uint32_t)0x00000020)        /*!<Bit 1 */
+
+/*******************  Bit definition for SAI_xCR1 register  *******************/
+#define  SAI_xCR1_MODE                    ((uint32_t)0x00000003)        /*!<MODE[1:0] bits (Audio Block Mode)           */
+#define  SAI_xCR1_MODE_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  SAI_xCR1_MODE_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+
+#define  SAI_xCR1_PRTCFG                  ((uint32_t)0x0000000C)        /*!<PRTCFG[1:0] bits (Protocol Configuration)   */
+#define  SAI_xCR1_PRTCFG_0                ((uint32_t)0x00000004)        /*!<Bit 0 */
+#define  SAI_xCR1_PRTCFG_1                ((uint32_t)0x00000008)        /*!<Bit 1 */
+
+#define  SAI_xCR1_DS                      ((uint32_t)0x000000E0)        /*!<DS[1:0] bits (Data Size) */
+#define  SAI_xCR1_DS_0                    ((uint32_t)0x00000020)        /*!<Bit 0 */
+#define  SAI_xCR1_DS_1                    ((uint32_t)0x00000040)        /*!<Bit 1 */
+#define  SAI_xCR1_DS_2                    ((uint32_t)0x00000080)        /*!<Bit 2 */
+
+#define  SAI_xCR1_LSBFIRST                ((uint32_t)0x00000100)        /*!<LSB First Configuration  */
+#define  SAI_xCR1_CKSTR                   ((uint32_t)0x00000200)        /*!<ClocK STRobing edge      */
+
+#define  SAI_xCR1_SYNCEN                  ((uint32_t)0x00000C00)        /*!<SYNCEN[1:0](SYNChronization ENable) */
+#define  SAI_xCR1_SYNCEN_0                ((uint32_t)0x00000400)        /*!<Bit 0 */
+#define  SAI_xCR1_SYNCEN_1                ((uint32_t)0x00000800)        /*!<Bit 1 */
+
+#define  SAI_xCR1_MONO                    ((uint32_t)0x00001000)        /*!<Mono mode                  */
+#define  SAI_xCR1_OUTDRIV                 ((uint32_t)0x00002000)        /*!<Output Drive               */
+#define  SAI_xCR1_SAIEN                   ((uint32_t)0x00010000)        /*!<Audio Block enable         */
+#define  SAI_xCR1_DMAEN                   ((uint32_t)0x00020000)        /*!<DMA enable                 */
+#define  SAI_xCR1_NODIV                   ((uint32_t)0x00080000)        /*!<No Divider Configuration   */
+
+#define  SAI_xCR1_MCKDIV                  ((uint32_t)0x00780000)        /*!<MCKDIV[3:0] (Master ClocK Divider)  */
+#define  SAI_xCR1_MCKDIV_0                ((uint32_t)0x00080000)        /*!<Bit 0  */
+#define  SAI_xCR1_MCKDIV_1                ((uint32_t)0x00100000)        /*!<Bit 1  */
+#define  SAI_xCR1_MCKDIV_2                ((uint32_t)0x00200000)        /*!<Bit 2  */
+#define  SAI_xCR1_MCKDIV_3                ((uint32_t)0x00400000)        /*!<Bit 3  */
+
+/*******************  Bit definition for SAI_xCR2 register  *******************/
+#define  SAI_xCR2_FTH                     ((uint32_t)0x00000003)        /*!<FTH[1:0](Fifo THreshold)  */
+#define  SAI_xCR2_FTH_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  SAI_xCR2_FTH_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
+
+#define  SAI_xCR2_FFLUSH                  ((uint32_t)0x00000008)        /*!<Fifo FLUSH                       */
+#define  SAI_xCR2_TRIS                    ((uint32_t)0x00000010)        /*!<TRIState Management on data line */
+#define  SAI_xCR2_MUTE                    ((uint32_t)0x00000020)        /*!<Mute mode                        */
+#define  SAI_xCR2_MUTEVAL                 ((uint32_t)0x00000040)        /*!<Muate value                      */
+
+#define  SAI_xCR2_MUTECNT                  ((uint32_t)0x00001F80)       /*!<MUTECNT[5:0] (MUTE counter) */
+#define  SAI_xCR2_MUTECNT_0               ((uint32_t)0x00000080)        /*!<Bit 0 */
+#define  SAI_xCR2_MUTECNT_1               ((uint32_t)0x00000100)        /*!<Bit 1 */
+#define  SAI_xCR2_MUTECNT_2               ((uint32_t)0x00000200)        /*!<Bit 2 */
+#define  SAI_xCR2_MUTECNT_3               ((uint32_t)0x00000400)        /*!<Bit 3 */
+#define  SAI_xCR2_MUTECNT_4               ((uint32_t)0x00000800)        /*!<Bit 4 */
+#define  SAI_xCR2_MUTECNT_5               ((uint32_t)0x00001000)        /*!<Bit 5 */
+
+#define  SAI_xCR2_CPL                     ((uint32_t)0x00080000)        /*!< Complement Bit             */
+
+#define  SAI_xCR2_COMP                    ((uint32_t)0x0000C000)        /*!<COMP[1:0] (Companding mode) */
+#define  SAI_xCR2_COMP_0                  ((uint32_t)0x00004000)        /*!<Bit 0 */
+#define  SAI_xCR2_COMP_1                  ((uint32_t)0x00008000)        /*!<Bit 1 */
+
+/******************  Bit definition for SAI_xFRCR register  *******************/
+#define  SAI_xFRCR_FRL                    ((uint32_t)0x000000FF)        /*!<FRL[1:0](Frame length)  */
+#define  SAI_xFRCR_FRL_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  SAI_xFRCR_FRL_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  SAI_xFRCR_FRL_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  SAI_xFRCR_FRL_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  SAI_xFRCR_FRL_4                  ((uint32_t)0x00000010)        /*!<Bit 4 */
+#define  SAI_xFRCR_FRL_5                  ((uint32_t)0x00000020)        /*!<Bit 5 */
+#define  SAI_xFRCR_FRL_6                  ((uint32_t)0x00000040)        /*!<Bit 6 */
+#define  SAI_xFRCR_FRL_7                  ((uint32_t)0x00000080)        /*!<Bit 7 */
+
+#define  SAI_xFRCR_FSALL                  ((uint32_t)0x00007F00)        /*!<FRL[1:0] (Frame synchronization active level length)  */
+#define  SAI_xFRCR_FSALL_0                ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  SAI_xFRCR_FSALL_1                ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  SAI_xFRCR_FSALL_2                ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  SAI_xFRCR_FSALL_3                ((uint32_t)0x00000800)        /*!<Bit 3 */
+#define  SAI_xFRCR_FSALL_4                ((uint32_t)0x00001000)        /*!<Bit 4 */
+#define  SAI_xFRCR_FSALL_5                ((uint32_t)0x00002000)        /*!<Bit 5 */
+#define  SAI_xFRCR_FSALL_6                ((uint32_t)0x00004000)        /*!<Bit 6 */
+
+#define  SAI_xFRCR_FSDEF                  ((uint32_t)0x00010000)        /*!< Frame Synchronization Definition */
+#define  SAI_xFRCR_FSPO                   ((uint32_t)0x00020000)        /*!<Frame Synchronization POLarity    */
+#define  SAI_xFRCR_FSOFF                  ((uint32_t)0x00040000)        /*!<Frame Synchronization OFFset      */
+
+/******************  Bit definition for SAI_xSLOTR register  *******************/
+#define  SAI_xSLOTR_FBOFF                 ((uint32_t)0x0000001F)        /*!<FRL[4:0](First Bit Offset)  */
+#define  SAI_xSLOTR_FBOFF_0               ((uint32_t)0x00000001)        /*!<Bit 0 */
+#define  SAI_xSLOTR_FBOFF_1               ((uint32_t)0x00000002)        /*!<Bit 1 */
+#define  SAI_xSLOTR_FBOFF_2               ((uint32_t)0x00000004)        /*!<Bit 2 */
+#define  SAI_xSLOTR_FBOFF_3               ((uint32_t)0x00000008)        /*!<Bit 3 */
+#define  SAI_xSLOTR_FBOFF_4               ((uint32_t)0x00000010)        /*!<Bit 4 */
+                                     
+#define  SAI_xSLOTR_SLOTSZ                ((uint32_t)0x000000C0)        /*!<SLOTSZ[1:0] (Slot size)  */
+#define  SAI_xSLOTR_SLOTSZ_0              ((uint32_t)0x00000040)        /*!<Bit 0 */
+#define  SAI_xSLOTR_SLOTSZ_1              ((uint32_t)0x00000080)        /*!<Bit 1 */
+
+#define  SAI_xSLOTR_NBSLOT                ((uint32_t)0x00000F00)        /*!<NBSLOT[3:0] (Number of Slot in audio Frame)  */
+#define  SAI_xSLOTR_NBSLOT_0              ((uint32_t)0x00000100)        /*!<Bit 0 */
+#define  SAI_xSLOTR_NBSLOT_1              ((uint32_t)0x00000200)        /*!<Bit 1 */
+#define  SAI_xSLOTR_NBSLOT_2              ((uint32_t)0x00000400)        /*!<Bit 2 */
+#define  SAI_xSLOTR_NBSLOT_3              ((uint32_t)0x00000800)        /*!<Bit 3 */
+
+#define  SAI_xSLOTR_SLOTEN                ((uint32_t)0xFFFF0000)        /*!<SLOTEN[15:0] (Slot Enable)  */
+
+/*******************  Bit definition for SAI_xIMR register  *******************/
+#define  SAI_xIMR_OVRUDRIE                ((uint32_t)0x00000001)        /*!<Overrun underrun interrupt enable                              */
+#define  SAI_xIMR_MUTEDETIE               ((uint32_t)0x00000002)        /*!<Mute detection interrupt enable                                */
+#define  SAI_xIMR_WCKCFGIE                ((uint32_t)0x00000004)        /*!<Wrong Clock Configuration interrupt enable                     */
+#define  SAI_xIMR_FREQIE                  ((uint32_t)0x00000008)        /*!<FIFO request interrupt enable                                  */
+#define  SAI_xIMR_CNRDYIE                 ((uint32_t)0x00000010)        /*!<Codec not ready interrupt enable                               */
+#define  SAI_xIMR_AFSDETIE                ((uint32_t)0x00000020)        /*!<Anticipated frame synchronization detection interrupt enable   */
+#define  SAI_xIMR_LFSDETIE                ((uint32_t)0x00000040)        /*!<Late frame synchronization detection interrupt enable          */
+
+/********************  Bit definition for SAI_xSR register  *******************/
+#define  SAI_xSR_OVRUDR                   ((uint32_t)0x00000001)         /*!<Overrun underrun                               */
+#define  SAI_xSR_MUTEDET                  ((uint32_t)0x00000002)         /*!<Mute detection                                 */
+#define  SAI_xSR_WCKCFG                   ((uint32_t)0x00000004)         /*!<Wrong Clock Configuration                      */
+#define  SAI_xSR_FREQ                     ((uint32_t)0x00000008)         /*!<FIFO request                                   */
+#define  SAI_xSR_CNRDY                    ((uint32_t)0x00000010)         /*!<Codec not ready                                */
+#define  SAI_xSR_AFSDET                   ((uint32_t)0x00000020)         /*!<Anticipated frame synchronization detection    */
+#define  SAI_xSR_LFSDET                   ((uint32_t)0x00000040)         /*!<Late frame synchronization detection           */
+
+#define  SAI_xSR_FLVL                     ((uint32_t)0x00070000)         /*!<FLVL[2:0] (FIFO Level Threshold)               */
+#define  SAI_xSR_FLVL_0                   ((uint32_t)0x00010000)         /*!<Bit 0 */
+#define  SAI_xSR_FLVL_1                   ((uint32_t)0x00020000)         /*!<Bit 1 */
+#define  SAI_xSR_FLVL_2                   ((uint32_t)0x00030000)         /*!<Bit 2 */
+
+/******************  Bit definition for SAI_xCLRFR register  ******************/
+#define  SAI_xCLRFR_COVRUDR               ((uint32_t)0x00000001)        /*!<Clear Overrun underrun                               */
+#define  SAI_xCLRFR_CMUTEDET              ((uint32_t)0x00000002)        /*!<Clear Mute detection                                 */
+#define  SAI_xCLRFR_CWCKCFG               ((uint32_t)0x00000004)        /*!<Clear Wrong Clock Configuration                      */
+#define  SAI_xCLRFR_CFREQ                 ((uint32_t)0x00000008)        /*!<Clear FIFO request                                   */
+#define  SAI_xCLRFR_CCNRDY                ((uint32_t)0x00000010)        /*!<Clear Codec not ready                                */
+#define  SAI_xCLRFR_CAFSDET               ((uint32_t)0x00000020)        /*!<Clear Anticipated frame synchronization detection    */
+#define  SAI_xCLRFR_CLFSDET               ((uint32_t)0x00000040)        /*!<Clear Late frame synchronization detection           */
+
+/******************  Bit definition for SAI_xDR register  ******************/
+#define  SAI_xDR_DATA                     ((uint32_t)0xFFFFFFFF)        
+
+/******************************************************************************/
+/*                                                                            */
+/*                          SD host Interface                                 */
+/*                                                                            */
+/******************************************************************************/
+/******************  Bit definition for SDIO_POWER register  ******************/
+#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!<PWRCTRL[1:0] bits (Power supply control bits) */
+#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!<Bit 0 */
+#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!<Bit 1 */
+
+/******************  Bit definition for SDIO_CLKCR register  ******************/
+#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!<Clock divide factor             */
+#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!<Clock enable bit                */
+#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!<Power saving configuration bit  */
+#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!<Clock divider bypass enable bit */
+
+#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!<WIDBUS[1:0] bits (Wide bus mode enable bit) */
+#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!<Bit 0 */
+#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!<Bit 1 */
+
+#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!<SDIO_CK dephasing selection bit */
+#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!<HW Flow Control enable          */
+
+/*******************  Bit definition for SDIO_ARG register  *******************/
+#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!<Command argument */
+
+/*******************  Bit definition for SDIO_CMD register  *******************/
+#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!<Command Index                               */
+
+#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!<WAITRESP[1:0] bits (Wait for response bits) */
+#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!< Bit 0 */
+#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!< Bit 1 */
+
+#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!<CPSM Waits for Interrupt Request                               */
+#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!<CPSM Waits for ends of data transfer (CmdPend internal signal) */
+#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!<Command path state machine (CPSM) Enable bit                   */
+#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!<SD I/O suspend command                                         */
+#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!<Enable CMD completion                                          */
+#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!<Not Interrupt Enable */
+#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!<CE-ATA command       */
+
+/*****************  Bit definition for SDIO_RESPCMD register  *****************/
+#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!<Response command index */
+
+/******************  Bit definition for SDIO_RESP0 register  ******************/
+#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
+
+/******************  Bit definition for SDIO_RESP1 register  ******************/
+#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
+
+/******************  Bit definition for SDIO_RESP2 register  ******************/
+#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
+
+/******************  Bit definition for SDIO_RESP3 register  ******************/
+#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
+
+/******************  Bit definition for SDIO_RESP4 register  ******************/
+#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
+
+/******************  Bit definition for SDIO_DTIMER register  *****************/
+#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!<Data timeout period. */
+
+/******************  Bit definition for SDIO_DLEN register  *******************/
+#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!<Data length value    */
+
+/******************  Bit definition for SDIO_DCTRL register  ******************/
+#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!<Data transfer enabled bit         */
+#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!<Data transfer direction selection */
+#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!<Data transfer mode selection      */
+#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!<DMA enabled bit                   */
+
+#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!<DBLOCKSIZE[3:0] bits (Data block size) */
+#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!<Bit 0 */
+#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!<Bit 1 */
+#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!<Bit 2 */
+#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!<Bit 3 */
+
+#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!<Read wait start         */
+#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!<Read wait stop          */
+#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!<Read wait mode          */
+#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!<SD I/O enable functions */
+
+/******************  Bit definition for SDIO_DCOUNT register  *****************/
+#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!<Data count value */
+
+/******************  Bit definition for SDIO_STA register  ********************/
+#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!<Command response received (CRC check failed)  */
+#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!<Data block sent/received (CRC check failed)   */
+#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!<Command response timeout                      */
+#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!<Data timeout                                  */
+#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!<Transmit FIFO underrun error                  */
+#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!<Received FIFO overrun error                   */
+#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!<Command response received (CRC check passed)  */
+#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!<Command sent (no response required)           */
+#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!<Data end (data counter, SDIDCOUNT, is zero)   */
+#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!<Start bit not detected on all data signals in wide bus mode */
+#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!<Data block sent/received (CRC check passed)   */
+#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!<Command transfer in progress                  */
+#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!<Data transmit in progress                     */
+#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!<Data receive in progress                      */
+#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!<Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
+#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!<Receive FIFO Half Full: there are at least 8 words in the FIFO */
+#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!<Transmit FIFO full                            */
+#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!<Receive FIFO full                             */
+#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!<Transmit FIFO empty                           */
+#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!<Receive FIFO empty                            */
+#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!<Data available in transmit FIFO               */
+#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!<Data available in receive FIFO                */
+#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!<SDIO interrupt received                       */
+#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!<CE-ATA command completion signal received for CMD61 */
+
+/*******************  Bit definition for SDIO_ICR register  *******************/
+#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!<CCRCFAIL flag clear bit */
+#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!<DCRCFAIL flag clear bit */
+#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!<CTIMEOUT flag clear bit */
+#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!<DTIMEOUT flag clear bit */
+#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!<TXUNDERR flag clear bit */
+#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!<RXOVERR flag clear bit  */
+#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!<CMDREND flag clear bit  */
+#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!<CMDSENT flag clear bit  */
+#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!<DATAEND flag clear bit  */
+#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!<STBITERR flag clear bit */
+#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!<DBCKEND flag clear bit  */
+#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!<SDIOIT flag clear bit   */
+#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!<CEATAEND flag clear bit */
+
+/******************  Bit definition for SDIO_MASK register  *******************/
+#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!<Command CRC Fail Interrupt Enable          */
+#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!<Data CRC Fail Interrupt Enable             */
+#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!<Command TimeOut Interrupt Enable           */
+#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!<Data TimeOut Interrupt Enable              */
+#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!<Tx FIFO UnderRun Error Interrupt Enable    */
+#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!<Rx FIFO OverRun Error Interrupt Enable     */
+#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!<Command Response Received Interrupt Enable */
+#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!<Command Sent Interrupt Enable              */
+#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!<Data End Interrupt Enable                  */
+#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!<Start Bit Error Interrupt Enable           */
+#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!<Data Block End Interrupt Enable            */
+#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!<CCommand Acting Interrupt Enable           */
+#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!<Data Transmit Acting Interrupt Enable      */
+#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!<Data receive acting interrupt enabled      */
+#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!<Tx FIFO Half Empty interrupt Enable        */
+#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!<Rx FIFO Half Full interrupt Enable         */
+#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!<Tx FIFO Full interrupt Enable              */
+#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!<Rx FIFO Full interrupt Enable              */
+#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!<Tx FIFO Empty interrupt Enable             */
+#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!<Rx FIFO Empty interrupt Enable             */
+#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!<Data available in Tx FIFO interrupt Enable */
+#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!<Data available in Rx FIFO interrupt Enable */
+#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!<SDIO Mode Interrupt Received interrupt Enable */
+#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!<CE-ATA command completion signal received Interrupt Enable */
+
+/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
+#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!<Remaining number of words to be written to or read from the FIFO */
+
+/******************  Bit definition for SDIO_FIFO register  *******************/
+#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!<Receive and transmit FIFO data */
+
+/******************************************************************************/
+/*                                                                            */
+/*                        Serial Peripheral Interface                         */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bit definition for SPI_CR1 register  ********************/
+#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!<Clock Phase      */
+#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!<Clock Polarity   */
+#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!<Master Selection */
+
+#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!<BR[2:0] bits (Baud Rate Control) */
+#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!<Bit 0 */
+#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!<Bit 1 */
+#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!<Bit 2 */
+
+#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!<SPI Enable                          */
+#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!<Frame Format                        */
+#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!<Internal slave select               */
+#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!<Software slave management           */
+#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!<Receive only                        */
+#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!<Data Frame Format                   */
+#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!<Transmit CRC next                   */
+#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!<Hardware CRC calculation enable     */
+#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!<Output enable in bidirectional mode */
+#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!<Bidirectional data mode enable      */
+
+/*******************  Bit definition for SPI_CR2 register  ********************/
+#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!<Rx Buffer DMA Enable                 */
+#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!<Tx Buffer DMA Enable                 */
+#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!<SS Output Enable                     */
+#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!<Error Interrupt Enable               */
+#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!<RX buffer Not Empty Interrupt Enable */
+#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!<Tx buffer Empty Interrupt Enable     */
+
+/********************  Bit definition for SPI_SR register  ********************/
+#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!<Receive buffer Not Empty */
+#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!<Transmit buffer Empty    */
+#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!<Channel side             */
+#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!<Underrun flag            */
+#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!<CRC Error flag           */
+#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!<Mode fault               */
+#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!<Overrun flag             */
+#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!<Busy flag                */
+
+/********************  Bit definition for SPI_DR register  ********************/
+#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!<Data Register           */
+
+/*******************  Bit definition for SPI_CRCPR register  ******************/
+#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!<CRC polynomial register */
+
+/******************  Bit definition for SPI_RXCRCR register  ******************/
+#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!<Rx CRC Register         */
+
+/******************  Bit definition for SPI_TXCRCR register  ******************/
+#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!<Tx CRC Register         */
+
+/******************  Bit definition for SPI_I2SCFGR register  *****************/
+#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!<Channel length (number of bits per audio channel) */
+
+#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!<DATLEN[1:0] bits (Data length to be transferred)  */
+#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!<Bit 0 */
+#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!<Bit 1 */
+
+#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!<steady state clock polarity               */
+
+#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!<I2SSTD[1:0] bits (I2S standard selection) */
+#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!<Bit 0 */
+#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!<Bit 1 */
+
+#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!<PCM frame synchronization                 */
+
+#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!<I2SCFG[1:0] bits (I2S configuration mode) */
+#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!<Bit 0 */
+#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!<Bit 1 */
+
+#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!<I2S Enable         */
+#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!<I2S mode selection */
+
+/******************  Bit definition for SPI_I2SPR register  *******************/
+#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!<I2S Linear prescaler         */
+#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!<Odd factor for the prescaler */
+#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!<Master Clock Output Enable   */
+
+/******************************************************************************/
+/*                                                                            */
+/*                                 SYSCFG                                     */
+/*                                                                            */
+/******************************************************************************/
+/******************  Bit definition for SYSCFG_MEMRMP register  ***************/  
+#define SYSCFG_MEMRMP_MEM_MODE          ((uint32_t)0x00000007) /*!< SYSCFG_Memory Remap Config */
+#define SYSCFG_MEMRMP_MEM_MODE_0        ((uint32_t)0x00000001) /*!<Bit 0 */
+#define SYSCFG_MEMRMP_MEM_MODE_1        ((uint32_t)0x00000002) /*!<Bit 1 */
+#define SYSCFG_MEMRMP_MEM_MODE_2        ((uint32_t)0x00000004) /*!<Bit 2 */
+
+#define SYSCFG_MEMRMP_FB_MODE           ((uint32_t)0x00000100) /*!< User Flash Bank mode */
+
+#define SYSCFG_MEMRMP_SWP_FMC           ((uint32_t)0x00000C00) /*!< FMC memory mapping swap */
+#define SYSCFG_MEMRMP_SWP_FMC_0         ((uint32_t)0x00000400) /*!<Bit 0 */
+#define SYSCFG_MEMRMP_SWP_FMC_1         ((uint32_t)0x00000800) /*!<Bit 1 */
+
+
+/******************  Bit definition for SYSCFG_PMC register  ******************/
+#define SYSCFG_PMC_ADCxDC2              ((uint32_t)0x00070000) /*!< Refer to AN4073 on how to use this bit  */
+#define SYSCFG_PMC_ADC1DC2              ((uint32_t)0x00010000) /*!< Refer to AN4073 on how to use this bit  */
+#define SYSCFG_PMC_ADC2DC2              ((uint32_t)0x00020000) /*!< Refer to AN4073 on how to use this bit  */
+#define SYSCFG_PMC_ADC3DC2              ((uint32_t)0x00040000) /*!< Refer to AN4073 on how to use this bit  */
+
+#define SYSCFG_PMC_MII_RMII_SEL         ((uint32_t)0x00800000) /*!<Ethernet PHY interface selection */
+/* Old MII_RMII_SEL bit definition, maintained for legacy purpose */
+#define SYSCFG_PMC_MII_RMII             SYSCFG_PMC_MII_RMII_SEL
+
+/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
+#define SYSCFG_EXTICR1_EXTI0            ((uint16_t)0x000F) /*!<EXTI 0 configuration */
+#define SYSCFG_EXTICR1_EXTI1            ((uint16_t)0x00F0) /*!<EXTI 1 configuration */
+#define SYSCFG_EXTICR1_EXTI2            ((uint16_t)0x0F00) /*!<EXTI 2 configuration */
+#define SYSCFG_EXTICR1_EXTI3            ((uint16_t)0xF000) /*!<EXTI 3 configuration */
+/** 
+  * @brief   EXTI0 configuration  
+  */ 
+#define SYSCFG_EXTICR1_EXTI0_PA         ((uint16_t)0x0000) /*!<PA[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PB         ((uint16_t)0x0001) /*!<PB[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PC         ((uint16_t)0x0002) /*!<PC[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PD         ((uint16_t)0x0003) /*!<PD[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PE         ((uint16_t)0x0004) /*!<PE[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PF         ((uint16_t)0x0005) /*!<PF[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PG         ((uint16_t)0x0006) /*!<PG[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PH         ((uint16_t)0x0007) /*!<PH[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PI         ((uint16_t)0x0008) /*!<PI[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PJ         ((uint16_t)0x0009) /*!<PJ[0] pin */
+#define SYSCFG_EXTICR1_EXTI0_PK         ((uint16_t)0x000A) /*!<PK[0] pin */
+
+/** 
+  * @brief   EXTI1 configuration  
+  */ 
+#define SYSCFG_EXTICR1_EXTI1_PA         ((uint16_t)0x0000) /*!<PA[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PB         ((uint16_t)0x0010) /*!<PB[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PC         ((uint16_t)0x0020) /*!<PC[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PD         ((uint16_t)0x0030) /*!<PD[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PE         ((uint16_t)0x0040) /*!<PE[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PF         ((uint16_t)0x0050) /*!<PF[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PG         ((uint16_t)0x0060) /*!<PG[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PH         ((uint16_t)0x0070) /*!<PH[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PI         ((uint16_t)0x0080) /*!<PI[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PJ         ((uint16_t)0x0090) /*!<PJ[1] pin */
+#define SYSCFG_EXTICR1_EXTI1_PK         ((uint16_t)0x00A0) /*!<PK[1] pin */
+
+/** 
+  * @brief   EXTI2 configuration  
+  */ 
+#define SYSCFG_EXTICR1_EXTI2_PA         ((uint16_t)0x0000) /*!<PA[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PB         ((uint16_t)0x0100) /*!<PB[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PC         ((uint16_t)0x0200) /*!<PC[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PD         ((uint16_t)0x0300) /*!<PD[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PE         ((uint16_t)0x0400) /*!<PE[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PF         ((uint16_t)0x0500) /*!<PF[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PG         ((uint16_t)0x0600) /*!<PG[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PH         ((uint16_t)0x0700) /*!<PH[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PI         ((uint16_t)0x0800) /*!<PI[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PJ         ((uint16_t)0x0900) /*!<PJ[2] pin */
+#define SYSCFG_EXTICR1_EXTI2_PK         ((uint16_t)0x0A00) /*!<PK[2] pin */
+
+/** 
+  * @brief   EXTI3 configuration  
+  */ 
+#define SYSCFG_EXTICR1_EXTI3_PA         ((uint16_t)0x0000) /*!<PA[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PB         ((uint16_t)0x1000) /*!<PB[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PC         ((uint16_t)0x2000) /*!<PC[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PD         ((uint16_t)0x3000) /*!<PD[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PE         ((uint16_t)0x4000) /*!<PE[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PF         ((uint16_t)0x5000) /*!<PF[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PG         ((uint16_t)0x6000) /*!<PG[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PH         ((uint16_t)0x7000) /*!<PH[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PI         ((uint16_t)0x8000) /*!<PI[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PJ         ((uint16_t)0x9000) /*!<PJ[3] pin */
+#define SYSCFG_EXTICR1_EXTI3_PK         ((uint16_t)0xA000) /*!<PK[3] pin */
+
+/*****************  Bit definition for SYSCFG_EXTICR2 register  ***************/
+#define SYSCFG_EXTICR2_EXTI4            ((uint16_t)0x000F) /*!<EXTI 4 configuration */
+#define SYSCFG_EXTICR2_EXTI5            ((uint16_t)0x00F0) /*!<EXTI 5 configuration */
+#define SYSCFG_EXTICR2_EXTI6            ((uint16_t)0x0F00) /*!<EXTI 6 configuration */
+#define SYSCFG_EXTICR2_EXTI7            ((uint16_t)0xF000) /*!<EXTI 7 configuration */
+/** 
+  * @brief   EXTI4 configuration  
+  */ 
+#define SYSCFG_EXTICR2_EXTI4_PA         ((uint16_t)0x0000) /*!<PA[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PB         ((uint16_t)0x0001) /*!<PB[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PC         ((uint16_t)0x0002) /*!<PC[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PD         ((uint16_t)0x0003) /*!<PD[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PE         ((uint16_t)0x0004) /*!<PE[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PF         ((uint16_t)0x0005) /*!<PF[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PG         ((uint16_t)0x0006) /*!<PG[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PH         ((uint16_t)0x0007) /*!<PH[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PI         ((uint16_t)0x0008) /*!<PI[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PJ         ((uint16_t)0x0009) /*!<PJ[4] pin */
+#define SYSCFG_EXTICR2_EXTI4_PK         ((uint16_t)0x000A) /*!<PK[4] pin */
+
+/** 
+  * @brief   EXTI5 configuration  
+  */ 
+#define SYSCFG_EXTICR2_EXTI5_PA         ((uint16_t)0x0000) /*!<PA[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PB         ((uint16_t)0x0010) /*!<PB[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PC         ((uint16_t)0x0020) /*!<PC[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PD         ((uint16_t)0x0030) /*!<PD[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PE         ((uint16_t)0x0040) /*!<PE[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PF         ((uint16_t)0x0050) /*!<PF[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PG         ((uint16_t)0x0060) /*!<PG[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PH         ((uint16_t)0x0070) /*!<PH[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PI         ((uint16_t)0x0080) /*!<PI[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PJ         ((uint16_t)0x0090) /*!<PJ[5] pin */
+#define SYSCFG_EXTICR2_EXTI5_PK         ((uint16_t)0x00A0) /*!<PK[5] pin */
+
+/** 
+  * @brief   EXTI6 configuration  
+  */ 
+#define SYSCFG_EXTICR2_EXTI6_PA         ((uint16_t)0x0000) /*!<PA[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PB         ((uint16_t)0x0100) /*!<PB[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PC         ((uint16_t)0x0200) /*!<PC[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PD         ((uint16_t)0x0300) /*!<PD[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PE         ((uint16_t)0x0400) /*!<PE[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PF         ((uint16_t)0x0500) /*!<PF[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PG         ((uint16_t)0x0600) /*!<PG[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PH         ((uint16_t)0x0700) /*!<PH[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PI         ((uint16_t)0x0800) /*!<PI[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PJ         ((uint16_t)0x0900) /*!<PJ[6] pin */
+#define SYSCFG_EXTICR2_EXTI6_PK         ((uint16_t)0x0A00) /*!<PK[6] pin */
+
+/** 
+  * @brief   EXTI7 configuration  
+  */ 
+#define SYSCFG_EXTICR2_EXTI7_PA         ((uint16_t)0x0000) /*!<PA[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PB         ((uint16_t)0x1000) /*!<PB[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PC         ((uint16_t)0x2000) /*!<PC[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PD         ((uint16_t)0x3000) /*!<PD[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PE         ((uint16_t)0x4000) /*!<PE[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PF         ((uint16_t)0x5000) /*!<PF[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PG         ((uint16_t)0x6000) /*!<PG[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PH         ((uint16_t)0x7000) /*!<PH[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PI         ((uint16_t)0x8000) /*!<PI[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PJ         ((uint16_t)0x9000) /*!<PJ[7] pin */
+#define SYSCFG_EXTICR2_EXTI7_PK         ((uint16_t)0xA000) /*!<PK[7] pin */
+
+/*****************  Bit definition for SYSCFG_EXTICR3 register  ***************/
+#define SYSCFG_EXTICR3_EXTI8            ((uint16_t)0x000F) /*!<EXTI 8 configuration */
+#define SYSCFG_EXTICR3_EXTI9            ((uint16_t)0x00F0) /*!<EXTI 9 configuration */
+#define SYSCFG_EXTICR3_EXTI10           ((uint16_t)0x0F00) /*!<EXTI 10 configuration */
+#define SYSCFG_EXTICR3_EXTI11           ((uint16_t)0xF000) /*!<EXTI 11 configuration */
+           
+/** 
+  * @brief   EXTI8 configuration  
+  */ 
+#define SYSCFG_EXTICR3_EXTI8_PA         ((uint16_t)0x0000) /*!<PA[8] pin */
+#define SYSCFG_EXTICR3_EXTI8_PB         ((uint16_t)0x0001) /*!<PB[8] pin */
+#define SYSCFG_EXTICR3_EXTI8_PC         ((uint16_t)0x0002) /*!<PC[8] pin */
+#define SYSCFG_EXTICR3_EXTI8_PD         ((uint16_t)0x0003) /*!<PD[8] pin */
+#define SYSCFG_EXTICR3_EXTI8_PE         ((uint16_t)0x0004) /*!<PE[8] pin */
+#define SYSCFG_EXTICR3_EXTI8_PF         ((uint16_t)0x0005) /*!<PF[8] pin */
+#define SYSCFG_EXTICR3_EXTI8_PG         ((uint16_t)0x0006) /*!<PG[8] pin */
+#define SYSCFG_EXTICR3_EXTI8_PH         ((uint16_t)0x0007) /*!<PH[8] pin */
+#define SYSCFG_EXTICR3_EXTI8_PI         ((uint16_t)0x0008) /*!<PI[8] pin */
+#define SYSCFG_EXTICR3_EXTI8_PJ         ((uint16_t)0x0009) /*!<PJ[8] pin */
+
+/** 
+  * @brief   EXTI9 configuration  
+  */ 
+#define SYSCFG_EXTICR3_EXTI9_PA         ((uint16_t)0x0000) /*!<PA[9] pin */
+#define SYSCFG_EXTICR3_EXTI9_PB         ((uint16_t)0x0010) /*!<PB[9] pin */
+#define SYSCFG_EXTICR3_EXTI9_PC         ((uint16_t)0x0020) /*!<PC[9] pin */
+#define SYSCFG_EXTICR3_EXTI9_PD         ((uint16_t)0x0030) /*!<PD[9] pin */
+#define SYSCFG_EXTICR3_EXTI9_PE         ((uint16_t)0x0040) /*!<PE[9] pin */
+#define SYSCFG_EXTICR3_EXTI9_PF         ((uint16_t)0x0050) /*!<PF[9] pin */
+#define SYSCFG_EXTICR3_EXTI9_PG         ((uint16_t)0x0060) /*!<PG[9] pin */
+#define SYSCFG_EXTICR3_EXTI9_PH         ((uint16_t)0x0070) /*!<PH[9] pin */
+#define SYSCFG_EXTICR3_EXTI9_PI         ((uint16_t)0x0080) /*!<PI[9] pin */
+#define SYSCFG_EXTICR3_EXTI9_PJ         ((uint16_t)0x0090) /*!<PJ[9] pin */
+
+/** 
+  * @brief   EXTI10 configuration  
+  */ 
+#define SYSCFG_EXTICR3_EXTI10_PA        ((uint16_t)0x0000) /*!<PA[10] pin */
+#define SYSCFG_EXTICR3_EXTI10_PB        ((uint16_t)0x0100) /*!<PB[10] pin */
+#define SYSCFG_EXTICR3_EXTI10_PC        ((uint16_t)0x0200) /*!<PC[10] pin */
+#define SYSCFG_EXTICR3_EXTI10_PD        ((uint16_t)0x0300) /*!<PD[10] pin */
+#define SYSCFG_EXTICR3_EXTI10_PE        ((uint16_t)0x0400) /*!<PE[10] pin */
+#define SYSCFG_EXTICR3_EXTI10_PF        ((uint16_t)0x0500) /*!<PF[10] pin */
+#define SYSCFG_EXTICR3_EXTI10_PG        ((uint16_t)0x0600) /*!<PG[10] pin */
+#define SYSCFG_EXTICR3_EXTI10_PH        ((uint16_t)0x0700) /*!<PH[10] pin */
+#define SYSCFG_EXTICR3_EXTI10_PI        ((uint16_t)0x0800) /*!<PI[10] pin */
+#define SYSCFG_EXTICR3_EXTI10_PJ        ((uint16_t)0x0900) /*!<PJ[10] pin */
+
+/** 
+  * @brief   EXTI11 configuration  
+  */ 
+#define SYSCFG_EXTICR3_EXTI11_PA        ((uint16_t)0x0000) /*!<PA[11] pin */
+#define SYSCFG_EXTICR3_EXTI11_PB        ((uint16_t)0x1000) /*!<PB[11] pin */
+#define SYSCFG_EXTICR3_EXTI11_PC        ((uint16_t)0x2000) /*!<PC[11] pin */
+#define SYSCFG_EXTICR3_EXTI11_PD        ((uint16_t)0x3000) /*!<PD[11] pin */
+#define SYSCFG_EXTICR3_EXTI11_PE        ((uint16_t)0x4000) /*!<PE[11] pin */
+#define SYSCFG_EXTICR3_EXTI11_PF        ((uint16_t)0x5000) /*!<PF[11] pin */
+#define SYSCFG_EXTICR3_EXTI11_PG        ((uint16_t)0x6000) /*!<PG[11] pin */
+#define SYSCFG_EXTICR3_EXTI11_PH        ((uint16_t)0x7000) /*!<PH[11] pin */
+#define SYSCFG_EXTICR3_EXTI11_PI        ((uint16_t)0x8000) /*!<PI[11] pin */
+#define SYSCFG_EXTICR3_EXTI11_PJ        ((uint16_t)0x9000) /*!<PJ[11] pin */
+
+/*****************  Bit definition for SYSCFG_EXTICR4 register  ***************/
+#define SYSCFG_EXTICR4_EXTI12           ((uint16_t)0x000F) /*!<EXTI 12 configuration */
+#define SYSCFG_EXTICR4_EXTI13           ((uint16_t)0x00F0) /*!<EXTI 13 configuration */
+#define SYSCFG_EXTICR4_EXTI14           ((uint16_t)0x0F00) /*!<EXTI 14 configuration */
+#define SYSCFG_EXTICR4_EXTI15           ((uint16_t)0xF000) /*!<EXTI 15 configuration */
+/** 
+  * @brief   EXTI12 configuration  
+  */ 
+#define SYSCFG_EXTICR4_EXTI12_PA        ((uint16_t)0x0000) /*!<PA[12] pin */
+#define SYSCFG_EXTICR4_EXTI12_PB        ((uint16_t)0x0001) /*!<PB[12] pin */
+#define SYSCFG_EXTICR4_EXTI12_PC        ((uint16_t)0x0002) /*!<PC[12] pin */
+#define SYSCFG_EXTICR4_EXTI12_PD        ((uint16_t)0x0003) /*!<PD[12] pin */
+#define SYSCFG_EXTICR4_EXTI12_PE        ((uint16_t)0x0004) /*!<PE[12] pin */
+#define SYSCFG_EXTICR4_EXTI12_PF        ((uint16_t)0x0005) /*!<PF[12] pin */
+#define SYSCFG_EXTICR4_EXTI12_PG        ((uint16_t)0x0006) /*!<PG[12] pin */
+#define SYSCFG_EXTICR4_EXTI12_PH        ((uint16_t)0x0007) /*!<PH[12] pin */
+#define SYSCFG_EXTICR4_EXTI12_PI        ((uint16_t)0x0008) /*!<PI[12] pin */
+#define SYSCFG_EXTICR4_EXTI12_PJ        ((uint16_t)0x0009) /*!<PJ[12] pin */
+
+/** 
+  * @brief   EXTI13 configuration  
+  */ 
+#define SYSCFG_EXTICR4_EXTI13_PA        ((uint16_t)0x0000) /*!<PA[13] pin */
+#define SYSCFG_EXTICR4_EXTI13_PB        ((uint16_t)0x0010) /*!<PB[13] pin */
+#define SYSCFG_EXTICR4_EXTI13_PC        ((uint16_t)0x0020) /*!<PC[13] pin */
+#define SYSCFG_EXTICR4_EXTI13_PD        ((uint16_t)0x0030) /*!<PD[13] pin */
+#define SYSCFG_EXTICR4_EXTI13_PE        ((uint16_t)0x0040) /*!<PE[13] pin */
+#define SYSCFG_EXTICR4_EXTI13_PF        ((uint16_t)0x0050) /*!<PF[13] pin */
+#define SYSCFG_EXTICR4_EXTI13_PG        ((uint16_t)0x0060) /*!<PG[13] pin */
+#define SYSCFG_EXTICR4_EXTI13_PH        ((uint16_t)0x0070) /*!<PH[13] pin */
+#define SYSCFG_EXTICR4_EXTI13_PI        ((uint16_t)0x0008) /*!<PI[13] pin */
+#define SYSCFG_EXTICR4_EXTI13_PJ        ((uint16_t)0x0009) /*!<PJ[13] pin */
+
+/** 
+  * @brief   EXTI14 configuration  
+  */ 
+#define SYSCFG_EXTICR4_EXTI14_PA        ((uint16_t)0x0000) /*!<PA[14] pin */
+#define SYSCFG_EXTICR4_EXTI14_PB        ((uint16_t)0x0100) /*!<PB[14] pin */
+#define SYSCFG_EXTICR4_EXTI14_PC        ((uint16_t)0x0200) /*!<PC[14] pin */
+#define SYSCFG_EXTICR4_EXTI14_PD        ((uint16_t)0x0300) /*!<PD[14] pin */
+#define SYSCFG_EXTICR4_EXTI14_PE        ((uint16_t)0x0400) /*!<PE[14] pin */
+#define SYSCFG_EXTICR4_EXTI14_PF        ((uint16_t)0x0500) /*!<PF[14] pin */
+#define SYSCFG_EXTICR4_EXTI14_PG        ((uint16_t)0x0600) /*!<PG[14] pin */
+#define SYSCFG_EXTICR4_EXTI14_PH        ((uint16_t)0x0700) /*!<PH[14] pin */
+#define SYSCFG_EXTICR4_EXTI14_PI        ((uint16_t)0x0800) /*!<PI[14] pin */
+#define SYSCFG_EXTICR4_EXTI14_PJ        ((uint16_t)0x0900) /*!<PJ[14] pin */
+
+/** 
+  * @brief   EXTI15 configuration  
+  */ 
+#define SYSCFG_EXTICR4_EXTI15_PA        ((uint16_t)0x0000) /*!<PA[15] pin */
+#define SYSCFG_EXTICR4_EXTI15_PB        ((uint16_t)0x1000) /*!<PB[15] pin */
+#define SYSCFG_EXTICR4_EXTI15_PC        ((uint16_t)0x2000) /*!<PC[15] pin */
+#define SYSCFG_EXTICR4_EXTI15_PD        ((uint16_t)0x3000) /*!<PD[15] pin */
+#define SYSCFG_EXTICR4_EXTI15_PE        ((uint16_t)0x4000) /*!<PE[15] pin */
+#define SYSCFG_EXTICR4_EXTI15_PF        ((uint16_t)0x5000) /*!<PF[15] pin */
+#define SYSCFG_EXTICR4_EXTI15_PG        ((uint16_t)0x6000) /*!<PG[15] pin */
+#define SYSCFG_EXTICR4_EXTI15_PH        ((uint16_t)0x7000) /*!<PH[15] pin */
+#define SYSCFG_EXTICR4_EXTI15_PI        ((uint16_t)0x8000) /*!<PI[15] pin */
+#define SYSCFG_EXTICR4_EXTI15_PJ        ((uint16_t)0x9000) /*!<PJ[15] pin */
+
+/******************  Bit definition for SYSCFG_CMPCR register  ****************/  
+#define SYSCFG_CMPCR_CMP_PD             ((uint32_t)0x00000001) /*!<Compensation cell ready flag */
+#define SYSCFG_CMPCR_READY              ((uint32_t)0x00000100) /*!<Compensation cell power-down */
+
+/******************************************************************************/
+/*                                                                            */
+/*                                    TIM                                     */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bit definition for TIM_CR1 register  ********************/
+#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!<Counter enable        */
+#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!<Update disable        */
+#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!<Update request source */
+#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!<One pulse mode        */
+#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!<Direction             */
+
+#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!<CMS[1:0] bits (Center-aligned mode selection) */
+#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!<Bit 0 */
+#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!<Bit 1 */
+
+#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!<Auto-reload preload enable     */
+
+#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!<CKD[1:0] bits (clock division) */
+#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
+#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
+
+/*******************  Bit definition for TIM_CR2 register  ********************/
+#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!<Capture/Compare Preloaded Control        */
+#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!<Capture/Compare Control Update Selection */
+#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!<Capture/Compare DMA Selection            */
+
+#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!<MMS[2:0] bits (Master Mode Selection) */
+#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
+#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
+#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
+
+#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!<TI1 Selection */
+#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!<Output Idle state 1 (OC1 output)  */
+#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!<Output Idle state 1 (OC1N output) */
+#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!<Output Idle state 2 (OC2 output)  */
+#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!<Output Idle state 2 (OC2N output) */
+#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!<Output Idle state 3 (OC3 output)  */
+#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!<Output Idle state 3 (OC3N output) */
+#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!<Output Idle state 4 (OC4 output)  */
+
+/*******************  Bit definition for TIM_SMCR register  *******************/
+#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!<SMS[2:0] bits (Slave mode selection)    */
+#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
+#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
+#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
+
+#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!<TS[2:0] bits (Trigger selection)        */
+#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
+#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
+#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
+
+#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!<Master/slave mode                       */
+
+#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!<ETF[3:0] bits (External trigger filter) */
+#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!<Bit 0 */
+#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!<Bit 1 */
+#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!<Bit 2 */
+#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!<Bit 3 */
+
+#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!<ETPS[1:0] bits (External trigger prescaler) */
+#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!<Bit 0 */
+#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!<Bit 1 */
+
+#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!<External clock enable     */
+#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!<External trigger polarity */
+
+/*******************  Bit definition for TIM_DIER register  *******************/
+#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!<Update interrupt enable */
+#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt enable   */
+#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt enable   */
+#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt enable   */
+#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt enable   */
+#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!<COM interrupt enable                 */
+#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!<Trigger interrupt enable             */
+#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!<Break interrupt enable               */
+#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!<Update DMA request enable            */
+#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!<Capture/Compare 1 DMA request enable */
+#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!<Capture/Compare 2 DMA request enable */
+#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 DMA request enable */
+#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!<Capture/Compare 4 DMA request enable */
+#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!<COM DMA request enable               */
+#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!<Trigger DMA request enable           */
+
+/********************  Bit definition for TIM_SR register  ********************/
+#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!<Update interrupt Flag              */
+#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt Flag   */
+#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt Flag   */
+#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt Flag   */
+#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt Flag   */
+#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!<COM interrupt Flag                 */
+#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!<Trigger interrupt Flag             */
+#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!<Break interrupt Flag               */
+#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!<Capture/Compare 1 Overcapture Flag */
+#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!<Capture/Compare 2 Overcapture Flag */
+#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!<Capture/Compare 3 Overcapture Flag */
+#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!<Capture/Compare 4 Overcapture Flag */
+
+/*******************  Bit definition for TIM_EGR register  ********************/
+#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!<Update Generation                         */
+#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!<Capture/Compare 1 Generation              */
+#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!<Capture/Compare 2 Generation              */
+#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!<Capture/Compare 3 Generation              */
+#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!<Capture/Compare 4 Generation              */
+#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!<Capture/Compare Control Update Generation */
+#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!<Trigger Generation                        */
+#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!<Break Generation                          */
+
+/******************  Bit definition for TIM_CCMR1 register  *******************/
+#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
+#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
+#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
+
+#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!<Output Compare 1 Fast enable                 */
+#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!<Output Compare 1 Preload enable              */
+
+#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!<OC1M[2:0] bits (Output Compare 1 Mode)       */
+#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
+#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
+#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
+
+#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!<Output Compare 1Clear Enable                 */
+
+#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
+#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
+#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
+
+#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!<Output Compare 2 Fast enable                 */
+#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!<Output Compare 2 Preload enable              */
+
+#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!<OC2M[2:0] bits (Output Compare 2 Mode)       */
+#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
+#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
+#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
+
+#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!<Output Compare 2 Clear Enable */
+
+/*----------------------------------------------------------------------------*/
+
+#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
+#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
+#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
+
+#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!<IC1F[3:0] bits (Input Capture 1 Filter)      */
+#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
+#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
+#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
+#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
+
+#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler)  */
+#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
+#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
+
+#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!<IC2F[3:0] bits (Input Capture 2 Filter)       */
+#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
+#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
+#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
+#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
+
+/******************  Bit definition for TIM_CCMR2 register  *******************/
+#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection)  */
+#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
+#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
+
+#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!<Output Compare 3 Fast enable           */
+#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!<Output Compare 3 Preload enable        */
+
+#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
+#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
+#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
+#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
+
+#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!<Output Compare 3 Clear Enable */
+
+#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
+#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
+#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
+
+#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!<Output Compare 4 Fast enable    */
+#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!<Output Compare 4 Preload enable */
+
+#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
+#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
+#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
+#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
+
+#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!<Output Compare 4 Clear Enable */
+
+/*----------------------------------------------------------------------------*/
+
+#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
+#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
+#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
+
+#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
+#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
+#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
+#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
+#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
+
+#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
+#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
+#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
+
+#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
+#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
+#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
+#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
+#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
+
+/*******************  Bit definition for TIM_CCER register  *******************/
+#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!<Capture/Compare 1 output enable                 */
+#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!<Capture/Compare 1 output Polarity               */
+#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!<Capture/Compare 1 Complementary output enable   */
+#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!<Capture/Compare 1 Complementary output Polarity */
+#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!<Capture/Compare 2 output enable                 */
+#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!<Capture/Compare 2 output Polarity               */
+#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!<Capture/Compare 2 Complementary output enable   */
+#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!<Capture/Compare 2 Complementary output Polarity */
+#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!<Capture/Compare 3 output enable                 */
+#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!<Capture/Compare 3 output Polarity               */
+#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!<Capture/Compare 3 Complementary output enable   */
+#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 Complementary output Polarity */
+#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!<Capture/Compare 4 output enable                 */
+#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!<Capture/Compare 4 output Polarity               */
+#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!<Capture/Compare 4 Complementary output Polarity */
+
+/*******************  Bit definition for TIM_CNT register  ********************/
+#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!<Counter Value            */
+
+/*******************  Bit definition for TIM_PSC register  ********************/
+#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!<Prescaler Value          */
+
+/*******************  Bit definition for TIM_ARR register  ********************/
+#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!<actual auto-reload Value */
+
+/*******************  Bit definition for TIM_RCR register  ********************/
+#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!<Repetition Counter Value */
+
+/*******************  Bit definition for TIM_CCR1 register  *******************/
+#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 1 Value  */
+
+/*******************  Bit definition for TIM_CCR2 register  *******************/
+#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 2 Value  */
+
+/*******************  Bit definition for TIM_CCR3 register  *******************/
+#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 3 Value  */
+
+/*******************  Bit definition for TIM_CCR4 register  *******************/
+#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 4 Value  */
+
+/*******************  Bit definition for TIM_BDTR register  *******************/
+#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
+#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
+#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
+#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
+#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
+#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
+#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
+#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!<Bit 6 */
+#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!<Bit 7 */
+
+#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!<LOCK[1:0] bits (Lock Configuration) */
+#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!<Bit 0 */
+#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!<Bit 1 */
+
+#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!<Off-State Selection for Idle mode */
+#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!<Off-State Selection for Run mode  */
+#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!<Break enable                      */
+#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!<Break Polarity                    */
+#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!<Automatic Output enable           */
+#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!<Main Output enable                */
+
+/*******************  Bit definition for TIM_DCR register  ********************/
+#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!<DBA[4:0] bits (DMA Base Address) */
+#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!<Bit 0 */
+#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!<Bit 1 */
+#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!<Bit 2 */
+#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!<Bit 3 */
+#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!<Bit 4 */
+
+#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!<DBL[4:0] bits (DMA Burst Length) */
+#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
+#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
+#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!<Bit 2 */
+#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!<Bit 3 */
+#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!<Bit 4 */
+
+/*******************  Bit definition for TIM_DMAR register  *******************/
+#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!<DMA register for burst accesses                    */
+
+/*******************  Bit definition for TIM_OR register  *********************/
+#define TIM_OR_TI4_RMP                       ((uint16_t)0x00C0)            /*!<TI4_RMP[1:0] bits (TIM5 Input 4 remap)             */
+#define TIM_OR_TI4_RMP_0                     ((uint16_t)0x0040)            /*!<Bit 0 */
+#define TIM_OR_TI4_RMP_1                     ((uint16_t)0x0080)            /*!<Bit 1 */
+#define TIM_OR_ITR1_RMP                      ((uint16_t)0x0C00)            /*!<ITR1_RMP[1:0] bits (TIM2 Internal trigger 1 remap) */
+#define TIM_OR_ITR1_RMP_0                    ((uint16_t)0x0400)            /*!<Bit 0 */
+#define TIM_OR_ITR1_RMP_1                    ((uint16_t)0x0800)            /*!<Bit 1 */
+
+
+/******************************************************************************/
+/*                                                                            */
+/*         Universal Synchronous Asynchronous Receiver Transmitter            */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bit definition for USART_SR register  *******************/
+#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!<Parity Error                 */
+#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!<Framing Error                */
+#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!<Noise Error Flag             */
+#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!<OverRun Error                */
+#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!<IDLE line detected           */
+#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!<Read Data Register Not Empty */
+#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!<Transmission Complete        */
+#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!<Transmit Data Register Empty */
+#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!<LIN Break Detection Flag     */
+#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!<CTS Flag                     */
+
+/*******************  Bit definition for USART_DR register  *******************/
+#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!<Data value */
+
+/******************  Bit definition for USART_BRR register  *******************/
+#define  USART_BRR_DIV_Fraction              ((uint16_t)0x000F)            /*!<Fraction of USARTDIV */
+#define  USART_BRR_DIV_Mantissa              ((uint16_t)0xFFF0)            /*!<Mantissa of USARTDIV */
+
+/******************  Bit definition for USART_CR1 register  *******************/
+#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!<Send Break                             */
+#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!<Receiver wakeup                        */
+#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!<Receiver Enable                        */
+#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!<Transmitter Enable                     */
+#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!<IDLE Interrupt Enable                  */
+#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!<RXNE Interrupt Enable                  */
+#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!<Transmission Complete Interrupt Enable */
+#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!<PE Interrupt Enable                    */
+#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!<PE Interrupt Enable                    */
+#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!<Parity Selection                       */
+#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!<Parity Control Enable                  */
+#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!<Wakeup method                          */
+#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!<Word length                            */
+#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!<USART Enable                           */
+#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!<USART Oversampling by 8 enable         */
+
+/******************  Bit definition for USART_CR2 register  *******************/
+#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!<Address of the USART node            */
+#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!<LIN Break Detection Length           */
+#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!<LIN Break Detection Interrupt Enable */
+#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!<Last Bit Clock pulse                 */
+#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!<Clock Phase                          */
+#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!<Clock Polarity                       */
+#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!<Clock Enable                         */
+
+#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!<STOP[1:0] bits (STOP bits) */
+#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
+#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
+
+#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!<LIN mode enable */
+
+/******************  Bit definition for USART_CR3 register  *******************/
+#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!<Error Interrupt Enable      */
+#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!<IrDA mode Enable            */
+#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!<IrDA Low-Power              */
+#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!<Half-Duplex Selection       */
+#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!<Smartcard NACK enable       */
+#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!<Smartcard mode enable       */
+#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!<DMA Enable Receiver         */
+#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!<DMA Enable Transmitter      */
+#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!<RTS Enable                  */
+#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!<CTS Enable                  */
+#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!<CTS Interrupt Enable        */
+#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!<USART One bit method enable */
+
+/******************  Bit definition for USART_GTPR register  ******************/
+#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!<PSC[7:0] bits (Prescaler value) */
+#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
+#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
+#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!<Bit 2 */
+#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!<Bit 3 */
+#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!<Bit 4 */
+#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!<Bit 5 */
+#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!<Bit 6 */
+#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!<Bit 7 */
+
+#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!<Guard time value */
+
+/******************************************************************************/
+/*                                                                            */
+/*                            Window WATCHDOG                                 */
+/*                                                                            */
+/******************************************************************************/
+/*******************  Bit definition for WWDG_CR register  ********************/
+#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!<T[6:0] bits (7-Bit counter (MSB to LSB)) */
+#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!<Bit 0 */
+#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!<Bit 1 */
+#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!<Bit 2 */
+#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!<Bit 3 */
+#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!<Bit 4 */
+#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!<Bit 5 */
+#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!<Bit 6 */
+
+#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!<Activation bit */
+
+/*******************  Bit definition for WWDG_CFR register  *******************/
+#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!<W[6:0] bits (7-bit window value) */
+#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!<Bit 0 */
+#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!<Bit 1 */
+#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!<Bit 2 */
+#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!<Bit 3 */
+#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!<Bit 4 */
+#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!<Bit 5 */
+#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!<Bit 6 */
+
+#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!<WDGTB[1:0] bits (Timer Base) */
+#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!<Bit 0 */
+#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!<Bit 1 */
+
+#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!<Early Wakeup Interrupt */
+
+/*******************  Bit definition for WWDG_SR register  ********************/
+#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!<Early Wakeup Interrupt Flag */
+
+
+/******************************************************************************/
+/*                                                                            */
+/*                                DBG                                         */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bit definition for DBGMCU_IDCODE register  *************/
+#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)
+#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)
+
+/********************  Bit definition for DBGMCU_CR register  *****************/
+#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)
+#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)
+#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)
+#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)
+
+#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)
+#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)/*!<Bit 0 */
+#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)/*!<Bit 1 */
+
+/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
+#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP            ((uint32_t)0x00000001)
+#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP            ((uint32_t)0x00000002)
+#define  DBGMCU_APB1_FZ_DBG_TIM4_STOP            ((uint32_t)0x00000004)
+#define  DBGMCU_APB1_FZ_DBG_TIM5_STOP            ((uint32_t)0x00000008)
+#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP            ((uint32_t)0x00000010)
+#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP            ((uint32_t)0x00000020)
+#define  DBGMCU_APB1_FZ_DBG_TIM12_STOP           ((uint32_t)0x00000040)
+#define  DBGMCU_APB1_FZ_DBG_TIM13_STOP           ((uint32_t)0x00000080)
+#define  DBGMCU_APB1_FZ_DBG_TIM14_STOP           ((uint32_t)0x00000100)
+#define  DBGMCU_APB1_FZ_DBG_RTC_STOP             ((uint32_t)0x00000400)
+#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP            ((uint32_t)0x00000800)
+#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP            ((uint32_t)0x00001000)
+#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT   ((uint32_t)0x00200000)
+#define  DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT   ((uint32_t)0x00400000)
+#define  DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT   ((uint32_t)0x00800000)
+#define  DBGMCU_APB1_FZ_DBG_CAN1_STOP            ((uint32_t)0x02000000)
+#define  DBGMCU_APB1_FZ_DBG_CAN2_STOP            ((uint32_t)0x04000000)
+/* Old IWDGSTOP bit definition, maintained for legacy purpose */
+#define  DBGMCU_APB1_FZ_DBG_IWDEG_STOP           DBGMCU_APB1_FZ_DBG_IWDG_STOP
+
+/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
+#define  DBGMCU_APB1_FZ_DBG_TIM1_STOP        ((uint32_t)0x00000001)
+#define  DBGMCU_APB1_FZ_DBG_TIM8_STOP        ((uint32_t)0x00000002)
+#define  DBGMCU_APB1_FZ_DBG_TIM9_STOP        ((uint32_t)0x00010000)
+#define  DBGMCU_APB1_FZ_DBG_TIM10_STOP       ((uint32_t)0x00020000)
+#define  DBGMCU_APB1_FZ_DBG_TIM11_STOP       ((uint32_t)0x00040000)
+
+/******************************************************************************/
+/*                                                                            */
+/*                Ethernet MAC Registers bits definitions                     */
+/*                                                                            */
+/******************************************************************************/
+/* Bit definition for Ethernet MAC Control Register register */
+#define ETH_MACCR_WD      ((uint32_t)0x00800000)  /* Watchdog disable */
+#define ETH_MACCR_JD      ((uint32_t)0x00400000)  /* Jabber disable */
+#define ETH_MACCR_IFG     ((uint32_t)0x000E0000)  /* Inter-frame gap */
+#define ETH_MACCR_IFG_96Bit     ((uint32_t)0x00000000)  /* Minimum IFG between frames during transmission is 96Bit */
+  #define ETH_MACCR_IFG_88Bit     ((uint32_t)0x00020000)  /* Minimum IFG between frames during transmission is 88Bit */
+  #define ETH_MACCR_IFG_80Bit     ((uint32_t)0x00040000)  /* Minimum IFG between frames during transmission is 80Bit */
+  #define ETH_MACCR_IFG_72Bit     ((uint32_t)0x00060000)  /* Minimum IFG between frames during transmission is 72Bit */
+  #define ETH_MACCR_IFG_64Bit     ((uint32_t)0x00080000)  /* Minimum IFG between frames during transmission is 64Bit */        
+  #define ETH_MACCR_IFG_56Bit     ((uint32_t)0x000A0000)  /* Minimum IFG between frames during transmission is 56Bit */
+  #define ETH_MACCR_IFG_48Bit     ((uint32_t)0x000C0000)  /* Minimum IFG between frames during transmission is 48Bit */
+  #define ETH_MACCR_IFG_40Bit     ((uint32_t)0x000E0000)  /* Minimum IFG between frames during transmission is 40Bit */              
+#define ETH_MACCR_CSD     ((uint32_t)0x00010000)  /* Carrier sense disable (during transmission) */
+#define ETH_MACCR_FES     ((uint32_t)0x00004000)  /* Fast ethernet speed */
+#define ETH_MACCR_ROD     ((uint32_t)0x00002000)  /* Receive own disable */
+#define ETH_MACCR_LM      ((uint32_t)0x00001000)  /* loopback mode */
+#define ETH_MACCR_DM      ((uint32_t)0x00000800)  /* Duplex mode */
+#define ETH_MACCR_IPCO    ((uint32_t)0x00000400)  /* IP Checksum offload */
+#define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */
+#define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */
+#define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling
+                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */
+  #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */
+  #define ETH_MACCR_BL_8     ((uint32_t)0x00000020)  /* k = min (n, 8) */
+  #define ETH_MACCR_BL_4     ((uint32_t)0x00000040)  /* k = min (n, 4) */
+  #define ETH_MACCR_BL_1     ((uint32_t)0x00000060)  /* k = min (n, 1) */ 
+#define ETH_MACCR_DC      ((uint32_t)0x00000010)  /* Defferal check */
+#define ETH_MACCR_TE      ((uint32_t)0x00000008)  /* Transmitter enable */
+#define ETH_MACCR_RE      ((uint32_t)0x00000004)  /* Receiver enable */
+
+/* Bit definition for Ethernet MAC Frame Filter Register */
+#define ETH_MACFFR_RA     ((uint32_t)0x80000000)  /* Receive all */ 
+#define ETH_MACFFR_HPF    ((uint32_t)0x00000400)  /* Hash or perfect filter */ 
+#define ETH_MACFFR_SAF    ((uint32_t)0x00000200)  /* Source address filter enable */ 
+#define ETH_MACFFR_SAIF   ((uint32_t)0x00000100)  /* SA inverse filtering */ 
+#define ETH_MACFFR_PCF    ((uint32_t)0x000000C0)  /* Pass control frames: 3 cases */
+  #define ETH_MACFFR_PCF_BlockAll                ((uint32_t)0x00000040)  /* MAC filters all control frames from reaching the application */
+  #define ETH_MACFFR_PCF_ForwardAll              ((uint32_t)0x00000080)  /* MAC forwards all control frames to application even if they fail the Address Filter */
+  #define ETH_MACFFR_PCF_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /* MAC forwards control frames that pass the Address Filter. */ 
+#define ETH_MACFFR_BFD    ((uint32_t)0x00000020)  /* Broadcast frame disable */ 
+#define ETH_MACFFR_PAM    ((uint32_t)0x00000010)  /* Pass all mutlicast */ 
+#define ETH_MACFFR_DAIF   ((uint32_t)0x00000008)  /* DA Inverse filtering */ 
+#define ETH_MACFFR_HM     ((uint32_t)0x00000004)  /* Hash multicast */ 
+#define ETH_MACFFR_HU     ((uint32_t)0x00000002)  /* Hash unicast */
+#define ETH_MACFFR_PM     ((uint32_t)0x00000001)  /* Promiscuous mode */
+
+/* Bit definition for Ethernet MAC Hash Table High Register */
+#define ETH_MACHTHR_HTH   ((uint32_t)0xFFFFFFFF)  /* Hash table high */
+
+/* Bit definition for Ethernet MAC Hash Table Low Register */
+#define ETH_MACHTLR_HTL   ((uint32_t)0xFFFFFFFF)  /* Hash table low */
+
+/* Bit definition for Ethernet MAC MII Address Register */
+#define ETH_MACMIIAR_PA   ((uint32_t)0x0000F800)  /* Physical layer address */ 
+#define ETH_MACMIIAR_MR   ((uint32_t)0x000007C0)  /* MII register in the selected PHY */ 
+#define ETH_MACMIIAR_CR   ((uint32_t)0x0000001C)  /* CR clock range: 6 cases */ 
+  #define ETH_MACMIIAR_CR_Div42   ((uint32_t)0x00000000)  /* HCLK:60-100 MHz; MDC clock= HCLK/42 */
+  #define ETH_MACMIIAR_CR_Div62   ((uint32_t)0x00000004)  /* HCLK:100-150 MHz; MDC clock= HCLK/62 */
+  #define ETH_MACMIIAR_CR_Div16   ((uint32_t)0x00000008)  /* HCLK:20-35 MHz; MDC clock= HCLK/16 */
+  #define ETH_MACMIIAR_CR_Div26   ((uint32_t)0x0000000C)  /* HCLK:35-60 MHz; MDC clock= HCLK/26 */
+  #define ETH_MACMIIAR_CR_Div102  ((uint32_t)0x00000010)  /* HCLK:150-168 MHz; MDC clock= HCLK/102 */  
+#define ETH_MACMIIAR_MW   ((uint32_t)0x00000002)  /* MII write */ 
+#define ETH_MACMIIAR_MB   ((uint32_t)0x00000001)  /* MII busy */ 
+  
+/* Bit definition for Ethernet MAC MII Data Register */
+#define ETH_MACMIIDR_MD   ((uint32_t)0x0000FFFF)  /* MII data: read/write data from/to PHY */
+
+/* Bit definition for Ethernet MAC Flow Control Register */
+#define ETH_MACFCR_PT     ((uint32_t)0xFFFF0000)  /* Pause time */
+#define ETH_MACFCR_ZQPD   ((uint32_t)0x00000080)  /* Zero-quanta pause disable */
+#define ETH_MACFCR_PLT    ((uint32_t)0x00000030)  /* Pause low threshold: 4 cases */
+  #define ETH_MACFCR_PLT_Minus4   ((uint32_t)0x00000000)  /* Pause time minus 4 slot times */
+  #define ETH_MACFCR_PLT_Minus28  ((uint32_t)0x00000010)  /* Pause time minus 28 slot times */
+  #define ETH_MACFCR_PLT_Minus144 ((uint32_t)0x00000020)  /* Pause time minus 144 slot times */
+  #define ETH_MACFCR_PLT_Minus256 ((uint32_t)0x00000030)  /* Pause time minus 256 slot times */      
+#define ETH_MACFCR_UPFD   ((uint32_t)0x00000008)  /* Unicast pause frame detect */
+#define ETH_MACFCR_RFCE   ((uint32_t)0x00000004)  /* Receive flow control enable */
+#define ETH_MACFCR_TFCE   ((uint32_t)0x00000002)  /* Transmit flow control enable */
+#define ETH_MACFCR_FCBBPA ((uint32_t)0x00000001)  /* Flow control busy/backpressure activate */
+
+/* Bit definition for Ethernet MAC VLAN Tag Register */
+#define ETH_MACVLANTR_VLANTC ((uint32_t)0x00010000)  /* 12-bit VLAN tag comparison */
+#define ETH_MACVLANTR_VLANTI ((uint32_t)0x0000FFFF)  /* VLAN tag identifier (for receive frames) */
+
+/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */ 
+#define ETH_MACRWUFFR_D   ((uint32_t)0xFFFFFFFF)  /* Wake-up frame filter register data */
+/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.
+   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */
+/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask
+   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
+   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask
+   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask
+   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command - 
+                              RSVD - Filter1 Command - RSVD - Filter0 Command
+   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset
+   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16
+   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */
+
+/* Bit definition for Ethernet MAC PMT Control and Status Register */ 
+#define ETH_MACPMTCSR_WFFRPR ((uint32_t)0x80000000)  /* Wake-Up Frame Filter Register Pointer Reset */
+#define ETH_MACPMTCSR_GU     ((uint32_t)0x00000200)  /* Global Unicast */
+#define ETH_MACPMTCSR_WFR    ((uint32_t)0x00000040)  /* Wake-Up Frame Received */
+#define ETH_MACPMTCSR_MPR    ((uint32_t)0x00000020)  /* Magic Packet Received */
+#define ETH_MACPMTCSR_WFE    ((uint32_t)0x00000004)  /* Wake-Up Frame Enable */
+#define ETH_MACPMTCSR_MPE    ((uint32_t)0x00000002)  /* Magic Packet Enable */
+#define ETH_MACPMTCSR_PD     ((uint32_t)0x00000001)  /* Power Down */
+
+/* Bit definition for Ethernet MAC Status Register */
+#define ETH_MACSR_TSTS      ((uint32_t)0x00000200)  /* Time stamp trigger status */
+#define ETH_MACSR_MMCTS     ((uint32_t)0x00000040)  /* MMC transmit status */
+#define ETH_MACSR_MMMCRS    ((uint32_t)0x00000020)  /* MMC receive status */
+#define ETH_MACSR_MMCS      ((uint32_t)0x00000010)  /* MMC status */
+#define ETH_MACSR_PMTS      ((uint32_t)0x00000008)  /* PMT status */
+
+/* Bit definition for Ethernet MAC Interrupt Mask Register */
+#define ETH_MACIMR_TSTIM     ((uint32_t)0x00000200)  /* Time stamp trigger interrupt mask */
+#define ETH_MACIMR_PMTIM     ((uint32_t)0x00000008)  /* PMT interrupt mask */
+
+/* Bit definition for Ethernet MAC Address0 High Register */
+#define ETH_MACA0HR_MACA0H   ((uint32_t)0x0000FFFF)  /* MAC address0 high */
+
+/* Bit definition for Ethernet MAC Address0 Low Register */
+#define ETH_MACA0LR_MACA0L   ((uint32_t)0xFFFFFFFF)  /* MAC address0 low */
+
+/* Bit definition for Ethernet MAC Address1 High Register */
+#define ETH_MACA1HR_AE       ((uint32_t)0x80000000)  /* Address enable */
+#define ETH_MACA1HR_SA       ((uint32_t)0x40000000)  /* Source address */
+#define ETH_MACA1HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control: bits to mask for comparison of the MAC Address bytes */
+  #define ETH_MACA1HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
+  #define ETH_MACA1HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
+  #define ETH_MACA1HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
+  #define ETH_MACA1HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
+  #define ETH_MACA1HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
+  #define ETH_MACA1HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [7:0] */ 
+#define ETH_MACA1HR_MACA1H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
+
+/* Bit definition for Ethernet MAC Address1 Low Register */
+#define ETH_MACA1LR_MACA1L   ((uint32_t)0xFFFFFFFF)  /* MAC address1 low */
+
+/* Bit definition for Ethernet MAC Address2 High Register */
+#define ETH_MACA2HR_AE       ((uint32_t)0x80000000)  /* Address enable */
+#define ETH_MACA2HR_SA       ((uint32_t)0x40000000)  /* Source address */
+#define ETH_MACA2HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
+  #define ETH_MACA2HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
+  #define ETH_MACA2HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
+  #define ETH_MACA2HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
+  #define ETH_MACA2HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
+  #define ETH_MACA2HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
+  #define ETH_MACA2HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
+#define ETH_MACA2HR_MACA2H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
+
+/* Bit definition for Ethernet MAC Address2 Low Register */
+#define ETH_MACA2LR_MACA2L   ((uint32_t)0xFFFFFFFF)  /* MAC address2 low */
+
+/* Bit definition for Ethernet MAC Address3 High Register */
+#define ETH_MACA3HR_AE       ((uint32_t)0x80000000)  /* Address enable */
+#define ETH_MACA3HR_SA       ((uint32_t)0x40000000)  /* Source address */
+#define ETH_MACA3HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
+  #define ETH_MACA3HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
+  #define ETH_MACA3HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
+  #define ETH_MACA3HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
+  #define ETH_MACA3HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
+  #define ETH_MACA3HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
+  #define ETH_MACA3HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
+#define ETH_MACA3HR_MACA3H   ((uint32_t)0x0000FFFF)  /* MAC address3 high */
+
+/* Bit definition for Ethernet MAC Address3 Low Register */
+#define ETH_MACA3LR_MACA3L   ((uint32_t)0xFFFFFFFF)  /* MAC address3 low */
+
+/******************************************************************************/
+/*                Ethernet MMC Registers bits definition                      */
+/******************************************************************************/
+
+/* Bit definition for Ethernet MMC Contol Register */
+#define ETH_MMCCR_MCFHP      ((uint32_t)0x00000020)  /* MMC counter Full-Half preset */
+#define ETH_MMCCR_MCP        ((uint32_t)0x00000010)  /* MMC counter preset */
+#define ETH_MMCCR_MCF        ((uint32_t)0x00000008)  /* MMC Counter Freeze */
+#define ETH_MMCCR_ROR        ((uint32_t)0x00000004)  /* Reset on Read */
+#define ETH_MMCCR_CSR        ((uint32_t)0x00000002)  /* Counter Stop Rollover */
+#define ETH_MMCCR_CR         ((uint32_t)0x00000001)  /* Counters Reset */
+
+/* Bit definition for Ethernet MMC Receive Interrupt Register */
+#define ETH_MMCRIR_RGUFS     ((uint32_t)0x00020000)  /* Set when Rx good unicast frames counter reaches half the maximum value */
+#define ETH_MMCRIR_RFAES     ((uint32_t)0x00000040)  /* Set when Rx alignment error counter reaches half the maximum value */
+#define ETH_MMCRIR_RFCES     ((uint32_t)0x00000020)  /* Set when Rx crc error counter reaches half the maximum value */
+
+/* Bit definition for Ethernet MMC Transmit Interrupt Register */
+#define ETH_MMCTIR_TGFS      ((uint32_t)0x00200000)  /* Set when Tx good frame count counter reaches half the maximum value */
+#define ETH_MMCTIR_TGFMSCS   ((uint32_t)0x00008000)  /* Set when Tx good multi col counter reaches half the maximum value */
+#define ETH_MMCTIR_TGFSCS    ((uint32_t)0x00004000)  /* Set when Tx good single col counter reaches half the maximum value */
+
+/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */
+#define ETH_MMCRIMR_RGUFM    ((uint32_t)0x00020000)  /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */
+#define ETH_MMCRIMR_RFAEM    ((uint32_t)0x00000040)  /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */
+#define ETH_MMCRIMR_RFCEM    ((uint32_t)0x00000020)  /* Mask the interrupt when Rx crc error counter reaches half the maximum value */
+
+/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */
+#define ETH_MMCTIMR_TGFM     ((uint32_t)0x00200000)  /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */
+#define ETH_MMCTIMR_TGFMSCM  ((uint32_t)0x00008000)  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */
+#define ETH_MMCTIMR_TGFSCM   ((uint32_t)0x00004000)  /* Mask the interrupt when Tx good single col counter reaches half the maximum value */
+
+/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */
+#define ETH_MMCTGFSCCR_TGFSCC     ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */
+
+/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */
+#define ETH_MMCTGFMSCCR_TGFMSCC   ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */
+
+/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */
+#define ETH_MMCTGFCR_TGFC    ((uint32_t)0xFFFFFFFF)  /* Number of good frames transmitted. */
+
+/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */
+#define ETH_MMCRFCECR_RFCEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with CRC error. */
+
+/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */
+#define ETH_MMCRFAECR_RFAEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with alignment (dribble) error */
+
+/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */
+#define ETH_MMCRGUFCR_RGUFC  ((uint32_t)0xFFFFFFFF)  /* Number of good unicast frames received. */
+
+/******************************************************************************/
+/*               Ethernet PTP Registers bits definition                       */
+/******************************************************************************/
+
+/* Bit definition for Ethernet PTP Time Stamp Contol Register */
+#define ETH_PTPTSCR_TSCNT       ((uint32_t)0x00030000)  /* Time stamp clock node type */
+#define ETH_PTPTSSR_TSSMRME     ((uint32_t)0x00008000)  /* Time stamp snapshot for message relevant to master enable */
+#define ETH_PTPTSSR_TSSEME      ((uint32_t)0x00004000)  /* Time stamp snapshot for event message enable */
+#define ETH_PTPTSSR_TSSIPV4FE   ((uint32_t)0x00002000)  /* Time stamp snapshot for IPv4 frames enable */
+#define ETH_PTPTSSR_TSSIPV6FE   ((uint32_t)0x00001000)  /* Time stamp snapshot for IPv6 frames enable */
+#define ETH_PTPTSSR_TSSPTPOEFE  ((uint32_t)0x00000800)  /* Time stamp snapshot for PTP over ethernet frames enable */
+#define ETH_PTPTSSR_TSPTPPSV2E  ((uint32_t)0x00000400)  /* Time stamp PTP packet snooping for version2 format enable */
+#define ETH_PTPTSSR_TSSSR       ((uint32_t)0x00000200)  /* Time stamp Sub-seconds rollover */
+#define ETH_PTPTSSR_TSSARFE     ((uint32_t)0x00000100)  /* Time stamp snapshot for all received frames enable */
+
+#define ETH_PTPTSCR_TSARU    ((uint32_t)0x00000020)  /* Addend register update */
+#define ETH_PTPTSCR_TSITE    ((uint32_t)0x00000010)  /* Time stamp interrupt trigger enable */
+#define ETH_PTPTSCR_TSSTU    ((uint32_t)0x00000008)  /* Time stamp update */
+#define ETH_PTPTSCR_TSSTI    ((uint32_t)0x00000004)  /* Time stamp initialize */
+#define ETH_PTPTSCR_TSFCU    ((uint32_t)0x00000002)  /* Time stamp fine or coarse update */
+#define ETH_PTPTSCR_TSE      ((uint32_t)0x00000001)  /* Time stamp enable */
+
+/* Bit definition for Ethernet PTP Sub-Second Increment Register */
+#define ETH_PTPSSIR_STSSI    ((uint32_t)0x000000FF)  /* System time Sub-second increment value */
+
+/* Bit definition for Ethernet PTP Time Stamp High Register */
+#define ETH_PTPTSHR_STS      ((uint32_t)0xFFFFFFFF)  /* System Time second */
+
+/* Bit definition for Ethernet PTP Time Stamp Low Register */
+#define ETH_PTPTSLR_STPNS    ((uint32_t)0x80000000)  /* System Time Positive or negative time */
+#define ETH_PTPTSLR_STSS     ((uint32_t)0x7FFFFFFF)  /* System Time sub-seconds */
+
+/* Bit definition for Ethernet PTP Time Stamp High Update Register */
+#define ETH_PTPTSHUR_TSUS    ((uint32_t)0xFFFFFFFF)  /* Time stamp update seconds */
+
+/* Bit definition for Ethernet PTP Time Stamp Low Update Register */
+#define ETH_PTPTSLUR_TSUPNS  ((uint32_t)0x80000000)  /* Time stamp update Positive or negative time */
+#define ETH_PTPTSLUR_TSUSS   ((uint32_t)0x7FFFFFFF)  /* Time stamp update sub-seconds */
+
+/* Bit definition for Ethernet PTP Time Stamp Addend Register */
+#define ETH_PTPTSAR_TSA      ((uint32_t)0xFFFFFFFF)  /* Time stamp addend */
+
+/* Bit definition for Ethernet PTP Target Time High Register */
+#define ETH_PTPTTHR_TTSH     ((uint32_t)0xFFFFFFFF)  /* Target time stamp high */
+
+/* Bit definition for Ethernet PTP Target Time Low Register */
+#define ETH_PTPTTLR_TTSL     ((uint32_t)0xFFFFFFFF)  /* Target time stamp low */
+
+/* Bit definition for Ethernet PTP Time Stamp Status Register */
+#define ETH_PTPTSSR_TSTTR    ((uint32_t)0x00000020)  /* Time stamp target time reached */
+#define ETH_PTPTSSR_TSSO     ((uint32_t)0x00000010)  /* Time stamp seconds overflow */
+
+/******************************************************************************/
+/*                 Ethernet DMA Registers bits definition                     */
+/******************************************************************************/
+
+/* Bit definition for Ethernet DMA Bus Mode Register */
+#define ETH_DMABMR_AAB       ((uint32_t)0x02000000)  /* Address-Aligned beats */
+#define ETH_DMABMR_FPM        ((uint32_t)0x01000000)  /* 4xPBL mode */
+#define ETH_DMABMR_USP       ((uint32_t)0x00800000)  /* Use separate PBL */
+#define ETH_DMABMR_RDP       ((uint32_t)0x007E0000)  /* RxDMA PBL */
+  #define ETH_DMABMR_RDP_1Beat    ((uint32_t)0x00020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
+  #define ETH_DMABMR_RDP_2Beat    ((uint32_t)0x00040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 2 */
+  #define ETH_DMABMR_RDP_4Beat    ((uint32_t)0x00080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
+  #define ETH_DMABMR_RDP_8Beat    ((uint32_t)0x00100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
+  #define ETH_DMABMR_RDP_16Beat   ((uint32_t)0x00200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
+  #define ETH_DMABMR_RDP_32Beat   ((uint32_t)0x00400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */                
+  #define ETH_DMABMR_RDP_4xPBL_4Beat   ((uint32_t)0x01020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
+  #define ETH_DMABMR_RDP_4xPBL_8Beat   ((uint32_t)0x01040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
+  #define ETH_DMABMR_RDP_4xPBL_16Beat  ((uint32_t)0x01080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
+  #define ETH_DMABMR_RDP_4xPBL_32Beat  ((uint32_t)0x01100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
+  #define ETH_DMABMR_RDP_4xPBL_64Beat  ((uint32_t)0x01200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 64 */
+  #define ETH_DMABMR_RDP_4xPBL_128Beat ((uint32_t)0x01400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 128 */  
+#define ETH_DMABMR_FB        ((uint32_t)0x00010000)  /* Fixed Burst */
+#define ETH_DMABMR_RTPR      ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */
+  #define ETH_DMABMR_RTPR_1_1     ((uint32_t)0x00000000)  /* Rx Tx priority ratio */
+  #define ETH_DMABMR_RTPR_2_1     ((uint32_t)0x00004000)  /* Rx Tx priority ratio */
+  #define ETH_DMABMR_RTPR_3_1     ((uint32_t)0x00008000)  /* Rx Tx priority ratio */
+  #define ETH_DMABMR_RTPR_4_1     ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */  
+#define ETH_DMABMR_PBL    ((uint32_t)0x00003F00)  /* Programmable burst length */
+  #define ETH_DMABMR_PBL_1Beat    ((uint32_t)0x00000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
+  #define ETH_DMABMR_PBL_2Beat    ((uint32_t)0x00000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
+  #define ETH_DMABMR_PBL_4Beat    ((uint32_t)0x00000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
+  #define ETH_DMABMR_PBL_8Beat    ((uint32_t)0x00000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
+  #define ETH_DMABMR_PBL_16Beat   ((uint32_t)0x00001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
+  #define ETH_DMABMR_PBL_32Beat   ((uint32_t)0x00002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
+  #define ETH_DMABMR_PBL_4xPBL_4Beat   ((uint32_t)0x01000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
+  #define ETH_DMABMR_PBL_4xPBL_8Beat   ((uint32_t)0x01000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
+  #define ETH_DMABMR_PBL_4xPBL_16Beat  ((uint32_t)0x01000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
+  #define ETH_DMABMR_PBL_4xPBL_32Beat  ((uint32_t)0x01000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
+  #define ETH_DMABMR_PBL_4xPBL_64Beat  ((uint32_t)0x01001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
+  #define ETH_DMABMR_PBL_4xPBL_128Beat ((uint32_t)0x01002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
+#define ETH_DMABMR_EDE       ((uint32_t)0x00000080)  /* Enhanced Descriptor Enable */
+#define ETH_DMABMR_DSL       ((uint32_t)0x0000007C)  /* Descriptor Skip Length */
+#define ETH_DMABMR_DA        ((uint32_t)0x00000002)  /* DMA arbitration scheme */
+#define ETH_DMABMR_SR        ((uint32_t)0x00000001)  /* Software reset */
+
+/* Bit definition for Ethernet DMA Transmit Poll Demand Register */
+#define ETH_DMATPDR_TPD      ((uint32_t)0xFFFFFFFF)  /* Transmit poll demand */
+
+/* Bit definition for Ethernet DMA Receive Poll Demand Register */
+#define ETH_DMARPDR_RPD      ((uint32_t)0xFFFFFFFF)  /* Receive poll demand  */
+
+/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */
+#define ETH_DMARDLAR_SRL     ((uint32_t)0xFFFFFFFF)  /* Start of receive list */
+
+/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */
+#define ETH_DMATDLAR_STL     ((uint32_t)0xFFFFFFFF)  /* Start of transmit list */
+
+/* Bit definition for Ethernet DMA Status Register */
+#define ETH_DMASR_TSTS       ((uint32_t)0x20000000)  /* Time-stamp trigger status */
+#define ETH_DMASR_PMTS       ((uint32_t)0x10000000)  /* PMT status */
+#define ETH_DMASR_MMCS       ((uint32_t)0x08000000)  /* MMC status */
+#define ETH_DMASR_EBS        ((uint32_t)0x03800000)  /* Error bits status */
+  /* combination with EBS[2:0] for GetFlagStatus function */
+  #define ETH_DMASR_EBS_DescAccess      ((uint32_t)0x02000000)  /* Error bits 0-data buffer, 1-desc. access */
+  #define ETH_DMASR_EBS_ReadTransf      ((uint32_t)0x01000000)  /* Error bits 0-write trnsf, 1-read transfr */
+  #define ETH_DMASR_EBS_DataTransfTx    ((uint32_t)0x00800000)  /* Error bits 0-Rx DMA, 1-Tx DMA */
+#define ETH_DMASR_TPS         ((uint32_t)0x00700000)  /* Transmit process state */
+  #define ETH_DMASR_TPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Tx Command issued  */
+  #define ETH_DMASR_TPS_Fetching        ((uint32_t)0x00100000)  /* Running - fetching the Tx descriptor */
+  #define ETH_DMASR_TPS_Waiting         ((uint32_t)0x00200000)  /* Running - waiting for status */
+  #define ETH_DMASR_TPS_Reading         ((uint32_t)0x00300000)  /* Running - reading the data from host memory */
+  #define ETH_DMASR_TPS_Suspended       ((uint32_t)0x00600000)  /* Suspended - Tx Descriptor unavailabe */
+  #define ETH_DMASR_TPS_Closing         ((uint32_t)0x00700000)  /* Running - closing Rx descriptor */
+#define ETH_DMASR_RPS         ((uint32_t)0x000E0000)  /* Receive process state */
+  #define ETH_DMASR_RPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Rx Command issued */
+  #define ETH_DMASR_RPS_Fetching        ((uint32_t)0x00020000)  /* Running - fetching the Rx descriptor */
+  #define ETH_DMASR_RPS_Waiting         ((uint32_t)0x00060000)  /* Running - waiting for packet */
+  #define ETH_DMASR_RPS_Suspended       ((uint32_t)0x00080000)  /* Suspended - Rx Descriptor unavailable */
+  #define ETH_DMASR_RPS_Closing         ((uint32_t)0x000A0000)  /* Running - closing descriptor */
+  #define ETH_DMASR_RPS_Queuing         ((uint32_t)0x000E0000)  /* Running - queuing the recieve frame into host memory */
+#define ETH_DMASR_NIS        ((uint32_t)0x00010000)  /* Normal interrupt summary */
+#define ETH_DMASR_AIS        ((uint32_t)0x00008000)  /* Abnormal interrupt summary */
+#define ETH_DMASR_ERS        ((uint32_t)0x00004000)  /* Early receive status */
+#define ETH_DMASR_FBES       ((uint32_t)0x00002000)  /* Fatal bus error status */
+#define ETH_DMASR_ETS        ((uint32_t)0x00000400)  /* Early transmit status */
+#define ETH_DMASR_RWTS       ((uint32_t)0x00000200)  /* Receive watchdog timeout status */
+#define ETH_DMASR_RPSS       ((uint32_t)0x00000100)  /* Receive process stopped status */
+#define ETH_DMASR_RBUS       ((uint32_t)0x00000080)  /* Receive buffer unavailable status */
+#define ETH_DMASR_RS         ((uint32_t)0x00000040)  /* Receive status */
+#define ETH_DMASR_TUS        ((uint32_t)0x00000020)  /* Transmit underflow status */
+#define ETH_DMASR_ROS        ((uint32_t)0x00000010)  /* Receive overflow status */
+#define ETH_DMASR_TJTS       ((uint32_t)0x00000008)  /* Transmit jabber timeout status */
+#define ETH_DMASR_TBUS       ((uint32_t)0x00000004)  /* Transmit buffer unavailable status */
+#define ETH_DMASR_TPSS       ((uint32_t)0x00000002)  /* Transmit process stopped status */
+#define ETH_DMASR_TS         ((uint32_t)0x00000001)  /* Transmit status */
+
+/* Bit definition for Ethernet DMA Operation Mode Register */
+#define ETH_DMAOMR_DTCEFD    ((uint32_t)0x04000000)  /* Disable Dropping of TCP/IP checksum error frames */
+#define ETH_DMAOMR_RSF       ((uint32_t)0x02000000)  /* Receive store and forward */
+#define ETH_DMAOMR_DFRF      ((uint32_t)0x01000000)  /* Disable flushing of received frames */
+#define ETH_DMAOMR_TSF       ((uint32_t)0x00200000)  /* Transmit store and forward */
+#define ETH_DMAOMR_FTF       ((uint32_t)0x00100000)  /* Flush transmit FIFO */
+#define ETH_DMAOMR_TTC       ((uint32_t)0x0001C000)  /* Transmit threshold control */
+  #define ETH_DMAOMR_TTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Transmit FIFO is 64 Bytes */
+  #define ETH_DMAOMR_TTC_128Bytes      ((uint32_t)0x00004000)  /* threshold level of the MTL Transmit FIFO is 128 Bytes */
+  #define ETH_DMAOMR_TTC_192Bytes      ((uint32_t)0x00008000)  /* threshold level of the MTL Transmit FIFO is 192 Bytes */
+  #define ETH_DMAOMR_TTC_256Bytes      ((uint32_t)0x0000C000)  /* threshold level of the MTL Transmit FIFO is 256 Bytes */
+  #define ETH_DMAOMR_TTC_40Bytes       ((uint32_t)0x00010000)  /* threshold level of the MTL Transmit FIFO is 40 Bytes */
+  #define ETH_DMAOMR_TTC_32Bytes       ((uint32_t)0x00014000)  /* threshold level of the MTL Transmit FIFO is 32 Bytes */
+  #define ETH_DMAOMR_TTC_24Bytes       ((uint32_t)0x00018000)  /* threshold level of the MTL Transmit FIFO is 24 Bytes */
+  #define ETH_DMAOMR_TTC_16Bytes       ((uint32_t)0x0001C000)  /* threshold level of the MTL Transmit FIFO is 16 Bytes */
+#define ETH_DMAOMR_ST        ((uint32_t)0x00002000)  /* Start/stop transmission command */
+#define ETH_DMAOMR_FEF       ((uint32_t)0x00000080)  /* Forward error frames */
+#define ETH_DMAOMR_FUGF      ((uint32_t)0x00000040)  /* Forward undersized good frames */
+#define ETH_DMAOMR_RTC       ((uint32_t)0x00000018)  /* receive threshold control */
+  #define ETH_DMAOMR_RTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Receive FIFO is 64 Bytes */
+  #define ETH_DMAOMR_RTC_32Bytes       ((uint32_t)0x00000008)  /* threshold level of the MTL Receive FIFO is 32 Bytes */
+  #define ETH_DMAOMR_RTC_96Bytes       ((uint32_t)0x00000010)  /* threshold level of the MTL Receive FIFO is 96 Bytes */
+  #define ETH_DMAOMR_RTC_128Bytes      ((uint32_t)0x00000018)  /* threshold level of the MTL Receive FIFO is 128 Bytes */
+#define ETH_DMAOMR_OSF       ((uint32_t)0x00000004)  /* operate on second frame */
+#define ETH_DMAOMR_SR        ((uint32_t)0x00000002)  /* Start/stop receive */
+
+/* Bit definition for Ethernet DMA Interrupt Enable Register */
+#define ETH_DMAIER_NISE      ((uint32_t)0x00010000)  /* Normal interrupt summary enable */
+#define ETH_DMAIER_AISE      ((uint32_t)0x00008000)  /* Abnormal interrupt summary enable */
+#define ETH_DMAIER_ERIE      ((uint32_t)0x00004000)  /* Early receive interrupt enable */
+#define ETH_DMAIER_FBEIE     ((uint32_t)0x00002000)  /* Fatal bus error interrupt enable */
+#define ETH_DMAIER_ETIE      ((uint32_t)0x00000400)  /* Early transmit interrupt enable */
+#define ETH_DMAIER_RWTIE     ((uint32_t)0x00000200)  /* Receive watchdog timeout interrupt enable */
+#define ETH_DMAIER_RPSIE     ((uint32_t)0x00000100)  /* Receive process stopped interrupt enable */
+#define ETH_DMAIER_RBUIE     ((uint32_t)0x00000080)  /* Receive buffer unavailable interrupt enable */
+#define ETH_DMAIER_RIE       ((uint32_t)0x00000040)  /* Receive interrupt enable */
+#define ETH_DMAIER_TUIE      ((uint32_t)0x00000020)  /* Transmit Underflow interrupt enable */
+#define ETH_DMAIER_ROIE      ((uint32_t)0x00000010)  /* Receive Overflow interrupt enable */
+#define ETH_DMAIER_TJTIE     ((uint32_t)0x00000008)  /* Transmit jabber timeout interrupt enable */
+#define ETH_DMAIER_TBUIE     ((uint32_t)0x00000004)  /* Transmit buffer unavailable interrupt enable */
+#define ETH_DMAIER_TPSIE     ((uint32_t)0x00000002)  /* Transmit process stopped interrupt enable */
+#define ETH_DMAIER_TIE       ((uint32_t)0x00000001)  /* Transmit interrupt enable */
+
+/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */
+#define ETH_DMAMFBOCR_OFOC   ((uint32_t)0x10000000)  /* Overflow bit for FIFO overflow counter */
+#define ETH_DMAMFBOCR_MFA    ((uint32_t)0x0FFE0000)  /* Number of frames missed by the application */
+#define ETH_DMAMFBOCR_OMFC   ((uint32_t)0x00010000)  /* Overflow bit for missed frame counter */
+#define ETH_DMAMFBOCR_MFC    ((uint32_t)0x0000FFFF)  /* Number of frames missed by the controller */
+
+/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */
+#define ETH_DMACHTDR_HTDAP   ((uint32_t)0xFFFFFFFF)  /* Host transmit descriptor address pointer */
+
+/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */
+#define ETH_DMACHRDR_HRDAP   ((uint32_t)0xFFFFFFFF)  /* Host receive descriptor address pointer */
+
+/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */
+#define ETH_DMACHTBAR_HTBAP  ((uint32_t)0xFFFFFFFF)  /* Host transmit buffer address pointer */
+
+/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */
+#define ETH_DMACHRBAR_HRBAP  ((uint32_t)0xFFFFFFFF)  /* Host receive buffer address pointer */
+
+/**
+  *
+  */
+
+ /**
+  * @}
+  */ 
+
+#ifdef USE_STDPERIPH_DRIVER
+  #include "stm32f4xx_conf.h"
+#endif /* USE_STDPERIPH_DRIVER */
+
+/** @addtogroup Exported_macro
+  * @{
+  */
+
+#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
+
+#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
+
+#define READ_BIT(REG, BIT)    ((REG) & (BIT))
+
+#define CLEAR_REG(REG)        ((REG) = (0x0))
+
+#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
+
+#define READ_REG(REG)         ((REG))
+
+#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
+
+/**
+  * @}
+  */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __STM32F4xx_H */
+
+/**
+  * @}
+  */
+
+  /**
+  * @}
+  */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/USER/stm32f4xx_conf.h b/stm32f407zg/uniproton/board/USER/stm32f4xx_conf.h
new file mode 100644
index 0000000..1f5f804
--- /dev/null
+++ b/stm32f407zg/uniproton/board/USER/stm32f4xx_conf.h
@@ -0,0 +1,125 @@
+/**
+  ******************************************************************************
+  * @file    Project/STM32F4xx_StdPeriph_Templates/stm32f4xx_conf.h  
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   Library configuration file.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_CONF_H
+#define __STM32F4xx_CONF_H
+
+/* Includes ------------------------------------------------------------------*/
+/* Uncomment the line below to enable peripheral header file inclusion */
+#include "stm32f4xx_adc.h"
+#include "stm32f4xx_crc.h"
+#include "stm32f4xx_dbgmcu.h"
+#include "stm32f4xx_dma.h"
+#include "stm32f4xx_exti.h"
+#include "stm32f4xx_flash.h"
+#include "stm32f4xx_gpio.h"
+#include "stm32f4xx_i2c.h"
+#include "stm32f4xx_iwdg.h"
+#include "stm32f4xx_pwr.h"
+#include "stm32f4xx_rcc.h"
+#include "stm32f4xx_rtc.h"
+#include "stm32f4xx_sdio.h"
+#include "stm32f4xx_spi.h"
+#include "stm32f4xx_syscfg.h"
+#include "stm32f4xx_tim.h"
+#include "stm32f4xx_usart.h"
+#include "stm32f4xx_wwdg.h"
+#include "misc.h" /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */
+
+#if defined (STM32F429_439xx)
+#include "stm32f4xx_cryp.h"
+#include "stm32f4xx_hash.h"
+#include "stm32f4xx_rng.h"
+#include "stm32f4xx_can.h"
+#include "stm32f4xx_dac.h"
+#include "stm32f4xx_dcmi.h"
+#include "stm32f4xx_dma2d.h"
+#include "stm32f4xx_fmc.h"
+#include "stm32f4xx_ltdc.h"
+#include "stm32f4xx_sai.h"
+#endif /* STM32F429_439xx */
+
+#if defined (STM32F427_437xx)
+#include "stm32f4xx_cryp.h"
+#include "stm32f4xx_hash.h"
+#include "stm32f4xx_rng.h"
+#include "stm32f4xx_can.h"
+#include "stm32f4xx_dac.h"
+#include "stm32f4xx_dcmi.h"
+#include "stm32f4xx_dma2d.h"
+#include "stm32f4xx_fmc.h"
+#include "stm32f4xx_sai.h"
+#endif /* STM32F427_437xx */
+
+#if defined (STM32F40_41xxx)
+#include "stm32f4xx_cryp.h"
+#include "stm32f4xx_hash.h"
+#include "stm32f4xx_rng.h"
+#include "stm32f4xx_can.h"
+#include "stm32f4xx_dac.h"
+#include "stm32f4xx_dcmi.h"
+#include "stm32f4xx_fsmc.h"
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F411xE)
+#include "stm32f4xx_flash_ramfunc.h"
+#endif /* STM32F411xE */
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+
+/* If an external clock source is used, then the value of the following define 
+   should be set to the value of the external clock source, else, if no external 
+   clock is used, keep this define commented */
+/*#define I2S_EXTERNAL_CLOCK_VAL   12288000 */ /* Value of the external clock in Hz */
+
+
+/* Uncomment the line below to expanse the "assert_param" macro in the 
+   Standard Peripheral Library drivers code */
+/* #define USE_FULL_ASSERT    1 */
+
+/* Exported macro ------------------------------------------------------------*/
+#ifdef  USE_FULL_ASSERT
+
+/**
+  * @brief  The assert_param macro is used for function's parameters check.
+  * @param  expr: If expr is false, it calls assert_failed function
+  *   which reports the name of the source file and the source
+  *   line number of the call that failed. 
+  *   If expr is true, it returns no value.
+  * @retval None
+  */
+  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+/* Exported functions ------------------------------------------------------- */
+  void assert_failed(uint8_t* file, uint32_t line);
+#else
+  #define assert_param(expr) ((void)0)
+#endif /* USE_FULL_ASSERT */
+
+#endif /* __STM32F4xx_CONF_H */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/USER/stm32f4xx_it.c b/stm32f407zg/uniproton/board/USER/stm32f4xx_it.c
new file mode 100644
index 0000000..16b3301
--- /dev/null
+++ b/stm32f407zg/uniproton/board/USER/stm32f4xx_it.c
@@ -0,0 +1,168 @@
+/**
+  ******************************************************************************
+  * @file    Project/STM32F4xx_StdPeriph_Templates/stm32f4xx_it.c 
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   Main Interrupt Service Routines.
+  *          This file provides template for all exceptions handler and 
+  *          peripherals interrupt service routine.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx_it.h"
+ 
+
+/** @addtogroup Template_Project
+  * @{
+  */
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/******************************************************************************/
+/*            Cortex-M4 Processor Exceptions Handlers                         */
+/******************************************************************************/
+
+/**
+  * @brief  This function handles NMI exception.
+  * @param  None
+  * @retval None
+  */
+void NMI_Handler(void)
+{
+}
+
+/**
+  * @brief  This function handles Hard Fault exception.
+  * @param  None
+  * @retval None
+  */
+void HardFault_Handler(void)
+{
+  /* Go to infinite loop when Hard Fault exception occurs */
+  while (1)
+  {
+  }
+}
+
+/**
+  * @brief  This function handles Memory Manage exception.
+  * @param  None
+  * @retval None
+  */
+void MemManage_Handler(void)
+{
+  /* Go to infinite loop when Memory Manage exception occurs */
+  while (1)
+  {
+  }
+}
+
+/**
+  * @brief  This function handles Bus Fault exception.
+  * @param  None
+  * @retval None
+  */
+void BusFault_Handler(void)
+{
+  /* Go to infinite loop when Bus Fault exception occurs */
+  while (1)
+  {
+  }
+}
+
+/**
+  * @brief  This function handles Usage Fault exception.
+  * @param  None
+  * @retval None
+  */
+void UsageFault_Handler(void)
+{
+  /* Go to infinite loop when Usage Fault exception occurs */
+  while (1)
+  {
+  }
+}
+
+/**
+  * @brief  This function handles SVCall exception.
+  * @param  None
+  * @retval None
+  */
+void SVC_Handler(void)
+{
+}
+
+/**
+  * @brief  This function handles Debug Monitor exception.
+  * @param  None
+  * @retval None
+  */
+void DebugMon_Handler(void)
+{
+}
+
+/**
+  * @brief  This function handles PendSVC exception.
+  * @param  None
+  * @retval None
+  */
+void PendSV_Handler(void)
+{
+}
+
+/**
+  * @brief  This function handles SysTick Handler.
+  * @param  None
+  * @retval None
+  */
+void SysTick_Handler(void)
+{
+ 
+}
+
+/******************************************************************************/
+/*                 STM32F4xx Peripherals Interrupt Handlers                   */
+/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
+/*  available peripheral interrupt handler's name please refer to the startup */
+/*  file (startup_stm32f4xx.s).                                               */
+/******************************************************************************/
+
+/**
+  * @brief  This function handles PPP interrupt request.
+  * @param  None
+  * @retval None
+  */
+/*void PPP_IRQHandler(void)
+{
+}*/
+
+/**
+  * @}
+  */ 
+
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/USER/stm32f4xx_it.h b/stm32f407zg/uniproton/board/USER/stm32f4xx_it.h
new file mode 100644
index 0000000..cde0901
--- /dev/null
+++ b/stm32f407zg/uniproton/board/USER/stm32f4xx_it.h
@@ -0,0 +1,60 @@
+/**
+  ******************************************************************************
+  * @file    Project/STM32F4xx_StdPeriph_Templates/stm32f4xx_it.h 
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   This file contains the headers of the interrupt handlers.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F4xx_IT_H
+#define __STM32F4xx_IT_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif 
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f4xx.h"
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions ------------------------------------------------------- */
+
+void NMI_Handler(void);
+void HardFault_Handler(void);
+void MemManage_Handler(void);
+void BusFault_Handler(void);
+void UsageFault_Handler(void);
+void SVC_Handler(void);
+void DebugMon_Handler(void);
+void PendSV_Handler(void);
+void SysTick_Handler(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F4xx_IT_H */
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/USER/system_stm32f4xx.c b/stm32f407zg/uniproton/board/USER/system_stm32f4xx.c
new file mode 100644
index 0000000..eaceabf
--- /dev/null
+++ b/stm32f407zg/uniproton/board/USER/system_stm32f4xx.c
@@ -0,0 +1,1130 @@
+/**
+  ******************************************************************************
+  * @file    system_stm32f4xx.c
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer System Source File.
+  *          This file contains the system clock configuration for STM32F4xx devices.
+  *             
+  * 1.  This file provides two functions and one global variable to be called from 
+  *     user application:
+  *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
+  *                      and Divider factors, AHB/APBx prescalers and Flash settings),
+  *                      depending on the configuration made in the clock xls tool. 
+  *                      This function is called at startup just after reset and 
+  *                      before branch to main program. This call is made inside
+  *                      the "startup_stm32f4xx.s" file.
+  *
+  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
+  *                                  by the user application to setup the SysTick 
+  *                                  timer or configure other parameters.
+  *                                     
+  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
+  *                                 be called whenever the core clock is changed
+  *                                 during program execution.
+  *
+  * 2. After each device reset the HSI (16 MHz) is used as system clock source.
+  *    Then SystemInit() function is called, in "startup_stm32f4xx.s" file, to
+  *    configure the system clock before to branch to main program.
+  *
+  * 3. If the system clock source selected by user fails to startup, the SystemInit()
+  *    function will do nothing and HSI still used as system clock source. User can 
+  *    add some code to deal with this issue inside the SetSysClock() function.
+  *
+  * 4. The default value of HSE crystal is set to 25MHz, refer to "HSE_VALUE" define
+  *    in "stm32f4xx.h" file. When HSE is used as system clock source, directly or
+  *    through PLL, and you are using different crystal you have to adapt the HSE
+  *    value to your own configuration.
+  *
+  * 5. This file configures the system clock as follows:
+  *=============================================================================
+  *=============================================================================
+  *                    Supported STM32F40xxx/41xxx devices
+  *-----------------------------------------------------------------------------
+  *        System Clock source                    | PLL (HSE)
+  *-----------------------------------------------------------------------------
+  *        SYSCLK(Hz)                             | 168000000
+  *-----------------------------------------------------------------------------
+  *        HCLK(Hz)                               | 168000000
+  *-----------------------------------------------------------------------------
+  *        AHB Prescaler                          | 1
+  *-----------------------------------------------------------------------------
+  *        APB1 Prescaler                         | 4
+  *-----------------------------------------------------------------------------
+  *        APB2 Prescaler                         | 2
+  *-----------------------------------------------------------------------------
+  *        HSE Frequency(Hz)                      | 25000000
+  *-----------------------------------------------------------------------------
+  *        PLL_M                                  | 25
+  *-----------------------------------------------------------------------------
+  *        PLL_N                                  | 336
+  *-----------------------------------------------------------------------------
+  *        PLL_P                                  | 2
+  *-----------------------------------------------------------------------------
+  *        PLL_Q                                  | 7
+  *-----------------------------------------------------------------------------
+  *        PLLI2S_N                               | NA
+  *-----------------------------------------------------------------------------
+  *        PLLI2S_R                               | NA
+  *-----------------------------------------------------------------------------
+  *        I2S input clock                        | NA
+  *-----------------------------------------------------------------------------
+  *        VDD(V)                                 | 3.3
+  *-----------------------------------------------------------------------------
+  *        Main regulator output voltage          | Scale1 mode
+  *-----------------------------------------------------------------------------
+  *        Flash Latency(WS)                      | 5
+  *-----------------------------------------------------------------------------
+  *        Prefetch Buffer                        | ON
+  *-----------------------------------------------------------------------------
+  *        Instruction cache                      | ON
+  *-----------------------------------------------------------------------------
+  *        Data cache                             | ON
+  *-----------------------------------------------------------------------------
+  *        Require 48MHz for USB OTG FS,          | Disabled
+  *        SDIO and RNG clock                     |
+  *-----------------------------------------------------------------------------
+  *=============================================================================
+  *=============================================================================
+  *                    Supported STM32F42xxx/43xxx devices
+  *-----------------------------------------------------------------------------
+  *        System Clock source                    | PLL (HSE)
+  *-----------------------------------------------------------------------------
+  *        SYSCLK(Hz)                             | 180000000
+  *-----------------------------------------------------------------------------
+  *        HCLK(Hz)                               | 180000000
+  *-----------------------------------------------------------------------------
+  *        AHB Prescaler                          | 1
+  *-----------------------------------------------------------------------------
+  *        APB1 Prescaler                         | 4
+  *-----------------------------------------------------------------------------
+  *        APB2 Prescaler                         | 2
+  *-----------------------------------------------------------------------------
+  *        HSE Frequency(Hz)                      | 25000000
+  *-----------------------------------------------------------------------------
+  *        PLL_M                                  | 25
+  *-----------------------------------------------------------------------------
+  *        PLL_N                                  | 360
+  *-----------------------------------------------------------------------------
+  *        PLL_P                                  | 2
+  *-----------------------------------------------------------------------------
+  *        PLL_Q                                  | 7
+  *-----------------------------------------------------------------------------
+  *        PLLI2S_N                               | NA
+  *-----------------------------------------------------------------------------
+  *        PLLI2S_R                               | NA
+  *-----------------------------------------------------------------------------
+  *        I2S input clock                        | NA
+  *-----------------------------------------------------------------------------
+  *        VDD(V)                                 | 3.3
+  *-----------------------------------------------------------------------------
+  *        Main regulator output voltage          | Scale1 mode
+  *-----------------------------------------------------------------------------
+  *        Flash Latency(WS)                      | 5
+  *-----------------------------------------------------------------------------
+  *        Prefetch Buffer                        | ON
+  *-----------------------------------------------------------------------------
+  *        Instruction cache                      | ON
+  *-----------------------------------------------------------------------------
+  *        Data cache                             | ON
+  *-----------------------------------------------------------------------------
+  *        Require 48MHz for USB OTG FS,          | Disabled
+  *        SDIO and RNG clock                     |
+  *-----------------------------------------------------------------------------
+  *=============================================================================
+  *=============================================================================
+  *                         Supported STM32F401xx devices
+  *-----------------------------------------------------------------------------
+  *        System Clock source                    | PLL (HSE)
+  *-----------------------------------------------------------------------------
+  *        SYSCLK(Hz)                             | 84000000
+  *-----------------------------------------------------------------------------
+  *        HCLK(Hz)                               | 84000000
+  *-----------------------------------------------------------------------------
+  *        AHB Prescaler                          | 1
+  *-----------------------------------------------------------------------------
+  *        APB1 Prescaler                         | 2
+  *-----------------------------------------------------------------------------
+  *        APB2 Prescaler                         | 1
+  *-----------------------------------------------------------------------------
+  *        HSE Frequency(Hz)                      | 25000000
+  *-----------------------------------------------------------------------------
+  *        PLL_M                                  | 25
+  *-----------------------------------------------------------------------------
+  *        PLL_N                                  | 336
+  *-----------------------------------------------------------------------------
+  *        PLL_P                                  | 4
+  *-----------------------------------------------------------------------------
+  *        PLL_Q                                  | 7
+  *-----------------------------------------------------------------------------
+  *        PLLI2S_N                               | NA
+  *-----------------------------------------------------------------------------
+  *        PLLI2S_R                               | NA
+  *-----------------------------------------------------------------------------
+  *        I2S input clock                        | NA
+  *-----------------------------------------------------------------------------
+  *        VDD(V)                                 | 3.3
+  *-----------------------------------------------------------------------------
+  *        Main regulator output voltage          | Scale1 mode
+  *-----------------------------------------------------------------------------
+  *        Flash Latency(WS)                      | 2
+  *-----------------------------------------------------------------------------
+  *        Prefetch Buffer                        | ON
+  *-----------------------------------------------------------------------------
+  *        Instruction cache                      | ON
+  *-----------------------------------------------------------------------------
+  *        Data cache                             | ON
+  *-----------------------------------------------------------------------------
+  *        Require 48MHz for USB OTG FS,          | Disabled
+  *        SDIO and RNG clock                     |
+  *-----------------------------------------------------------------------------
+  *=============================================================================
+  *=============================================================================
+  *                         Supported STM32F411xx devices
+  *-----------------------------------------------------------------------------
+  *        System Clock source                    | PLL (HSI)
+  *-----------------------------------------------------------------------------
+  *        SYSCLK(Hz)                             | 100000000
+  *-----------------------------------------------------------------------------
+  *        HCLK(Hz)                               | 100000000
+  *-----------------------------------------------------------------------------
+  *        AHB Prescaler                          | 1
+  *-----------------------------------------------------------------------------
+  *        APB1 Prescaler                         | 2
+  *-----------------------------------------------------------------------------
+  *        APB2 Prescaler                         | 1
+  *-----------------------------------------------------------------------------
+  *        HSI Frequency(Hz)                      | 16000000
+  *-----------------------------------------------------------------------------
+  *        PLL_M                                  | 16
+  *-----------------------------------------------------------------------------
+  *        PLL_N                                  | 400
+  *-----------------------------------------------------------------------------
+  *        PLL_P                                  | 4
+  *-----------------------------------------------------------------------------
+  *        PLL_Q                                  | 7
+  *-----------------------------------------------------------------------------
+  *        PLLI2S_N                               | NA
+  *-----------------------------------------------------------------------------
+  *        PLLI2S_R                               | NA
+  *-----------------------------------------------------------------------------
+  *        I2S input clock                        | NA
+  *-----------------------------------------------------------------------------
+  *        VDD(V)                                 | 3.3
+  *-----------------------------------------------------------------------------
+  *        Main regulator output voltage          | Scale1 mode
+  *-----------------------------------------------------------------------------
+  *        Flash Latency(WS)                      | 3
+  *-----------------------------------------------------------------------------
+  *        Prefetch Buffer                        | ON
+  *-----------------------------------------------------------------------------
+  *        Instruction cache                      | ON
+  *-----------------------------------------------------------------------------
+  *        Data cache                             | ON
+  *-----------------------------------------------------------------------------
+  *        Require 48MHz for USB OTG FS,          | Disabled
+  *        SDIO and RNG clock                     |
+  *-----------------------------------------------------------------------------
+  *=============================================================================
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/** @addtogroup CMSIS
+  * @{
+  */
+
+/** @addtogroup stm32f4xx_system
+  * @{
+  */  
+  
+/** @addtogroup STM32F4xx_System_Private_Includes
+  * @{
+  */
+
+#include "stm32f4xx.h"
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F4xx_System_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F4xx_System_Private_Defines
+  * @{
+  */
+
+/************************* Miscellaneous Configuration ************************/
+/*!< Uncomment the following line if you need to use external SRAM or SDRAM mounted
+     on STM324xG_EVAL/STM324x7I_EVAL/STM324x9I_EVAL boards as data memory  */     
+#if defined (STM32F40_41xxx) || defined (STM32F427_437xx) || defined (STM32F429_439xx)
+/* #define DATA_IN_ExtSRAM */
+#endif /* STM32F40_41xxx || STM32F427_437x || STM32F429_439xx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+/* #define DATA_IN_ExtSDRAM */
+#endif /* STM32F427_437x || STM32F429_439xx */ 
+
+#if defined (STM32F411xE)    
+/*!< Uncomment the following line if you need to clock the STM32F411xE by HSE Bypass
+     through STLINK MCO pin of STM32F103 microcontroller. The frequency cannot be changed
+     and is fixed at 8 MHz. 
+     Hardware configuration needed for Nucleo Board:
+     ?SB54, SB55 OFF
+     ?R35 removed
+     ?SB16, SB50 ON */
+/* #define USE_HSE_BYPASS */
+
+#if defined (USE_HSE_BYPASS)     
+#define HSE_BYPASS_INPUT_FREQUENCY   8000000
+#endif /* USE_HSE_BYPASS */    
+#endif /* STM32F411xE */
+    
+/*!< Uncomment the following line if you need to relocate your vector Table in
+     Internal SRAM. */
+/* #define VECT_TAB_SRAM */
+#define VECT_TAB_OFFSET  0x00 /*!< Vector Table base offset field. 
+                                   This value must be a multiple of 0x200. */
+/******************************************************************************/
+
+/************************* PLL Parameters *************************************/
+#if defined (STM32F40_41xxx) || defined (STM32F427_437xx) || defined (STM32F429_439xx) || defined (STM32F401xx)
+/* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N */
+#define PLL_M      8
+#else /* STM32F411xE */
+#if defined (USE_HSE_BYPASS)
+#define PLL_M      8    
+#else /* STM32F411xE */   
+#define PLL_M      16
+#endif /* USE_HSE_BYPASS */
+#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx */  
+
+/* USB OTG FS, SDIO and RNG Clock =  PLL_VCO / PLLQ */
+#define PLL_Q      7
+
+#if defined (STM32F40_41xxx)
+#define PLL_N      336
+/* SYSCLK = PLL_VCO / PLL_P */
+#define PLL_P      2
+#endif /* STM32F40_41xxx */
+
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+#define PLL_N      360
+/* SYSCLK = PLL_VCO / PLL_P */
+#define PLL_P      2
+#endif /* STM32F427_437x || STM32F429_439xx */
+
+#if defined (STM32F401xx)
+#define PLL_N      336
+/* SYSCLK = PLL_VCO / PLL_P */
+#define PLL_P      4
+#endif /* STM32F401xx */
+
+#if defined (STM32F411xE)
+#define PLL_N      400
+/* SYSCLK = PLL_VCO / PLL_P */
+#define PLL_P      4   
+#endif /* STM32F411xx */
+
+/******************************************************************************/
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F4xx_System_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F4xx_System_Private_Variables
+  * @{
+  */
+
+#if defined (STM32F40_41xxx)
+  uint32_t SystemCoreClock = 168000000;
+#endif /* STM32F40_41xxx */
+
+// #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+//   uint32_t SystemCoreClock = 180000000;
+// #endif /* STM32F427_437x || STM32F429_439xx */
+
+// #if defined (STM32F401xx)
+//   uint32_t SystemCoreClock = 84000000;
+// #endif /* STM32F401xx */
+
+// #if defined (STM32F411xE)
+//   uint32_t SystemCoreClock = 100000000;
+// #endif /* STM32F401xx */
+
+__I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F4xx_System_Private_FunctionPrototypes
+  * @{
+  */
+
+static void SetSysClock(void);
+
+#if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
+static void SystemInit_ExtMemCtl(void); 
+#endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F4xx_System_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Setup the microcontroller system
+  *         Initialize the Embedded Flash Interface, the PLL and update the 
+  *         SystemFrequency variable.
+  * @param  None
+  * @retval None
+  */
+void SystemInit(void)
+{
+  /* FPU settings ------------------------------------------------------------*/
+  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
+  #endif
+  /* Reset the RCC clock configuration to the default reset state ------------*/
+  /* Set HSION bit */
+  RCC->CR |= (uint32_t)0x00000001;
+
+  /* Reset CFGR register */
+  RCC->CFGR = 0x00000000;
+
+  /* Reset HSEON, CSSON and PLLON bits */
+  RCC->CR &= (uint32_t)0xFEF6FFFF;
+
+  /* Reset PLLCFGR register */
+  RCC->PLLCFGR = 0x24003010;
+
+  /* Reset HSEBYP bit */
+  RCC->CR &= (uint32_t)0xFFFBFFFF;
+
+  /* Disable all interrupts */
+  RCC->CIR = 0x00000000;
+
+#if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
+  SystemInit_ExtMemCtl(); 
+#endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */
+         
+  /* Configure the System clock source, PLL Multiplier and Divider factors, 
+     AHB/APBx prescalers and Flash settings ----------------------------------*/
+  SetSysClock();
+
+  /* Configure the Vector Table location add offset address ------------------*/
+#ifdef VECT_TAB_SRAM
+  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
+#else
+  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
+#endif
+}
+
+/**
+   * @brief  Update SystemCoreClock variable according to Clock Register Values.
+  *         The SystemCoreClock variable contains the core clock (HCLK), it can
+  *         be used by the user application to setup the SysTick timer or configure
+  *         other parameters.
+  *           
+  * @note   Each time the core clock (HCLK) changes, this function must be called
+  *         to update SystemCoreClock variable value. Otherwise, any configuration
+  *         based on this variable will be incorrect.         
+  *     
+  * @note   - The system frequency computed by this function is not the real 
+  *           frequency in the chip. It is calculated based on the predefined 
+  *           constant and the selected clock source:
+  *             
+  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
+  *                                              
+  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
+  *                          
+  *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
+  *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
+  *         
+  *         (*) HSI_VALUE is a constant defined in stm32f4xx.h file (default value
+  *             16 MHz) but the real value may vary depending on the variations
+  *             in voltage and temperature.   
+  *    
+  *         (**) HSE_VALUE is a constant defined in stm32f4xx.h file (default value
+  *              25 MHz), user has to ensure that HSE_VALUE is same as the real
+  *              frequency of the crystal used. Otherwise, this function may
+  *              have wrong result.
+  *                
+  *         - The result of this function could be not correct when using fractional
+  *           value for HSE crystal.
+  *     
+  * @param  None
+  * @retval None
+  */
+void SystemCoreClockUpdate(void)
+{
+  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
+  
+  /* Get SYSCLK source -------------------------------------------------------*/
+  tmp = RCC->CFGR & RCC_CFGR_SWS;
+
+  switch (tmp)
+  {
+    case 0x00:  /* HSI used as system clock source */
+      SystemCoreClock = HSI_VALUE;
+      break;
+    case 0x04:  /* HSE used as system clock source */
+      SystemCoreClock = HSE_VALUE;
+      break;
+    case 0x08:  /* PLL used as system clock source */
+       /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
+         SYSCLK = PLL_VCO / PLL_P
+         */    
+      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
+      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
+      
+#if defined (STM32F40_41xxx) || defined (STM32F427_437xx) || defined (STM32F429_439xx) || defined (STM32F401xx)
+      if (pllsource != 0)
+      {
+        /* HSE used as PLL clock source */
+        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
+      }
+      else
+      {
+        /* HSI used as PLL clock source */
+        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
+      }
+#elif defined (STM32F411xE)
+#if defined (USE_HSE_BYPASS)
+      if (pllsource != 0)
+      {
+        /* HSE used as PLL clock source */
+        pllvco = (HSE_BYPASS_INPUT_FREQUENCY / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
+      }  
+#else  
+      if (pllsource == 0)
+      {
+        /* HSI used as PLL clock source */
+        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
+      }  
+#endif /* USE_HSE_BYPASS */  
+#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx */  
+      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
+      SystemCoreClock = pllvco/pllp;      
+      break;
+    default:
+      SystemCoreClock = HSI_VALUE;
+      break;
+  }
+  /* Compute HCLK frequency --------------------------------------------------*/
+  /* Get HCLK prescaler */
+  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
+  /* HCLK frequency */
+  SystemCoreClock >>= tmp;
+}
+
+/**
+  * @brief  Configures the System clock source, PLL Multiplier and Divider factors, 
+  *         AHB/APBx prescalers and Flash settings
+  * @Note   This function should be called only once the RCC clock configuration  
+  *         is reset to the default reset state (done in SystemInit() function).   
+  * @param  None
+  * @retval None
+  */
+static void SetSysClock(void)
+{
+#if defined (STM32F40_41xxx) || defined (STM32F427_437xx) || defined (STM32F429_439xx) || defined (STM32F401xx)
+/******************************************************************************/
+/*            PLL (clocked by HSE) used as System clock source                */
+/******************************************************************************/
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+  
+  /* Enable HSE */
+  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
+ 
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC->CR & RCC_CR_HSERDY;
+    StartUpCounter++;
+  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
+
+  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Select regulator voltage output Scale 1 mode */
+    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
+    PWR->CR |= PWR_CR_VOS;
+
+    /* HCLK = SYSCLK / 1*/
+    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
+
+#if defined (STM32F40_41xxx) || defined (STM32F427_437xx) || defined (STM32F429_439xx)      
+    /* PCLK2 = HCLK / 2*/
+    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
+    
+    /* PCLK1 = HCLK / 4*/
+    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
+#endif /* STM32F40_41xxx || STM32F427_437x || STM32F429_439xx */
+
+#if defined (STM32F401xx)
+    /* PCLK2 = HCLK / 2*/
+    RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;
+    
+    /* PCLK1 = HCLK / 4*/
+    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
+#endif /* STM32F401xx */
+   
+    /* Configure the main PLL */
+    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
+                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);
+
+    /* Enable the main PLL */
+    RCC->CR |= RCC_CR_PLLON;
+
+    /* Wait till the main PLL is ready */
+    while((RCC->CR & RCC_CR_PLLRDY) == 0)
+    {
+    }
+   
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+    /* Enable the Over-drive to extend the clock frequency to 180 Mhz */
+    PWR->CR |= PWR_CR_ODEN;
+    while((PWR->CSR & PWR_CSR_ODRDY) == 0)
+    {
+    }
+    PWR->CR |= PWR_CR_ODSWEN;
+    while((PWR->CSR & PWR_CSR_ODSWRDY) == 0)
+    {
+    }      
+    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
+    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
+#endif /* STM32F427_437x || STM32F429_439xx  */
+
+#if defined (STM32F40_41xxx)     
+    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
+    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
+#endif /* STM32F40_41xxx  */
+
+#if defined (STM32F401xx)
+    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
+    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_2WS;
+#endif /* STM32F401xx */
+
+    /* Select the main PLL as system clock source */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC->CFGR |= RCC_CFGR_SW_PLL;
+
+    /* Wait till the main PLL is used as system clock source */
+    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock
+         configuration. User can add here some code to deal with this error */
+  }
+#elif defined (STM32F411xE)
+#if defined (USE_HSE_BYPASS) 
+/******************************************************************************/
+/*            PLL (clocked by HSE) used as System clock source                */
+/******************************************************************************/
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+  
+  /* Enable HSE and HSE BYPASS */
+  RCC->CR |= ((uint32_t)RCC_CR_HSEON | RCC_CR_HSEBYP);
+ 
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC->CR & RCC_CR_HSERDY;
+    StartUpCounter++;
+  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
+
+  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Select regulator voltage output Scale 1 mode */
+    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
+    PWR->CR |= PWR_CR_VOS;
+
+    /* HCLK = SYSCLK / 1*/
+    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
+
+    /* PCLK2 = HCLK / 2*/
+    RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;
+    
+    /* PCLK1 = HCLK / 4*/
+    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
+
+    /* Configure the main PLL */
+    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
+                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);
+    
+    /* Enable the main PLL */
+    RCC->CR |= RCC_CR_PLLON;
+
+    /* Wait till the main PLL is ready */
+    while((RCC->CR & RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
+    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_2WS;
+
+    /* Select the main PLL as system clock source */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC->CFGR |= RCC_CFGR_SW_PLL;
+
+    /* Wait till the main PLL is used as system clock source */
+    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock
+         configuration. User can add here some code to deal with this error */
+  }
+#else /* HSI will be used as PLL clock source */
+  /* Select regulator voltage output Scale 1 mode */
+  RCC->APB1ENR |= RCC_APB1ENR_PWREN;
+  PWR->CR |= PWR_CR_VOS;
+  
+  /* HCLK = SYSCLK / 1*/
+  RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
+  
+  /* PCLK2 = HCLK / 2*/
+  RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;
+  
+  /* PCLK1 = HCLK / 4*/
+  RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
+  
+  /* Configure the main PLL */
+  RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) | (PLL_Q << 24); 
+  
+  /* Enable the main PLL */
+  RCC->CR |= RCC_CR_PLLON;
+  
+  /* Wait till the main PLL is ready */
+  while((RCC->CR & RCC_CR_PLLRDY) == 0)
+  {
+  }
+  
+  /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
+  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_2WS;
+  
+  /* Select the main PLL as system clock source */
+  RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+  RCC->CFGR |= RCC_CFGR_SW_PLL;
+  
+  /* Wait till the main PLL is used as system clock source */
+  while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
+  {
+  }
+#endif /* USE_HSE_BYPASS */  
+#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx */  
+}
+
+/**
+  * @brief  Setup the external memory controller. Called in startup_stm32f4xx.s 
+  *          before jump to __main
+  * @param  None
+  * @retval None
+  */ 
+#ifdef DATA_IN_ExtSRAM
+/**
+  * @brief  Setup the external memory controller.
+  *         Called in startup_stm32f4xx.s before jump to main.
+  *         This function configures the external SRAM mounted on STM324xG_EVAL/STM324x7I boards
+  *         This SRAM will be used as program data memory (including heap and stack).
+  * @param  None
+  * @retval None
+  */
+void SystemInit_ExtMemCtl(void)
+{
+/*-- GPIOs Configuration -----------------------------------------------------*/
+/*
+ +-------------------+--------------------+------------------+--------------+
+ +                       SRAM pins assignment                               +
+ +-------------------+--------------------+------------------+--------------+
+ | PD0  <-> FMC_D2  | PE0  <-> FMC_NBL0 | PF0  <-> FMC_A0 | PG0 <-> FMC_A10 | 
+ | PD1  <-> FMC_D3  | PE1  <-> FMC_NBL1 | PF1  <-> FMC_A1 | PG1 <-> FMC_A11 | 
+ | PD4  <-> FMC_NOE | PE3  <-> FMC_A19  | PF2  <-> FMC_A2 | PG2 <-> FMC_A12 | 
+ | PD5  <-> FMC_NWE | PE4  <-> FMC_A20  | PF3  <-> FMC_A3 | PG3 <-> FMC_A13 | 
+ | PD8  <-> FMC_D13 | PE7  <-> FMC_D4   | PF4  <-> FMC_A4 | PG4 <-> FMC_A14 | 
+ | PD9  <-> FMC_D14 | PE8  <-> FMC_D5   | PF5  <-> FMC_A5 | PG5 <-> FMC_A15 | 
+ | PD10 <-> FMC_D15 | PE9  <-> FMC_D6   | PF12 <-> FMC_A6 | PG9 <-> FMC_NE2 | 
+ | PD11 <-> FMC_A16 | PE10 <-> FMC_D7   | PF13 <-> FMC_A7 |-----------------+
+ | PD12 <-> FMC_A17 | PE11 <-> FMC_D8   | PF14 <-> FMC_A8 | 
+ | PD13 <-> FMC_A18 | PE12 <-> FMC_D9   | PF15 <-> FMC_A9 | 
+ | PD14 <-> FMC_D0  | PE13 <-> FMC_D10  |-----------------+
+ | PD15 <-> FMC_D1  | PE14 <-> FMC_D11  |
+ |                  | PE15 <-> FMC_D12  |
+ +------------------+------------------+
+*/
+   /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */
+  RCC->AHB1ENR   |= 0x00000078;
+  
+  /* Connect PDx pins to FMC Alternate function */
+  GPIOD->AFR[0]  = 0x00cc00cc;
+  GPIOD->AFR[1]  = 0xcccccccc;
+  /* Configure PDx pins in Alternate function mode */  
+  GPIOD->MODER   = 0xaaaa0a0a;
+  /* Configure PDx pins speed to 100 MHz */  
+  GPIOD->OSPEEDR = 0xffff0f0f;
+  /* Configure PDx pins Output type to push-pull */  
+  GPIOD->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PDx pins */ 
+  GPIOD->PUPDR   = 0x00000000;
+
+  /* Connect PEx pins to FMC Alternate function */
+  GPIOE->AFR[0]  = 0xcccccccc;
+  GPIOE->AFR[1]  = 0xcccccccc;
+  /* Configure PEx pins in Alternate function mode */ 
+  GPIOE->MODER   = 0xaaaaaaaa;
+  /* Configure PEx pins speed to 100 MHz */ 
+  GPIOE->OSPEEDR = 0xffffffff;
+  /* Configure PEx pins Output type to push-pull */  
+  GPIOE->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PEx pins */ 
+  GPIOE->PUPDR   = 0x00000000;
+
+  /* Connect PFx pins to FMC Alternate function */
+  GPIOF->AFR[0]  = 0x00cccccc;
+  GPIOF->AFR[1]  = 0xcccc0000;
+  /* Configure PFx pins in Alternate function mode */   
+  GPIOF->MODER   = 0xaa000aaa;
+  /* Configure PFx pins speed to 100 MHz */ 
+  GPIOF->OSPEEDR = 0xff000fff;
+  /* Configure PFx pins Output type to push-pull */  
+  GPIOF->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PFx pins */ 
+  GPIOF->PUPDR   = 0x00000000;
+
+  /* Connect PGx pins to FMC Alternate function */
+  GPIOG->AFR[0]  = 0x00cccccc;
+  GPIOG->AFR[1]  = 0x000000c0;
+  /* Configure PGx pins in Alternate function mode */ 
+  GPIOG->MODER   = 0x00080aaa;
+  /* Configure PGx pins speed to 100 MHz */ 
+  GPIOG->OSPEEDR = 0x000c0fff;
+  /* Configure PGx pins Output type to push-pull */  
+  GPIOG->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PGx pins */ 
+  GPIOG->PUPDR   = 0x00000000;
+  
+/*-- FMC Configuration ------------------------------------------------------*/
+  /* Enable the FMC/FSMC interface clock */
+  RCC->AHB3ENR         |= 0x00000001;
+  
+#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
+  /* Configure and enable Bank1_SRAM2 */
+  FMC_Bank1->BTCR[2]  = 0x00001011;
+  FMC_Bank1->BTCR[3]  = 0x00000201;
+  FMC_Bank1E->BWTR[2] = 0x0fffffff;
+#endif /* STM32F427_437xx || STM32F429_439xx */ 
+
+#if defined (STM32F40_41xxx)
+  /* Configure and enable Bank1_SRAM2 */
+  FSMC_Bank1->BTCR[2]  = 0x00001011;
+  FSMC_Bank1->BTCR[3]  = 0x00000201;
+  FSMC_Bank1E->BWTR[2] = 0x0fffffff;
+#endif  /* STM32F40_41xxx */
+
+/*
+  Bank1_SRAM2 is configured as follow:
+  In case of FSMC configuration 
+  NORSRAMTimingStructure.FSMC_AddressSetupTime = 1;
+  NORSRAMTimingStructure.FSMC_AddressHoldTime = 0;
+  NORSRAMTimingStructure.FSMC_DataSetupTime = 2;
+  NORSRAMTimingStructure.FSMC_BusTurnAroundDuration = 0;
+  NORSRAMTimingStructure.FSMC_CLKDivision = 0;
+  NORSRAMTimingStructure.FSMC_DataLatency = 0;
+  NORSRAMTimingStructure.FSMC_AccessMode = FMC_AccessMode_A;
+
+  FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM2;
+  FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
+  FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;
+  FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
+  FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
+  FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;  
+  FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
+  FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
+  FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
+  FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
+  FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
+  FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
+  FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
+  FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &NORSRAMTimingStructure;
+  FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &NORSRAMTimingStructure;
+
+  In case of FMC configuration   
+  NORSRAMTimingStructure.FMC_AddressSetupTime = 1;
+  NORSRAMTimingStructure.FMC_AddressHoldTime = 0;
+  NORSRAMTimingStructure.FMC_DataSetupTime = 2;
+  NORSRAMTimingStructure.FMC_BusTurnAroundDuration = 0;
+  NORSRAMTimingStructure.FMC_CLKDivision = 0;
+  NORSRAMTimingStructure.FMC_DataLatency = 0;
+  NORSRAMTimingStructure.FMC_AccessMode = FMC_AccessMode_A;
+
+  FMC_NORSRAMInitStructure.FMC_Bank = FMC_Bank1_NORSRAM2;
+  FMC_NORSRAMInitStructure.FMC_DataAddressMux = FMC_DataAddressMux_Disable;
+  FMC_NORSRAMInitStructure.FMC_MemoryType = FMC_MemoryType_SRAM;
+  FMC_NORSRAMInitStructure.FMC_MemoryDataWidth = FMC_MemoryDataWidth_16b;
+  FMC_NORSRAMInitStructure.FMC_BurstAccessMode = FMC_BurstAccessMode_Disable;
+  FMC_NORSRAMInitStructure.FMC_AsynchronousWait = FMC_AsynchronousWait_Disable;  
+  FMC_NORSRAMInitStructure.FMC_WaitSignalPolarity = FMC_WaitSignalPolarity_Low;
+  FMC_NORSRAMInitStructure.FMC_WrapMode = FMC_WrapMode_Disable;
+  FMC_NORSRAMInitStructure.FMC_WaitSignalActive = FMC_WaitSignalActive_BeforeWaitState;
+  FMC_NORSRAMInitStructure.FMC_WriteOperation = FMC_WriteOperation_Enable;
+  FMC_NORSRAMInitStructure.FMC_WaitSignal = FMC_WaitSignal_Disable;
+  FMC_NORSRAMInitStructure.FMC_ExtendedMode = FMC_ExtendedMode_Disable;
+  FMC_NORSRAMInitStructure.FMC_WriteBurst = FMC_WriteBurst_Disable;
+  FMC_NORSRAMInitStructure.FMC_ContinousClock = FMC_CClock_SyncOnly;
+  FMC_NORSRAMInitStructure.FMC_ReadWriteTimingStruct = &NORSRAMTimingStructure;
+  FMC_NORSRAMInitStructure.FMC_WriteTimingStruct = &NORSRAMTimingStructure;
+*/
+  
+}
+#endif /* DATA_IN_ExtSRAM */
+  
+#ifdef DATA_IN_ExtSDRAM
+/**
+  * @brief  Setup the external memory controller.
+  *         Called in startup_stm32f4xx.s before jump to main.
+  *         This function configures the external SDRAM mounted on STM324x9I_EVAL board
+  *         This SDRAM will be used as program data memory (including heap and stack).
+  * @param  None
+  * @retval None
+  */
+void SystemInit_ExtMemCtl(void)
+{
+  register uint32_t tmpreg = 0, timeout = 0xFFFF;
+  register uint32_t index;
+
+  /* Enable GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH and GPIOI interface 
+      clock */
+  RCC->AHB1ENR |= 0x000001FC;
+  
+  /* Connect PCx pins to FMC Alternate function */
+  GPIOC->AFR[0]  = 0x0000000c;
+  GPIOC->AFR[1]  = 0x00007700;
+  /* Configure PCx pins in Alternate function mode */  
+  GPIOC->MODER   = 0x00a00002;
+  /* Configure PCx pins speed to 50 MHz */  
+  GPIOC->OSPEEDR = 0x00a00002;
+  /* Configure PCx pins Output type to push-pull */  
+  GPIOC->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PCx pins */ 
+  GPIOC->PUPDR   = 0x00500000;
+  
+  /* Connect PDx pins to FMC Alternate function */
+  GPIOD->AFR[0]  = 0x000000CC;
+  GPIOD->AFR[1]  = 0xCC000CCC;
+  /* Configure PDx pins in Alternate function mode */  
+  GPIOD->MODER   = 0xA02A000A;
+  /* Configure PDx pins speed to 50 MHz */  
+  GPIOD->OSPEEDR = 0xA02A000A;
+  /* Configure PDx pins Output type to push-pull */  
+  GPIOD->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PDx pins */ 
+  GPIOD->PUPDR   = 0x00000000;
+
+  /* Connect PEx pins to FMC Alternate function */
+  GPIOE->AFR[0]  = 0xC00000CC;
+  GPIOE->AFR[1]  = 0xCCCCCCCC;
+  /* Configure PEx pins in Alternate function mode */ 
+  GPIOE->MODER   = 0xAAAA800A;
+  /* Configure PEx pins speed to 50 MHz */ 
+  GPIOE->OSPEEDR = 0xAAAA800A;
+  /* Configure PEx pins Output type to push-pull */  
+  GPIOE->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PEx pins */ 
+  GPIOE->PUPDR   = 0x00000000;
+
+  /* Connect PFx pins to FMC Alternate function */
+  GPIOF->AFR[0]  = 0xcccccccc;
+  GPIOF->AFR[1]  = 0xcccccccc;
+  /* Configure PFx pins in Alternate function mode */   
+  GPIOF->MODER   = 0xAA800AAA;
+  /* Configure PFx pins speed to 50 MHz */ 
+  GPIOF->OSPEEDR = 0xAA800AAA;
+  /* Configure PFx pins Output type to push-pull */  
+  GPIOF->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PFx pins */ 
+  GPIOF->PUPDR   = 0x00000000;
+
+  /* Connect PGx pins to FMC Alternate function */
+  GPIOG->AFR[0]  = 0xcccccccc;
+  GPIOG->AFR[1]  = 0xcccccccc;
+  /* Configure PGx pins in Alternate function mode */ 
+  GPIOG->MODER   = 0xaaaaaaaa;
+  /* Configure PGx pins speed to 50 MHz */ 
+  GPIOG->OSPEEDR = 0xaaaaaaaa;
+  /* Configure PGx pins Output type to push-pull */  
+  GPIOG->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PGx pins */ 
+  GPIOG->PUPDR   = 0x00000000;
+  
+  /* Connect PHx pins to FMC Alternate function */
+  GPIOH->AFR[0]  = 0x00C0CC00;
+  GPIOH->AFR[1]  = 0xCCCCCCCC;
+  /* Configure PHx pins in Alternate function mode */ 
+  GPIOH->MODER   = 0xAAAA08A0;
+  /* Configure PHx pins speed to 50 MHz */ 
+  GPIOH->OSPEEDR = 0xAAAA08A0;
+  /* Configure PHx pins Output type to push-pull */  
+  GPIOH->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PHx pins */ 
+  GPIOH->PUPDR   = 0x00000000;
+  
+  /* Connect PIx pins to FMC Alternate function */
+  GPIOI->AFR[0]  = 0xCCCCCCCC;
+  GPIOI->AFR[1]  = 0x00000CC0;
+  /* Configure PIx pins in Alternate function mode */ 
+  GPIOI->MODER   = 0x0028AAAA;
+  /* Configure PIx pins speed to 50 MHz */ 
+  GPIOI->OSPEEDR = 0x0028AAAA;
+  /* Configure PIx pins Output type to push-pull */  
+  GPIOI->OTYPER  = 0x00000000;
+  /* No pull-up, pull-down for PIx pins */ 
+  GPIOI->PUPDR   = 0x00000000;
+  
+/*-- FMC Configuration ------------------------------------------------------*/
+  /* Enable the FMC interface clock */
+  RCC->AHB3ENR |= 0x00000001;
+  
+  /* Configure and enable SDRAM bank1 */
+  FMC_Bank5_6->SDCR[0] = 0x000039D0;
+  FMC_Bank5_6->SDTR[0] = 0x01115351;      
+  
+  /* SDRAM initialization sequence */
+  /* Clock enable command */
+  FMC_Bank5_6->SDCMR = 0x00000011; 
+  tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
+  while((tmpreg != 0) & (timeout-- > 0))
+  {
+    tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
+  }
+  
+  /* Delay */
+  for (index = 0; index<1000; index++);
+  
+  /* PALL command */
+  FMC_Bank5_6->SDCMR = 0x00000012;           
+  timeout = 0xFFFF;
+  while((tmpreg != 0) & (timeout-- > 0))
+  {
+  tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
+  }
+  
+  /* Auto refresh command */
+  FMC_Bank5_6->SDCMR = 0x00000073;
+  timeout = 0xFFFF;
+  while((tmpreg != 0) & (timeout-- > 0))
+  {
+  tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
+  }
+ 
+  /* MRD register program */
+  FMC_Bank5_6->SDCMR = 0x00046014;
+  timeout = 0xFFFF;
+  while((tmpreg != 0) & (timeout-- > 0))
+  {
+  tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
+  } 
+  
+  /* Set refresh count */
+  tmpreg = FMC_Bank5_6->SDRTR;
+  FMC_Bank5_6->SDRTR = (tmpreg | (0x0000027C<<1));
+  
+  /* Disable write protection */
+  tmpreg = FMC_Bank5_6->SDCR[0]; 
+  FMC_Bank5_6->SDCR[0] = (tmpreg & 0xFFFFFDFF);
+  
+/*
+  Bank1_SDRAM is configured as follow:
+
+  FMC_SDRAMTimingInitStructure.FMC_LoadToActiveDelay = 2;      
+  FMC_SDRAMTimingInitStructure.FMC_ExitSelfRefreshDelay = 6;  
+  FMC_SDRAMTimingInitStructure.FMC_SelfRefreshTime = 4;        
+  FMC_SDRAMTimingInitStructure.FMC_RowCycleDelay = 6;         
+  FMC_SDRAMTimingInitStructure.FMC_WriteRecoveryTime = 2;      
+  FMC_SDRAMTimingInitStructure.FMC_RPDelay = 2;                
+  FMC_SDRAMTimingInitStructure.FMC_RCDDelay = 2;               
+
+  FMC_SDRAMInitStructure.FMC_Bank = SDRAM_BANK;
+  FMC_SDRAMInitStructure.FMC_ColumnBitsNumber = FMC_ColumnBits_Number_8b;
+  FMC_SDRAMInitStructure.FMC_RowBitsNumber = FMC_RowBits_Number_11b;
+  FMC_SDRAMInitStructure.FMC_SDMemoryDataWidth = FMC_SDMemory_Width_16b;
+  FMC_SDRAMInitStructure.FMC_InternalBankNumber = FMC_InternalBank_Number_4;
+  FMC_SDRAMInitStructure.FMC_CASLatency = FMC_CAS_Latency_3; 
+  FMC_SDRAMInitStructure.FMC_WriteProtection = FMC_Write_Protection_Disable;
+  FMC_SDRAMInitStructure.FMC_SDClockPeriod = FMC_SDClock_Period_2;
+  FMC_SDRAMInitStructure.FMC_ReadBurst = FMC_Read_Burst_disable;
+  FMC_SDRAMInitStructure.FMC_ReadPipeDelay = FMC_ReadPipe_Delay_1;
+  FMC_SDRAMInitStructure.FMC_SDRAMTimingStruct = &FMC_SDRAMTimingInitStructure;
+*/
+  
+}
+#endif /* DATA_IN_ExtSDRAM */
+
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+  
+/**
+  * @}
+  */    
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/USER/system_stm32f4xx.h b/stm32f407zg/uniproton/board/USER/system_stm32f4xx.h
new file mode 100644
index 0000000..5fc2bbc
--- /dev/null
+++ b/stm32f407zg/uniproton/board/USER/system_stm32f4xx.h
@@ -0,0 +1,105 @@
+/**
+  ******************************************************************************
+  * @file    system_stm32f4xx.h
+  * @author  MCD Application Team
+  * @version V1.4.0
+  * @date    04-August-2014
+  * @brief   CMSIS Cortex-M4 Device System Source File for STM32F4xx devices.       
+  ******************************************************************************  
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************  
+  */ 
+
+/** @addtogroup CMSIS
+  * @{
+  */
+
+/** @addtogroup stm32f4xx_system
+  * @{
+  */  
+  
+/**
+  * @brief Define to prevent recursive inclusion
+  */
+#ifndef __SYSTEM_STM32F4XX_H
+#define __SYSTEM_STM32F4XX_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif 
+
+/** @addtogroup STM32F4xx_System_Includes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+
+/** @addtogroup STM32F4xx_System_Exported_types
+  * @{
+  */
+
+extern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
+
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F4xx_System_Exported_Constants
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F4xx_System_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F4xx_System_Exported_Functions
+  * @{
+  */
+  
+extern void SystemInit(void);
+extern void SystemCoreClockUpdate(void);
+/**
+  * @}
+  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__SYSTEM_STM32F4XX_H */
+
+/**
+  * @}
+  */
+  
+/**
+  * @}
+  */  
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32f407zg/uniproton/board/rtos.ld b/stm32f407zg/uniproton/board/rtos.ld
new file mode 100644
index 0000000..aafab52
--- /dev/null
+++ b/stm32f407zg/uniproton/board/rtos.ld
@@ -0,0 +1,117 @@
+/*
+*****************************************************************************
+**
+
+**  File        : LinkerScript.ld
+**
+**  Abstract    : Linker script for STM32F103ZETx Device with
+**                512KByte FLASH, 64KByte RAM
+**
+**                Set heap size, stack size and stack location according
+**                to application requirements. 
+**
+**                Set memory bank area and size if external memory is used.
+**
+**  Target      : STMicroelectronics STM32
+**
+**
+**  Distribution: The file is distributed as is, without any warranty
+**                of any kind.
+**
+**  (c)Copyright Ac6.
+**  You may use this file as-is or modify it according to the needs of your
+**  project. Distribution of this file (unmodified or modified) is not
+**  permitted. Ac6 permit registered System Workbench for MCU users the
+**  rights to distribute the assembled, compiled & linked contents of this
+**  file as part of an application binary file, provided that it is built
+**  using the System Workbench for MCU toolchain.
+**
+*****************************************************************************
+*/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-bigarm", "elf32-littlearm") 
+OUTPUT_ARCH(arm)
+ENTRY(g_bootVectors)  
+
+SVC_IRQ_STACK_SIZE  = 4K; 
+
+FLASH_START         = 0x08000000;
+FLASH_SIZE          = 1M;
+
+PS_RAM_START        = 0x20000000;
+PS_RAM_SIZE         = 128K;
+
+MEMORY
+{
+    flash(rx) : ORIGIN = FLASH_START, LENGTH = FLASH_SIZE
+    ram(rwx) : ORIGIN = PS_RAM_START, LENGTH = PS_RAM_SIZE
+}
+
+SECTIONS
+{
+    _stext = .;
+    .vector : {
+        KEEP (*(SORT_NONE(.reset)))
+    } > flash
+
+    .got : {
+        *(.got.plt)
+        *(.igot.plt)
+        *(.got)
+        *(.igot)
+    } > flash
+
+    .text : {
+        . = ALIGN(0x4);
+        __text_start = .;
+        *(.text.*)
+        . = ALIGN(0x4);
+        _etext = .;
+        *(.rodata .rodata.* .gnu.linkonce.r.*)
+        *(.rodata1)
+    } > flash
+ 
+    .data : {
+        __data_start = . ;
+        g_data_start = . ;
+
+        *(.data .data.* .gnu.linkonce.d.*)
+
+        . = ALIGN(0x80);
+        KEEP (*(SORT_NONE(VECTOR)))	
+        __data_end = . ;
+        g_data_end = . ;
+    } > ram AT > flash
+
+    data_load_start = LOADADDR(.data);
+
+    .bss : ALIGN(0x4) {
+        __bss_start = .;
+        g_bssStart = .;
+        *(.dynbss)
+        *(.bss .bss.* .gnu.linkonce.b.*)
+        *(COMMON)
+        . = ALIGN(0x4);
+        __bss_end = .;
+        g_bssEnd = .;
+    } > ram
+
+    _sstack = .;
+    .stack : ALIGN(0x8) {
+        _stack = .;
+        g_stackStart = .;
+        __irq_stack_bootom = .;
+        . += SVC_IRQ_STACK_SIZE;
+        __irq_stack_top = .;
+        g_stackEnd = .;
+        _estack = .;
+    } > ram
+
+    .heap (NOLOAD): ALIGN(0x40) {
+        __heap_start = .;
+    } > ram
+
+    __heap_size = PS_RAM_SIZE - (__heap_start - __data_start);
+    end = .;
+    /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }
+}
\ No newline at end of file
diff --git a/stm32f407zg/uniproton/board/target_config.h b/stm32f407zg/uniproton/board/target_config.h
new file mode 100644
index 0000000..41c15ad
--- /dev/null
+++ b/stm32f407zg/uniproton/board/target_config.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2009-2022 Huawei Technologies Co., Ltd. All rights reserved.
+ *
+ * UniProton is licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Create: 2009-12-22
+ * Description: UniProton配置头文件，裁剪开关和配置项。
+ */
+#ifndef TARGET_CONFIG_H
+#define TARGET_CONFIG_H
+
+#include "prt_buildef.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/* ***************************** 配置系统基本信息 ******************************* */
+/* 芯片主频 */
+#define OS_SYS_CLOCK                                    168000000
+
+/* ***************************** 中断模块配置 ************************** */
+/* 硬中断最大支持个数 */
+#define OS_HWI_MAX_NUM_CONFIG                           150
+
+/* ***************************** 配置Tick中断模块 *************************** */
+/* Tick中断模块裁剪开关 */
+#define OS_INCLUDE_TICK                                 YES
+/* Tick中断时间间隔，tick处理时间不能超过1/OS_TICK_PER_SECOND(s) */
+#define OS_TICK_PER_SECOND                              10000
+
+/* ***************************** 配置定时器模块 ***************************** */
+/* 基于TICK的软件定时器裁剪开关 */
+#define OS_INCLUDE_TICK_SWTMER                          YES
+/* 基于TICK的软件定时器最大个数 */
+#define OS_TICK_SWITIMER_MAX_NUM                        8
+
+/* ***************************** 配置任务模块 ******************************* */
+/* 任务模块裁剪开关 */
+#define OS_INCLUDE_TASK                                 YES
+/* 最大支持的任务数,最大共支持254个 */
+#define OS_TSK_MAX_SUPPORT_NUM                          8
+/* 缺省的任务栈大小 */
+#define OS_TSK_DEFAULT_STACK_SIZE                       0x800
+/* IDLE任务栈的大小 */
+#define OS_TSK_IDLE_STACK_SIZE                          0x800
+/* 任务栈初始化魔术字，默认是0xCA，只支持配置一个字节 */
+#define OS_TSK_STACK_MAGIC_WORD                         0xCA
+
+/* ***************************** 配置CPU占用率及CPU告警模块 **************** */
+/* CPU占用率模块裁剪开关 */
+#define OS_INCLUDE_CPUP                                 YES
+/* 采样时间间隔(单位tick)，若其值大于0，则作为采样周期，否则两次调用PRT_CpupNow或PRT_CpupThread间隔作为周期 */
+#define OS_CPUP_SAMPLE_INTERVAL                         0
+/* CPU占用率告警动态配置项 */
+#define OS_CONFIG_CPUP_WARN                             NO
+/* CPU占用率告警阈值(精度为万分比) */
+#define OS_CPUP_SHORT_WARN                              0
+/* CPU占用率告警恢复阈值(精度为万分比) */
+#define OS_CPUP_SHORT_RESUME                            0
+
+/* ***************************** 配置内存管理模块 ************************** */
+/* 用户可以创建的最大分区数，取值范围[0,253] */
+#define OS_MEM_MAX_PT_NUM                               1
+/* 私有FSC内存分区起始地址 */
+extern unsigned int __heap_start;
+extern unsigned int __heap_size;
+#define OS_MEM_FSC_PT_ADDR                              ((uintptr_t)&__heap_start)
+/* 私有FSC内存分区大小 */
+#define OS_MEM_FSC_PT_SIZE                              (((unsigned int)&__heap_size) / 2)
+
+/* ***************************** 配置信号量管理模块 ************************* */
+/* 信号量模块裁剪开关 */
+//#define OS_INCLUDE_SEM                                  YES
+
+/* 最大支持的信号量数 */
+#define OS_SEM_MAX_SUPPORT_NUM                          20
+
+/* ***************************** 配置队列模块 ******************************* */
+/* 队列模块裁剪开关 */
+#define OS_INCLUDE_QUEUE                                YES
+/* 最大支持的队列数,范围(0,0xFFFF] */
+#define OS_QUEUE_MAX_SUPPORT_NUM                        10
+
+#define OS_OPTION_TASK_DELETE                           1
+
+typedef enum OsinitPhaseId {
+    OS_MOUDLE_REG,
+    OS_MOUDLE_INIT,
+    OS_MOUDLE_CONFIG = 2,
+};
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cpluscplus */
+#endif /* __cpluscplus */
+
+#endif /* TARGET_CONFIG_H */
diff --git a/stm32f407zg/uniproton/config.gni b/stm32f407zg/uniproton/config.gni
new file mode 100644
index 0000000..2130bc4
--- /dev/null
+++ b/stm32f407zg/uniproton/config.gni
@@ -0,0 +1,96 @@
+# Copyright (c) 2022 Huawei Device Co., Ltd. All rights reserved.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Kernel type, e.g. "linux", "liteos_a", "liteos_m", "uniproton".
+kernel_type = "uniproton"
+
+# Kernel version.
+kernel_version = "3.0.0"
+
+# Board CPU type, e.g. "cortex-a7", "riscv32","cortex-m4".
+board_cpu = "cortex-m4"
+
+# Board arch, e.g.  "armv7-a", "rv32imac".
+board_arch = ""
+
+# Toolchain name used for system compiling.
+# E.g. gcc-arm-none-eabi, arm-linux-harmonyeabi-gcc, ohos-clang,  riscv32-unknown-elf.
+# Note: The default toolchain is "ohos-clang". It's not mandatory if you use the default toolchain.
+board_toolchain = "arm-none-eabi-gcc"
+
+use_board_toolchain = true
+
+# The toolchain path installed, it's not mandatory if you have added toolchain path to your ~/.bashrc.
+board_toolchain_path = ""
+
+# Compiler prefix.
+board_toolchain_prefix = "arm-none-eabi-"
+
+# Compiler type, "gcc" or "clang".
+board_toolchain_type = "gcc"
+
+#Debug compiler optimization level options
+board_opt_flags = []
+
+# Board related common compile flags.
+board_cflags = [
+  "-std=gnu11",
+  "-fno-common",
+  "-fomit-frame-pointer",
+  "-fstack-protector-strong",
+  "-fdata-sections",
+  "-ffunction-sections",
+  "-fshort-enums",
+  "-funsigned-char",
+  "-O2",
+  "-DSECUREC_BUFFER_SIZE=32",
+  "-D__RTOS__",
+  "-DOS_DEVICE_CONFIG",
+  "-nostdinc",
+]
+board_cflags += board_opt_flags
+
+board_asmflags = [
+  "-std=gnu11",
+  "-fno-common",
+  "-fomit-frame-pointer",
+  "-funsigned-char",
+  "-O2",
+]
+board_asmflags += board_opt_flags
+
+board_cxx_flags = board_cflags
+
+board_ld_flags = []
+
+# Newlib adapt.
+board_ld_flags += [
+  "-Wl,--wrap=_free_r",
+  "-Wl,--wrap,_malloc_usable_size_r",
+  "-Wl,--wrap,_malloc_r",
+  "-Wl,--wrap,_memalign_r",
+  "-Wl,--wrap,_realloc_r",
+  "-Wl,--wrap,_calloc_r",
+]
+
+# Board related headfiles search path.
+board_include_dirs = [ "//utils/native/lite/include" ]
+
+# Board adapter dir for OHOS components.
+board_adapter_dir = ""
+
+# Sysroot path.
+board_configed_sysroot = ""
+
+# Board storage type, it used for file system generation.
+storage_type = "spinor"
-- 
2.25.1

